# This file is part of IntegerSequences.
# Copyright Peter Luschny. License is MIT.
# This file includes parts from Combinatorics.jl in modified form.

# Version of: UTC 2019-05-26 10:30:37
# 89d7f300-7f90-11e9-2316-5b680c2c6b88

# Do not edit this file, it is generated from the modules and will be overwritten!
# Edit the modules in the src directory and build this file with BuildSequences.jl!

__precompile__()
module IntegerSequences
using Nemo, IterTools, HTTP, DocStringExtensions
export 
André,
BellNumber,
BellNumberList,
BellTrans,
BellTriangle,
Bernoulli,
BernoulliInt,
BernoulliIntList,
BernoulliList,
Bil,
BinaryIntegerLength,
Binomial,
CalkinWilfTree,
CantorBoustrophedonicEnumeration,
CantorBoustrophedonicMachine,
CantorBoustrophedonicPairing,
CantorEnumeration,
CantorMachine,
CantorPairing,
ClausenNumber,
ClausenNumberList,
Coefficients,
Combinations,
Count,
DedekindEtaPowers,
DeléhamΔ,
Divides,
Divisors,
EuclidTree,
EulerTransform,
F!,
Factors,
FallingFactorial,
GammaHyp,
GaussFactorial,
HilbertHotel,
InvOrthoPoly,
JacobiTheta3Powers,
JacobiTheta4Powers,
KolakoskiList,
List,
ModuleAbundant,
ModuleAndreNumbers,
ModuleBellNumbers,
ModuleBernoulliNumbers,
ModuleBinaryInteger,
ModuleBinaryQF,
ModuleCantorMachines,
ModuleCarmichaelNumbers,
ModuleClausenNumbers,
ModuleCombinationsIterator,
ModuleCompositions,
ModuleCounts,
ModuleCyclotomicBinaryForms,
ModuleDedekindEta,
ModuleDelehamDelta,
ModuleEulerTransforms,
ModuleFibonacci,
ModuleFigurativeNumbers,
ModuleGaussFactorials,
ModuleGeneralizedBinomial,
ModuleHighlyAbundant,
ModuleHyper1F1,
ModuleJacobiTheta,
ModuleKolakoski,
ModuleNarayanaCows,
ModuleNumberTheory,
ModuleOEISUtils,
ModuleOrthoPolynomials,
ModulePartitions,
ModulePrimeSwingFactorial,
ModulePrimesIterator,
ModuleProducts,
ModuleQueensProblems,
ModuleRationalTrees,
ModuleRecordSearch,
ModuleRiordanSquares,
ModuleSelfConvolutive,
ModuleSeqUtils,
ModuleSeriesExpansion,
ModuleStirlingNumbers,
ModuleSwingFactorial,
ModuleTriangles,
ModuleUlamNumbers,
ModuleZumkellerNumbers,
MultiFactorial,
NarayanasCows,
Nemofmpz,
NextPrime,
Nth,
OrthoPoly,
PSfactorial,
Partition,
PartitionNumberList,
Pascal,
PolygonalNumber,
PreviousPrime,
PrimeDivisors,
PrimeList,
PrimePi,
PrimePiList,
PrimeSieve,
Primes,
Println,
Product,
PyramidalNumber,
QTriangle,
Queens,
Radical,
RamanujanTau,
RamanujanTauList,
RecTriangle,
Records,
RiordanProduct,
RiordanSquare,
RisingFactorial,
RosenbergStrongBoustrophedonicEnumeration,
RosenbergStrongBoustrophedonicMachine,
RosenbergStrongBoustrophedonicPairing,
Row,
RowSums,
SchinzelSierpinskiEncoding,
SelfConvRec,
SeqName,
SeqNum,
SeqPrint,
SeqShow,
Sfactorial,
ShowAsMatrix,
ShowAsΔ,
Swing,
Triangle,
TriangleToList,
TriangularNumber,
UlamList,
ZArray,
ZTriangle,
assertTriangular,
fromΔ,
isA206864,
isA206942,
isA293654,
isA296095,
isA299498,
isA299733,
isA299928,
isA299929,
isA299930,
isA325143,
isA325145,
isAbundant,
isCarmichael,
isComposite,
isCyclic,
isEven,
isNonnegative,
isOdd,
isPerfectPower,
isPositive,
isPowerOfPrimes,
isPrime,
isPrimePower,
isPrimeTo,
isSquare,
isSquareFree,
isStrongCyclic,
isStrongPrimeTo,
isTriangular,
isUlam,
isZumkeller,
isweakCarmichael,
mods,
oeis_isinstalled,
oeis_local,
oeis_notinstalled,
oeis_path,
oeis_readbfile,
oeis_remote,
oeis_search,
oeis_trimdata,
oeis_writebfile,
takeFirst,
toΔ,
Ω,
σ,
σ2,
τ,
ω,
ϕ,
↑,
↓,
∏,
⊥,
⍊,
C000002,I000002,L000002,
V000005,
V000010,
G000032,L000032,
L000041,
F000045,G000045,I000045,L000045,R000045,V000045,is000045,
G000073,L000073,
L000085,
G000108,L000108,
L000110,V000110,
C000111,V000111,
L000118,
L000122,
L000132,
L000141,
V000142,
L000143,
L000144,
L000145,
V000165,
V000203,
V000217,
V000255,
G000257,L000257,
V000262,
V000290,
V000292,
V000326,
V000330,
T000369,
V000384,
V000407,
V000566,
V000567,
L000594,
L000698,
L000712,
L000716,
L000720,
L000727,
L000728,
L000729,
L000730,
L000731,
L000735,
L000739,
G000957,L000957,
L000961,
G001003,L001003,
G001006,L001006,
G001045,L001045,
V001106,
V001107,
V001147,
V001157,
V001221,
V001222,
V001339,
L001464,
V001477,
T001497,
L001710,
V001783,
V001813,
V001855,
L001934,
F002093,I002093,L002093,V002093,
L002107,
V002110,
V002411,
V002412,
V002413,
V002414,
G002426,L002426,
L002445,V002445,
L002448,
L002476,
L002808,
L002858,
F002997,I002997,L002997,
I003277,L003277,
V003314,
L003319,
L003723,
L004018,
L004402,
L004403,
L004404,
L004405,
L004406,
L004407,
L004408,
L004409,
L004410,
L004411,
L004412,
L004413,
L004414,
L004415,
L004416,
L004417,
L004418,
L004419,
L004420,
L004421,
L004422,
L004423,
L004424,
L004425,
T004747,
G005043,L005043,
F005101,I005101,L005101,V005101,is005101,
L005117,
L005411,
L005412,
L005425,
V005564,
L005758,
L005773,
L005875,
L006012,
L006171,V006171,
L006229,
G006318,L006318,
L006922,
V007060,
T007318,
L007522,
V007559,
V007584,
V007585,
V007696,
A007917,
I008279,L008279,M008279,V008279,
L008451,
L008452,
L008453,
V008544,
V008545,
V008683,
L008784,
L010815,
L010816,
L010817,
L010819,
L010820,
L010821,
L010822,
L010823,
L010824,
L010825,
L010826,
L010827,
L010828,
L010829,
L010830,
L010831,
L010832,
L010833,
L010834,
L010835,
L010836,
L010837,
L010838,
L010839,
L010840,
L010841,
T011117,
L013928,
V014107,
L015128,
L023003,
L023004,
L023005,
L023006,
L023007,
L023008,
L023009,
L023010,
L023011,
L023012,
L023013,
L023014,
L023015,
L023016,
L023017,
L023018,
L023019,
L023020,
L023021,
L025528,
V027641,
V027642,
L031363,
V032031,
V033156,
L033200,
V033815,
L034017,
V034386,
V034444,
F034885,I034885,L034885,V034885,
L035016,
L035251,
T037027,
L038872,
L038873,
T039599,
T039683,
L042965,
V047053,
L047891,
I048993,L048993,M048993,V048993,
T049218,
T049310,
I050384,L050384,
T051141,
T051142,
L052847,V052847,
T053117,
T053120,
T053121,
V054248,
V055634,
T055883,
L057126,
L057127,
V058373,
T059419,
T060693,
V061142,
V061168,
L061256,V061256,
L062980,
T064189,
L065515,
L065619,V065619,
L065855,
T066325,
V066570,
V067998,
L068228,
G068875,L068875,
L069637,
V080577,
V080956,
V081125,
L082298,
L082301,
L082302,
L082556,
L082557,
L082558,
L082559,
F083207,I083207,L083207,V083207,is083207,
V083652,
L084916,
T084938,
T088969,
L089270,
T090238,
T090981,
I094587,L094587,M094587,V094587,
T094665,
V095794,
L096727,
V097383,
I097805,L097805,M097805,V097805,
V099022,
T099174,
T104556,
T104562,
L104794,
L105523,
T106566,
L107716,
L107895,V107895,
L108624,
T111062,
L111529,
L111530,
L111531,
L111532,
L111533,
T111593,
T116392,
T119274,
V123753,
V124320,
V124441,
V124442,
T132062,
I132393,L132393,M132393,V132393,
T137286,
T137338,
T137452,
T137513,
L141158,
L146559,
A151800,
T159834,
L167872,
T172094,
V178963,
V178964,
V181830,
V181936,
T184962,
L190905,V190905,
F193338,I193338,L193338,V193338,
F193339,I193339,L193339,V193339,
V195441,
T202327,
T203412,
F206864,I206864,L206864,
F206942,I206942,L206942,
L213384,
L214551,
T216916,
V216919,
T217537,
L217924,
T225478,
F225498,I225498,L225498,
V232980,
V232981,
V232982,
L242660,
L243168,
L243655,
L244291,
L244779,
L244780,
L244819,
L246547,
L246655,
V250283,
V251568,
V254749,
A257993,
T264428,
T265606,
V265609,
I271703,L271703,M271703,V271703,
L275585,V275585,
L276285,
L276286,
L276287,
V281586,
V281588,
L290351,V290351,
F293654,I293654,L293654,
V295513,
F296095,I296095,L296095,
L299214,V299214,
F299498,I299498,L299498,
L299733,
F299928,I299928,L299928,
F299929,I299929,L299929,
F299930,I299930,L299930,
L319284,
L319514,V319514,
T321620,
T321621,
T321623,
T321624,
T322942,
F325143,I325143,L325143,
F325145,I325145,L325145
# *** Abundant.jl ****************
"""
``n`` is an abundant number if ``σ(n) > 2n``. An abundant number is a number for which the sum of its proper divisors is greater than the number itself.

* isAbundant, is005101, I005101, F005101, L005101, V005101.
"""
const ModuleAbundant = ""
"""
Is ``n`` an abundant number, i.e. is ``σ(n) > 2n`` ?
$(SIGNATURES)
"""
isAbundant(n) = σ(n) > 2n
"""
Is ``n`` a term of sequence A005101?
$(SIGNATURES)
"""
is005101(n) = isAbundant(n)
"""
Iterate over the first ``n`` abundant numbers.
$(SIGNATURES)
"""
I005101(n) = takeFirst(isAbundant, n)
"""
Iterate over the abundant numbers which do not exceed ``n (1 ≤ i ≤ n)``.
$(SIGNATURES)
"""
F005101(n) = Iterators.filter(isAbundant, 1:n)
"""
Return a list of the  first ``n`` abundant numbers.
$(SIGNATURES)
"""
L005101(n) = collect(I005101(n))
"""
Return the value of the ``n``-th abundant number.
$(SIGNATURES)
"""
V005101(n) = nth(I005101(n), n)
# *** AndreNumbers.jl ****************
"""
Generalized André numbers count the ``m``-alternating permutations of length ``n``, cf. A181937.

```
[  SEQ  ] n|k [0][1][2][3][4] [5] [6]  [7]   [8]   [9]  [10]
[V000012] [1]  1, 1, 1, 1, 1,  1,  1,   1,    1,    1,     1
[V000111] [2]  1, 1, 1, 2, 5, 16, 61, 272, 1385, 7936, 50521
[V178963] [3]  1, 1, 1, 1, 3,  9, 19,  99,  477, 1513, 11259
[V178964] [4]  1, 1, 1, 1, 1,  4, 14,  34,   69,  496,  2896
[V181936] [5]  1, 1, 1, 1, 1,  1,  5,  20,   55,  125,   251
[V250283] [6]  1, 1, 1, 1, 1,  1,  1,   6,   27,   83,   209
```

* André, C000111, V000111, V178963, V178964, V181936, V250283.
"""
const ModuleAndreNumbers = ""
"""
Return the generalized André numbers which are the ``m``-alternating permutations of length ``n``, cf. A181937.
$(SIGNATURES)
"""
function André(m::Int, n::Int)
haskey(CacheAndré, (m, n)) && return CacheAndré[(m, n)]
n ≤ 0 && return fmpz(1)
r = range(0, step=m, stop=n-1)
S = sum(binom(n, k) * André(m, k) for k in r)
V = n % m == 0 ? -S : S
CacheAndré[(m, n)] = V
return V
end
const CacheAndré = Dict{Tuple{Int, Int}, fmpz}()
"""
Return the generalized André numbers which are the ``m``-alternating permutations of length ``n``.
$(SIGNATURES)
"""
V181937(m::Int, n::Int) = abs(André(m, n))
"""
Return the up-down numbers (2-alternating permutations).
$(SIGNATURES)
"""
V000111(n::Int) = abs(André(2, n))
"""
Return the number of 3-alternating permutations.
$(SIGNATURES)
"""
V178963(n::Int) = abs(André(3, n))
"""
Return the number of 4-alternating permutations.
$(SIGNATURES)
"""
V178964(n::Int) = abs(André(4, n))
"""
Return the number of 5-alternating permutations.
$(SIGNATURES)
"""
V181936(n::Int) = abs(André(5, n))
"""
Return the number of 6-alternating permutations.
$(SIGNATURES)
"""
V250283(n::Int) = abs(André(6, n))
"""
Generate the André numbers (a.k.a. Euler-up-down numbers A000111). Don't confuse with the Euler numbers A122045.
$(SIGNATURES)
"""
C000111() = Channel(csize=2) do c
D = Dict{Int,fmpz}(0 => 1, -1 => 0)
i = k = 0
s = 1
while true
A = 0; D[k + s] = 0; s = -s
for j in 0:i
A += D[k]; D[k] = A; k += s
end
put!(c, A)
i += 1
end
end
# *** BellNumbers.jl ****************
"""
The Bell transform transforms an integer sequence into an integer triangle; also known as incomplete Bell polynomials.

Let ``X`` be an integer sequence, then ``B_{n, k}(X) = \\sum_{m=1}^{n-k+1} \\binom{n-1}{m-1} X[m] B_{n-m,k-1}(X)`` where ``B_{0,0} = 1, B_{n,0} = 0`` for ``n≥1, B_{0,k} = 0`` for ``k≥1``.

The Bell transform is (0,0)-based and the associated triangle always has as first column 1,0,0,0,... This column is often missing in the OEIS. Other Stirling number related sequences are implemented in the module StirlingLahNumbers.

* BellTrans, BellTriangle, BellNumberList, BellNumber
* V000110, L000110, T137452, T264428, T137513, T104556, T001497, T132062, T039683, T203412, T004747, T051141, T265606, T119274, T000369, T051142
"""
const ModuleBellNumbers = ""
"""
Return a list of the first m Bell numbers (a.k.a. exponential numbers).
$(SIGNATURES)
"""
function BellNumberList(m::Int)
m == 0 && return fmpz[]
R = ZArray(m)
R[1] = 1; m == 1 && return R
R[2] = 1; m == 2 && return R
A = ZArray(m)
A[1] = fmpz(1)
for n in 2:m - 1
A[n] = A[1]
for k in n:-1:2
A[k - 1] += A[k]
end
R[n + 1] = A[1]
end
R
end
"""
Return the n-th Bell number. Bell numbers count the ways to partition a set of ``n`` labeled elements.

```
julia> BellNumber(10)
115975
```
$(SIGNATURES)
"""
BellNumber(n::Int) = Nemo.bell(n)
"""
Return the n-th Bell number ``B_n``.

```
julia> V000110(11)
678570
```
$(SIGNATURES)
"""
V000110(n::Int) = Nemo.bell(n)
"""
Return a list of Bell numbers of length len.

```
julia> L000110(10)
[1, 1, 2, 5, 15, 52, 203, 877, 4140, 21147]
```
$(SIGNATURES)
"""
L000110(len::Int) = BellNumberList(len)
"""
The Bell transform transforms an integer sequence into an integer triangle; also known as incomplete Bell polynomials.

Let ``X`` be an integer sequence, then ``B_{n,k}(X) = \\sum_{m=1}^{n-k+1} \\binom{n-1}{m-1} X[m] B_{n-m,k-1}(X)`` where ``B_{0,0} = 1, B_{n,0} = 0`` for ``n≥1, B_{0,k} = 0`` for ``k≥1``.
$(SIGNATURES)
"""
function BellTrans(n::Int, k::Int, X::Array)
if haskey(CacheBellA, (n, k, X))
return CacheBellA[(n, k, X)]
end
a = fmpz(1); s = fmpz(0)
if (n == 0) && (k == 0) return a end
if (n == 0) || (k == 0) return s end
for m in 1:n-k+1
s += a * BellTrans(n - m, k - 1, X) * X[m]
a = div(a * (n - m), m)
end
CacheBellA[(n, k, X)] = s
return s
end
const CacheBellA = Dict{Tuple{Int, Int, Array}, fmpz}()
"""
The Bell transform transforms an integer sequence into an integer triangle; also known as incomplete Bell polynomials.

Let ``F`` be an integer sequence generating function, then ``B_{n,k}(F) = \\sum_{m=1}^{n-k+1} \\binom{n-1}{m-1} F(m) B_{n-m,k-1}(F)`` where ``B_{0,0} = 1, B_{n,0} = 0`` for ``n≥1, B_{0,k} = 0`` for ``k≥1``.
$(SIGNATURES)
"""
function BellTrans(n::Int, k::Int, F::Function)
haskey(CacheBellF, (n, k, F)) && return CacheBellF[(n, k, F)]
a = fmpz(1); s = fmpz(0)
if (n == 0) && (k == 0) return a end
if (n == 0) || (k == 0) return s end
for m in 1:n-k+1
s += a * BellTrans(n - m, k - 1, F) * F(m - 1)
a = div(a * (n - m), m)
end
CacheBellF[(n, k, F)] = s
return s
end
const CacheBellF = Dict{Tuple{Int, Int, Function}, fmpz}()
"""
The Bell triangle gathers the results of the Bell transform applied to the initial segments of the input sequence.

Famously the sequence (1,1,1,...) is mapped to the triangle of the Stirling set numbers.

```
julia> ShowAsΔ(BellTriangle(5, k -> 1))
1
0 1
0 1 1
0 1 3 1
0 1 7 6 1
```
$(SIGNATURES)
"""
function BellTriangle(n::Int, seq)
M = ZTriangle(n)
i = 1
for j in 0:n - 1, k in 0:j
M[i] = BellTrans(j, k, seq)
i += 1
end
return M
end
"""
Return the coefficients of the first ``n`` Abel polynomials.

```
julia> ShowAsΔ(T137452(5))
1
0 1
0 -2 1
0 9 -6 1
0 -64 48 -12 1
```
$(SIGNATURES)
"""
T137452(n::Int) = BellTriangle(n, k -> (-k - 1)^k)
"""
Return the Bell transform of the Bell numbers.

```
julia> ShowAsΔ(T264428(5))
1
0 1
0 1 1
0 2 3 1
0 5 11 6 1
```
$(SIGNATURES)
"""
T264428(n::Int) = BellTriangle(n, BellNumber)
"""
Return the triangle of the coefficients of the Mittag-Leffler polynomials.

```
julia> ShowAsΔ(T137513(5))
1
0 2
0 0 4
0 4 0 8
0 0 32 0 16
```
$(SIGNATURES)
"""
T137513(n::Int) = BellTriangle(n, k -> isOdd(k) ? 0 : 2fac(k))
"""
Return the matrix inverse of coefficients of Bessel polynomials; essentially the same as coefficients of modified Hermite polynomials T096713.

```
julia> ShowAsΔ(T104556(5))
1
0 1
0 -1 1
0 0 -3 1
0 0 3 -6 1
```
$(SIGNATURES)
"""
T104556(n::Int) = BellTriangle(n, k -> k < 2 ? (-1)^k : 0)
"""
Return a triangle of coefficients of Bessel polynomials (better use A132062).
$(SIGNATURES)
"""
T001497(n::Int) = BellTriangle(n, MultiFactorial(2, 1))
"""
Return the triangle of coefficients of Bessel polynomials, also the Sheffer triangle ``(1, 1 - √(1 - 2x))`` (Cf. A001497).

```
julia> ShowAsΔ(T132062(5))
1
0 1
0 1 1
0 3 3 1
0 15 15 6 1
```
$(SIGNATURES)
"""
T132062(n::Int) = BellTriangle(n, MultiFactorial(2, 1))
"""
Return the signed double Pochhammer triangle: expansion of ``x(x-2)(x-4)..(x-2n+2)``.

```
julia> ShowAsΔ(T039683(5))
1
0 1
0 2 1
0 8 6 1
0 48 44 12 1
```
$(SIGNATURES)
"""
T039683(n::Int) = BellTriangle(n, MultiFactorial(2, 2))
"""
Return the Bell transform of the MultiFactorial numbers of type (3,1).

```
julia> ShowAsΔ(T203412(5))
1
0 1
0 1 1
0 4 3 1
0 28 19 6 1
```
$(SIGNATURES)
"""
T203412(n::Int) = BellTriangle(n, MultiFactorial(3, 1))
"""
Return the Bell transform of the MultiFactorial numbers of type (3,2).

```
julia> ShowAsΔ(T004747(5))
1
0 1
0 2 1
0 10 6 1
0 80 52 12 1
```
$(SIGNATURES)
"""
T004747(n::Int) = BellTriangle(n, MultiFactorial(3, 2))
"""
Return the triangle ``3^{n-m}S1(n, m)`` where S1 are the signed Stirling numbers of first kind.

```
julia> ShowAsΔ(T051141(5))
1
0 1
0 3 1
0 18 9 1
0 162 99 18 1
```
$(SIGNATURES)
"""
T051141(n::Int) = BellTriangle(n, MultiFactorial(3, 3))
"""
Return the Bell transform of the quartic factorial numbers.

```
julia> ShowAsΔ(T265606(5))
1
0 1
0 1 1
0 5 3 1
0 45 23 6 1
```
$(SIGNATURES)
"""
T265606(n::Int) = BellTriangle(n, MultiFactorial(4, 1))
"""
Return the triangle of coefficients of numerators in Pade approximation to ``e^x``.

```
julia> ShowAsΔ(T119274(5))
1
0 1
0 2 1
0 12 6 1
0 120 60 12 1
```
$(SIGNATURES)
"""
T119274(n::Int) = BellTriangle(n, MultiFactorial(4, 2))
"""
Return the Bell transform of the MultiFactorial numbers of type (4,3).

```
julia> ShowAsΔ(T000369(5))
1
0 1
0 3 1
0 21 9 1
0 231 111 18 1
```
$(SIGNATURES)
"""
T000369(n::Int) = BellTriangle(n, MultiFactorial(4, 3))
"""
Return the Bell transform of the MultiFactorial numbers of type (4,4).

```
julia> ShowAsΔ(T051142(5))
1
0 1
0 4 1
0 32 12 1
0 384 176 24 1
```
$(SIGNATURES)
"""
T051142(n::Int) = BellTriangle(n, MultiFactorial(4, 4))
# *** BernoulliNumbers.jl ****************
"""
We are primarily concerned with the integer Bernoulli numbers.

Cf. ``A000182 (m=2), A293951 (m=3), A273352 (m=4), A318258 (m=5).``

```
[1] [0, 1,    0,       0,             0,                  0]
[2] [0, 1,   -2,      16,          -272,               7936]
[3] [0, 1,   -9,     477,        -74601,           25740261]
[4] [0, 1,  -34,   11056,     -14873104,        56814228736]
[5] [0, 1, -125,  249250,   -2886735625,    122209131374375]
[6] [0, 1, -461, 5699149, -574688719793, 272692888959243481]
```

The rational Bernoulli numbers are defined here with ``B(1) = 1/2``. Why this is preferred over ``B(1) = -1/2`` is explained in the [Bernoulli Manifesto](http://luschny.de/math/zeta/The-Bernoulli-Manifesto.html).

* BernoulliInt, BernoulliIntList, Bernoulli, BernoulliList
* V195441, V065619, V281586, V281588, V027641, L065619
"""
const ModuleBernoulliNumbers = ""
"""
Return the generalized integer Bernoulli numbers ``b_{m}(n) = n × ``André``(m, n-1)``.
$(SIGNATURES)
"""
BernoulliInt(m::Int, n::Int) = n == 0 ? ZZ(0) : n * André(m, n - 1)
"""
Return the number of down-up permutations w on ``[n+1]`` such that ``w_2 = 1``.
$(SIGNATURES)
"""
V065619(n::Int) = BernoulliInt(2, n)
"""
Return the generalized integer Bernoulli numbers ``b_{3}(n) = n × ``André``_{3}(n-1)``.
$(SIGNATURES)
"""
V281586(n::Int) = BernoulliInt(3, n)
"""
Return the generalized integer Bernoulli numbers ``b_{4}(n) = n × `` André``_{4}(n-1)``.
$(SIGNATURES)
"""
V281588(n::Int) = BernoulliInt(4, n)
"""
Return a list of length `len` of the integer Bernoulli numbers ``b_{m}(n)`` using Seidel's boustrophedon algorithm.
$(SIGNATURES)
"""
function BernoulliIntList(m::Int, len::Int)
len ≤ 0 && return fmpz[]
R = zeros(ZZ, len)
len == 1 && return R
R[2] = 1
len == 2 && return R
A = zeros(ZZ, len)
A[1] = 1; A[2] = 1
for n in 1:len - 2
if n % m ≠ 0
for i in n:-1:1 A[i] += A[i + 1] end
C = A[1]
else
C = 0
for i in 1:(n + 2) A[i], C = C, A[i]; C = A[i] - C end
end
R[n + 2] = C
end
R
end
"""
Computes a list of length `len` of the integer Bernoulli numbers ``b_{2}(n)`` using Seidel's boustrophedon algorithm.
$(SIGNATURES)
"""
function L065619(len::Int)
len ≤ 0  && return fmpz[]
R  = zeros(ZZ, len)
len == 1 && return R[0]
len == 2 && (R[0, 1] = 1; return R)
A = Dict{Int,fmpz}(-1 => 1, 0 => 0)
k = 0; e = 1
for i in 0:len - 1
Am = 0; A[k + e] = 0; e = -e
for j in 0:i
Am += A[k]; A[k] = Am; k += e
end
j = e < 0 ? div(-i, 2) : div(i, 2)
R[i+1] = A[j]
end
R
end
"""
Return the rational Bernoulli number ``B_n``  (cf. A027641/A027642).
$(SIGNATURES)
"""
function Bernoulli(n::Int)
isOdd(n) && (n == 1 ? (return fmpq(1, 2)) : (return fmpq(0, 1)))
n == 0 && return fmpq(1, 1)
denom = ^(ZZ(4), n) - ^(ZZ(2), n)
fmpq(BernoulliInt(2, n), denom)
end
"""
Return a list of the first `len` Bernoulli numbers ``B_n`` (cf. A027641/A027642).
$(SIGNATURES)
"""
function BernoulliList(len::Int)
if len ≤ 0 return fmpq[] end
R = zeros(QQ, len)
R[1] = fmpq(1, 1); len == 1 && return R
R[2] = fmpq(1, 2); len == 2 && return R
A = Dict{Int,fmpz}(0 => 1, -2 => 0, -1 => 1, 1 => 0)
a = fmpz(12); b = fmpz(240)
k = e = 1
for i in 2:len - 1
Am = 0; A[k + e] = 0; e = -e
for j in 0:i
Am += A[k]; A[k] = Am; k += e
end
if e > 0
R[i + 1] = fmpq(0, 1)
else
d = i >> 1
R[i + 1] = isEven(d) ? fmpq(-A[-d], a) : fmpq(A[-d], a)
a, b = b, b << 4 + b << 2 - a << 6
end
end
R
end
"""
Return the numerator of the Bernoulli number ``B_n``.
$(SIGNATURES)
"""
function V027641(n::Int)
isOdd(n) && (n == 1 ? (return ZZ(-1)) : return ZZ(0))
n == 0 && return ZZ(1)
denom = ^(ZZ(4), n) - ^(ZZ(2), n)
Nemo.numerator(BernoulliInt(2, n) // denom)
end
"""
Return denominator(Bernoulli ``_{n+1}(x) - `` Bernoulli ``_{n+1})``.
$(SIGNATURES)
"""
function V195441(n::Int)
n < 4 && return ZZ([1, 1, 2, 1][n + 1])
P = Primes(2, div(n + 2, 2 + n % 2))
∏([p for p in P if p ≤ sum(digits(n + 1, base=Int(p)))])
end
# *** BinaryInteger.jl ****************
"""
For positive n, BinaryIntegerLength is ``⌊ log[2](n) ⌋ + 1``, BinaryIntegerLength(0) = 0.

* BinaryIntegerLength, Bil, V001855, V003314, V033156, V054248, V061168, V083652, V097383, V123753, V295513
"""
const ModuleBinaryInteger = ""
"""
Return the length of the binary extension of an integer ``n``, which is defined as ``0`` if ``n = 0`` and for ``n > 0`` as ``⌊ log[2](n) ⌋ + 1``.
$(SIGNATURES)
"""
BinaryIntegerLength(n) = n == 0 ? 0 : floor(Int, log2(n)) + 1
"""
Alias for the function BinaryIntegerLength.
$(SIGNATURES)
"""
Bil(n) = BinaryIntegerLength(n)
"""
Return ``n`` Bil``(n) - 2^{\\text{Bil}(n)}`` where Bil``(n)`` is the binary integer length of ``n``.
$(SIGNATURES)
"""
V295513(n) = n*Bil(n) - 2^Bil(n)
"""
Maximal number of comparisons for sorting ``n`` elements by binary insertion.
$(SIGNATURES)
"""
V001855(n) = V295513(n) + 1
"""
Return the sum of lengths of binary expansions of ``0`` through ``n``.
$(SIGNATURES)
"""
V083652(n) = V295513(n+1) + 2
"""
Recurrence ``a(n) = a(n-1) + ⌊ a(n-1)/(n-1) ⌋ + 2`` for ``m ≥ 2`` and ``a(1) = 1``.
$(SIGNATURES)
"""
V033156(n) = V295513(n) + 2n
"""
Binary entropy function: ``a(n) = n + `` min ``( a(k) + a(n-k) : 1 ≤ k ≤ n-1 )`` for ``n > 1,`` and ``a(1) = 0``.
$(SIGNATURES)
"""
V003314(n) = V295513(n) + n
"""
Binary entropy: ``a(n) = n +`` min ``{ a(k) + a(n-k) : 1 ≤ k ≤ n-1 }.``
$(SIGNATURES)
"""
V054248(n) = V295513(n) + n + rem(n, 2)
"""
Minimum total number of comparisons to find each of the values ``1`` through ``n`` using a binary search with ``3``-way comparisons.
$(SIGNATURES)
"""
V097383(n) = V295513(n+1) - div(n-1, 2)
"""
Partial sums of the sequence ``⌊ log[2](n) ⌋``.
$(SIGNATURES)
"""
V061168(n) = V295513(n+1) - n + 1
"""
Partial sums of the sequence of length of the binary expansion of ``2n+1``.
$(SIGNATURES)
"""
V123753(n) = V295513(n+1) + n + 2
# *** BinaryQF.jl ****************
"""
A binary quadratic form over Z is a quadratic homogeneous polynomial in two variables with integer coefficients, ``q(x, y) = ax^2 + bxy + cy^2``.

A quadratic form ``q(x, y)`` represents an integer ``n`` if there exist integers ``x`` and ``y`` with ``q(x, y) = n``. We say that ``q`` primitively represents ``n`` if there exist relatively prime integers ``x`` and ``y`` such that ``q(x, y) = n``.

Ported from [BinaryQuadraticForms](http://oeis.org/wiki/User:Peter_Luschny/BinaryQuadraticForms) where you can find much more information on this subject.

* L002476, L008784, L031363, L034017, L035251, L038872, L038873, L042965, L057126, L057127, L068228, L084916, L089270, L141158, L242660, L243655, L244779, L244780, L244819, L243168, L244291, L007522, L033200
"""
const ModuleBinaryQF = ""
"""
Return integers that are represented by the binary quadratic form ``a x^2 + b xy + c y^2`` over Z. Parameter 'subset' is in {"positive", "primitively", "prime"}. Use it only as an intern function.
$(SIGNATURES)
"""
function binaryQF(a::Int, b::Int, c::Int, bound = 100::Int, subset = "positive", verbose = false)
α, β, γ = a, b, c
discriminant() = fmpz(β^2 - 4 * α * γ)
isreduced() = (-α < β ≤ α < γ) || (fmpz(0) ≤ β ≤ α == γ)
function roots(a::Int, b::Int, c::Int, n::Int, y::Int)
throw(ErrorException("not yet implemented"))
end
function sqr_disc(M, primitively = false)
d = discriminant()
d == 0 && throw(ValueError("discriminant must not be zero"))
a, b, c = α, β, γ
(a == 0 && c == 0) && return [b * n for n in 1:div(M, abs(b))]
D = isqrt(d)
if a == 0
a, c = c, 0
end
k = 2 * D; m = 4 * a * D
u = b + D; v = b - D
S = fmpz[]
for n in 1:M
h = fmpz(4 * a * n)  # a <> 0 and n <> 0
for t in Divisors(h) # returns fmpz
g = fmpz(div(h, t))
if rem(g - t, k) == 0 && rem(g * u - t * v, m) == 0
if primitively
y = div(g - t, k)
R = roots(a, b, c, n, y)
if isPrimeTo(R[1], y)
push!(S, n)
break
end
else
push!(S, n)
break
end
end
end
end
sort([s for s in Set(S)])
end
function imag_prime(M)
throw(ErrorException("not yet implemented"))
end
function imag_primitively(M)
a, b, c = α, β, γ
d = c - div(b * b, 4 * a)
A = []
for y in 0:isqrt(div(M, d))
r = y * b / (2 * a)
s = sqrt((M - d * y * y) / a)
for x in Int(round(ceil(-s - r))):Int(round(floor(s - r)))
isPrimeTo(x, y) && push!(A, a * x^2 + b * x * y + c * y^2)
end
end
sort([s for s in Set(A)])
end
function imag_positive(M)
throw(ErrorException("not yet implemented"))
end
function primitive_reps(a, h, b, M, S)
if a ≤ M
push!(S, a)
if b ≤ M
push!(S, b)
if a ≤ (M - b) && h ≤ (M - a - b)
a ≤ (M - a - h) && primitive_reps(a, h + 2 * a, a + b + h, M, S)
b ≤ (M - b - h) && primitive_reps(a + b + h, h + 2 * b, b, M, S)
end
end
end
end
function positive_primitives(bound, primitively)
a, b, c = α, β, γ
S = fmpz[]
while true
new_val = a + b + c
if new_val > 0
primitive_reps(a, b + 2 * a, new_val, bound, S)
b += 2 * c
a = new_val
else
if new_val < 0
b += 2 * a
c = new_val
end
end
if a == α && b == β && c == γ break end
end
if ! primitively
X = fmpz[]
for p in S
q = t = 1
while q ≤ bound
push!(X, q)
q = t * t * p
t += 1
end
end
S = X
end
sort([s for s in Set(S)])
end
function reduce_real()
d = discriminant()
isSquare(d) && throw(ValueError("form must not have square discriminant"))
droot = isqrt(d)
a, b, c = α, β, γ
while a ≤ 0 || c ≥ 0 || b ≤ abs(a + c)
cAbs = c
if cAbs < 0  cAbs *= -1 end
delta = div(b + droot, 2 * cAbs)
if c < 0  delta *= -1 end
aa = c
bb = 2 * c * delta - b
cc = c * delta * delta - b * delta + a
a, b, c = aa, bb, cc
end
return [a, b, c]
end
function reduce_imag()
a, b, c = α, β, γ
if a < 0
a, b, c = -a, -b, -c
end
d = discriminant()
while true
A = (a == c && b < 0) || (c < a)
L = (-a == b && a < c) || (a < abs(b))
!(A || L) && break
if A
a, b, c = c, -b, a
end
if L
b -= 2 * a * div(b, 2 * a)
if abs(b) > a  b -= 2 * a end
c = div(b * b - d, 4 * a)
end
end
return [a, b, c]
end
function reduced_form()
isreduced() && return [α, β, γ]
if discriminant() ≥ 0
return reduce_real()
else
return reduce_imag()
end
end
prime = false || subset == "prime"
primitively = false || subset == "primitively"
d = discriminant()
d == 0 && throw(ValueError("discriminant must not be 0"))
a, b, c = α, β, γ
if verbose
println("Original form [", a, ", ", b, ", ", c, "] with discriminant ", d)
end
if isSquare(d)
verbose && println("Square discriminant!")
if prime primitively = false end # for efficiency
pp = sqr_disc(bound, primitively)
if prime pp = [m for m in pp if isPrime(m)] end
else
α, β, γ = reduced_form()
verbose && println("Reduced form  [", α, ", ", β, ", ", γ, "]")
if d < 0
if prime
pp = imag_prime(bound)
else
if primitively
pp = imag_primitively(bound)
else
pp = imag_positive(bound)
end
end
else # d > 0 and not square
if prime
primitively = true
end # for efficiency
pp = positive_primitives(bound, primitively)
if prime pp = [m for m in pp if isPrime(m)] end
end
end
if verbose
msg0 = prime ? " primes " : " positive integers "
msg1 = primitively ? "primitively " : ""
msg2 = "represented up to "
println("There are ", length(pp), msg0, msg1, msg2, bound)
end
pp
end # binary_QF
"""
Return positive numbers of the form ``n = x^2-3y^2`` of discriminant 12.
$(SIGNATURES)
"""
L084916(bound::Int) = binaryQF(1, 0, -3, bound)
"""
Return positive numbers that are primitively represented by the indefinite quadratic form ``x^2 - 3y^2`` of discriminant 12.
$(SIGNATURES)
"""
L243655(bound::Int) = binaryQF(1, 0, -3, bound, "primitively")
"""
Return primes congruent to 1 (mod 12).
$(SIGNATURES)
"""
L068228(bound::Int) = binaryQF(1, 0, -3, bound, "prime")
"""
Return positive numbers of the form ``x^2+xy-2y^2``.
$(SIGNATURES)
"""
L242660(bound::Int) = binaryQF(1, 1, -2, bound)
"""
Return positive numbers primitively represented by the binary quadratic form (1, 1, -2).
$(SIGNATURES)
"""
L244713(bound::Int) = binaryQF(1, 1, -2, bound, "primitively")
"""
Return primes of the form ``6m + 1``.
$(SIGNATURES)
"""
L002476(bound::Int) = binaryQF(1, 1, -2, bound, "prime")
"""
Return positive numbers of the form ``x^2 - 2y^2`` with integers ``x, y`` (discriminant is 8).
$(SIGNATURES)
"""
L035251(bound::Int) = binaryQF(1, 0, -2, bound)
"""
Return mumbers n such that 2 is a square mod n.
$(SIGNATURES)
"""
L057126(bound::Int) = binaryQF(1, 0, -2, bound, "primitively")
"""
Return primes p such that 2 is a square mod p; or, primes congruent to ``{1, 2, 7}`` mod ``8``.
$(SIGNATURES)
"""
L038873(bound::Int) = binaryQF(1, 0, -2, bound, "prime")
"""
Return positive numbers of the form ``x^2+xy-y^2``; or, of the form ``5x^2-y^2``.
$(SIGNATURES)
"""
L031363(bound::Int) = binaryQF(1, 1, -1, bound) # "positive"
"""
Return positive numbers represented by the integer binary quadratic form ``x^2+xy-y^2`` with ``x`` and ``y`` relatively prime.
$(SIGNATURES)
"""
L089270(bound::Int) = binaryQF(1, 1, -1, bound, "primitively")
"""
Return primes represented by the integer binary quadratic form ``x^2+xy-y^2``.
$(SIGNATURES)
"""
L141158(bound::Int) = binaryQF(1, 1, -1, bound, "prime")
"""
Return primes congruent to ``{0, 1, 4}`` mod 5 (cf. also `[A141158]`).
$(SIGNATURES)
"""
L038872(bound::Int) = binaryQF(1, 1, -1, bound, "prime")
"""
Return positive integers not congruent to 2 mod 4; regular numbers modulo 4.
$(SIGNATURES)
"""
L042965(bound::Int) = binaryQF(1, 0, -1, bound) # "positive"
"""
Return numbers that are congruent to ``{0, 1, 3, 5, 7}`` mod 8. Positive integers represented by the binary quadratic form ``x^2-y^2`` with ``x`` and ``y`` relatively prime.
$(SIGNATURES)
"""
L047486(bound::Int) = binaryQF(1, 0, -1, bound, "primitively")
"""
Return positive integers of the form ``x^2 + xy + y^2`` (Loeschian numbers).
$(SIGNATURES)
"""
L003136(bound::Int) = binaryQF(1, 1, 1, bound) # "positive"
"""
Return positive integers that are primitively represented by ``x^2 + xy + y^2``.
$(SIGNATURES)
"""
L034017(bound::Int) = binaryQF(1, 1, 1, bound, "primitively")
"""
Return primes that are represented by ``x^2 + xy + y^2`` (generalized cuban primes).
$(SIGNATURES)
"""
L007645(bound::Int) = binaryQF(1, 1, 1, bound, "prime")
"""
Return positive integers that are the sum of 2 squares.
$(SIGNATURES)
"""
L001481(bound::Int) = binaryQF(1, 0, 1, bound) # "positive"
"""
Return numbers ``n`` that are primitively represented by ``x^2 + y^2``. Also numbers n such that ``√(-1)`` mod ``n`` exists.
$(SIGNATURES)
"""
L008784(bound::Int) = binaryQF(1, 0, 1, bound, "primitively")
"""
Return primes of form ``x^2 + y^2``; or primes congruent to 1 or 2 modulo 4.
$(SIGNATURES)
"""
L002313(bound::Int) = binaryQF(1, 0, 1, bound, "prime")
"""
Return Pythagorean primes: primes of form ``4n + 1``.
$(SIGNATURES)
"""
L002144(bound::Int) = binaryQF(1, 0, 1, bound, "prime")
"""
Return positive integers of the form ``x^2+xy+2y^2`` with ``x`` and ``y`` integers. See also A035248.
$(SIGNATURES)
"""
L028951(bound::Int) = binaryQF(1, 1, 2, bound) # "positive"
"""
Return positive numbers primitively represented by the binary quadratic form (1, 1, 2).
$(SIGNATURES)
"""
L244779(bound::Int) = binaryQF(1, 1, 2, bound, "primitively")
"""
Return primes represented by the binary quadratic form (1, 1, 2). Primes congruent to ``{0, 1, 2, 4}`` mod 7.
$(SIGNATURES)
"""
L045373(bound::Int) = binaryQF(1, 1, 2, bound, "prime")
"""
Return primes of form ``x^2+7*y^2``.
$(SIGNATURES)
"""
L033207(bound::Int) = binaryQF(1, 1, 2, bound, "prime")
"""
Return integers of form ``x^2 + 2y^2``.
$(SIGNATURES)
"""
L002479(bound::Int) = binaryQF(1, 0, 2, bound)
"""
Return positive integers primitively represented by ``x^2 + 2y^2``.
$(SIGNATURES)
"""
L057127(bound::Int) = binaryQF(1, 0, 2, bound, "primitively")
"""
Return primes of form ``x^2+2*y^2``. Primes congruent to ``{1, 2, 3}`` mod 8.
$(SIGNATURES)
"""
L033203(bound::Int) = binaryQF(1, 0, 2, bound, "prime")
"""
Return odd primes of form ``x^2+2y^2``. Primes congruent to ``{1, 3}`` mod 8.
$(SIGNATURES)
"""
L033200(bound::Int) = binaryQF(1, 0, 2, bound, "prime")
"""
Return positive numbers represented by the binary quadratic form (1, 1, 3). (See also A028954.)
$(SIGNATURES)
"""
L035247(bound::Int) = binaryQF(1, 1, 3, bound) # "positive"
"""
Return positive numbers primitively represented by the binary quadratic form (1, 1, 3).
$(SIGNATURES)
"""
L244780(bound::Int) = binaryQF(1, 1, 3, bound, "primitively")
"""
Return primes of form ``x^2+xy+3y^2``, discriminant -11.
$(SIGNATURES)
"""
L056874(bound::Int) = binaryQF(1, 1, 3, bound, "prime")
"""
Return positive numbers primitively represented by the binary quadratic form (1, 0, 3).
$(SIGNATURES)
"""
L244819(bound::Int) = binaryQF(1, 0, 3, bound, "primitively")
"""
Return positive integers of the form ``x^2+6xy-3y^2``.
$(SIGNATURES)
"""
L243168(bound::Int) = binaryQF(1, 6, -3, bound)
"""
Return positive numbers primitively represented by the binary quadratic form (1, 6, -3).
$(SIGNATURES)
"""
L244291(bound::Int) = binaryQF(1, 6, -3, bound, "primitively")
"""
Return primes of the form ``8n+7``, that is, primes congruent to -1 mod 8.
$(SIGNATURES)
"""
L007522(bound::Int) = binaryQF(-1, 4, 4, bound, "prime")
# *** CantorMachines.jl ****************
"""
[Cantor's enumeration of N X N revisited](https://luschny.wordpress.com/2018/09/24/cantors-enumeration-of-n2-revisited/).

* Cantor-Machine, Cantor-Enumeration, Cantor-Pairing, Cantor-BoustrophedonicMachine, Cantor-BoustrophedonicEnumeration, Cantor-BoustrophedonicPairing, RosenbergStrong-BoustrophedonicMachine, RosenbergStrong-BoustrophedonicEnumeration, RosenbergStrong-BoustrophedonicPairing
"""
const ModuleCantorMachines = ""
"""
The Cantor enumeration implemented as a state machine to avoid the evaluation of the square root function.
$(SIGNATURES)
"""
function CantorMachine(x, y, state)
x == 0 && !state && return x, y + 1, !state
y == 0 &&  state && return x + 1, y, !state
state && return x + 1, y - 1, state
return x - 1, y + 1, state
end
"""
The  Cantor enumeration of N X N where N = {0, 1, 2, ...}. If (x, y) and (x', y') are adjacent points on the trajectory of the map then max(|x - x'|, |y - y'|) can become arbitrarily large. In this sense Cantor's enumeration is not continous.
$(SIGNATURES)
"""
function CantorEnumeration(len)
x, y, state = 0, 0, false
for n in 0:len
print("$x, $y, ")
x, y, state = CantorMachine(x, y, state)
end
end
"""
The inverse function of the Cantor enumeration (the pairing function), computes n for given (x, y) and returns (x + y)*(x + y + 1)/2 + p where p = x if x - y is odd and y otherwise.
$(SIGNATURES)
"""
function CantorPairing(x, y)
p = isodd(x - y) ? x : y
div((x + y) * (x + y + 1), 2) + p
end
"""
The boustrophedonic Cantor enumeration implemented as a state machine to avoid the evaluation of the square root function.
$(SIGNATURES)
"""
function CantorBoustrophedonicMachine(x, y)
x == 0 && return y >> 1 + 1, y - y >> 1
x > y && return y, x
return y + 1, x - 1
end
"""
$(SIGNATURES)
"""
function CantorBoustrophedonicEnumeration(len)
x, y = 0, 0
for n in 0:len
print("$x, $y, ")
x, y = CantorBoustrophedonicMachine(x, y)
end
end
"""
The inverse function of the boustrophedonic Cantor enumeration (the pairing function), computes n for given (x, y) and returns (x + y)*(x + y + 1)/2 + m where m = abs(x - y) - (x > y ? 1 : 0).
$(SIGNATURES)
"""
function CantorBoustrophedonicPairing(x, y)
m = abs(x - y) - (x > y ? 1 : 0)
div((x + y) * (x + y + 1), 2) + m
end
"""
The boustrophedonic Rosenberg-Strong enumeration as considered by Pigeon implemented as a state machine to avoid the evaluation of the square root function.
$(SIGNATURES)
"""
function RosenbergStrongBoustrophedonicMachine(x, y, state)
x == 0 && state == 0 && return x, y + 1, 1
y == 0 && state == 2 && return x + 1, y, 3
x == y && state == 1 && return x, y - 1, 2
x == y && return x - 1, y, 0
state == 0 && return x - 1, y, 0
state == 1 && return x + 1, y, 1
state == 2 && return x, y - 1, 2
return x, y + 1, 3
end
"""
The boustrophedonic Rosenberg-Strong enumeration of N X N where N = {0, 1, 2, ...}. If (x, y) and (x', y') are adjacent points on the trajectory of the map then max(|x - x'|, |y - y'|) is always 1 whereas the Rosenberg-Strong realization is not.
$(SIGNATURES)
"""
function RosenbergStrongBoustrophedonicEnumeration(len)
x, y, state = 0, 0, 0
for n in 0:len
print("$x, $y, ")
x, y, state = RosenbergStrongBoustrophedonicMachine(x, y, state)
end
end
"""
The inverse function of the boustrophedonic Rosenberg-Strong enumeration (the pairing function), computes n for given (x, y).
$(SIGNATURES)
"""
function RosenbergStrongBoustrophedonicPairing(x::Int, y::Int)
m = max(x, y)
d = isodd(m) ? x - y : y - x
m * (m + 1) + d
end
"""
Return the pair (x, y) for given n as given by the boustrophedonic Rosenberg-Strong enumeration.
$(SIGNATURES)
"""
function V319514(n)
k, r = divrem(n, 2)
m = x = isqrt(k)
y = k - x^2
x <= y && ((x, y) = (2x - y, x))
isodd(m) ? (y, x)[r + 1] : (x, y)[r + 1]
end
"""
Return a list of pairs (x, y) given by the boustrophedonic Rosenberg-Strong enumeration.
$(SIGNATURES)
"""
L319514(len) = [V319514(n) for n in 0:len-1]
# *** CarmichaelNumbers.jl ****************
"""
* isCarmichael, I002997, F002997, L002997
* isweakCarmichael, I225498, F225498, L225498
"""
const ModuleCarmichaelNumbers = ""
"""
Is ``n`` a Carmichael/Šimerka number?
$(SIGNATURES)
"""
function isCarmichael(n)
(n == 1 || isEven(n) || isPrime(n)) && return false
for f in Factors(n)
(f[2] > 1 || (n - 1) % (f[1] - 1) != 0) && return false
end
return true
end
"""
Iterate over the first n Carmichael/Šimerka numbers.
$(SIGNATURES)
"""
I002997(n) = takeFirst(isCarmichael, n)
"""
Iterate over the Carmichael/Šimerka numbers which do not exceed n.
$(SIGNATURES)
"""
F002997(n) = filter(isCarmichael, 1:n)
"""
Return the first n Carmichael/Šimerka numbers in an array.
$(SIGNATURES)
"""
L002997(n) = collect(I002997(n))
"""
Is ``n`` a weak Carmichael number?
$(SIGNATURES)
"""
function isweakCarmichael(n)
(n == 1 || isEven(n) || isPrime(n)) && return false
for f in Factors(n)
(n - 1) % (f[1] - 1) != 0 && return false
end
return true
end
"""
Iterate over the first n weak Carmichael numbers.
$(SIGNATURES)
"""
I225498(n) = takeFirst(isweakCarmichael, n)
"""
Iterate over the weak Carmichael numbers which do not exceed n.
$(SIGNATURES)
"""
F225498(n) = filter(isweakCarmichael, 1:n)
"""
Return the first n weak Carmichael numbers in an array.
$(SIGNATURES)
"""
L225498(n) = collect(I225498(n))
# *** ClausenNumbers.jl ****************
"""
* ClausenNumber, ClausenNumberList, V002445, L002445, V027642
"""
const ModuleClausenNumbers = ""
"""
Return the Clausen number ``C_n`` which is the denominator of the Bernoulli number ``B_{2n}``.
$(SIGNATURES)
"""
function ClausenNumber(n::Int)
n == 0 && return ZZ(1)
m = [d + 1 for d in Divisors(2n)]
∏([q for q in m if isPrime(q)])
end
"""
Return the list of length len of Clausen numbers which are the denominators of the Bernoulli numbers ``B_{2n}``.
$(SIGNATURES)
"""
function ClausenNumberList(len::Int)
len ≤ 0 && return fmpz[]
A = fill(ZZ(2), len);  A[1] = 1
m = len - 1
m == 0 && return A
for p in Primes(3, 2m + 1)
r = div(p - 1, 2)
for k in range(r, step=r, length=div(m, r))
A[k+1] *= p
end
end
A
end
"""
Return the Clausen number ``C(n)`` which is the denominator of the Bernoulli number ``B_{2n}``.
$(SIGNATURES)
"""
V002445(n::Int) = ClausenNumber(n)
"""
Return the list of length len of Clausen numbers which are the denominators of the Bernoulli numbers ``B_{2n}``.
$(SIGNATURES)
"""
L002445(len::Int) = ClausenNumberList(len)
"""
Return the denominator of Bernoulli number ``B_n``.
$(SIGNATURES)
"""
function V027642(n::Int)
isEven(n) && return ClausenNumber(div(n, 2))
n == 1 && return ZZ(2)
return ZZ(1)
end
# *** CombinationsIterator.jl ****************
"""
* Combinations
"""
const ModuleCombinationsIterator = ""
struct combinations
n::Int
t::Int
end
function Base.iterate(c::combinations, s=[min(c.t - 1, i) for i in 1:c.t])
if c.t == 0 # special case to generate 1 result for t==0
isempty(s) && return (s, [1])
return
end
for i in c.t:-1:1
s[i] += 1
if s[i] > (c.n - (c.t - i))
continue
end
for j in i + 1:c.t
s[j] = s[j - 1] + 1
end
break
end
s[1] > c.n - c.t + 1 && return
(s, s)
end
Base.length(c::combinations) = binomial(c.n, c.t)
Base.eltype(::Type{combinations}) = Vector{Int}
"""
Generate all Combinations of ``n`` elements from an indexable object ``a``. Because the number of Combinations can be very large, this function returns an iterator object.
 Use collect(Combinations(a, n)) to get an array of all Combinations.
$(SIGNATURES)
"""
function Combinations(a, t::Integer)
if t < 0
t = length(a) + 1
end
reorder(c) = [a[ci] for ci in c]
(reorder(c) for c in combinations(length(a), t))
end
"""
Generate Combinations of the elements of ``a`` of all orders. Chaining of order iterators is eager, but the sequence at each order is lazy.
$(SIGNATURES)
"""
Combinations(a) = Iterators.flatten([Combinations(a, k) for k = 1:length(a)])
# *** Compositions.jl ****************
"""
* I097805, L097805, V097805, M097805
"""
const ModuleCompositions = ""
"""
Recurrence for `A097805`, the compositions of ``n`` with ``k`` parts.
$(SIGNATURES)
"""
function R097805(n, k, prevrow::Function)
k == 0 && return ZZ(k^n)
prevrow(k - 1) + prevrow(k)
end
"""
Iterates over the first ``n`` rows of A097805.
$(SIGNATURES)
"""
I097805(n) = RecTriangle(n, R097805)
"""
Lists the first ``n`` rows of A097805 by concatinating. This is the format for submissions to the OEIS.
$(SIGNATURES)
"""
L097805(n) = vcat(I097805(n)...)
"""
Return the triangular array as a square matrix.
$(SIGNATURES)
"""
M097805(dim) = fromΔ(L097805(dim))
"""
Return row ``n`` of A097805 based on the iteration I097805(n).
$(SIGNATURES)
"""
V097805(n) = nth(I097805(n+1), n+1)
# *** Counts.jl ****************
"""
* PreviousPrime, NextPrime, PrimePiList, takeFirst, Nth, Count, List, HilbertHotel
* L000961, L002808, L005117, L013928, L025528, L065515, L065855, L069637, L246547, L246655, L000720, A007917, A151800, A257993
"""
const ModuleCounts = ""
"""
Return a list of length len of integers ``≥ 0`` which are isA.
$(SIGNATURES)
"""
function List(len, isA::Function)
len ≤ 0 && return fmpz[]
j, c = Int(0), Int(1)
A = fill(ZZ(0), len)
while c <= len
if isA(j)
A[c] = fmpz(j)
c += 1
end
j += 1
end
A
end
"""
Iverson brackets.
$(SIGNATURES)
"""
ι(b) = b ? 1 : 0
"""
Inverse Iverson brackets.
$(SIGNATURES)
"""
ιι(n) = n == 0 ? true : false
"""
Return a iterator of length n which has value 1 if isA(i) is true and otherwise 0.
$(SIGNATURES)
"""
function Indicators(n, isA::Function)
(ι(isA(i)) for i in 0:n - 1)
end
"""
Return a list of length len which gives the numbers of integers ≤ n which are isA. Integers start at ``n=0``.
```
julia> CountList(8, isPrime)
[0, 0, 1, 2, 2, 3, 3, 4]
```
$(SIGNATURES)
"""
CountList(len::Int, isA::Function) = Accumulate(Indicators(len, isA))
"""
Return the numbers of integers in the range 0:n which are isA.
```
julia> Count(8, isPrime)
4
```
$(SIGNATURES)
"""
Count(n::Int, isAb::Function) = Base.count((isAb(i) for i in 0:n))
"""
Return the numbers of integers in the range a:b which are isA.
```
julia> Count(3:8, isPrime)
3
```
$(SIGNATURES)
"""
Count(r, isAb::Function) = Base.count((isAb(i) for i in r))
"""
Return a SeqArray listing the values satisfying the predicate isA for arguments ``0 ≤ x ≤ `` bound.
```
julia> FindUpTo(7, isPrime)
[2, 3, 5, 7]
```
$(SIGNATURES)
"""
function FindUpTo(bound, isA::Function)
bound < 0 && return fmpz[]
filter(isA, 0:bound)
end
"""
Return the first ``n`` numbers satisfying the predicate isA.
$(SIGNATURES)
"""
takeFirst(isA, n) = Iterators.take(Iterators.filter(isA, Iterators.countfrom(1)), n)
"""
Return a iterator listing the values satisfying the predicate isA for arguments in ``0 ≤ n ≤ bound .``
$(SIGNATURES)
"""
function IterateUpTo(bound, isA::Function)
(i for i in 0:bound if isA(i))
end
"""
Returns an integer which is the highest index in `b` for the value `a`. Whenever `a` is not a member of `b` it returns -1.
```
julia> L = List(10, isPrime); IndexIn(13, L)
5
```
$(SIGNATURES)
"""
function IndexIn(a, b::AbstractArray)
bdict = Dict(zip(b, 0:length(b)))
get(bdict, fmpz(a), -1)
end
"""
Return the Nth integer which is isA. (For N ≤ 0 return 0.)
```
julia> Nth(7, isPrime)
17
```
$(SIGNATURES)
"""
function Nth(N, isA::Function)
N ≤ 0 && return 0
n, c = Int(0), Int(0)
while c < N
i = isA(n)
i && (c += 1)
n += 1
end
n - 1
end
"""
Return the cumulative sum of an SeqArray.
$(SIGNATURES)
"""
function Accumulate(A)
R = fill(ZZ(0), length(A))
i, acu = 1, 0
for a in A
acu += a
R[i] = acu
i += 1
end
R
end
"""
Return the smallest list of indicators of isA with ∑(A) = count.
```
julia> IndicatorsFind(7, isPrime)
[0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1]
```
$(SIGNATURES)
"""
function IndicatorsFind(count, isA::Function)
count ≤ 0 && return []
n, c = Int(0), Int(0)
A = Int[]
while c < count
i = isA(n)
i && (c += 1)
push!(A, ι(i))
n += 1
end
A
end
"""
Return the first integer ``n ≥ 0`` such that isA(n) = true.
```
julia> First(isPrime)
2
```
$(SIGNATURES)
"""
function First(isA::Function)
n = 0
while !isA(n)
n += 1
end
n
end
First(A::Array{Int}) = A == [] ? nothing : first(A)
"""
Return the element at the end of the list A if A is not empty, 0 otherwise.
$(SIGNATURES)
"""
Last(A) = A == [] ? "undef" : A[end]
"""
Trick described by David Hilbert in a 1924 lecture "Über das Unendliche".
$(SIGNATURES)
"""
HilbertHotel(guest, hotel) = prepend!(hotel, guest)
"""
Return largest ``0 < k < n`` such that isA(k) = true or nothing if no such ``k`` exists.
```
julia> Previous(7, isPrime)
5
```
$(SIGNATURES)
"""
function Previous(n, isA::Function)
n == nothing && return First(isA)
while true
n -= 1
isA(n) && break
n < 0 && return First(isA)
end
n
end
"""
Return least ``k > n ≥ 0`` such that isA(k) = true. NOTE: It is assumed that such a ``k`` exists! (If not, the function will run forever.)
```
julia> Next(7, isPrime)
11
```
$(SIGNATURES)
"""
function Next(n, isA::Function)
((n ≤ 0) || (n == nothing)) && return First(isA)
while true
n += 1
isA(n) && break
end
n
end
"""
Return a list of composite numbers of length len. (Numbers which have more than one prime divisor.)
```
julia> L002808(8)
[4, 6, 8, 9, 10, 12, 14, 15]
```
$(SIGNATURES)
"""
L002808(len) = List(len, isComposite)
"""
Return a list of the number of composite numbers ``≤ n``.
```
julia> L065855(8)
[0, 0, 0, 0, 1, 1, 2, 2]
```
$(SIGNATURES)
"""
L065855(len) = CountList(len, isComposite)
"""
Return a list of squarefree numbers of length len. (Numbers which are not divisible by a square greater than 1.)
```
julia> L005117(8)
[1, 2, 3, 5, 6, 7, 10, 11]
```
$(SIGNATURES)
"""
L005117(len) = List(len, isSquareFree)
"""
Return a list of the number of squarefree numbers ``< n``.
```
julia> L013928(8)
[0, 1, 2, 3, 3, 4, 5, 6]
```
$(SIGNATURES)
"""
L013928(len) = CountList(len, isSquareFree)
"""
Return a list of powers of primes of length len. (Numbers of the form ``p^k`` where ``p`` is a prime and ``k ≥ 0``.)
```
julia> L000961(8)
[1, 2, 3, 4, 5, 7, 8, 9]
```
$(SIGNATURES)
"""
L000961(len) = List(len, isPowerOfPrimes)
"""
Return the number of powers of primes ``≤ n``. (Powers of primes are numbers of the form ``p^k`` where ``p`` is a prime and ``k ≥ 0``.)
```
julia> L065515(8)
[0, 1, 2, 3, 4, 5, 5, 6]
```
$(SIGNATURES)
"""
L065515(len) = CountList(len, isPowerOfPrimes)
"""
Return a list of prime powers of length len. (Numbers of the form ``p^k`` where ``p`` is a prime and ``k ≥ 1``.)
```
julia> L246655(8)
[2, 3, 4, 5, 7, 8, 9, 11]
```
$(SIGNATURES)
"""
L246655(len) = List(len, isPrimePower)
"""
Return a list of the number of prime powers ``≤ n`` with exponents ``k ≥ 1``.
```
julia> L025528(8)
[0, 0, 1, 2, 3, 4, 4, 5]
```
$(SIGNATURES)
"""
L025528(len) = CountList(len, isPrimePower)
"""
Return a list of perfect powers of length len. (Numbers of the form ``p^k`` where ``p`` is a prime and ``k ≥ 2``.
```
julia> L246547(8)
[4, 8, 9, 16, 25, 27, 32, 49]
```
$(SIGNATURES)
"""
L246547(len) = List(len, isPerfectPower)
"""
Return a list of the number of prime powers ``≤ n`` with exponents ``k ≥ 2``.
```
julia> L069637(8)
[0, 0, 0, 0, 1, 1, 1, 1]
```
$(SIGNATURES)
"""
L069637(len) = CountList(len, isPerfectPower)
"""
Return the largest prime in ``N`` (the semiring of natural numbers including zero) less than n for ``n ≥ 0``.
 (The `prev_prime` function of Mathematica, Maple, Magma and SageMath.)
$(SIGNATURES)
"""
A007917(n::Int) = Previous(n, isPrime)
"""
Return the largest prime in ``Z`` (the ring of all integers) less than ``n`` for ``n ≥ 0`` (cf. A007917).
$(SIGNATURES)
"""
PreviousPrime(n::Int) = n ∈ [0, 1, 2] ? -2 : Previous(n - 1, isPrime)
"""
Return least prime ``> n``. The next_prime function of Mathematica, Maple, Magma and SageMath (cf. A151800).
$(SIGNATURES)
"""
NextPrime(n::Int) = Next(n, isPrime)
"""
Return least prime ``> n``. The `next_prime` function of Mathematica, Maple, Magma and SageMath.
$(SIGNATURES)
"""
A151800(n::Int) = Next(n, isPrime)
"""
Return the list of number of primes ``≤ n`` for ``n ≥ 0``.

```
julia> PrimePiList(8)

[0, 0, 1, 2, 2, 3, 3, 4]
```
$(SIGNATURES)
"""
PrimePiList(len::Int) = CountList(len, isPrime)
"""
Return the list of number of primes ``≤ n`` for ``n ≥ 0``.

```
julia> L000720(8)

[0, 0, 1, 2, 2, 3, 3, 4]
```
$(SIGNATURES)
"""
L000720(len::Int) = PrimePiList(len)
"""
Return the index of the least prime not dividing ``n``.
$(SIGNATURES)
"""
function A257993(n::Int)
c, p = 1, 2
while n % p == 0
p = NextPrime(p)
c += 1
end
c
end
# *** CyclotomicBinaryForms.jl ****************
"""
E. Fouvry, C. Levesque, M. Waldschmidt,
[Representation of integers by cyclotomic binary forms](https://arxiv.org/pdf/1712.09019.pdf), arXiv:1712.09019 [math.NT], 2017.

* isA206864, F206864, I206864, L206864, isA206942, F206942, I206942, L206942, isA293654, F293654, I293654, L293654, isA296095, F296095, I296095, L296095, V299214, L299214, isA299498, F299498, I299498, L299498, isA299733, L299733, isA299928, F299928, I299928, L299928, isA299929, F299929, I299929, L299929, isA299930, F299930, I299930, L299930, isA325143, F325143, I325143, L325143, isA325145, F325145, I325145, L325145
"""
const ModuleCyclotomicBinaryForms = ""
"""
Is ``n`` a numbers of the form ``Phi_k(m)`` with ``k > 2`` and ``|m| > 1``
where ``Phi_k(m)`` denotes the ``k``-th cyclotomic polynomial evaluated at ``m``.
$(SIGNATURES)
"""
function isA206942(n)
if n < 3 return false end
R, x = PolynomialRing(ZZ, "x")
K = floor(Int, 5.383*log(n)^1.161) # Bounds from
M = floor(Int, 2*sqrt(n/3))        # Fouvry & Levesque & Waldschmidt
for k in 3:K
c = cyclotomic(k, x)
for m in 2:M
n == subst(c, m) && return true
end
end
return false
end
"""
Filter the integers which are A206942 and <= ``n``.
$(SIGNATURES)
"""
F206942(n) = filter(isA206942, 1:n)
"""
Iterate over the first ``n`` integers which are A206942.
$(SIGNATURES)
"""
I206942(n) = takeFirst(isA206942, n)
"""
Return the list of the first ``n`` integers which are A206942.
$(SIGNATURES)
"""
L206942(n) = collect(I206942(n))
"""
Is ``n`` a prime of the form ``Phi_k(m)`` with ``k > 2`` and ``|m| > 1``
where ``Phi_k(m)`` denotes the ``k``-th cyclotomic polynomial evaluated at ``m``.
$(SIGNATURES)
"""
isA206864(n) = isPrime(n) && isA206942(n)
"""
Filter the integers which are A206864 and <= ``n``.
$(SIGNATURES)
"""
F206864(n) = (j for j in 1:n if isA206864(j))
"""
Iterate over the first ``n`` integers which are A206864.
$(SIGNATURES)
"""
I206864(n) = takeFirst(isA206864, n)
"""
Return the list of the first ``n`` integers which are A206864.
$(SIGNATURES)
"""
L206864(n) = collect(I206864(n))
"""
Is ``n`` primitively represented by a cyclotomic binary forms?
$(SIGNATURES)
"""
function isA299498(n)
isPrimeTo(n, k) = gcd(ZZ(n), ZZ(k)) == ZZ(1)
R, x = PolynomialRing(ZZ, "x")
K = floor(Int, 5.383*log(n)^1.161) # Bounds from
M = floor(Int, 2*sqrt(n/3))  # Fouvry & Levesque & Waldschmidt
N = QQ(n)
for k in 3:K
e = Int(eulerphi(ZZ(k)))
c = cyclotomic(k, x)
for m in 1:M, j in m+1:M if isPrimeTo(m, j)
N == m^e*subst(c, QQ(j,m)) && return true
end end end
return false
end
"""
Filter the integers which are A299498 and <= ``n``.
$(SIGNATURES)
"""
F299498(n) = (j for j in 1:n if isA299498(j))
"""
Iterate over the first ``n`` integers which are A299498.
$(SIGNATURES)
"""
I299498(n) = takeFirst(isA299498, n)
"""
Return the list of the first ``n`` integers which are A299498.
$(SIGNATURES)
"""
L299498(n) = collect(I299498(n))
"""
Count the number of cyclotomic binary forms which primitively represent ``n``.
$(SIGNATURES)
"""
function countA299498(n)
if n < 3 return 0 end
isPrimeTo(n, k) = gcd(ZZ(n), ZZ(k)) == ZZ(1)
R, x = PolynomialRing(ZZ, "x")
K = floor(Int, 5.383*log(n)^1.161) # Bounds from
M = floor(Int, 2*sqrt(n/3))  # Fouvry & Levesque & Waldschmidt
N = QQ(n); count = 0
for k in 3:K
e = Int(eulerphi(ZZ(k)))
c = cyclotomic(k, x)
for m in 1:M, j in m+1:M if isPrimeTo(m, j)
N == m^e*subst(c, QQ(j,m)) && (count += 1)
end end end
count
end
"""
Is ``n`` represented by a cyclotomic binary form f(x, y) where x and y are prime numbers and 0 < y < x?
$(SIGNATURES)
"""
function isA299928(n)
R, z = PolynomialRing(ZZ, "z")
K = floor(Int, 5.383*log(n)^1.161) # Bounds from
M = floor(Int, 2*sqrt(n/3))  # Fouvry & Levesque & Waldschmidt
N = QQ(n)
P(u) = (p for p in u:M if isprime(ZZ(p)))
for k in 3:K
e = Int(eulerphi(ZZ(k)))
c = cyclotomic(k, z)
for y in P(2), x in P(y+1)
N == y^e*subst(c, QQ(x, y)) && return true
end
end
return false
end
"""
Filter the integers which are A299928 and <= ``n``.
$(SIGNATURES)
"""
F299928(n) = (j for j in 1:n if isA299928(j))
"""
Iterate over the first ``n`` integers which are A299928.
$(SIGNATURES)
"""
I299928(n) = takeFirst(isA299928, n)
"""
Return the list of the first ``n`` integers which are A299928.
$(SIGNATURES)
"""
L299928(n) = collect(I299928(n))
"""
Is ``n`` a prime represented by a cyclotomic binary form f(x, y) where x and y are prime numbers and 0 < y < x?
$(SIGNATURES)
"""
isA299929(n) = isPrime(n) && isA299928(n)
"""
Filter the integers which are A299929 and <= ``n``.
$(SIGNATURES)
"""
F299929(n) = (j for j in 1:n if isA299929(j))
"""
Iterate over the first ``n`` integers which are A299929.
$(SIGNATURES)
"""
I299929(n) = takeFirst(isA299929, n)
"""
Return the list of the first ``n`` integers which are A299929.
$(SIGNATURES)
"""
L299929(n) = collect(I299929(n))
"""
Is ``n`` a prime represented by a cyclotomic binary form f(x, y) with x and y odd prime numbers and x > y.
$(SIGNATURES)
"""
function isA299930(n)
!isprime(ZZ(n)) && return false
R, z = PolynomialRing(ZZ, "z")
K = floor(Int, 5.383*log(n)^1.161)
M = floor(Int, 2*sqrt(n/3))
N = QQ(n)
P(u) = (p for p in u:M if isprime(ZZ(p)))
for k in 3:K
e = Int(eulerphi(ZZ(k)))
c = cyclotomic(k, z)
for y in P(3), x in P(y+2)
N == y^e*subst(c, QQ(x, y)) && return true
end end
return false
end
"""
Filter the integers which are A299930 and <= ``n``.
$(SIGNATURES)
"""
F299930(n) = (j for j in 1:n if isA299930(j))
"""
Iterate over the first ``n`` integers which are A299930.
$(SIGNATURES)
"""
I299930(n) = takeFirst(isA299930, n)
"""
Return the list of the first ``n`` integers which are A299930.
$(SIGNATURES)
"""
L299930(n) = collect(I299930(n))
"""
Is ``n`` represented by a cyclotomic binary form?
$(SIGNATURES)
"""
function isA296095(n)
n < 3 && return false
R, z = PolynomialRing(ZZ, "z")
N = QQ(n)
logn = log(n)^1.161
K = floor(Int, 5.383*logn)
M = floor(Int, 2*(n/3)^(1/2))
k = 3
while true
c = cyclotomic(k, z)
e = Int(eulerphi(ZZ(k)))
if k == 7
K = ceil(Int, 4.864*logn)
M = ceil(Int, 2*(n/11)^(1/4))
end
for y in 2:M, x in 1:y
N == y^e*subst(c, QQ(x, y)) && return true
end
k += 1
k > K && break
end
return false
end
"""
Filter the integers which are A296095 and <= ``n``.
$(SIGNATURES)
"""
F296095(n) = (j for j in 1:n if isA296095(j))
"""
Iterate over the first ``n`` integers which are A296095.
$(SIGNATURES)
"""
I296095(n) = takeFirst(isA296095, n)
"""
Return the list of the first ``n`` integers which are A296095.
$(SIGNATURES)
"""
L296095(n) = collect(I296095(n))
"""
Is ``n`` unrepresentable by a cyclotomic binary forms?
$(SIGNATURES)
"""
function isA293654(n)
if n < 3 return true end
R, x = PolynomialRing(ZZ, "x")
K = floor(Int, 5.383*log(n)^1.161) # Bounds from
M = floor(Int, 2*sqrt(n/3)) # Fouvry & Levesque & Waldschmidt
N = QQ(n); count = 0
for k in 3:K
e = Int(eulerphi(ZZ(k)))
c = cyclotomic(k, x)
for m in 1:M, j in 0:M if max(j, m) > 1
N == m^e*subst(c, QQ(j,m)) && return false
end end end
return true
end
"""
Filter the integers which are A293654 and <= ``n``.
$(SIGNATURES)
"""
F293654(n) = (j for j in 1:n if isA293654(j))
"""
Iterate over the first ``n`` integers which are A293654.
$(SIGNATURES)
"""
I293654(n) = takeFirst(isA293654, n)
"""
Return the list of the first ``n`` integers which are A293654.
$(SIGNATURES)
"""
L293654(n) = collect(I293654(n))
"""
Is ``n`` a prime represented by a cyclotomic binary form?
$(SIGNATURES)
"""
function isA325143(n)
(n < 3 || !isprime(ZZ(n))) && return false
R, x = PolynomialRing(ZZ, "x")
K = floor(Int, 5.383*log(n)^1.161) # Bounds from
M = floor(Int, 2*sqrt(n/3)) # Fouvry & Levesque & Waldschmidt
N = QQ(n)
for k in 3:K
e = Int(eulerphi(ZZ(k)))
c = cyclotomic(k, x)
for m in 1:M, j in 0:M if max(j, m) > 1
N == m^e*subst(c, QQ(j,m)) && return true
end end end
return false
end
"""
Filter the integers which are A325143 and <= ``n``.
$(SIGNATURES)
"""
F325143(n) = (j for j in 1:n if isA325143(j))
"""
Iterate over the first ``n`` integers which are A325143.
$(SIGNATURES)
"""
I325143(n) = takeFirst(isA325143, n)
"""
Return the list of the first ``n`` integers which are A325143.
$(SIGNATURES)
"""
L325143(n) = collect(I325143(n))
"""
Is ``n`` a prime unrepresentable by a cyclotomic binary form?
$(SIGNATURES)
"""
isA325145(n) = isprime(ZZ(n)) && ! isA325143(n)
"""
Filter the integers which are A325145 and <= ``n``.
$(SIGNATURES)
"""
F325145(n) = (j for j in 1:n if isA325145(j))
"""
Iterate over the first ``n`` integers which are A325145.
$(SIGNATURES)
"""
I325145(n) = takeFirst(isA325145, n)
"""
Return the list of the first ``n`` integers which are A325145.
$(SIGNATURES)
"""
L325145(n) = collect(I325145(n))
"""
Return the number of representations of ``n`` by cyclotomic binary forms.
$(SIGNATURES)
"""
function V299214(n)
if n < 3 return 0 end
R, x = PolynomialRing(ZZ, "x")
K = floor(Int, 5.383*log(n)^1.161) # Bounds from
M = floor(Int, 2*sqrt(n/3))  # Fouvry & Levesque & Waldschmidt
N = QQ(n); count = 0
for k in 3:K
e = Int(eulerphi(ZZ(k)))
c = cyclotomic(k, x)
for m in 1:M, j in 0:M if max(j, m) > 1
N == m^e*subst(c, QQ(j,m)) && (count += 1)
end end end
4*count
end
"""
Return the initial list of V299214 of length len .
$(SIGNATURES)
"""
L299214(len) = [V299214(i) for i in 1:len]
"""
Is n a prime represented in more than one way by cyclotomic binary forms f(x,y) with x and y prime numbers and y < x?
$(SIGNATURES)
"""
function isA299733(n)
if n < 3 || !isprime(ZZ(n)) return false end
R, x = PolynomialRing(ZZ, "x")
K = floor(Int, 5.383*log(n)^1.161) # Bounds from
M = floor(Int, 2*sqrt(n/3)) # Fouvry & Levesque & Waldschmidt
N = QQ(n); multi = 0
for k in 3:K
e = Int(eulerphi(ZZ(k)))
c = cyclotomic(k, x)
for m in 2:M if isprime(ZZ(m))
for j in m:M if isprime(ZZ(j))
if N == m^e*subst(c, QQ(j,m)) multi += 1
end end end end end end
multi > 1
end
"""
Return the list of the first ``n`` integers which are A299733.
$(SIGNATURES)
"""
L299733(n) = [i for i in 1:n if isA299733(i)]
# *** DedekindEta.jl ****************
"""
* DedekindEtaPowers, RamanujanTau, RamanujanTauList, PartitionNumberList
"""
const ModuleDedekindEta = ""
"""
Compute the ``q``-expansion to length len of the Dedekind ``η`` function (without
 the leading factor ``q^{1/24}``) raised to the power ``r``, i.e.
``{(q^{-1/24} η(q))^r = ∏_{k ≥ 1} (1 - q^k)^r.}`` In particular, ``r = -1`` returns the generating function of the Partition function ``p(k)`` and ``r = 24`` gives the Ramanujan tau function ``τ(k)``.
$(SIGNATURES)
"""
function DedekindEtaPowers(len::Int, r::Int)
len ≤ 0 && return fmpz[]
R, x = PolynomialRing(ZZ, "x")
e = eta_qexp(r, len, x)
[coeff(e, j) for j in 0:len - 1]
end
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)``.
$(SIGNATURES)
"""
L010815(len::Int) = DedekindEtaPowers(len, 1)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^2``.
$(SIGNATURES)
"""
L002107(len::Int) = DedekindEtaPowers(len, 2)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^3``.
$(SIGNATURES)
"""
L010816(len::Int) = DedekindEtaPowers(len, 3)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^4``.
$(SIGNATURES)
"""
L000727(len::Int) = DedekindEtaPowers(len, 4)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^5``.
$(SIGNATURES)
"""
L000728(len::Int) = DedekindEtaPowers(len, 5)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^6``.
$(SIGNATURES)
"""
L000729(len::Int) = DedekindEtaPowers(len, 6)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^7``.
$(SIGNATURES)
"""
L000730(len::Int) = DedekindEtaPowers(len, 7)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^8``.
$(SIGNATURES)
"""
L000731(len::Int) = DedekindEtaPowers(len, 8)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^9``.
$(SIGNATURES)
"""
L010817(len::Int) = DedekindEtaPowers(len, 9)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{10}``.
$(SIGNATURES)
"""
L010818(len::Int) = DedekindEtaPowers(len, 10)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{11}``.
$(SIGNATURES)
"""
L010819(len::Int) = DedekindEtaPowers(len, 11)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{12}``.
$(SIGNATURES)
"""
L000735(len::Int) = DedekindEtaPowers(len, 12)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{13}``.
$(SIGNATURES)
"""
L010820(len::Int) = DedekindEtaPowers(len, 13)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{14}``.
$(SIGNATURES)
"""
L010821(len::Int) = DedekindEtaPowers(len, 14)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{15}``.
$(SIGNATURES)
"""
L010822(len::Int) = DedekindEtaPowers(len, 15)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{16}``.
$(SIGNATURES)
"""
L000739(len::Int) = DedekindEtaPowers(len, 16)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{17}``.
$(SIGNATURES)
"""
L010823(len::Int) = DedekindEtaPowers(len, 17)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{18}``.
$(SIGNATURES)
"""
L010824(len::Int) = DedekindEtaPowers(len, 18)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{19}``.
$(SIGNATURES)
"""
L010825(len::Int) = DedekindEtaPowers(len, 19)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{20}``.
$(SIGNATURES)
"""
L010826(len::Int) = DedekindEtaPowers(len, 20)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{21}``.
$(SIGNATURES)
"""
L010827(len::Int) = DedekindEtaPowers(len, 21)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{22}``.
$(SIGNATURES)
"""
L010828(len::Int) = DedekindEtaPowers(len, 22)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{23}``.
$(SIGNATURES)
"""
L010829(len::Int) = DedekindEtaPowers(len, 23)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{24}``.
$(SIGNATURES)
"""
L000594(len::Int) = DedekindEtaPowers(len, 24)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{25}``.
$(SIGNATURES)
"""
L010830(len::Int) = DedekindEtaPowers(len, 25)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{26}``.
$(SIGNATURES)
"""
L010831(len::Int) = DedekindEtaPowers(len, 26)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{27}``.
$(SIGNATURES)
"""
L010832(len::Int) = DedekindEtaPowers(len, 27)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{28}``.
$(SIGNATURES)
"""
L010833(len::Int) = DedekindEtaPowers(len, 28)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{29}``.
$(SIGNATURES)
"""
L010834(len::Int) = DedekindEtaPowers(len, 29)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{30}``.
$(SIGNATURES)
"""
L010835(len::Int) = DedekindEtaPowers(len, 30)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{31}``.
$(SIGNATURES)
"""
L010836(len::Int) = DedekindEtaPowers(len, 31)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{32}``.
$(SIGNATURES)
"""
L010837(len::Int) = DedekindEtaPowers(len, 32)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{40}``.
$(SIGNATURES)
"""
L010840(len::Int) = DedekindEtaPowers(len, 40)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{44}``.
$(SIGNATURES)
"""
L010838(len::Int) = DedekindEtaPowers(len, 44)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{48}``.
$(SIGNATURES)
"""
L010839(len::Int) = DedekindEtaPowers(len, 48)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{64}``.
$(SIGNATURES)
"""
L010841(len::Int) = DedekindEtaPowers(len, 64)
"""
List of the first values of the Ramanujan tau function, the Fourier coefficients of the Weierstrass Delta-function.
$(SIGNATURES)
"""
RamanujanTauList(len::Int) = DedekindEtaPowers(len, 24)
"""
Return Ramanujan's tau(n).
$(SIGNATURES)
"""
RamanujanTau(n::Int) = DedekindEtaPowers(n, 24)[end]
"""
Return the first n numbers of integer partitions.
$(SIGNATURES)
"""
PartitionNumberList(len::Int) = DedekindEtaPowers(len, -1)
"""
Return the first n numbers of integer partitions.
$(SIGNATURES)
"""
L000041(len::Int) = DedekindEtaPowers(len, -1)
"""
Return the number of partitions of n into parts of 2 kinds.
$(SIGNATURES)
"""
L000712(len::Int) = DedekindEtaPowers(len, -2)
"""
Return the number of partitions of n into parts of 3 kinds.
$(SIGNATURES)
"""
L000716(len::Int) = DedekindEtaPowers(len, -3)
"""
Return the number of partitions of n into parts of 4 kinds.
$(SIGNATURES)
"""
L023003(len::Int) = DedekindEtaPowers(len, -4)
"""
Return the number of partitions of n into parts of 5 kinds.
$(SIGNATURES)
"""
L023004(len::Int) = DedekindEtaPowers(len, -5)
"""
Return the number of partitions of n into parts of 6 kinds.
$(SIGNATURES)
"""
L023005(len::Int) = DedekindEtaPowers(len, -6)
"""
Return the number of partitions of n into parts of 7 kinds.
$(SIGNATURES)
"""
L023006(len::Int) = DedekindEtaPowers(len, -7)
"""
Return the number of partitions of n into parts of 8 kinds.
$(SIGNATURES)
"""
L023007(len::Int) = DedekindEtaPowers(len, -8)
"""
Return the number of partitions of n into parts of 9 kinds.
$(SIGNATURES)
"""
L023008(len::Int) = DedekindEtaPowers(len, -9)
"""
Return the number of partitions of n into parts of 10 kinds.
$(SIGNATURES)
"""
L023009(len::Int) = DedekindEtaPowers(len, -10)
"""
Return the number of partitions of n into parts of 11 kinds.
$(SIGNATURES)
"""
L023010(len::Int) = DedekindEtaPowers(len, -11)
"""
Return the number of partitions of n into parts of 12 kinds.
$(SIGNATURES)
"""
L005758(len::Int) = DedekindEtaPowers(len, -12)
"""
Return the number of partitions of n into parts of 13 kinds.
$(SIGNATURES)
"""
L023011(len::Int) = DedekindEtaPowers(len, -13)
"""
Return the number of partitions of n into parts of 14 kinds.
$(SIGNATURES)
"""
L023012(len::Int) = DedekindEtaPowers(len, -14)
"""
Return the number of partitions of n into parts of 15 kinds.
$(SIGNATURES)
"""
L023013(len::Int) = DedekindEtaPowers(len, -15)
"""
Return the number of partitions of n into parts of 16 kinds.
$(SIGNATURES)
"""
L023014(len::Int) = DedekindEtaPowers(len, -16)
"""
Return the number of partitions of n into parts of 17 kinds.
$(SIGNATURES)
"""
L023015(len::Int) = DedekindEtaPowers(len, -17)
"""
Return the number of partitions of n into parts of 18 kinds.
$(SIGNATURES)
"""
L023016(len::Int) = DedekindEtaPowers(len, -18)
"""
Return the number of partitions of n into parts of 19 kinds.
$(SIGNATURES)
"""
L023017(len::Int) = DedekindEtaPowers(len, -19)
"""
Return the number of partitions of n into parts of 20 kinds.
$(SIGNATURES)
"""
L023018(len::Int) = DedekindEtaPowers(len, -20)
"""
Return the number of partitions of n into parts of 21 kinds.
$(SIGNATURES)
"""
L023019(len::Int) = DedekindEtaPowers(len, -21)
"""
Return the number of partitions of n into parts of 22 kinds.
$(SIGNATURES)
"""
L023020(len::Int) = DedekindEtaPowers(len, -22)
"""
Return the number of partitions of n into parts of 23 kinds.
$(SIGNATURES)
"""
L023021(len::Int) = DedekindEtaPowers(len, -23)
"""
Return the number of partitions of n into parts of 24 kinds.
$(SIGNATURES)
"""
L006922(len::Int) = DedekindEtaPowers(len, -24)
"""
Return the number of partitions of n into parts of 30 kinds.
$(SIGNATURES)
"""
L082556(len::Int) = DedekindEtaPowers(len, -30)
"""
Return the number of partitions of n into parts of 32 kinds.
$(SIGNATURES)
"""
L082557(len::Int) = DedekindEtaPowers(len, -32)
"""
Return the number of partitions of n into parts of 48 kinds.
$(SIGNATURES)
"""
L082558(len::Int) = DedekindEtaPowers(len, -48)
"""
Return the number of partitions of n into parts of 64 kinds.
$(SIGNATURES)
"""
L082559(len::Int) = DedekindEtaPowers(len, -64)
# *** DelehamDelta.jl ****************
"""
Philippe Deléham’s Δ-operation maps, similar to the Riordan product, two integer sequences on a lower triangular matrix.
It effectively computes a continued fraction depending on the two input sequences!

Applying Deléham's Δ-operation often gives an additional first column or an additional main diagonal in the resulting triangle compared to what is listed in the OEIS.

[Introduction to the Riordan Square](http://luschny.de/math/seq/RiordanSquare.html)

* DeléhamΔ, T084938, T060693, T106566, T094665, T090238, T225478, T055883, T184962, T088969, T090981, T011117
"""
const ModuleDelehamDelta = ""
"""
Return the product of two integer sequences introduced by Philippe Deléham in A084938.
$(SIGNATURES)
"""
function DeléhamΔ(n::Int, S::Function, T::Function)
n ≤ 0 && return fmpz[]
R, x = PolynomialRing(ZZ, "x")
A = [R(S(k) + x * T(k)) for k in 0:n - 2]
C = [R(1) for i in 0:n]; C[1] = R(0)
M = ZTriangle(n)
m = 1
for k in 0:n - 1
for j in k + 1:-1:2
C[j] = C[j - 1] + C[j + 1] * A[j - 1]
end
for j in 0:k
M[m] = coeff(C[2], j)
m += 1
end
end
M
end
"""
Return the number of permutations of ``{1,2,...,n}`` having ``k`` cycles such that the elements of each cycle of the permutation form an interval. (Ran Pan)
$(SIGNATURES)
"""
T084938(n::Int) = DeléhamΔ(n, i -> div(i + 1, 2), i -> 0^i)
"""
Return the number of lattice paths from ``(0,0)`` to ``(x,y)`` that never pass below ``y = x`` and use step set ``{(0,1), (1,0), (2,0), (3,0), ...}``.
$(SIGNATURES)
"""
T011117(n::Int) = DeléhamΔ(n, i -> 0^i, i -> isodd(i) ? 1 : (i > 0 ? 2 : 0))
"""
Return the number of Schroeder paths (i.e., consisting of steps ``U=(1,1), D=(1,-1), H=(2,0)`` and never going below the x-axis) from ``(0,0)`` to ``(2n,0)``, having ``k`` peaks.
$(SIGNATURES)
"""
T060693(n::Int) = DeléhamΔ(n, i -> 1, i -> isodd(i) ? 0 : 1)
"""
Return the the Catalan convolution triangle.
$(SIGNATURES)
"""
T106566(n::Int) = DeléhamΔ(n, i -> i == 0 ? 0 : 1, i -> i == 0 ? 1 : 0)
"""
Return the number of increasing 0-2 trees (A002105) on ``2n`` edges in which the minimal path from the root has length ``k``.
$(SIGNATURES)
"""
T094665(n::Int) = DeléhamΔ(n, i -> div(i * (i + 1), 2), i -> i + 1)
"""
Return the number of lists of ``k`` unlabeled permutations whose total length is ``n``.
$(SIGNATURES)
"""
T090238(n::Int) = DeléhamΔ(n, i -> div(i, 2) + (isodd(i) ? 2 : 0), i -> i == 0 ? 1 : 0)
"""
Return the triangle ``4^k S_4(n, k)`` where ``S_m(n, k)`` are the Stirling-Frobenius cycle numbers of order ``m``.
$(SIGNATURES)
"""
T225478(n::Int) = DeléhamΔ(n, i -> 2(i + 1) + (i + 1) % 2, i -> isodd(i) ? 0 : 4)
"""
Return the exponential transform of Pascal's triangle.
$(SIGNATURES)
"""
T055883(n::Int) = DeléhamΔ(n, i -> isodd(i) ? div(i + 1, 2) : 1, i -> isodd(i) ? div(i + 1, 2) : 1)
"""
Return the number of Schroeder paths of length ``2n`` and having ``k`` ascents.
$(SIGNATURES)
"""
T090981(n::Int) = DeléhamΔ(n, i -> i == 0 ? 1 : (isodd(i) ? 0 : 2), i -> isodd(i) ? 1 : 0)
"""
Return a triangle related to the median Euler numbers.
$(SIGNATURES)
"""
T088969(n::Int) = DeléhamΔ(n, i -> i^2, i -> isodd(i) ? 3div(i, 2) + 2 : 5div(i, 2) + 1)
"""
Return the Bell transform of the Fubini numbers.
$(SIGNATURES)
"""
T184962(n::Int) = DeléhamΔ(n, i -> div((i + 1) - (i + 1) % 2, 2 - (i + 1) % 2), i -> isodd(i) ? 0 : 1)
# *** EulerTransforms.jl ****************
"""
* V006171, L006171, V107895, L107895, V061256, L061256, V190905, L190905, V275585, L275585, V290351, L290351
"""
const ModuleEulerTransforms = ""
"""
Return the Euler transform of f.
$(SIGNATURES)
"""
function EulerTransform(f::Function)
function E(n)
haskey(CacheET, (f, n)) && return CacheET[(f, n)]
n == 0 && return ZZ(1)
a(j) = ZZ(sum(d*f(Int(d)) for d in Divisors(j)))
b = sum(a(j) * E(n-j) for j in 1:n)
r = div(b, n)
CacheET[(f, n)] = r
return r
end
end
const CacheET = Dict{Tuple{Function, Int}, fmpz}()
"""
Return the number of factorization patterns of polynomials of degree n over integers.
$(SIGNATURES)
"""
V006171(n) = EulerTransform(τ)(n)
"""
Return a list of length len of the Euler transform of tau.
$(SIGNATURES)
"""
L006171(len) = [V006171(n) for n in 0:len-1]
"""
Return the Euler transform of sigma.
$(SIGNATURES)
"""
V061256(n) = EulerTransform(σ)(n)
"""
Return a list of length len of the Euler transform of sigma.
$(SIGNATURES)
"""
L061256(len) = [V061256(n) for n in 0:len-1]
"""
Return the Euler transform of sigma_2.
$(SIGNATURES)
"""
V275585(n) = EulerTransform(σ2)(n)
"""
Return a list of length len of the Euler transform of sigma_2.
$(SIGNATURES)
"""
L275585(len) = [V275585(n) for n in 0:len-1]
"""
Return the Euler transform of the factorial.
$(SIGNATURES)
"""
V107895(n) = EulerTransform(fac)(n)
"""
Return a list of length len of the Euler transform of the factorial.
$(SIGNATURES)
"""
L107895(len) = [V107895(n) for n in 0:len-1]
"""
Return the Euler transform of the swinging factorial (A056040).
$(SIGNATURES)
"""
V190905(n) = EulerTransform(n -> div(fac(n), fac(div(n, 2))^2))(n)
"""
Return a list of length len of the Euler transform of the swinging factorial.
$(SIGNATURES)
"""
L190905(len) = [V190905(n) for n in 0:len-1]
"""
Return the Euler transform of the Bell numbers.
$(SIGNATURES)
"""
V290351(n) = EulerTransform(Nemo.bell)(n)
"""
Return a list of length len of the Euler transform of the Bell numbers.
$(SIGNATURES)
"""
L290351(len) = [V290351(n) for n in 0:len-1]
"""
Return the Euler transform of [0, 1, 2, 3, ...].
$(SIGNATURES)
"""
V052847(n) = EulerTransform(k -> k-1)(n)
"""
Return a list of length len of the Euler transform of [0, 1, 2, 3, ...].
$(SIGNATURES)
"""
L052847(len) = [V052847(n) for n in 0:len-1]
# *** Fibonacci.jl ****************
"""
* I000045, F000045, L000045, V000045, R000045, is000045
"""
const ModuleFibonacci = ""
struct FiboIterate
length
end
function Base.iterate(I::FiboIterate)
I.length == 0 && return nothing
state = (ZZ(0), (ZZ(0), ZZ(1), ZZ(1)))
end
function Base.iterate(I::FiboIterate, (a, b, c))
c >= I.length && return nothing
(b, (b, a + b, c + 1))
end
Base.length(f::FiboIterate) = f.length
Base.eltype(f::FiboIterate) = Nemo.fmpz
"""
Iterate over the first ``n`` Fibonacci numbers.
$(SIGNATURES)
"""
I000045(n) = FiboIterate(n)
"""
Iterate over the Fibonacci numbers which do not exceed ``n``.
$(SIGNATURES)
"""
F000045(n) = IterTools.takewhile(k -> k <= n, FiboIterate(n+1))
"""
Return the first ``n`` Fibonacci numbers in an array.
$(SIGNATURES)
"""
L000045(n) = Base.collect(FiboIterate(n))
"""
Return the ``n``-th Fibonacci number.
$(SIGNATURES)
"""
function V000045(n)
F = ZZ[1 1; 1 0]
Fn = F^n
Fn[2, 1]
end
"""
Return the ``n``-th Fibonacci number, explicite formula by Paul Hankin.
$(SIGNATURES)
"""
function HankinFibonacci(n)
n < 2 && return n
a = <<(ZZ(4), (n - 1) * (n + 2))
b = <<(ZZ(4), 2 * (n - 1))
c = <<(ZZ(2), n - 1)
div(a, b - c - 1) & (c - 1)
end
"""
Fibonacci function for real values, returns a Float64.
$(SIGNATURES)
"""
function R000045(x::Float64)
(Base.MathConstants.golden^x - cos(x * Base.MathConstants.pi) *
Base.MathConstants.golden^(-x)) / sqrt(5)
end
"""
Query if ``n`` is a Fibonacci number, returns a Bool.
$(SIGNATURES)
"""
function is000045(n)
d = 0
for f in FiboIterate(n+2)
d = n - f
d <= 0 && break
end
d == 0
end
# *** FigurativeNumbers.jl ****************
"""
* PolygonalNumber, PyramidalNumber, V014107, V095794, V067998, V080956, V001477, V000217, V000290, V000326, V000384, V000566, V000567, V001106, V001107, V005564, V058373, V254749, V000292, V000330, V002411, V002412, V002413, V002414, V007584, V007585
"""
const ModuleFigurativeNumbers = ""
"""
Return the polygonal number with shape k.
$(SIGNATURES)
"""
function PolygonalNumber(n, k)
s = div(n^2 * (k - 2) - n * (k - 4), 2)
k < 2 ? -s : s
end
"""
Return the pyramidal number with shape k.
$(SIGNATURES)
"""
function PyramidalNumber(n, k)
s = div(3 * n^2 + n^3 * (k - 2) - n * (k - 5), 6)
k < 2 ? -s : s
end
"""
Return the polygonal numbers of shape -2.
$(SIGNATURES)
"""
V014107(n) = PolygonalNumber(n, -2)
"""
Return the polygonal numbers of shape -1.
$(SIGNATURES)
"""
V095794(n) = PolygonalNumber(n, -1)
"""
Return the polygonal numbers of shape 0.
$(SIGNATURES)
"""
V067998(n) = PolygonalNumber(n, 0)
"""
Return the polygonal numbers of shape 1.
$(SIGNATURES)
"""
V080956(n) = PolygonalNumber(n, 1)
"""
Return the polygonal numbers of shape 2 (these are the natural numbers).
$(SIGNATURES)
"""
V001477(n) = PolygonalNumber(n, 2)
"""
Return the polygonal numbers of shape 3 (the triangular numbers).
$(SIGNATURES)
"""
V000217(n) = PolygonalNumber(n, 3)
"""
Return the polygonal numbers of shape 4 (the squares).
$(SIGNATURES)
"""
V000290(n) = PolygonalNumber(n, 4)
"""
Return the polygonal numbers of shape 5 (the pentagonal numbers).
$(SIGNATURES)
"""
V000326(n) = PolygonalNumber(n, 5)
"""
Return the polygonal numbers of shape 6 (the hexagonal numbers).
$(SIGNATURES)
"""
V000384(n) = PolygonalNumber(n, 6)
"""
Return the polygonal numbers of shape 7 (the heptagonal numbers).
$(SIGNATURES)
"""
V000566(n) = PolygonalNumber(n, 7)
"""
Return the polygonal numbers of shape 8 (the octagonal numbers).
$(SIGNATURES)
"""
V000567(n) = PolygonalNumber(n, 8)
"""
Return the polygonal numbers of shape 9 (the nonagonal numbers).
$(SIGNATURES)
"""
V001106(n) = PolygonalNumber(n, 9)
"""
Return the polygonal numbers of shape 10 (decagonal numbers).
$(SIGNATURES)
"""
V001107(n) = PolygonalNumber(n, 10)
"""
Return the pyramidal numbers of shape -1.
$(SIGNATURES)
"""
V005564(n) = PyramidalNumber(n, -1)
"""
Return the pyramidal numbers of shape 0.
$(SIGNATURES)
"""
V058373(n) = PyramidalNumber(n, 0)
"""
Return the pyramidal numbers of shape 1.
$(SIGNATURES)
"""
V254749(n) = PyramidalNumber(n, 1)
"""
Return the pyramidal numbers of shape 3 (tetrahedral numbers).
$(SIGNATURES)
"""
V000292(n) = PyramidalNumber(n, 3)
"""
Return the pyramidal numbers of shape 4 (square pyramidal numbers).
$(SIGNATURES)
"""
V000330(n) = PyramidalNumber(n, 4)
"""
Return the pyramidal numbers of shape 5 (pentagonal pyramidal numbers).
$(SIGNATURES)
"""
V002411(n) = PyramidalNumber(n, 5)
"""
Return the pyramidal numbers of shape 6 (hexagonal pyramidal numbers).
$(SIGNATURES)
"""
V002412(n) = PyramidalNumber(n, 6)
"""
Return the pyramidal numbers of shape 7 (heptagonal pyramidal numbers).
$(SIGNATURES)
"""
V002413(n) = PyramidalNumber(n, 7)
"""
Return the pyramidal numbers of shape 8 (octagonal pyramidal numbers).
$(SIGNATURES)
"""
V002414(n) = PyramidalNumber(n, 8)
"""
Return the pyramidal numbers of shape 9 (enneagonal pyramidal numbers).
$(SIGNATURES)
"""
V007584(n) = PyramidalNumber(n, 9)
"""
Return the pyramidal numbers of shape 10 (decagonal pyramidal numbers).
$(SIGNATURES)
"""
V007585(n) = PyramidalNumber(n, 10)
# *** GaussFactorials.jl ****************
"""
The Gauß factorial is ``∏_{1 ≤ j ≤ N, j ⊥ n} j``, the product of the positive integers which are ``≤ N`` and are prime to ``n``.

* GaussFactorial, I193338, F193338, L193338, V193338, I193339, F193339, L193339, V193339, V216919, V001783, V055634, V232980, V232981, V232982, V124441, V124442, V066570
"""
const ModuleGaussFactorials = ""
"""
Return ``∏_{1 ≤ j ≤ N, j ⊥ n} j``, the product of the positive integers which are ``≤ N`` and are prime to ``n``.
$(SIGNATURES)
"""
GaussFactorial(N, n) = ∏([j for j in 1:Int(N) if ⊥(j, n)])
"""
Return ``∏_{1 ≤ j ≤ n, j ⊥ n} j``, the product of the positive integers which are ``≤ n`` and are prime to ``n``.
$(SIGNATURES)
"""
GaussFactorial(n) = GaussFactorial(n, n)
"""
Return GaussFactorial(N, n).
$(SIGNATURES)
"""
V216919(N, n) = GaussFactorial(N, n)
"""
Return ``∏_{1 ≤ j ≤ n, j ⊥ n} j``, the product of the positive integers which are ``≤ N`` and are prime to ``n``, a.k.a. the phi-torial of n.
$(SIGNATURES)
"""
V001783(n) = GaussFactorial(n, n)
""" 
Return the 2-adic factorial of n.
$(SIGNATURES)
"""
V055634(n) = GaussFactorial(n, 2)*(-1)^n
""" 
Return GaussFactorial(n, 3).
$(SIGNATURES)
"""
V232980(n) = GaussFactorial(n, 3)
""" 
Return GaussFactorial(n, 5).
$(SIGNATURES)
"""
V232981(n) = GaussFactorial(n, 5)
""" 
Return GaussFactorial(n, 6).
$(SIGNATURES)
"""
V232982(n) = GaussFactorial(n, 6)
"""
Return GaussFactorial(div(n, 2), n).
$(SIGNATURES)
"""
V124441(n) = GaussFactorial(div(n, 2), n)
"""
Return GaussFactorial(n, n)/GaussFactorial(div(n, 2), n).
$(SIGNATURES)
"""
V124442(n) = div(GaussFactorial(n, n), GaussFactorial(div(n, 2), n))
"""
Return GaussFactorial(n, 1)/GaussFactorial(n, n).
$(SIGNATURES)
"""
V066570(n) = div(GaussFactorial(n, 1), GaussFactorial(n, n))
"""
Iterate over the indices of the first ``n`` record values of the Gauß factorial.
$(SIGNATURES)
"""
I193339(n) = Records(GaussFactorial, n, true, true)
"""
Iterate over indices of the record values of the Gauß factorial which do not exceed ``n`` (``1 ≤ i ≤ n``).
$(SIGNATURES)
"""
F193339(n) = Records(GaussFactorial, n, false, true)
"""
Return the indices of the first ``n`` record values of the Gauß factorial as an array.
$(SIGNATURES)
"""
L193339(n) = collect(I193339(n))
"""
Return the index of the ``n``-th record value of the Gauß factorial.
$(SIGNATURES)
"""
V193339(n) = nth(I193339(n), n)
"""
Iterate over the first ``n`` record values of the Gauß factorial (``1 ≤ r``).
$(SIGNATURES)
"""
I193338(n) = Records(GaussFactorial, n, true, false)
"""
Iterate over the record values of the Gauß factorial which do not exceed ``n`` (``1 ≤ i ≤ n``).
$(SIGNATURES)
"""
F193338(n) = Records(GaussFactorial, n, false, false)
"""
Return the first ``n`` record values of the Gauß factorial as an array.
$(SIGNATURES)
"""
L193338(n) = collect(I193338(n))
"""
Return the (value of the) ``n``-th record of the Gauß factorial.
$(SIGNATURES)
"""
V193338(n) = nth(I193338(n), n)
# *** GeneralizedBinomial.jl ****************
"""
 P. Luschny, [Generalized Binomial](http://oeis.org/wiki/User:Peter_Luschny/ExtensionsOfTheBinomial), OEIS Wiki.

* Binomial, Pascal, T007318
"""
const ModuleGeneralizedBinomial = ""
"""
The classical binomial coefficients defined for ``n≥0`` and ``0≤k≤n`` (a.k.a. Pascal's triangle).
$(SIGNATURES)
"""
function Pascal(n::Int, k::Int)
(k == 0 || k == n) && return 1
if k > div(n, 2) k = n - k end
nk = n - k
factors = fmpz[]
rootN = isqrt(n)
for prime in Primes(2, n)
if prime > nk
push!(factors, prime)
continue
end
prime > div(n, 2) && continue
if prime > rootN
(n % prime < k % prime) && push!(factors, prime)
continue
end
r, N, K, p = 0, n, k, 1
while N > 0
r = N % prime < (K % prime + r) ? 1 : 0
if r == 1 p *= prime end
N = div(N, prime)
K = div(K, prime)
end
p > 1 && push!(factors, p)
end
∏(factors) end
"""
Pascal's triangle.
$(SIGNATURES)
"""
function T007318(n::Int)
T = zeros(QQ, div(n * (n + 1), 2))
j = 1
for m in 0:n - 1, k in 0:m
T[j] = binom(m, k)
j += 1
end
T
end
"""
Return the extended binomial coefficients defined for all ``n ∈ Z`` and ``k ∈ Z``. Behaves like the binomial function in Maple and Mathematica.

``\\binom{n}{k} = \\lim \\limits_{x \\rightarrow 1}(Γ(n + x) / (Γ(k + x) Γ(n - k + x))).``

$(SIGNATURES)
"""
function Binomial(n::Int, k::Int)
0 ≤ k ≤ n  && return binom(n, k)
k ≤ n <  0 && return binom(-k - 1, n - k) * (-1)^(n - k)
n <  0 ≤ k && return binom(-n + k - 1, k) * (-1)^k
ZZ(0)
end
# *** HighlyAbundant.jl ****************
"""
* I002093, F002093, L002093, V002093, I034885, F034885, L034885, V034885
"""
const ModuleHighlyAbundant = ""
"""
Iterate over the first ``n`` highly abundant numbers.
$(SIGNATURES)
"""
I002093(n) = Records(σ, n, true, true)
"""
Iterate over the highly abundant numbers which do not exceed ``n`` (``1 ≤ i ≤ n``).
$(SIGNATURES)
"""
F002093(n) = Records(σ, n, false, true)
"""
Return the first ``n`` highly abundant numbers as an array.
$(SIGNATURES)
"""
L002093(n) = collect(I002093(n))
"""
Return the ``n``-th highly abundant number.
$(SIGNATURES)
"""
V002093(n) = nth(I002093(n), n)
"""
Iterate over the first ``n`` record values of sigma.
$(SIGNATURES)
"""
I034885(n) = Records(σ, n, true, false)
"""
Iterate over the record values of sigma the indices of which do not exceed ``n`` (``1 ≤ r ≤ n``).
$(SIGNATURES)
"""
F034885(n) = Records(σ, n, false, false)
"""
Return the first ``n`` record values of sigma as an array.
$(SIGNATURES)
"""
L034885(n) = collect(I034885(n))
"""
Return the ``n``-th record of sigma.
$(SIGNATURES)
"""
V034885(n) = nth(I034885(n), n)
# *** Hyper1F1.jl ****************
"""
GammaHyp: ``(a, b, c, d)`` ↦ ``Γ(a) `` Hypergeometric``1F1(b, c, d).``

* GammaHyp, V000255, V000262, V001339, V007060, V033815, V099022, V251568
"""
const ModuleHyper1F1 = ""
"""
Return ``Γ(a) `` Hypergeometric``1F1(b, c, d).``
$(SIGNATURES)
"""
function GammaHyp(a, b, c, d)
prec = 64
while prec <= 10000
CC = AcbField(prec)
g = gamma(CC(a)) * hyp1f1(CC(b), CC(c), CC(d))
b, i = unique_integer(g)
b && return i
prec = div(8*prec, 5)
end
error("GammaHyp with $a $b $c $d gives an InexactError!")
end
"""
Return ``(n+1)!`` Hypergeometric1F1``[-n, -n-1, -1]``. Number of fixedpoint-free permutations beginning with 2. (L. Euler).
$(SIGNATURES)
"""
V000255(n) = n == 0 ? ZZ(1) : GammaHyp(n + 2, -n, -n-1, -1)
"""
Return ``n!`` Hypergeometric1F1``[1-n, 2, -1]``. Number of partitions of ``{1,...,n}`` into any number of ordered subsets.
$(SIGNATURES)
"""
V000262(n) = n == 0 ? ZZ(1) : GammaHyp(n + 1, 1 - n, 2, -1)
"""
Return ``(n+1)!`` Hypergeometric1F1``[-n, -n-1, 1]``. Number of arrangements of ``{1, 2, ..., n+1}`` containing the element 1.
$(SIGNATURES)
"""
V001339(n) = n == 0 ? ZZ(1) : GammaHyp(n + 2, -n, -n-1, 1)
"""
Return ``(2n)!`` Hypergeometric1F1``[-n, -2n, -2]``. Number of ways ``n`` couples can sit in a row without any spouses next to each other.
$(SIGNATURES)
"""
V007060(n) = n == 0 ? ZZ(1) : GammaHyp(2n + 1, -n, -2n, -2)
"""
Return ``(2n)!`` Hypergeometric1F1``[-n, -2n, -1]``. Number of acyclic orientations of the Turán graph ``T(2n,n)``.
$(SIGNATURES)
"""
V033815(n) = n == 0 ? ZZ(1) : GammaHyp(2n + 1, -n, -2n, -1)
"""
Return ``(2n)!`` Hypergeometric1F1``[-n, -2n, 1]``.
$(SIGNATURES)
"""
V099022(n) = n == 0 ? ZZ(1) : GammaHyp(2n + 1, -n, -2n, 1)
"""
Return ``((2n)!/(n+1)!)`` Hypergeometric1F1``[1-n, n+2, -1]``. Egf. exp ``(x C(x)^2)`` where ``C(x) = 1 + xC(x)^2`` is the generating function of the Catalan numbers.
$(SIGNATURES)
"""
function V251568(n::Int)
n == 0 && return fmpz(1)
prec = 64
while prec <= 10000
CC = ComplexField(prec)
c = gamma(CC(2 * n + 1)) * hyp1f1(CC(1 - n), CC(n + 2), CC(-1)) / gamma(CC(n + 2))
b, i = unique_integer(c)
b && return i
prec *= 2
end
error("n = $n gives an InexactError!")
end
# *** JacobiTheta.jl ****************
"""
The ``q``-expansion of the Jacobi theta functions 3 and 4 raised to the power ``r`` is computed for various values of ``r``.

* JacobiTheta3Powers, JacobiTheta4Powers, L000122, L002448, L004018, L104794, L005875, L213384, L000118, L035016, L008452, L096727, L000132, L000141, L008451, L000143, L000144, L008453, L000145, L276285, L276286, L276287, L004402, L004406, L004407, L015128, L004403, L001934, L004404, L004405, L004408, L004409, L004410, L004411, L004412, L004413, L004414, L004420, L004421, L004415, L004416, L004417, L004418, L004419, L004422, L004423, L004424, L004425
"""
const ModuleJacobiTheta = ""
"""
The ``q``-expansion to length len of the Jacobi theta function raised to the power ``r``, i.e. ``ϑ(q)^r`` where ``ϑ(q) = 1 + ∑_{k ≥ 1} q^{k^2}``. Number of ways of writing ``n`` as a sum of ``r`` squares.
$(SIGNATURES)
"""
function JacobiTheta3Powers(len::Int, r::Int)
len ≤ 0 && return fmpz[]
R, x = PolynomialRing(ZZ, "x")
e = theta_qexp(r, len, x)
[fmpz(coeff(e, j)) for j in 0:len - 1]
end
"""
Return the ``q``-expansion to length ``len`` of the Jacobi theta function raised to the power ``r``, i.e. ``ϑ(-q)^r`` where ``ϑ(q) = 1 + ∑_{k ≥ 1} q^{k^2} .``
$(SIGNATURES)
"""
function JacobiTheta4Powers(len::Int, r::Int)
len ≤ 0 && return fmpz[]
R, x = PolynomialRing(ZZ, "x")
e = theta_qexp(r, len, -x)
[fmpz(coeff(e, j)) for j in 0:len - 1]
end
"""
Return the number of ways of writing a nonnegative integer n as a square.
$(SIGNATURES)
"""
L000122(len::Int) = JacobiTheta3Powers(len, 1)
"""
Return the expansion of Jacobi theta function ``ϑ(-q)``.
$(SIGNATURES)
"""
L002448(len::Int) = JacobiTheta4Powers(len, 1)
"""
Return the number of ways of writing a nonnegative integer n as a sum of 2 squares.
$(SIGNATURES)
"""
L004018(len::Int) = JacobiTheta3Powers(len, 2)
"""
Return the expansion of ``ϑ_4(q)^2`` in powers of q.
$(SIGNATURES)
"""
L104794(len::Int) = JacobiTheta4Powers(len, 2)
"""
Return the number of ways of writing a nonnegative integer n as a sum of 3 squares.
$(SIGNATURES)
"""
L005875(len::Int) = JacobiTheta3Powers(len, 3)
"""
Return the expansion of ``ϑ_4(q)^3`` in powers of q.
$(SIGNATURES)
"""
L213384(len::Int) = JacobiTheta4Powers(len, 3)
"""
Number of ways of writing a nonnegative integer n as a sum
of 4 squares.
$(SIGNATURES)
"""
L000118(len::Int) = JacobiTheta3Powers(len, 4)
"""
Return the expansion of ``ϑ_4(q)^4`` in powers of q.
$(SIGNATURES)
"""
L096727(len::Int) = JacobiTheta4Powers(len, 4)
"""
Return the number of ways of writing a nonnegative integer n as a sum
of 5 squares.
$(SIGNATURES)
"""
L000132(len::Int) = JacobiTheta3Powers(len, 5)
"""
Return the number of ways of writing a nonnegative integer n as a sum
of 6 squares.
$(SIGNATURES)
"""
L000141(len::Int) = JacobiTheta3Powers(len, 6)
"""
Return the nnumber of ways of writing a nonnegative integer n as a sum
of 7 squares.
$(SIGNATURES)
"""
L008451(len::Int) = JacobiTheta3Powers(len, 7)
"""
Return the number of ways of writing a nonnegative integer n as a sum
of 8 squares.
$(SIGNATURES)
"""
L000143(len::Int) = JacobiTheta3Powers(len, 8)
"""
Return the expansion of ``ϑ_4(q)^8`` in powers of q.
$(SIGNATURES)
"""
L035016(len::Int) = JacobiTheta4Powers(len, 8)
"""
Return the number of ways of writing a nonnegative integer n as a sum
of 9 squares.
$(SIGNATURES)
"""
L008452(len::Int) = JacobiTheta3Powers(len, 9)
"""
Return the number of ways of writing a nonnegative integer n as a sum
of 10 squares.
$(SIGNATURES)
"""
L000144(len::Int) = JacobiTheta3Powers(len, 10)
"""
Return the number of ways of writing a nonnegative integer n as a sum
of 11 squares.
$(SIGNATURES)
"""
L008453(len::Int) = JacobiTheta3Powers(len, 11)
"""
Return the number of ways of writing a nonnegative integer n as a sum
of 12 squares.
$(SIGNATURES)
"""
L000145(len::Int) = JacobiTheta3Powers(len, 12)
"""
Return the number of ways of writing a nonnegative integer n as a sum
of 13 squares.
$(SIGNATURES)
"""
L276285(len::Int) = JacobiTheta3Powers(len, 13)
"""
Return the number of ways of writing a nonnegative integer n as a sum
of 14 squares.
$(SIGNATURES)
"""
L276286(len::Int) = JacobiTheta3Powers(len, 14)
"""
Return the nnumber of ways of writing a nonnegative integer n as a sum
of 15 squares.
$(SIGNATURES)
"""
L276287(len::Int) = JacobiTheta3Powers(len, 15)
"""
Return the expansion of ``1/ϑ_3(q)`` in powers of q.
$(SIGNATURES)
"""
L004402(len::Int) = JacobiTheta3Powers(len, -1)
"""
Return the expansion of ``1/ϑ_4(q)`` in powers of q.
$(SIGNATURES)
"""
L015128(len::Int) = JacobiTheta4Powers(len, -1)
"""
Return the expansion of ``1/ϑ_3(q)^2`` in powers of q.
$(SIGNATURES)
"""
L004403(len::Int) = JacobiTheta3Powers(len, -2)
"""
Return the expansion of ``1/ϑ_4(q)^2`` in powers of q.
$(SIGNATURES)
"""
L001934(len::Int) = JacobiTheta4Powers(len, -2)
"""
Return the expansion of ``1/ϑ_3(q)^3`` in powers of q.
$(SIGNATURES)
"""
L004404(len::Int) = JacobiTheta3Powers(len, -3)
"""
Return the expansion of ``1/ϑ_3(q)^4`` in powers of q.
$(SIGNATURES)
"""
L004405(len::Int) = JacobiTheta3Powers(len, -4)
"""
Return the expansion of ``1/ϑ_3(q)^5`` in powers of q.
$(SIGNATURES)
"""
L004406(len::Int) = JacobiTheta3Powers(len, -5)
"""
Return the expansion of ``1/ϑ_3(q)^6`` in powers of q.
$(SIGNATURES)
"""
L004407(len::Int) = JacobiTheta3Powers(len, -6)
"""
Return the expansion of ``1/ϑ_3(q)^7`` in powers of q.
$(SIGNATURES)
"""
L004408(len::Int) = JacobiTheta3Powers(len, -7)
"""
Return the expansion of ``1/ϑ_3(q)^8`` in powers of q.
$(SIGNATURES)
"""
L004409(len::Int) = JacobiTheta3Powers(len, -8)
"""
Return the expansion of ``1/ϑ_3(q)^9`` in powers of q.
$(SIGNATURES)
"""
L004410(len::Int) = JacobiTheta3Powers(len, -9)
"""
Return the expansion of ``1/ϑ_3(q)^{10}`` in powers of q.
$(SIGNATURES)
"""
L004411(len::Int) = JacobiTheta3Powers(len, -10)
"""
Return the expansion of ``1/ϑ_3(q)^{11}`` in powers of q.
$(SIGNATURES)
"""
L004412(len::Int) = JacobiTheta3Powers(len, -11)
"""
Return the expansion of ``1/ϑ_3(q)^{12}`` in powers of q.
$(SIGNATURES)
"""
L004413(len::Int) = JacobiTheta3Powers(len, -12)
"""
Return the expansion of ``1/ϑ_3(q)^{13}`` in powers of q.
$(SIGNATURES)
"""
L004414(len::Int) = JacobiTheta3Powers(len, -13)
"""
Return the expansion of ``1/ϑ_3(q)^{14}`` in powers of q.
$(SIGNATURES)
"""
L004415(len::Int) = JacobiTheta3Powers(len, -14)
"""
Return the expansion of ``1/ϑ_3(q)^{15}`` in powers of q.
$(SIGNATURES)
"""
L004416(len::Int) = JacobiTheta3Powers(len, -15)
"""
Return the expansion of ``1/ϑ_3(q)^{16}`` in powers of q.
$(SIGNATURES)
"""
L004417(len::Int) = JacobiTheta3Powers(len, -16)
"""
Return the expansion of ``1/ϑ_3(q)^{17}`` in powers of q.
$(SIGNATURES)
"""
L004418(len::Int) = JacobiTheta3Powers(len, -17)
"""
Return the expansion of ``1/ϑ_3(q)^{18}`` in powers of q.
$(SIGNATURES)
"""
L004419(len::Int) = JacobiTheta3Powers(len, -18)
"""
Return the expansion of ``1/ϑ_3(q)^{19}`` in powers of q.
$(SIGNATURES)
"""
L004420(len::Int) = JacobiTheta3Powers(len, -19)
"""
Return the expansion of ``1/ϑ_3(q)^{20}`` in powers of q.
$(SIGNATURES)
"""
L004421(len::Int) = JacobiTheta3Powers(len, -20)
"""
Return the expansion of ``1/ϑ_3(q)^{21}`` in powers of q.
$(SIGNATURES)
"""
L004422(len::Int) = JacobiTheta3Powers(len, -21)
"""
Return the expansion of ``1/ϑ_3(q)^{22}`` in powers of q.
$(SIGNATURES)
"""
L004423(len::Int) = JacobiTheta3Powers(len, -22)
"""
Return the expansion of ``1/ϑ_3(q)^{23}`` in powers of q.
$(SIGNATURES)
"""
L004424(len::Int) = JacobiTheta3Powers(len, -23)
"""
Return the expansion of ``1/ϑ_3(q)^{24}`` in powers of q.
$(SIGNATURES)
"""
L004425(len::Int) = JacobiTheta3Powers(len, -24)
# *** Kolakoski.jl ****************
"""
* KolakoskiList, C000002, I000002, L000002
"""
const ModuleKolakoski = ""
"""
Generate the Kolakoski sequence which is the unique sequence over the alphabet ``{1, 2}`` starting with ``1`` and having the sequence of run lengths identical with itself.
$(SIGNATURES)
"""
C000002() = Channel(csize = 10) do c
x = y = Int(-1)
while true
put!(c, [2, 1][(x & 1) + 1])
f = y & ~(y + 1)
x = xor(x, f)
y = (y + 1) | (f & (x >> 1))
end
end
struct KolakoskiSeq
count::Int
ch::Channel
KolakoskiSeq(count) = new(count, C000002())
end
function Base.iterate(I::KolakoskiSeq)
if I.count == 0
close(I.ch)
return nothing
end
(take!(I.ch), (0))
end
function Base.iterate(I::KolakoskiSeq, S)
j = S[1] + 1
if I.count == j
close(I.ch)
return nothing
end
(take!(I.ch), (j))
end
Base.length(I::KolakoskiSeq) = I.count
Base.eltype(I::KolakoskiSeq) = Int
"""
Iterate over the first ``n`` Kolakoski numbers.
$(SIGNATURES)
"""
I000002(n::Int) = KolakoskiSeq(n)
"""
Return the list of the first ``n`` terms of the Kolakoski sequence.
$(SIGNATURES)
"""
function KolakoskiList(len::Int)
len ≤ 0 && return []
generator = C000002()
L = [take!(generator) for _ in 1:len]
close(generator)
return L
end
"""
Return the list of the first ``n`` terms of the Kolakoski sequence.
$(SIGNATURES)
"""
L000002(n::Int) = KolakoskiList(n)
# *** NarayanaCows.jl ****************
"""
* NarayanasCows, L214551

For background information see
* J.-P. Allouche, T. Johnson, [Narayana's Cows and Delayed Morphisms](http://recherche.ircam.fr/equipes/repmus/jim96/actes/Allouche.ps).
* C.M. Wilmott, [From Fibonacci to the mathematics of cows and quantum circuitry](https://iopscience.iop.org/article/10.1088/1742-6596/574/1/012097/pdf).
"""
const ModuleNarayanaCows = ""
"""
The type object to construct a new instance of the modified Narayanas cows sequence with given length.
$(SIGNATURES)
"""
struct NarayanasCows
length
end
"""
Return the first term of the modified Narayanas cows sequence.
$(SIGNATURES)
"""
function Base.iterate(I::NarayanasCows)
I.length == 0 && return nothing
state = (1, (0, 0, 1, 1))
end
"""
Return the next term of the modified Narayanas cows sequence.
$(SIGNATURES)
"""
function Base.iterate(I::NarayanasCows, (x, y, z, c))
c >= I.length && return nothing
x = div(z + x, gcd(z, x))
(x, (y, z, x, c + 1))
end
Base.length(f::NarayanasCows) = f.length
Base.eltype(f::NarayanasCows) = Int
"""
Return a list of the first n terms of the modified Narayanas cows sequence.
$(SIGNATURES)
"""
L214551(n) = collect(NarayanasCows(n))
# *** NumberTheory.jl ****************
"""
* τ, σ, σ2, ϕ, ω, Ω, ⊥, ⍊
* Divisors, PrimeDivisors, Factors, Radical, mods, Divides, isPrime, isCyclic, isStrongCyclic, isOdd, PrimeList, isPrimeTo, isStrongPrimeTo, isNonnegative, isPositive, isEven, isSquare, isComposite, isSquareFree, isPrimePower, isPowerOfPrimes, isPerfectPower
* V000005, V000010, V000203, V001222, V001221, V008683, V181830, V034444, I003277, L003277, V061142, V034386, V002110, I050384, L050384, V001157
"""
const ModuleNumberTheory = ""
"""
Return true if n is prime false otherwise.
$(SIGNATURES)
"""
isPrime(n) = Nemo.isprime(fmpz(n))
"""
Return factors of ``n``.
$(SIGNATURES)
"""
Factors(n) = n == 0 ? [] : Nemo.factor(fmpz(n))
"""
Return the positive integers dividing ``n``.
$(SIGNATURES)
"""
function Divisors(m, dosort=false)
n = ZZ(m)
n == ZZ(0) && return fmpz[]
Nemo.isprime(n) && return [ZZ(1), n]
d = [ZZ(1)]
for (p, e) in Nemo.factor(n)
d *= permutedims([p^i for i in 0:e])
d = reshape(d, length(d))
end
dosort && sort!(d)
d
end
"""
Return the prime numbers dividing ``n``.
$(SIGNATURES)
"""
function PrimeDivisors(n)
n == 0 && return []
isPrime(n) && return [fmpz(n)]
f = Factors(n)
sort!([p for (p, e) in f])
end
"""
Return the radical of ``n`` which is the product of the prime numbers dividing ``n`` (also called the squarefree kernel of ``n``).
$(SIGNATURES)
"""
Radical(n) = ∏(PrimeDivisors(n))
"""
Return ``Ω(n)``, the number of prime divisors of ``n`` counted with multiplicity (cf. A001222).
$(SIGNATURES)
"""
function Ω(n)
n == fmpz(0) && return 0
isPrime(n) && return fmpz(1)
f = Factors(n)
sum([e for (p, e) in f])
end
"""
Return the number of prime divisors of ``n`` counted with multiplicity.
$(SIGNATURES)
"""
V001222(n) = Ω(n)
"""
Return the result of replacing each prime factor of n with 2.
$(SIGNATURES)
"""
V061142(n) = 1 << Int(Ω(n))
"""
Return ``ω(n)``,  the number of distinct prime divisors of ``n`` (cf. A001221).
$(SIGNATURES)
"""
ω(n) = fmpz(length(PrimeDivisors(n)))
"""
Return the number of distinct prime divisors of ``n``.
$(SIGNATURES)
"""
V001221(n) = ω(n)
"""
Return the number of unitary divisors of ``n``, ``d`` such that ``d`` divides ``n`` and ``d ⊥ n/d``.
$(SIGNATURES)
"""
V034444(n::Int) = 1 << Int(ω(n))
"""
Return ``τ(n)`` (a.k.a. ``σ_0(n)``), the number of divisors of ``n`` (cf A000005).
$(SIGNATURES)
"""
τ(n) = Nemo.sigma(fmpz(n), 0)
"""
Return the number of divisors of ``n``.
$(SIGNATURES)
"""
V000005(n) = τ(n)
"""
Return ``σ(n)`` (a.k.a. ``σ_1(n)``), the sum of the divisors of ``n`` (cf. A000203).
$(SIGNATURES)
"""
σ(n) = Nemo.sigma(fmpz(n), 1)
"""
Return ``σ2(n)`` (a.k.a. ``σ_2(n)``), the sum of squares of the divisors of ``n`` (cf. A001157).
$(SIGNATURES)
"""
σ2(n) = Nemo.sigma(fmpz(n), 2)
"""
Return ``σ2(n)`` (a.k.a. ``σ_2(n)``), the sum of squares of the divisors of ``n``.
$(SIGNATURES)
"""
V001157(n) = σ2(n)
"""
Return the Euler totient ``ϕ(n)``, numbers which are ``≤ n`` and prime to ``n``.
$(SIGNATURES)
"""
ϕ(n) = Nemo.eulerphi(fmpz(n))
"""
Return the number of integers ``≤ n`` and prime to ``n``.
$(SIGNATURES)
"""
V000010(n) = ϕ(n)
"""
Return the value of the Möbius function ``μ(n)`` which is the sum of the primitive n-th roots of unity.
$(SIGNATURES)
"""
μ(n) = Nemo.moebiusmu(fmpz(n))
"""
Return the value of the Möbius function ``μ(n)`` which is the sum of the primitive n-th roots of unity.
$(SIGNATURES)
"""
V008683(n) = μ(n)
"""
Return the sum of the divisors of ``n``.
$(SIGNATURES)
"""
V000203(n) = σ(n)
"""
Query if ``m`` is prime to ``n``.
$(SIGNATURES)
"""
isPrimeTo(m, n) = Nemo.gcd(fmpz(m), fmpz(n)) == fmpz(1)
"""
Query if ``m`` is prime to ``n``. Knuth, Graham and Patashnik write in "Concrete Mathematics": "Hear us, O mathematicians of the world! Let us not wait any longer! We can make many formulas clearer by defining a new notation now! Let us agree to write m ⊥ n, and to say "m is prime to n", if m and n are relatively prime."
$(SIGNATURES)
"""
⊥(m, n) = isPrimeTo(m, n)
"""
Query if ``m`` is strong prime to ``n``. ``m`` is strong prime to ``n`` iff ``m`` is prime to ``n`` and ``m`` does not divide ``n-1``.
$(SIGNATURES)
"""
isStrongPrimeTo(m, n) = isPrimeTo(m, n) && n ∉ Divisors(m - 1)
"""
Query if ``m`` is strong prime to ``n``. ``m`` is strong prime to ``n`` iff ``m`` is prime to ``n`` and ``m`` does not divide ``n-1``.
$(SIGNATURES)
"""
⍊(m, n) = isStrongPrimeTo(m, n)
function NumbersStronglyPrimeTo(n::Int)
P = fmpz[m for m in 1:n if ⊥(m, n)]
D = Divisors(n - 1)
return setdiff(P, D)
end
"""
Return the number of integers ``≤ n`` which are strong prime to ``n``.
$(SIGNATURES)
"""
V181830(n) = n == 0 ? 0 : ϕ(n) - τ(n - 1)
"""
Is ``n`` a cyclic number? ``n`` such that there is just one group of order ``n``.
$(SIGNATURES)
"""
isCyclic(n) = n == 0 ? false : ⊥(n, ϕ(n))
"""
Iterate over the first ``n`` cyclic numbers.
$(SIGNATURES)
"""
I003277(n::Int) = Iterators.take(Iterators.filter(isCyclic, Iterators.countfrom(1)), n)
"""
Return the first ``n`` cyclic numbers in an array.
$(SIGNATURES)
"""
L003277(n::Int) = collect(I003277(n))
"""
Is ``n`` a strong cyclic number?
$(SIGNATURES)
"""
isStrongCyclic(n) = n == 0 ? false : ⍊(n, ϕ(n))
"""
Iterate over the first ``n`` strong cyclic numbers.
$(SIGNATURES)
"""
I050384(n::Int) = Iterators.take(Iterators.filter(isStrongCyclic, Iterators.countfrom(1)), n)
"""
Return the first ``n`` strong cyclic numbers in an array.
$(SIGNATURES)
"""
L050384(n::Int) = collect(I050384(n))
"""
Return the least absolute remainder. mods uses the symmetric representation for integers modulo m, i.e. remainders will be reduced to integers in the range ``[-``div``(|m| - 1, 2), ``div``(|m|, 2)]``.
$(SIGNATURES)
"""
function mods(b, a)
b == 0 && return a
h = a >> 1
(q, r) = divrem(b, a)
if h <  r  r -= a end
if h < -r  r += a end
r
end
"""
Is the integer ``n`` nonnegative?
$(SIGNATURES)
"""
isNonnegative(n) = n ≥ 0
"""
Is the integer ``n`` positive?
$(SIGNATURES)
"""
isPositive(n) = n > 0
"""
Is the integer ``n`` a square number?
$(SIGNATURES)
"""
isSquare(n) = Nemo.issquare(fmpz(n))
"""
Is the integer ``n`` a composite number?
$(SIGNATURES)
"""
isComposite(n) = (n > 0) && 1 < Ω(n)
"""
Is the integer ``n`` a squarefree number?
$(SIGNATURES)
"""
isSquareFree(n) = (n > 0) && ω(n) == Ω(n)
"""
Is the integer ``n`` a prime power?
$(SIGNATURES)
"""
isPrimePower(n) = ω(n) == 1
"""
Is the integer ``n`` a power of primes?
$(SIGNATURES)
"""
isPowerOfPrimes(n) = (n == 1) || (ω(n) == 1)
"""
Is the integer ``n`` a perfect powers?
$(SIGNATURES)
"""
isPerfectPower(n) = ω(n) == 1 && Ω(n) ≠ 1
"""
Return `true` if b is divisible by a, otherwise return `false`.
$(SIGNATURES)
"""
Divides(a, b) = a ≠ 0 && rem(fmpz(b), fmpz(a)) == fmpz(0)
"""
Is ``n`` divisble by 2?
$(SIGNATURES)
"""
isEven(n) = Base.iseven(n)
"""
Is ``n`` indivisble by 2?
$(SIGNATURES)
"""
isOdd(n) = Base.isodd(n)
"""
Return the primorial of ``n``, the product of the primes ``≤ n``.
$(SIGNATURES)
"""
V034386(n) = Nemo.primorial(n)
"""
Return a list of the first ``n`` primes.
$(SIGNATURES)
"""
PrimeList(len::Int) = Iterators.take(Iterators.filter(isPrime, Iterators.countfrom(1)), len)
"""
Return the product of first ``n`` primes.
$(SIGNATURES)
"""
V002110(n) = ∏(PrimeList(n))
# *** OEISUtils.jl ****************
"""
A collection of utilities for handling OEIS related tasks.
"""
const ModuleOEISUtils = ""
srcdir = realpath(joinpath(dirname(@__FILE__)))
ROOTDIR = dirname(srcdir)
datadir = joinpath(ROOTDIR, "data")
"""
Returns the path where the oeis data is expected.
$(SIGNATURES)
"""
oeis_path() = joinpath(datadir, "stripped")
"""
Indicates if the local copy of the OEIS data (the so-called 'stripped' file) is installed (in ../data).
$(SIGNATURES)
"""
oeis_isinstalled() = isfile(oeis_path())
"""
Indicates if the local copy of the OEIS data (the so-called 'stripped' file) is not installed and warns.
$(SIGNATURES)
"""
function oeis_notinstalled()
if !oeis_isinstalled()
@warn("OEIS data not installed! Download stripped.gz from oeis.org,")
@warn("expand it and put it in the directory ../data.")
return true
end
return false
end
"""
Write a so-called b-file for submission to the OEIS. The file is saved in the 'data' directory.
$(SIGNATURES)
"""
function oeis_writebfile(anum::String, fun::Function, range::OrdinalRange)
if !occursin(r"^A[0-9]{6}$", anum)
@warn("Not a valid A-number!")
return
end
filename = joinpath(datadir, "b" * anum[2:end] * ".txt")
@info("Writing " * anum * " to " * filename)
f = open(filename, "w")
for n in range
println(f, n, " ", fun(n))
end
close(f)
end
function oeis_writebfile(anum, list, offset=1)
if !occursin(r"^A[0-9]{6}$", anum)
@warn("Not a valid A-number!")
return
end
filename = joinpath(datadir, "b" * anum[2:end] * ".txt")
@info("Writing " * anum * " to " * filename)
n = offset
f = open(filename, "w")
for l in list
println(f, n, " ", list[n])
n += 1
end
close(f)
end
"""
Read a file in the so-called b-file format of the OEIS.
$(SIGNATURES)
"""
function oeis_readbfile(filename)
@info("Reading "  * filename)
file = open(filename, "r")
lines = readlines(file)
for l in lines
s = split(l, ' ')
i = parse(Int, s[1])
v = parse(Int, s[2])
println(i, " ", v)
end
close(file)
end
"""
Make sure that the length of the data section of an OEIS entry does not exceed 260 characters.
$(SIGNATURES)
"""
function oeis_trimdata(fun, offset::Int)
len = n = 0
S = ""
while true
st = string(fun(offset + n))
len += length(st)
len > 260 && break
S *= st * ", "
len += 2
n += 1
end
println(n, " terms")
return S
end
"""
Download the sequence with A-number 'anum' from the OEIS to a file in json format. The file is saved in the 'data' directory.
$(SIGNATURES)
"""
function oeis_remote(anum)
if !occursin(r"^A[0-9]{6}$", anum)
@warn("Not a valid A-number!")
return
end
filename = joinpath(datadir, anum * ".json")
url = HTTP.URI("http://oeis.org/search?q=id:" * anum * "&fmt=json")
tries = 3
r = nothing
for i = 1:tries
try
r = HTTP.get(url; readtimeout=2)
getfield(r, :status) == 200 && break
getfield(r, :status) == 302 && break
catch e
@warn(e)
end
sleep(2)
end
if r ≠ nothing && getfield(r, :status) == 200
open(filename, "w") do f
write(f, getfield(r, :body))
end
@info("Dowloaded " * basename(filename) * " to " * datadir)
else
if r === nothing
@warn("Could not download $url, connection timed out.\n")
else
@warn("Could not download $url\nStatus: $(getfield(r, :status))")
end
end
end
"""
Get the sequence with A-number 'anum' from a local copy of the expanded 'stripped.gz' file which can be downloaded from the OEIS. 'bound' is an upper bound for the number of terms returned. The 'stripped' file is assumed to be in the '../data' directory.
$(SIGNATURES)
"""
function oeis_local(anum::String, bound::Int)
if !occursin(r"^A[0-9]{6}$", anum)
@warn(anum * " is not a valid A-number!")
return []
end
oeis_notinstalled() && return []
A = Array{String}
data = open(oeis_path())
for ln in eachline(data)
if startswith(ln, anum)
A = split(chop(chomp(ln)), ","; limit=bound + 2)
break;
end
end
close(data)
[convert(fmpz, parse(BigInt, n)) for n in A[2:min(bound + 1, end)]]
end
"""
Search for a sequence in the local OEIS database ('../data/stripped'). Input the sequence as a comma separated string. If restart = true the search is redone in the case that no match was found with the first term removed from the search string. Prints the matches.
$(SIGNATURES)
"""
function oeis_search(seq::String, restart::Bool)
oeis_notinstalled() && return []
found = false
seq = replace(seq, ' ' => "")
println("Searching for:")
println(seq)
data = open(oeis_path())
for line in eachline(data)
index = findfirst(seq, line)
index === nothing && continue
println("Range ", index , " in line: ", line)
found = true
end
close(data)
if !found && restart
ind = findfirst(isequal(','), seq)
if !(ind === nothing) && (length(seq) > ind)
seq = seq[ind + 1:end]
println("Restarting omitting the first term.")
oeis_search(seq, false)
end
end
end
# *** OrthoPolynomials.jl ****************
"""
* OrthoPoly, InvOrthoPoly, T053121, T216916, T217537, T064189, T202327, T111062, T099174, T066325, T049310, T137338, T104562, T037027, T049218, T159834, T137286, T053120, T053117, T111593, T059419, L217924, L005773, L108624, L005425, L000085, L001464, L003723, L006229
"""
const ModuleOrthoPolynomials = ""
"""
By the theorem of Favard an orthogonal polynomial systems  ``p_{n}(x)`` is a sequence of real polynomials with deg``(p_{n}(x)) = n`` for all ``n`` if and only if

`` p_{n+1}(x) = (x - s_n)p_n(x) - t_n p_{n-1}(x) ``

with ``p_{0}(x)=1`` for some pair of seq's ``s_k`` and ``t_k``. Return the coefficients of the polynomials as a triangular array with `dim` rows.
$(SIGNATURES)
"""
function OrthoPoly(dim::Int, s::Function, t::Function)
dim ≤ 0 && return fmpz[]
T = zeros(ZZ, dim, dim)
for n in 1:dim T[n, n] = 1 end
for n in 2:dim
for k in 1:n-1
T[n, k] = ((k > 1 ? T[n-1, k - 1] : 0)
+ s(k-1) * T[n-1, k]
+ t(k ) * T[n-1, k + 1])
end
end
[T[n,k] for n in 1:dim for k in 1:n]
end
"""
Return the inverse of the coefficients of the orthogonal polynomials generated by ``s`` and ``t`` as a triangular array with `dim` rows.
$(SIGNATURES)
"""
function InvOrthoPoly(dim::Int, s::Function, t::Function)
dim ≤ 0 && return fmpz[]
T = zeros(ZZ, dim, dim)
for n in 1:dim T[n, n] = 1 end
for n in 1:dim - 1
for k in 1:n + 1
T[n+1, k] = ((k > 1 ? T[n, k - 1] : 0)
- s(n - 1) * T[n, k]
- (n > 1 ? t(n - 1) * T[n - 1, k] : 0))
end
end
[T[n,k] for n in 1:dim for k in 1:n]
end
"""
Return the Catalan triangle (with 0's) read by rows.
$(SIGNATURES)
"""
T053121(dim::Int) = OrthoPoly(dim, n -> 0, n -> 1)
"""
Return the coefficients of some orthogonal polynomials related to set partitions without singletons (cf. A000296).
$(SIGNATURES)
"""
T216916(dim::Int) = OrthoPoly(dim, n -> n + 1, n -> n + 1)
"""
Return the triangle ``T(n,k)`` of tangent numbers, coefficient of ``x^n/n!`` in the expansion of ``(tan x)^k/k!``.
$(SIGNATURES)
"""
T059419(dim::Int) = OrthoPoly(dim, n -> 0, n -> n * (n-1))
"""
Return the expansion of exp(tan(x)).
$(SIGNATURES)
"""
L006229(len::Int) = RowSums(T059419(len))
"""
Return the first len integers defined as ``a(n) = n! [x^n] \\exp(2 \\exp (x) - x - 2)``.
$(SIGNATURES)
"""
L217924(len::Int) = RowSums(T217537(len))
"""
Return the coefficients of some orthogonal polynomials related to indecomposable set partitions without singletons (cf. A098742).
$(SIGNATURES)
"""
T217537(dim::Int) = OrthoPoly(dim, n -> n , n -> n )
"""
Return the (reflected) Motzkin triangle.
$(SIGNATURES)
"""
T064189(dim::Int) = OrthoPoly(dim, n -> 1, n -> 1)
"""
Return the number of directed animals of size n as an array of length len.
$(SIGNATURES)
"""
L005773(len::Int) = RowSums(T064189(len))
"""
Return the coefficients of ``x^n`` in the expansion of ``((-1-x+√(1+2x+5x^2))/2)^k`` as a triangle with dim rows.
$(SIGNATURES)
"""
T202327(dim::Int) = OrthoPoly(dim, n -> -1, n -> -1)
"""
Return the sequence with generating function satisfying ``x = (A(x)+(A(x))^2)/(1-A(x)-(A(x))^2)``.
$(SIGNATURES)
"""
L108624(len::Int) = RowSums(T202327(len))
"""
Return the triangle ``T(n, k) = \\binom{n}{k} \\times`` involutions``(n - k)``.
$(SIGNATURES)
"""
T111062(dim::Int) = OrthoPoly(dim, n -> 1, n -> n)
"""
Return the number of self-inverse partial permutations.
$(SIGNATURES)
"""
L005425(len::Int) = RowSums(T111062(len))
"""
Return the coefficients of the modified Hermite polynomials.
$(SIGNATURES)
"""
T099174(dim::Int) = OrthoPoly(dim, n -> 0, n -> n)
"""
Return the number of involutions.
$(SIGNATURES)
"""
L000085(len::Int) = RowSums(T099174(len))
"""
Return the coefficients of unitary Hermite polynomials He``_n(x)``.
$(SIGNATURES)
"""
T066325(dim::Int) = InvOrthoPoly(dim, n -> 0, n -> n)
"""
Return the sequence defined by ``a(n) = n! [x^n] \\exp(-x-(x^2)/2)``.
$(SIGNATURES)
"""
L001464(len::Int) = RowSums(T066325(len), true)
"""
Return the triangle of tanh numbers.
$(SIGNATURES)
"""
T111593(dim::Int) = OrthoPoly(dim, n -> 0, n -> -n * (n - 1))
"""
Return the sequence defined by ``A(n) = n! [x^n] \\exp \\tan(x)`` as an array of length `len`.
$(SIGNATURES)
"""
L003723(len::Int) = RowSums(T111593(len))
"""
Return the coefficients of Chebyshev's U``(n, x/2)`` polynomials.
$(SIGNATURES)
"""
T049310(dim::Int) = InvOrthoPoly(dim, n -> 0, n -> 1)
"""
Return the coefficients of the Charlier polynomials with parameter ``a = 1``.
$(SIGNATURES)
"""
T137338(dim::Int) = InvOrthoPoly(dim, n -> n + 1, n -> n + 1)
"""
Return the inverse of the Motzkin triangle (cf. A064189).
$(SIGNATURES)
"""
T104562(dim::Int) = InvOrthoPoly(dim, n -> 1, n -> 1)
"""
Return the skew Fibonacci-Pascal triangle with `dim` rows.
$(SIGNATURES)
"""
T037027(dim::Int) = InvOrthoPoly(dim, n -> -1, n -> -1)
"""
Return the arctangent numbers (expansion of arctan``(x)^n/n!``).
$(SIGNATURES)
"""
T049218(dim::Int) = InvOrthoPoly(dim, n -> 0, n -> n * (n + 1))
"""
Return the coefficients of Hermite polynomials ``H(n, (x-1)/√(2))/(√(2))^n``.
$(SIGNATURES)
"""
T159834(dim::Int) = InvOrthoPoly(dim, n -> 1, n -> n)
"""
Return the coefficients of a variant of the Hermite polynomials.
$(SIGNATURES)
"""
T137286(dim::Int) = InvOrthoPoly(dim, n -> 0, n -> n + 1)
"""
Return the coefficients of the Chebyshev-T polynomials.
$(SIGNATURES)
"""
function T053120(len)
T = ZTriangle(len)
R, x = PolynomialRing(ZZ, "x")
m = 1
for n in 0:len - 1
f = chebyshev_t(n, x)
for k in 0:n
T[m] = coeff(f, k)
m += 1
end
end
T
end
"""
Return the coefficients of the Chebyshev-U polynomials.
$(SIGNATURES)
"""
function T053117(len)
T = ZTriangle(len)
R, x = PolynomialRing(ZZ, "x")
m = 1
for n in 0:len - 1
f = chebyshev_u(n, x)
for k in 0:n
T[m] = coeff(f, k)
m += 1
end
end
T
end
# *** Partitions.jl ****************
"""
An alternative to Combinatorics.partitions.

For n = 100 the benchmark shows:

* 167.598273 seconds (15 allocations: 4.813 KiB)
*  86.960344 seconds (381.14 M allocations:  48.735 GiB, 11.29% gc time)

Our function takes twice as long but the Combinatorics's function takes vastly more space.

* Partition, V080577
"""
const ModulePartitions = ""
"""
Generates the integer partitions of ``n`` in lexicographic order. Ported from Wilf/Nijenhuis "Combinatorial Algorithms". (cf. A080577).
$(SIGNATURES)
"""
function NEXPAR(N::Int)
PAR = Array{Int}(undef, N)
R = Dict{Int,Int}()
M = Dict{Int,Int}()
NLAST = 0
D = 0
@label(L10)
N == NLAST && @goto(L20)
NLAST = N
@label(L30)
S = N
D = 0
@label(L50)
D = D + 1
R[D] = S
M[D] = 1
@label(L40)
MTC = M[D] ≠ N
fill!(PAR, 0)
K = 0
for I in 1:D, J in 1:M[I]
K = K + 1
PAR[K] = R[I]
end
VISIT(PAR)
! MTC && return
@goto(L10)
@label(L20)
! MTC && @goto(L30)
SUM = 1
R[D] > 1 && @goto(L60)
SUM = M[D] + 1
D = D - 1
@label(L60)
F = R[D] - 1
M[D] == 1 && @goto(L70)
M[D] = M[D] - 1
D = D + 1
@label(L70)
R[D] = F
M[D] = 1 + div(SUM, F)
S = SUM % F
S == 0 && @goto(L40)
@goto(L50)
end
"""
Prints the partitions given in the format used in function NEXPAR.
$(SIGNATURES)
"""
function VISIT(P)
println(P)
end
"""
Generates the integer partitions of ``n`` in graded reverse lexicographic order, the canonical ordering of partitions.
$(SIGNATURES)
"""
Partition(n) = NEXPAR(n)
"""
Generates the integer partitions of ``n`` in graded reverse lexicographic order, the canonical ordering of partitions.
$(SIGNATURES)
"""
V080577(n) = NEXPAR(n)
# *** PrimesIterator.jl ****************
"""
* Primes, PrimePi, PrimeSieve
"""
const ModulePrimesIterator = ""
const wheel         = [4,  2,  4,  2,  4,  6,  2,  6]
const wheel_primes  = [7, 11, 13, 17, 19, 23, 29, 31]
const wheel_indices = [0,0,0,0,0,0,0,1,1,1,1,2,2,3,3,3,3,4,4,5,5,5,5,6,6,6,6,6,6,7,7]
@inline function wheel_index(n)
d, r = divrem(n - 1, 30)
return 8d + wheel_indices[r + 2]
end
@inline function wheel_prime(n)
d, r = (n - 1) >>> 3, (n - 1) & 7
return 30d + wheel_primes[r + 1]
end
function mask(limit::Int)
limit < 7 && throw(ArgumentError("The condition limit ≥ 7 must be met."))
n = wheel_index(limit)
m = wheel_prime(n)
sieve = ones(Bool, n)
@inbounds for i = 1:wheel_index(isqrt(limit))
if sieve[i]
p = wheel_prime(i)
q = p^2
j = (i - 1) & 7 + 1
while q ≤ m
sieve[wheel_index(q)] = false
q += wheel[j] * p
j = j & 7 + 1
end
end
end
return sieve
end
function mask(lo::Int, hi::Int)
7 ≤ lo ≤ hi || throw(ArgumentError("The condition 7 ≤ lo ≤ hi must be met."))
lo == 7 && return mask(hi)
wlo, whi = wheel_index(lo - 1), wheel_index(hi)
m = wheel_prime(whi)
sieve = ones(Bool, whi - wlo)
hi < 49 && return sieve
small_sieve = mask(isqrt(hi))
@inbounds for i = 1:length(small_sieve)  # don't use eachindex here
if small_sieve[i]
p = wheel_prime(i)
j = wheel_index(2 * div(lo - p - 1, 2p) + 1)
q = p * wheel_prime(j + 1)
j = j & 7 + 1
while q ≤ m
sieve[wheel_index(q) - wlo] = false
q += wheel[j] * p
j = j & 7 + 1
end
end
end
return sieve
end
"""
Return the prime sieve, as a `BitArray`, of the positive integers (from `lo`, if specified) up to `hi`. Useful when working with either primes or composite numbers.
$(SIGNATURES)
"""
function PrimeSieve(lo::Int, hi::Int)
0 < lo ≤ hi || throw(ArgumentError("The condition 0 < lo ≤ hi must be met."))
sieve = falses(hi - lo + 1)
lo ≤ 2 ≤ hi && (sieve[3 - lo] = true)
lo ≤ 3 ≤ hi && (sieve[4 - lo] = true)
lo ≤ 5 ≤ hi && (sieve[6 - lo] = true)
hi < 7 && return sieve
wheel_sieve = mask(max(7, lo), hi)
lsi = lo - 1
lwi = wheel_index(lsi)
@inbounds for i = 1:length(wheel_sieve)   # don't use eachindex here
sieve[wheel_prime(i + lwi) - lsi] = wheel_sieve[i]
end
return sieve
end
function PrimeSieve(lo::T, hi::T) where {T <: Integer}
lo ≤ hi ≤ typemax(Int) && return PrimeSieve(Int(lo), Int(hi))
throw(ArgumentError("Both endpoints of the interval to sieve must be ≤ $(typemax(Int)), got $lo and $hi."))
end
PrimeSieve(limit::Int) = PrimeSieve(1, limit)
function PrimeSieve(n::Integer)
n ≤ typemax(Int) && return PrimeSieve(Int(n))
throw(ArgumentError("Requested number of primes must be ≤ $(typemax(Int)), got $n."))
end
"""
Return the collection of the prime numbers (from `lo`, if specified) up to `hi`.
$(SIGNATURES)
"""
function Primes(lo::Int, hi::Int)
lo ≤ hi || throw(ArgumentError("The condition lo ≤ hi must be met."))
list = Int[]
lo ≤ 2 ≤ hi && push!(list, 2)
lo ≤ 3 ≤ hi && push!(list, 3)
lo ≤ 5 ≤ hi && push!(list, 5)
hi < 7 && return list
lo = max(2, lo)
sizehint!(list, 5 + floor(Int, hi / (log(hi) - 1.12) - lo / (log(lo) - 1.12 * (lo > 7))))
sieve = mask(max(7, lo), hi)
lwi = wheel_index(lo - 1)
@inbounds for i = 1:length(sieve)
sieve[i] && push!(list, wheel_prime(i + lwi))
end
return list
end
Primes(n::Int) = Primes(1, n)
"""
Return the number of primes ``≤ n``.
$(SIGNATURES)
"""
PrimePi(n::Int) = length(Primes(1, n))
# *** PrimeSwingFactorial.jl ****************
"""
 Cf. P. Luschny, [Swing, divide and conquer the factorial](https://oeis.org/A000142/a000142.pdf), excerpt.

* PSfactorial, Swing
"""
const ModulePrimeSwingFactorial = ""
const SwingOddpart = [1,1,1,3,3,15,5,35,35, 315, 63, 693, 231,
3003, 429, 6435, 6435, 109395,12155,230945,46189,969969,
88179,2028117, 676039,16900975,1300075,35102025,5014575,
145422675,9694845,300540195,300540195]
"""
Computes the odd part of the swinging factorial ``n≀`` (cf. A163590).
$(SIGNATURES)
"""
function swing_oddpart(n::Int)
n < 33 && return ZZ(SwingOddpart[n+1])
sqrtn = isqrt(n)
factors = Primes(div(n,2) + 1, n)
P = Primes(sqrtn + 1, div(n, 3))
s = [p for p in P if isodd(div(n, p))]
for prime in Primes(3, sqrtn)
p, q = 1, n
while true
q = div(q, prime)
q == 0 && break
isodd(q) && (p *= prime)
end
p > 1 && push!(s, p)
end
return ∏(factors)*∏(s)
end
"""
Computes the swinging factorial (a.k.a. Swing numbers n≀) (cf. A056040).
$(SIGNATURES)
"""
function Swing(n::Int)
sh = count_ones(div(n, 2))
swing_oddpart(n) << sh
end
const FactorialOddPart = [1, 1, 1, 3, 3, 15, 45, 315, 315, 2835, 14175, 155925,
467775, 6081075, 42567525, 638512875, 638512875, 10854718875, 97692469875,
1856156927625, 9280784638125, 194896477400625, 2143861251406875,
49308808782358125, 147926426347074375, 3698160658676859375]
"""
Return the largest odd divisor of ``n!``. Cf. A049606.
$(SIGNATURES)
"""
function factorial_oddpart(n::Int)
n < length(FactorialOddPart) && return ZZ(FactorialOddPart[n+1])
swing_oddpart(n)*(factorial_oddpart(div(n,2))^2)
end
"""
Return the factorial ``n! = 1×2× ... ×n``, which is the order of the symmetric group S_n or the number of permutations of n letters (cf. A000142).
$(SIGNATURES)
"""
function PSfactorial(n::Int)
n < 0 && ArgumentError("Argument must be >= 0")
sh = n - count_ones(n)
factorial_oddpart(n) << sh
end
# *** Products.jl ****************
"""
* ∏, Product, F!, RisingFactorial, ↑, FallingFactorial, ↓, MultiFactorial
* V000407, V124320, V265609, V000142, V081125, V001147, V000165, V032031, V007559, V008544, V007696, V001813, V008545, V047053
"""
const ModuleProducts = ""
"""
If ``a ≤ b`` then return the product of ``i`` in ``a:b`` else return ``1``.
$(SIGNATURES)
"""
function ∏(a, b)
n = b - a
if n < 24
p = ZZ(1)
for k in a:b
p *= k
end
return ZZ(p)
end
m = div(a + b, 2)
∏(a, m) * ∏(m + 1, b)
end
"""
If ``a ≤ b`` then return the product of ``i`` in ``a:b`` else return ``1``.
$(SIGNATURES)
"""
Product(a, b) = ∏(a, b)
"""
Return the accumulated product of an array.
$(SIGNATURES)
"""
function ∏(A)
function prod(a, b)
n = b - a
if n < 24
p = ZZ(1)
for k in a:b
p *= A[k]
end
return ZZ(p)
end
m = div(a + b, 2)
prod(a, m) * prod(m + 1, b)
end
A == [] && return 1
prod(1, length(A))
end
"""
Return the accumulated product of an array.
$(SIGNATURES)
"""
Product(A) = ∏(A)
"""
Return frac``{n!} {⌊n/2⌋!}``.
$(SIGNATURES)
"""
V081125(n::Int) = ∏(div(n, 2) + 1, n)
"""
Return the rising factorial which is the product of ``i`` in ``n:(n + k - 1)``.
$(SIGNATURES)
"""
RisingFactorial(n::Int, k::Int) = ∏(n, n + k - 1)
"""
Return the rising factorial which is the product of ``i`` in ``n:(n + k - 1)``. A convenient infix syntax for the rising factorial is n ↑ k.
$(SIGNATURES)
"""
↑(n, k) = RisingFactorial(n, k)
"""
Return the rising factorial i.e. the product of ``i`` in ``n:(n + k - 1)``.
$(SIGNATURES)
"""
V265609(n::Int, k::Int) = RisingFactorial(n, k)
"""
Return the falling factorial which is the product of ``i`` in ``(n - k + 1):n``.
$(SIGNATURES)
"""
FallingFactorial(n::Int, k::Int) = ∏(n - k + 1, n)
"""
Return the falling factorial which is the product of ``i`` in ``(n - k + 1):n``. A convenient infix syntax for the falling factorial is n ↓ k.
$(SIGNATURES)
"""
↓(n, k) = FallingFactorial(n, k)
"""
Return the number of permutations of n letters, ``n! = ∏(1, n)``, the factorial of ``n``. (The notation is a shortcut breaking Julia conventions.)
$(SIGNATURES)
"""
F!(n::Int) = Nemo.fac(n)
"""
Return the factorial numbers.
$(SIGNATURES)
"""
V000142(n::Int) = Nemo.fac(n)
"""
Return the central rising factorial ``(n+1) ↑ (n+1) = (2n+1)! / n!``.
$(SIGNATURES)
"""
V000407(n::Int) = (n + 1) ↑ (n + 1)
"""
Return the restricted rising factorial which is zero for ``n < 0`` or ``k > n``.
$(SIGNATURES)
"""
V124320(n::Int, k::Int) = (n < 0 || k > n) ? 0 : ∏(n, n + k - 1)
"""
Return the multi-factorial which is the function ``n → ∏(a + b, a(n-1) + b)``
$(SIGNATURES)
"""
MultiFactorial(a::Int, b::Int) = n -> ∏([a * k + b for k in 0:(n - 1)])
"""
Return the double factorial of odd numbers, ``1×3×5×...×(2n-1) = (2n-1)!!``.
$(SIGNATURES)
"""
V001147(n::Int) = MultiFactorial(2, 1)(n)
"""
Return the double factorial of even numbers: ``2^n n! = (2n)!!``.
$(SIGNATURES)
"""
V000165(n::Int) = MultiFactorial(2, 2)(n)
"""
Return the triple factorial numbers with shift 1, ``3^n n! = (3n)!!!``.
$(SIGNATURES)
"""
V007559(n::Int) = MultiFactorial(3, 1)(n)
"""
Return the triple factorial numbers with shift 2.
$(SIGNATURES)
"""
V008544(n::Int) = MultiFactorial(3, 2)(n)
"""
Return the triple factorial numbers with shift 3.
$(SIGNATURES)
"""
V032031(n::Int) = MultiFactorial(3, 3)(n)
"""
Return the quadruple factorial numbers with shift 1.
$(SIGNATURES)
"""
V007696(n::Int) = MultiFactorial(4, 1)(n)
"""
Return the quadruple factorial numbers with shift 2, ``(2n)!/n!``.
$(SIGNATURES)
"""
V001813(n::Int) = MultiFactorial(4, 2)(n) # = ∏(n + 1, 2n)
"""
Return the quadruple factorial numbers with shift 3.
$(SIGNATURES)
"""
V008545(n::Int) = MultiFactorial(4, 3)(n)
"""
Return the quadruple factorial numbers ``4^n n!``.
$(SIGNATURES)
"""
V047053(n::Int) = MultiFactorial(4, 4)(n)
# *** QueensProblems.jl ****************
"""
For some background see: [Backtracking with profiles](https://wp.me/paipV7-E).

* Queens, L319284
"""
const ModuleQueensProblems = ""
function solve!(profile, level, size, start, cols, diag4, diag1)
if level > 0
for i in start:size
save = cols & (1 << i) +
diag1 & (1 << (i + level)) +
diag4 & (1 << (32 + i - level))
if save == 0
cols  = xor(cols,  1 << i)
diag1 = xor(diag1, 1 << (i + level))
diag4 = xor(diag4, 1 << (32 + i - level))
solve!(profile, level - 1, size, 0, cols, diag4, diag1)
cols  = xor(cols,  1 << i)
diag1 = xor(diag1, 1 << (i + level))
diag4 = xor(diag4, 1 << (32 + i - level))
profile[level + 1] += 1
end
end
else
for i in 0:size
save = cols & (1<<i) + diag1 & (1<<i) + diag4 & (1<<(32+i))
save == 0 && (profile[1] += 1)
end
end
end
function search(n::Int)
profile = zeros(Int, n + 1)
cols = diag4 = diag1 = Int(0)
solve!(profile, n - 1, n - 1, 0, cols, diag4, diag1)
return profile
end
"""
Returns the profile of the backtrack tree for the n queens problem (see `A319284`).
$(SIGNATURES)
"""
function Queens(n::Int)
n == 0 && return [1]
profile = search(n)
profile[n+1] = 1  # add the root
[profile[n-i+1] for i = 0:n]
end
"""
Returns the profile of the backtrack tree for the n queens problem.
$(SIGNATURES)
"""
L319284(n) = Queens(n)
# *** RationalTrees.jl ****************
"""
Rational trees as understood here are binary trees enumerating the positive or
nonnegative rational numbers. Examples are the Euclid tree, the Kepler tree and the
Stern-Brocot tree (a.k.a. Farey tree). They are closely related to binary partitions
and to Stern's diatomic sequence or Dijkstra's fusc function.

Malter, Schleicher, Zagier, [New looks at old number theory](https://pdfs.semanticscholar.org/6d28/dcef911dd91f47e6ca4bd2c564c1f3099a05.pdf), Amer. Math. Monthly, 120(3), 2013, pp. 243-264.

* EuclidTree, CalkinWilfTree, SchinzelSierpinskiEncoding
"""
const ModuleRationalTrees = ""
"""
```
julia> for n in 1:4 Println(EuclidTree(n)) end
[1//1]
[1//2, 2//1]
[1//3, 3//2, 2//3, 3//1]
[1//4, 4//3, 3//5, 5//2, 2//5, 5//3, 3//4, 4//1]
```
$(SIGNATURES)
"""
function EuclidTree(n)
function DijkstraFusc(m)
a, b, k = 1, 0, m
while k > 0
k % 2 == 1 ? b += a : a += b
k = k >> 1
end
b end
DF = [DijkstraFusc(k) for k in 2^(n-1):2^n]
[fmpq(DF[j], DF[j+1]) for j in 1:2^(n-1)]
end
"""
Alias for the (much better named) EuclidTree. See Malter, Schleicher, Zagier, New looks at old number theory, Amer. Math. Monthly, 120(3), 2013, pp. 243-264.
$(SIGNATURES)
"""
CalkinWilfTree(n) = EuclidTree(n)
"""
Return the Schinzel-Sierpinski encoding of the positive rational number r.

```
julia> for n in 1:4 println([SchinzelSierpinski(l) for l in EuclidTree(n)]) end
[1//1]
[2//5, 5//2]
[3//11, 5//3, 3//5, 11//3]
[2//11, 3//2, 11//19, 19//7, 7//19, 19//11, 2//3, 11//2]
```
$(SIGNATURES)
"""
function SchinzelSierpinskiEncoding(l, searchLimit=500000)
a, b = numerator(l), denominator(l)
sgn = a < b ? -1 : 1
p, q = 1, 2
while q < searchLimit
r = a*(q + 1)
r % b == 0 && (p = div(r, b) - 1)
isPrime(p) && return fmpq(p, q)
q = NextPrime(q)
end
warn("Search limit reached for ", l )
return 0
end
# *** RecordSearch.jl ****************
"""
The type object to construct an iterated search for records in sequences.

* Records
"""
const ModuleRecordSearch = ""
"""
The type object to construct an iterated search for records in sequences.
$(SIGNATURES)
"""
struct Records
"function representing the sequence"
fun::Function
"search limit OR search length"
lim::Int
"true ↦ search all below lim, false ↦ search length items"
below::Bool
"true ↦ return index of record, false ↦ return value of record"
index::Bool
end
Base.iterate(::Records) = (ZZ(1), (ZZ(1), ZZ(0), ZZ(1)))
"""
Return the value or the index of the next record.
$(SIGNATURES)
"""
function Base.iterate(R::Records, state)
h, n, s = state
(R.below ? s : n) >= R.lim && return nothing
while true
v = R.fun(n)
v > h && return (R.index ? n : v, (v, n + 1, s + 1))
n += 1
end
end
Base.length(R::Records) = R.lim
Base.eltype(R::Records) = fmpz
# *** RiordanSquares.jl ****************
"""
The Riordan product is a map a, b ↦ [a, b] associating two formal power series a, b with a lower triangular matrix [a, b]. The Riordan square is the case a = b of the Riordan product. Formally we can describe the Riordan square as a transform RS: Z[[x]] ↦ Mat[Z] which maps power series over the integers to (lower triangular) integer matrices.

* RiordanProduct, RiordanSquare
* T039599, T116392, T172094, T321620, T321621, T321623, T321624, T322942

[Introduction to the Riordan Square](http://luschny.de/math/seq/RiordanSquare.html)
"""
const ModuleRiordanSquares = ""
"""
Return the Riordan array associated with the generating functions a and b.
$(SIGNATURES)
"""
function RiordanProduct(a, b, dim, expo=false)
A = Coefficients(a, dim)
B = b == nothing ? A : Coefficients(b, dim)
M = identity_matrix(QQ, dim)
for k in 1:dim M[k, 1] = A[k] end
for k in 2:dim, m in k+1:dim
M[m, k] = sum(M[j+1, k-1]*B[m-j] for j in k-2:m-2)
end
toΔ(M)
end
"""
Return the Riordan array (Riordan product) ``a \times a``.
$(SIGNATURES)
"""
RiordanSquare(a, n, expo=false) = RiordanProduct(a, nothing, n, expo)
"""
The Riordan square of the Catalan numbers.
$(SIGNATURES)
"""
T039599(n) = RiordanSquare(G000108, n)
"""
The Riordan square of the central trinomial.
$(SIGNATURES)
"""
T116392(n) = RiordanSquare(G002426, n)
"""
The Riordan square of the little Schröder numbers.
$(SIGNATURES)
"""
T172094(n) = RiordanSquare(G001003, n)
"""
The Riordan square of the Riordan numbers (with 1 prepended).
$(SIGNATURES)
"""
T321620(n) = RiordanSquare(G005043, n)
"""
The Riordan square of the Motzkin numbers.
$(SIGNATURES)
"""
T321621(n) = RiordanSquare(G001006, n)
"""
The Riordan square of the large Schröder numbers.
$(SIGNATURES)
"""
T321623(n) = RiordanSquare(G006318, n)
"""
The Riordan square of the Lucas numbers.
$(SIGNATURES)
"""
T321624(n) = RiordanSquare(G000032, n)
"""
The Riordan square of the Jacobsthal numbers.
$(SIGNATURES)
"""
T322942(n) = RiordanSquare(G001045, n)
# *** SelfConvolutive.jl ****************
"""
Some exactly solvable self-convolutive recurrences.

* SelfConvRec, L000698, L001710, L003319, L005411, L005412, L006012, L006318
L047891, L062980, L082298, L082301, L082302, L105523, L107716
L111529, L111530, L111531, L111532, L111533, L146559, L167872
"""
const ModuleSelfConvolutive = ""
Convolution(A, n) = sum(A[j+1] * A[n-j+1] for j in 0:n)
"""
An exactly solvable self-convolutive recurrence studied by R. J. Martin and M. J. Kearney.
$(SIGNATURES)
"""
function SelfConvRec(len, a, b, c)
A = fill(ZZ(0), len)
len == 0 && return A
A[1] = 1
for n in 1:len - 1
A[n+1] = (a * (n + 1) + b) * A[n] + c * Convolution(A, n-1)
end
A
end
"""
Return the number of indecomposable perfect matchings on ``[2n]``.
$(SIGNATURES)
"""
L000698(len::Int) = SelfConvRec(len, 2, -3, 1)
"""
Return the order of alternating group ``A_n``, or number of even permutations of ``n`` letters.
$(SIGNATURES)
"""
L001710(len::Int) = SelfConvRec(len, 1, 1, 0)
"""
Return the number of connected permutations of ``[1..n]``. Also called indecomposable permutations.
$(SIGNATURES)
"""
L003319(len::Int) = SelfConvRec(len, 1, -2, 1)
"""
Return the number of non-vanishing Feynman diagrams of order ``2n`` for the electron or the photon propagators in quantum electrodynamics.
$(SIGNATURES)
"""
L005411(len::Int) = SelfConvRec(len, 2, -4, 1)
"""
Return the number of non-vanishing Feynman diagrams of order ``2n`` for the vacuum polarization in quantum electrodynamics.
$(SIGNATURES)
"""
L005412(len::Int) = SelfConvRec(len, 2, -2, 1)
"""
Counting some sets of permutations.
$(SIGNATURES)
"""
L006012(len::Int) = SelfConvRec(len, -1, 2, 2)
"""
Return the large Schröder numbers.
$(SIGNATURES)
"""
L006318(len::Int) = SelfConvRec(len, 0, 1, 1)
"""
Return the number of planar rooted trees with ``n`` nodes and tricolored end nodes.
$(SIGNATURES)
"""
L047891(len::Int) = SelfConvRec(len, 0, 2, 1)
"""
Return the number of rooted unlabeled connected triangular maps on a compact closed oriented surface with ``2n`` faces.
$(SIGNATURES)
"""
L062980(len::Int) = SelfConvRec(len, 6, -8, 1)
"""
Return the number of lattice paths from ``(0,0)`` to ``(n+1,n+1)`` that consist of steps ``(i,0)`` and ``(0,j)`` with ``i,j≥1`` and stay strictly below the diagonal line ``y=x`` except at the endpoints.
$(SIGNATURES)
"""
L082298(len::Int) = SelfConvRec(len, 0, 3, 1)
"""
Return the number of Schröder paths of semilength n in which the (2,0)-steps come in 4 colors.
$(SIGNATURES)
"""
L082301(len::Int) = SelfConvRec(len, 0, 4, 1)
"""
Return the coefficients in the expansion of ``(1-5x-√(25x^2-14x+1))/(2x)``.
$(SIGNATURES)
"""
L082302(len::Int) = SelfConvRec(len, 0, 5, 1)
"""
Return the coefficients in the expansion of ``(1+2x-√(1+4x^2))/(2x)``.
$(SIGNATURES)
"""
L105523(len::Int) = SelfConvRec(len, 0, -2, 1)
"""
A transform the of triple factorial numbers.
$(SIGNATURES)
"""
L107716(len::Int) = SelfConvRec(len, 3, -4, 1)
"""
A convolutory inverse of the factorial sequence.
$(SIGNATURES)
"""
L111529(len::Int) = SelfConvRec(len, 1, -3, 2)
"""
A convolutory inverse of the factorial sequence.
$(SIGNATURES)
"""
L111530(len::Int) = SelfConvRec(len, 1, -4, 3)
"""
A convolutory inverse of the factorial sequence.
$(SIGNATURES)
"""
L111531(len::Int) = SelfConvRec(len, 1, -5, 4)
"""
A convolutory inverse of the factorial sequence.
$(SIGNATURES)
"""
L111532(len::Int) = SelfConvRec(len, 1, -6, 5)
"""
A convolutory inverse of the factorial sequence.
$(SIGNATURES)
"""
L111533(len::Int) = SelfConvRec(len, 1, -7, 6)
"""
Return the expansion of ``(1-x)/(1 - 2x + 2x^2)``.
$(SIGNATURES)
"""
L146559(len::Int) = SelfConvRec(len, 1, 1, -2)
"""
Return half the number of Feynman diagrams of order ``2(n+1)``, for the electron self-energy in quantum electrodynamics.
$(SIGNATURES)
"""
L167872(len::Int) = SelfConvRec(len, 2, -3, 2)
# *** SeqUtils.jl ****************
"""
Nemo is a library designed, developed and maintained by William Hart with the help of others. Many functions in our project are based on Nemo.
"""
const ModuleSeqUtils = ""
"""
The basic integer type of our project is 'Nemo.fmpz'. Think of a 'Nemo.fmpz' as a 'BigInt'. 'fmpz' stands for 'fast multiple precision zahl' (zahl=integer). The mathematical symbol for the ring of integers is the blackboard (double-struck) Z, also written ZZ. In reference to this ZZ(n) defines the integer n as a fmpz.
$(SIGNATURES)
"""
function Nemofmpz(n::Int) return ZZ(n) end
"""
Return an array of type `fmpz` of length ``n`` preset with ``0``.
$(SIGNATURES)
"""
ZArray(len::Int) = zeros(ZZ, len)
"""
Return an array of type fmpz and of size ``n`` filled by the values of the function ``f`` in the range `offset:n`.
$(SIGNATURES)
"""
function ZArray(n::Int, f::Function, offset=1)
n ≤ 0 && return fmpz[]
fmpz[f(k) for k in offset:offset+n-1] # !
end
"""
Return the size of the array ``A``.
$(SIGNATURES)
"""
SeqSize(A) = Base.length(A)
"""
Return the range of a SeqArray.
$(SIGNATURES)
"""
SeqRange(A) = 1:SeqSize(A)
"""
Print the array ``A`` in the format ``n ↦ A[n]`` for n in the given range.
$(SIGNATURES)
"""
function SeqShow(A::Array, R::AbstractRange, offset=0)
for k in R
if isassigned(A, k)
println(k + offset, " ↦ ", A[k])
else
println(k + offset, " ↦ ", "undef")
end
end
end
"""
Print the array ``A`` in the format ``n ↦ A[n]`` for n in the range first:last.
$(SIGNATURES)
"""
SeqShow(A, first::Int, last::Int) = SeqShow(A, first:last)
"""
Print the array ``A`` in the format ``n ↦ A[n]``.
$(SIGNATURES)
"""
SeqShow(A::Array, offset=0) = SeqShow(A, 1:length(A), offset - 1)
function print_without_type(io, v::AbstractVector)
print(io, "[")
for (i, el) in enumerate(v)
i > 1 && print(io, ", ")
print(io, el)
end
println(io, "]")
end
"""
Print the array without typeinfo.
$(SIGNATURES)
"""
Println(v::AbstractVector) = print_without_type(IOContext(stdout), v)
"""
Print the array with or without typeinfo.
$(SIGNATURES)
"""
function SeqPrint(v::AbstractVector, typeinfo = false)
typeinfo ? println(v) : Println(v)
end
"""
Valid prefixes to the numerical part of the OEIS A-numbers.

* C => Channel
* F => Filter (all below n)
* G => Generating function
* I => Iteration
* L => List (array based)
* M => Matrix
* R => RealFunction
* S => Staircase (iteration)
* T => Triangle (iteration)
* TA => Triangle (triangular array)
* TL => Triangle (flat-list array)
* V => Value
* is => is a (predicate), boolean
$(SIGNATURES)
"""
const ValidPrefixes = ['C', 'F', 'G', 'I', 'L', 'M', 'R', 'S', 'T', 'V']
"""
Return the name of a OEIS sequence given a similar named function as a string.
$(SIGNATURES)
"""
function SeqName(fun)
aname = string(fun)
for X in ValidPrefixes
aname = replace(aname, X => 'A')
end
if !occursin(r"^A[0-9]{6}$", aname)
fullname = split(aname, ".")
aname = String(fullname[end])
if !occursin(r"^A[0-9]{6}$", aname)
@error(aname, " is not a valid A-name!")
return
end
end
aname
end
"""
Return the A-number of a OEIS sequence given a similar named function as an integer.
$(SIGNATURES)
"""
function SeqNum(seq)
aname = SeqName(seq)
parse(Int, aname[2:end])
end
# *** SeriesExpansion.jl ****************
"""
The generating functions of various combinatorial and number-theoretic functions.

* Coefficients, G000045, G000257, L000257, G000032, L000032, G000073, L000073, G000108, L000108, G000957, L000957, G001003, L001003, G001006, L001006, G001045, L001045, G002426, L002426, G005043, L005043, G006318, G068875, L068875
"""
const ModuleSeriesExpansion = ""
"""
Return the list of coefficients of the power series s.
$(SIGNATURES)
"""
function Coefficients(s, len)
R, x = PowerSeriesRing(ZZ, len + 2, "x")
ser = s(x)
[coeff(ser, k) for k in 0:len-1]
end
"""
The generating function of the Lucas numbers.
$(SIGNATURES)
"""
G000032(x) = 1 + divexact(x*(1 + 2x), 1 - x - x^2)
"""
Return a list of Lucas numbers.
$(SIGNATURES)
"""
L000032(n) = Coefficients(G000032, n)
"""
The generating function of the Fibonacci numbers.
$(SIGNATURES)
"""
G000045(x) = divexact(x, 1 - x - x^2)
"""
The generating function of the Tribonacci numbers.
$(SIGNATURES)
"""
G000073(x) = inv(1 - x - x^2 - x^3)
"""
Return a list of Tribonacci numbers.
$(SIGNATURES)
"""
L000073(n) = Coefficients(G000073, n)
"""
The generating function of the Catalan numbers.
$(SIGNATURES)
"""
G000108(x) = divexact(1 - sqrt(1 - 4x), 2x)
"""
Return a list of Catalan numbers.
$(SIGNATURES)
"""
L000108(n) = Coefficients(G000108, n)
"""
The generating function of the number of rooted bicubic maps.
$(SIGNATURES)
"""
G000257(x) = divexact(sqrt((1 - 8x)^3) + 8x^2 + 12x - 1, 32x^2)
"""
Return a list of the number of rooted bicubic maps.
$(SIGNATURES)
"""
L000257(n) = Coefficients(G000257, n)
"""
The generating function of the Fine numbers (with a(0) = 1).
$(SIGNATURES)
"""
G000957(x) = 1 + divexact(1 - sqrt(1 - 4x), 3 - sqrt(1 - 4x))
"""
Return a list of Fine numbers.
$(SIGNATURES)
"""
L000957(n) = Coefficients(G000957, n)
"""
The generating function of the little Schröder numbers.
$(SIGNATURES)
"""
G001003(x) = divexact(1 + x - sqrt(1 - 6x + x^2), 4x)
"""
Return a list of little Schröder numbers.
$(SIGNATURES)
"""
L001003(n) = Coefficients(G001003, n)
"""
The generating function of the Motzkin numbers.
$(SIGNATURES)
"""
G001006(x) = divexact(1 - x - sqrt(1 - 2x - 3x^2), 2x^2)
"""
Return a list of Motzkin numbers.
$(SIGNATURES)
"""
L001006(n) = Coefficients(G001006, n)
"""
The generating function of the Jacobsthal numbers (with a(0) = 1).
$(SIGNATURES)
"""
G001045(x) = divexact(2x^2 - 1, (x + 1)*(2x - 1))
"""
Return a list of Jacobsthal numbers.
$(SIGNATURES)
"""
L001045(n) = Coefficients(G001045, n)
"""
The generating function of the central trinomial.
$(SIGNATURES)
"""
G002426(x) = inv(sqrt(1 - 2x - 3x^2))
"""
Return a list of the central trinomials.
$(SIGNATURES)
"""
L002426(n) = Coefficients(G002426, n)
"""
The generating function of the Riordan numbers with 1 prepended.
$(SIGNATURES)
"""
G005043(x) = 1 + divexact(2x , 1 + x + sqrt(1 - 2x - 3x^2))
"""
Return a list of the Riordan numbers (1 prepended).
$(SIGNATURES)
"""
L005043(n) = Coefficients(G005043, n)
"""
The generating function of the large Schröder numbers.
$(SIGNATURES)
"""
G006318(x) = divexact(1 - x - sqrt(1 - 6x + x^2), 2x)
"""
The generating function of twice the Catalan numbers.
$(SIGNATURES)
"""
G068875(x) = shift_right(1 - x - sqrt(1 - 4x), 1)
"""
Return a list of twice the Catalan numbers.
$(SIGNATURES)
"""
L068875(n) = Coefficients(G068875, n)
# *** StirlingLahNumbers.jl ****************
"""
* I132393, L132393, V132393, M132393, I048993, L048993, V048993, M048993, I271703, L271703, V271703, M271703, I094587, L094587, V094587, M094587, I008279, L008279, V008279, M008279
"""
const ModuleStirlingNumbers = ""
"""
Recurrence for A132393, StirlingCycle numbers.
$(SIGNATURES)
"""
function R132393(n::Int, k::Int, prevrow::Function)
(k == 0 && n == 0) && return ZZ(1)
(n - 1)*prevrow(k) + prevrow(k - 1)
end
"""
Recurrence for A048993, StirlingSet numbers.
$(SIGNATURES)
"""
function R048993(n::Int, k::Int, prevrow::Function)
(k == 0 && n == 0) && return ZZ(1)
k*prevrow(k) + prevrow(k - 1)
end
"""
Recurrence for A271703, Lah numbers.
$(SIGNATURES)
"""
function R271703(n::Int, k::Int, prevrow::Function)
(k == 0 && n == 0) && return ZZ(1)
(k - 1 + n)*prevrow(k) + prevrow(k - 1)
end
"""
Recurrence for A094587.
$(SIGNATURES)
"""
function R094587(n::Int, k::Int, prevrow::Function)
(k == 0 && n == 0) && return ZZ(1)
(n - k)*prevrow(k) + prevrow(k - 1)
end
"""
Recurrence for A008279. Number of permutations of n things k at a time.
$(SIGNATURES)
"""
function R008279(n::Int, k::Int, prevrow::Function)
(k == 0 && n == 0) && return ZZ(1)
prevrow(k) + k*prevrow(k - 1)
end
"""
Iterates over the first n rows of `A132393`.
$(SIGNATURES)
"""
I132393(n) = RecTriangle(n, R132393)
"""
Iterates over the first n rows of `A048993`.
$(SIGNATURES)
"""
I048993(n) = RecTriangle(n, R048993)
"""
Iterates over the first n rows of `A271703`.
$(SIGNATURES)
"""
I271703(n) = RecTriangle(n, R271703)
"""
Iterates over the first n rows of `A094587`.
$(SIGNATURES)
"""
I094587(n) = RecTriangle(n, R094587)
"""
Iterates over the first n rows of `A008279`.
$(SIGNATURES)
"""
I008279(n) = RecTriangle(n, R008279)
"""
Lists the first n rows of `A132393` by concatenating.
$(SIGNATURES)
"""
L132393(n) = vcat(I132393(n)...)
"""
Lists the first n rows of `A048993` by concatenating.
$(SIGNATURES)
"""
L048993(n) = vcat(I048993(n)...)
"""
Lists the first n rows of `A271703` by concatenating.
$(SIGNATURES)
"""
L271703(n) = vcat(I271703(n)...)
"""
Lists the first n rows of `A094587` by concatenating.
$(SIGNATURES)
"""
L094587(n) = vcat(I094587(n)...)
"""
Lists the first n rows of `A008279` by concatenating.
$(SIGNATURES)
"""
L008279(n) = vcat(I008279(n)...)
"""
Return the triangular array as a square matrix with dim rows.
$(SIGNATURES)
"""
M132393(dim) = fromΔ(I132393(dim))
"""
Return the triangular array as a square matrix with dim rows.
$(SIGNATURES)
"""
M048993(dim) = fromΔ(I048993(dim))
"""
Return the triangular array as a square matrix with dim rows.
$(SIGNATURES)
"""
M271703(dim) = fromΔ(I271703(dim))
"""
Return the triangular array as a square matrix with dim rows.
$(SIGNATURES)
"""
M094587(dim) = fromΔ(I094587(dim))
"""
Return the triangular array as a square matrix with dim rows.
$(SIGNATURES)
"""
M008279(dim) = fromΔ(I008279(dim))
"""
Return row n of A132393 based on the iteration `I132393`(n).
$(SIGNATURES)
"""
V132393(n) = nth(I132393(n+1), n+1)
"""
Return row n of A048993 based on the iteration `I048993`(n).
$(SIGNATURES)
"""
V048993(n) = nth(I048993(n+1), n+1)
"""
Return row n of A271703 based on the iteration `I271703`(n).
$(SIGNATURES)
"""
V271703(n) = nth(I271703(n+1), n+1)
"""
Return row n of A094587 based on the iteration `I094587`(n).
$(SIGNATURES)
"""
V094587(n) = nth(I094587(n+1), n+1)
"""
Return row n of A008279 based on the iteration `I008279`(n).
$(SIGNATURES)
"""
V008279(n) = nth(I008279(n+1), n+1)
# *** SwingFactorial.jl ****************
"""
Basic implementation of the swing algorithm using no primes. Claims to be the most efficient simple algorithm to compute the factorial. An advanced version based on prime-factorization is available as the prime-swing factorial factorialPS.

* Sfactorial
"""
const ModuleSwingFactorial = ""
"""
Return the factorial of ``n``. Basic implementation of the swing algorithm using no primes. An advanced version based on prime-factorization is available as the prime-swing factorial factorialPS.
$(SIGNATURES)
"""
function Sfactorial(n::Int)::fmpz
smallOddFactorial =           fmpz[0x0000000000000000000000000000001,
0x0000000000000000000000000000001, 0x0000000000000000000000000000001,
0x0000000000000000000000000000003, 0x0000000000000000000000000000003,
0x000000000000000000000000000000f, 0x000000000000000000000000000002d,
0x000000000000000000000000000013b, 0x000000000000000000000000000013b,
0x0000000000000000000000000000b13, 0x000000000000000000000000000375f,
0x0000000000000000000000000026115, 0x000000000000000000000000007233f,
0x00000000000000000000000005cca33, 0x0000000000000000000000002898765,
0x00000000000000000000000260eeeeb, 0x00000000000000000000000260eeeeb,
0x0000000000000000000000286fddd9b, 0x00000000000000000000016beecca73,
0x000000000000000000001b02b930689, 0x00000000000000000000870d9df20ad,
0x0000000000000000000b141df4dae31, 0x00000000000000000079dd498567c1b,
0x00000000000000000af2e19afc5266d, 0x000000000000000020d8a4d0f4f7347,
0x000000000000000335281867ec241ef, 0x0000000000000029b3093d46fdd5923,
0x0000000000000465e1f9767cc5866b1, 0x0000000000001ec92dd23d6966aced7,
0x0000000000037cca30d0f4f0a196e5b, 0x0000000000344fd8dc3e5a1977d7755,
0x000000000655ab42ab8ce915831734b, 0x000000000655ab42ab8ce915831734b,
0x00000000d10b13981d2a0bc5e5fdcab, 0x0000000de1bc4d19efcac82445da75b,
0x000001e5dcbe8a8bc8b95cf58cde171, 0x00001114c2b2deea0e8444a1f3cecf9,
0x0002780023da37d4191deb683ce3ffd, 0x002ee802a93224bddd3878bc84ebfc7,
0x07255867c6a398ecb39a64b83ff3751, 0x23baba06e131fc9f8203f7993fc1495]
function oddProduct(m::Int, len::Int)
if len < 24
p = fmpz(m)
for k in 2:2:2(len-1)
p *= (m - k)
end
return p
end
hlen = len >> 1
oddProduct(m - 2 * hlen, len - hlen) * oddProduct(m, hlen)
end
function oddFactorial(n)
if n < 41
oddFact = smallOddFactorial[1+n]
sqrOddFact = smallOddFactorial[1+div(n, 2)]
else
sqrOddFact, oldOddFact = oddFactorial(div(n, 2))
len = div(n - 1, 4)
(n % 4) != 2 && (len += 1)
high = n - ((n + 1) & 1)
oddSwing = div(oddProduct(high, len), oldOddFact)
oddFact = sqrOddFact^2 * oddSwing
end
(oddFact, sqrOddFact)
end
n < 0 && ArgumentError("n must be ≥ 0")
if n == 0 return fmpz(1) end
sh = n - count_ones(n)
oddFactorial(n)[1] << sh
end
# *** Triangles.jl ****************
"""
* Triangle, ZTriangle, QTriangle, RecTriangle, TriangularNumber, isTriangular, assertTriangular, ShowAsΔ, ShowAsMatrix, Row, RowSums, fromΔ, toΔ, TriangleToList
"""
const ModuleTriangles = ""
abstract type AbstractTriangle end
"""
A Triangle is a list of rows. The rows of the triangle are generated by a function `(n::Int, k::Int) → gen::fmpz` for ``0 ≤ k ≤ n`` and ``0 ≤ n <``dim.
$(SIGNATURES)
"""
struct Triangle <: AbstractTriangle
dim::Int
gen::Function
function Triangle(dim::Int, gen::Function)
dim <= 0 && throw(ArgumentError("dim has to be a positive integer."))
new(dim, (n::Int, k::Int) -> gen(n, k)::fmpz )
end
end
"""
Return the first row of the triangle.
$(SIGNATURES)
"""
function Base.iterate(T::Triangle)
([T.gen(0, 0)], 1)
end
"""
Return the next row of the triangle.
$(SIGNATURES)
"""
function Base.iterate(T::Triangle, n)
n >= T.dim && return nothing
row = [T.gen(n, k) for k in 0:n]
(row, n + 1)
end
Base.length(T::Triangle) = T.dim
Base.eltype(T::Triangle) = fmpz
"""
A recursive triangle `RecTriangle` is a subtype of `AbstractTriangle`.
The rows of the triangle are generated by a function `gen(n, k, prevrow)` defined for ``n ≥ 0`` and ``0 ≤ k ≤ n``. The function returns value of type Nemo.fmpz.

The parameter prevrow is a function which returns the values of `row(n-1)` of the triangle and 0 if ``k < 0`` or ``k > n``. The function prevrow is provided
by an instance of `RecTriangle` and must not be defined by the user.
$(SIGNATURES)
"""
struct RecTriangle <: AbstractTriangle
dim::Int
A::Array{fmpz}
gen::Function  # generating function
function RecTriangle(dim::Int, gen::Function)
dim <= 0 && throw(ArgumentError("dim has to be a positive integer."))
new( dim,
fill(ZZ(0), dim),
(n::Int, k::Int, f::Function) -> gen(n, k, f)::fmpz)
end
end
function Base.iterate(T::RecTriangle)
top = T.gen(0, 0, () -> undefined)
T.A[1] = ZZ(top)
([top], 1)
end
"""
Return the next row of the triangle.
$(SIGNATURES)
"""
function Base.iterate(T::RecTriangle, n)
@inline prevrow(A, n) = (k) -> (k<0 || k>n) ? ZZ(0) : A[k+1]
n == T.dim && return nothing
F(n, k) = T.gen(n, k, prevrow(T.A, n))
row = [F(n, k) for k in 0:n]
for k in 1:n+1 T.A[k] = row[k] end
(row, n + 1)
end
Base.length(R::RecTriangle) = R.dim
Base.eltype(R::RecTriangle) = fmpz
"""
Return the``n``-th triangular number.
$(SIGNATURES)
"""
TriangularNumber(n) = div(n * (n + 1), 2)
"""
Is ``n`` a triangular number?
$(SIGNATURES)
"""
isTriangular(n) = n == TriangularNumber(isqrt(2n))
"""
Return the square root of ``2n`` or throw an ArgumentError if ``n`` is not a triangular number.
$(SIGNATURES)
"""
function assertTriangular(n)
dim = isqrt(2n)
n ≠ TriangularNumber(dim) && throw(ArgumentError("This is not a triangular array!"))
return dim
end
"""
Return a trianguler array with ``n`` rows set to ``0`` (type ZZ).
$(SIGNATURES)
"""
ZTriangle(dim::Int) = zeros(ZZ, TriangularNumber(dim))
"""
Return a trianguler array with ``n`` rows set to ``0`` (type QQ).
$(SIGNATURES)
"""
QTriangle(dim::Int) = zeros(QQ, TriangularNumber(dim))
"""
Return the triangle as a list of rows.
$(SIGNATURES)
"""
TriangularArray(T::AbstractTriangle) = [row for row in T]
"""
Return the triangle as a list of integers.
$(SIGNATURES)
"""
TriangleToList(T::AbstractTriangle) = [k for row in T for k in row]
"""
Return row ``n (0 ≤ n)`` of the lower triangular matrix T or the row ``n`` in reversed order if `reversed` is set true.
$(SIGNATURES)
"""
function Row(T, n, reversed=false)
s = length(T)
(s == 0 || n < 0) && return []
assertTriangular(s)
t = TriangularNumber(n+1)
s < t && error("This row is not in the matrix.")
R = reversed ? range(t, step=-1, stop=t-n) : range(t-n, step=1, stop=t)
return [T[k] for k in R]
end
"""
Return the row sums of a triangle, if `alternate=true` then the alternating row sums.
$(SIGNATURES)
"""
function RowSums(T, alternate = false)
n = length(T)
n == 0 && return T
len = assertTriangular(n)
S = zeros(ZZ, len)
lo = hi = 0
step = 0
while hi < n
if alternate
s = sum((-1)^k * T[lo+k+1] for k in 0:hi - lo)
else
s = sum(T[k+1] for k in lo:hi)
end
step += 1
S[step] = s
hi += 1
lo, hi = hi, hi + step
end
S
end
"""
Display a lower triangular matrix.
$(SIGNATURES)
"""
function ShowAsΔ(T::AbstractTriangle, separator=", ")
for row in T
for k in row print(k, separator) end
println()
end
end
"""
Display an array as a lower triangular matrix.
$(SIGNATURES)
"""
function ShowAsΔ(T::AbstractArray, separator=", ")
if typeof(T) == Array{Array{fmpz,1},1}
for row in T
for k in row print(k, separator) end
println()
end
elseif typeof(T) == Array{fmpz,2}
for row in 1:size(T,1)
T[row,:]' |> Println
end
elseif typeof(T) == Array{fmpz,1}
dim = assertTriangular(length(T))
low = high = 1
for r in 2:dim+1
[T[j] for j = low:high] |> Println
low, high = high + 1, high + r
end
else
println(T)
end
end
"""
Convert a lower triangular array to a square matrix.
$(SIGNATURES)
"""
function fromΔ(T::AbstractTriangle)
L = TriangleToList(T)
dim = assertTriangular(length(L))
A = fill(ZZ(0), dim, dim)
k = 1
for r in 1:dim
for j = 1:r
A[r, j] = L[k]
k += 1
end
end
A
end
"""
Convert a square matrix to a list using only the ``T(n,k)`` with ``0 ≤ k ≤ n``. Returns a ZArray.
$(SIGNATURES)
"""
function toΔ(M)
dim = size(M, 1)
T = ZTriangle(dim)
k = 1
if typeof(M[1, 1]) == Nemo.fmpq
for r in 1:dim, j = 1:r
T[k] = numerator(M[r, j])
k += 1
end
else
for r in 1:dim, j = 1:r
T[k] = M[r, j]
k += 1
end
end
T
end
"""
Print the triangle in matrix form.
$(SIGNATURES)
"""
ShowAsMatrix(T) = println(fromΔ(T))
# *** UlamNumbers.jl ****************
"""
An Ulam number u(n) is the least number > u(n-1) which is a unique sum of two distinct earlier terms; u(1) = 1 and u(2) = 2.

* UlamList, isUlam, L002858
"""
const ModuleUlamNumbers = ""
"""
Is ``n`` an Ulam number?
$(SIGNATURES)
"""
function isUlam(u, n, h, i, r)
ur = u[r]; ui = u[i]
ur <= ui && return h
if ur + ui > n
r -= 1
elseif ur + ui < n
i += 1
else
h && return false
h = true; i += 1; r -= 1
end
isUlam(u, n, h, i, r)
end
"""
Return a list of Ulam numbers. An Ulam number u(n) is the least number > u(n-1) which is a unique sum of two distinct earlier terms; u(1) = 1 and u(2) = 2.
$(SIGNATURES)
"""
function UlamList(len)
u = Array{Int, 1}(undef, len)
u[1] = 1; u[2] = 2
i = 2; n = 2
while i < len
n += 1
if isUlam(u, n, false, 1, i)
i += 1
u[i] = n
end
end
return u
end
"""
Return a list of Ulam numbers.
$(SIGNATURES)
"""
L002858(len) = UlamList(len)
# *** ZumkellerNumbers.jl ****************
"""
A Zumkeller number ``n`` is an integer whose divisors can be partitioned into two disjoint sets whose sums are both ``σ(n)/2``.

* isZumkeller, is083207, I083207, F083207, L083207, V083207
"""
const ModuleZumkellerNumbers = ""
"""
Is ``n`` a Zumkeller number? A Zumkeller number ``n`` is an integer whose divisors can be partitioned into two disjoint sets whose sums are both ``σ(n)/2``.
$(SIGNATURES)
"""
function isZumkeller(n::Int)
n == 0 && return false
s = σ(n)
((s % 2 ≠ 0) || (s < 2n)) && return false
S = s >> 1 - n
D = [d for d in Divisors(n) if d ≤ S]
D == [] && return true
for c in Combinations(D)
S == sum(c) && return true
end
return false
end
"""
Is ``n`` a Zumkeller number?
$(SIGNATURES)
"""
is083207(n) = isZumkeller(n)
"""
Iterate over the first ``n`` Zumkeller numbers.
$(SIGNATURES)
"""
I083207(n) = Iterators.take(Iterators.filter(isZumkeller, Iterators.countfrom(1)), n)
"""
Iterate over the Zumkeller numbers ``z`` which are below ``n, (1 ≤ z ≤ n)``.
$(SIGNATURES)
"""
F083207(n) = Iterators.filter(isZumkeller, 1:n)
"""
List the first ``n`` Zumkeller numbers.
$(SIGNATURES)
"""
L083207(n) = collect(I083207(n))
"""
Return the ``n``-th Zumkeller number.
$(SIGNATURES)
"""
V083207(n) = nth(I083207(n), n)
end
