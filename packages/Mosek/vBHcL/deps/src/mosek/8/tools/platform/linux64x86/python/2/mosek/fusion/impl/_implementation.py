import numpy
import types
import io
import sys
import mosek

def _():
  import types

  class Enum:
    @staticmethod
    def __inst(c,name):
      o = types.InstanceType(c)
      o.name  = name
      o.value = len(c.__members__)
      c.__members__.append(o)
      setattr(c, name, o)

    @classmethod
    def fromInt(c,value):
      return c.members[value]

    @staticmethod
    def new(name,membernames):
      members = []
      c = types.ClassType(name, (Enum,),{ '__members__' : members })
      for n in membernames:
        Enum.__inst(c,n)
      return c
    @classmethod
    def members(c):
      return iter(c.__members__)

    def __str__(self):
      return self.__class__.__name__ + "." + self.name
    def __repr__(self):
      return self.__class__.__name__ + "." + self.name
  return Enum

class _monty:
  Enum = _()
  @staticmethod
  def deduceShape(l,dim):
    def _deduceShape(l,dim):
      if dim > 1:
        shplst = [ _deduceShape(i,dim-1) for i in l ]
        if all([shplst[0] == i for i in shplst ]):
          shplst[0].append(len(l))
          return shplst[0]
        else:
          raise TypeError("Irregular array shape")
      else:
        return [len(dim)]
    return tuple(reversed(_deduceShape(l,dim)))
  @staticmethod
  def checkShape(l,dim):
    def _checkShape(l,dim):
      if dim > 1:
        shplst = [ _checkShape(i,dim-1) for i in l ]
        if all([shplst[0] == i for i in shplst ]):
          pass
        else:
          raise TypeError("Irregular array shape")
        return len(l)
      else:
        try:
          return len(l)
        except TypeError:
          raise TypeError("Wrong or irregular array shape")
    _checkShape(l,dim)
    return dim

  @staticmethod
  def initJaggedArray(data, nd):
    dims = []
    d = data
    for i in range(nd):
      dims.append(len(d))
      d = d[0]

    res = numpy.zeros(dims,dtype=object)
    res.__setitem__([ slice(d) for d in dims ], data)

    return res


  @staticmethod
  def makeJaggedArray(src,ndims,dtype):
    if src is None:
      return None
    elif len(ndims) == 1:
      if ndims[0] == 1:
        r = numpy.zeros((len(src),),dtype=dtype)
        r[:] = src
      else:
        d = _monty.deduceDims(src,ndims[0])
        r = numpy.zeros(d,dtype=dtype)
        r.__setitem__(tuple([slice(None)]*ndims[0]),src) # basically: r[:,...,:] = src
      return r
    elif ndims[0] == 1:
      r = numpy.zeros((len(src),),dtype=numpy.dtype(object))
      # Note: This is a bit tricky to do reliably with numpy as it
      # tends to think we are dealing with multidimensional arrays and
      # explode
      for i,s in enumerate(src):
        r[i] = _monty.makeJaggedArray(s,ndims[1:],dtype)

      #r[:] = [ _monty.makeJaggedArray(s,ndims[1:],dtype) for s in src ]
      return r
    else:
      d = _monty.deduceDims(src,ndims[0])
      def _(src,nd):
        if nd == 0:
          return _monty.makeJaggedArray(src)
        else:
          return [ _(s,nd-1) for s in src ]

      r = numpy.zeros(d,dtype=numpy.dtype(object))
      r.__setitem__(tuple([slice(None)]*ndims[0]),_(src,ndims[0])) # basically: r[:,...,:] = convert(src)
      return r

  @staticmethod
  def copyArray(src,dst,dim):
    if dim == 1:
      src[:] = dst[:]
    else:
      for i in range(len(src)):
        _monty.copyArray(src[i],dst[i],dim-1)
  @staticmethod
  def arg_match_sloppy_array(v,elmmatch,dim,l=None):
    if dim == 0:
      elmmatch(v)
    elif dim == 1:
      if l is not None:
        if l != len(v): return False
      elif len(v) == 0: return True
      for e in v:
        if not elmmatch(e): return False
      return True
    elif isinstance(v,list) or isinstance(v,numpy.ndarray):
      if l is not None:
        if l != len(v): return False
      elif len(v) == 0: return True
      elif not (isinstance(v[0],list) or isinstance(v[0],numpy.ndarray)): return False

      top_len = len(v[0])
      for e in v:
        if not _monty.arg_match_sloppy_array(e,elmmatch,dim-1,top_len): return False
      return True
    else:
      return False

del _

mosek_fusion_RelationKey=_monty.Enum.new('RelationKey',['EqualsTo','LessThan','GreaterThan','IsFree','InRange'])
mosek_fusion_PSDKey=_monty.Enum.new('PSDKey',['IsSymPSD','IsTrilPSD'])
mosek_fusion_QConeKey=_monty.Enum.new('QConeKey',['InQCone','InRotatedQCone'])
mosek_fusion_ObjectiveSense=_monty.Enum.new('ObjectiveSense',['Undefined','Minimize','Maximize'])
mosek_fusion_SolutionStatus=_monty.Enum.new('SolutionStatus',['Undefined','Unknown','Optimal','NearOptimal','Feasible','NearFeasible','Certificate','NearCertificate','IllposedCert'])
mosek_fusion_AccSolutionStatus=_monty.Enum.new('AccSolutionStatus',['Anything','Optimal','NearOptimal','Feasible','Certificate'])
mosek_fusion_ProblemStatus=_monty.Enum.new('ProblemStatus',['Unknown','PrimalAndDualFeasible','PrimalFeasible','DualFeasible','PrimalInfeasible','DualInfeasible','PrimalAndDualInfeasible','IllPosed','PrimalInfeasibleOrUnbounded'])
mosek_fusion_SolutionType=_monty.Enum.new('SolutionType',['Default','Basic','Interior','Integer'])
mosek_fusion_StatusKey=_monty.Enum.new('StatusKey',['Unknown','Basic','SuperBasic','OnBound','Infinity'])
#BEFORE CLASS
def __mk_mosek_fusion_Variable():
 class Variable:
  def make_continuous(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_make_1continuous__3J(*args): # []int64
      return self._make_1continuous__3J(*args)
    elif mosek_fusion_Variable._match_alt_make_1continuous__3J(*args): # []int64
      return self._make_1continuous_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_continuous('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.make_continuous(array(int64,ndim=1))')
  def values(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_I_3DZ(*args)
    elif mosek_fusion_Variable._match_alt_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_alt_I_3DZ(*args)
    elif mosek_fusion_Variable._match_values__3JI_3DZ(*args): # []int64,int32,[]double,bool
      return self._values__3JI_3DZ(*args)
    elif mosek_fusion_Variable._match_alt_values__3JI_3DZ(*args): # []int64,int32,[]double,bool
      return self._values_alt__3JI_3DZ(*args)
    elif mosek_fusion_Variable._match_values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._values_J_3I_3JI_3DZ(*args)
    elif mosek_fusion_Variable._match_alt_values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._values_alt_J_3I_3JI_3DZ(*args)
    else:
      raise ValueError('Invalid argument list values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.values(int32,array(double,ndim=1),bool)\n\tmosek.fusion.Variable.values(array(int64,ndim=1),int32,array(double,ndim=1),bool)\n\tmosek.fusion.Variable.values(int64,array(int32,ndim=1),array(int64,ndim=1),int32,array(double,ndim=1),bool)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_Variable._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.toString()')
  def inst(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_inst_JJ_3I_3I_3I(*args): # int64,int64,[]int32,[]int32,[]int32
      return self._inst_JJ_3I_3I_3I(*args)
    elif mosek_fusion_Variable._match_alt_inst_JJ_3I_3I_3I(*args): # int64,int64,[]int32,[]int32,[]int32
      return self._inst_alt_JJ_3I_3I_3I(*args)
    elif mosek_fusion_Variable._match_inst__3JIIJJ_3I_3I_3I(*args): # []int64,int32,int32,int64,int64,[]int32,[]int32,[]int32
      return self._inst__3JIIJJ_3I_3I_3I(*args)
    elif mosek_fusion_Variable._match_alt_inst__3JIIJJ_3I_3I_3I(*args): # []int64,int32,int32,int64,int64,[]int32,[]int32,[]int32
      return self._inst_alt__3JIIJJ_3I_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list inst('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.inst(int64,int64,array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.Variable.inst(array(int64,ndim=1),int32,int32,int64,int64,array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))')
  def make_integer(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_make_1integer__3J(*args): # []int64
      return self._make_1integer__3J(*args)
    elif mosek_fusion_Variable._match_alt_make_1integer__3J(*args): # []int64
      return self._make_1integer_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_integer('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.make_integer(array(int64,ndim=1))')
  def antidiag(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_antidiag_(*args): # 
      return self._antidiag_(*args)
    elif mosek_fusion_Variable._match_alt_antidiag_(*args): # 
      return self._antidiag_alt_(*args)
    elif mosek_fusion_Variable._match_antidiag_I(*args): # int32
      return self._antidiag_I(*args)
    elif mosek_fusion_Variable._match_alt_antidiag_I(*args): # int32
      return self._antidiag_alt_I(*args)
    else:
      raise ValueError('Invalid argument list antidiag('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.antidiag()\n\tmosek.fusion.Variable.antidiag(int32)')
  def getModel(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_getModel_(*args): # 
      return self._getModel_(*args)
    elif mosek_fusion_Variable._match_alt_getModel_(*args): # 
      return self._getModel_alt_(*args)
    else:
      raise ValueError('Invalid argument list getModel('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.getModel()')
  def slice(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_slice_II(*args): # int32,int32
      return self._slice_II(*args)
    elif mosek_fusion_Variable._match_alt_slice_II(*args): # int32,int32
      return self._slice_alt_II(*args)
    elif mosek_fusion_Variable._match_slice__3I_3I(*args): # []int32,[]int32
      return self._slice__3I_3I(*args)
    elif mosek_fusion_Variable._match_alt_slice__3I_3I(*args): # []int32,[]int32
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.slice(int32,int32)\n\tmosek.fusion.Variable.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def diag(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_diag_(*args): # 
      return self._diag_(*args)
    elif mosek_fusion_Variable._match_alt_diag_(*args): # 
      return self._diag_alt_(*args)
    elif mosek_fusion_Variable._match_diag_I(*args): # int32
      return self._diag_I(*args)
    elif mosek_fusion_Variable._match_alt_diag_I(*args): # int32
      return self._diag_alt_I(*args)
    else:
      raise ValueError('Invalid argument list diag('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.diag()\n\tmosek.fusion.Variable.diag(int32)')
  def dual(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_dual_(*args): # 
      return self._dual_(*args)
    elif mosek_fusion_Variable._match_alt_dual_(*args): # 
      return self._dual_alt_(*args)
    else:
      raise ValueError('Invalid argument list dual('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.dual()')
  def getShape(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_getShape_(*args): # 
      return self._getShape_(*args)
    elif mosek_fusion_Variable._match_alt_getShape_(*args): # 
      return self._getShape_alt_(*args)
    else:
      raise ValueError('Invalid argument list getShape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.getShape()')
  def pick(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_pick__3I(*args): # []int32
      return self._pick__3I(*args)
    elif mosek_fusion_Variable._match_alt_pick__3I(*args): # []int32
      return self._pick_alt__3I(*args)
    elif mosek_fusion_Variable._match_pick__3_5I(*args): # [,]int32
      return self._pick__3_5I(*args)
    elif mosek_fusion_Variable._match_alt_pick__3_5I(*args): # [,]int32
      return self._pick_alt__3_5I(*args)
    elif mosek_fusion_Variable._match_pick__3I_3I(*args): # []int32,[]int32
      return self._pick__3I_3I(*args)
    elif mosek_fusion_Variable._match_alt_pick__3I_3I(*args): # []int32,[]int32
      return self._pick_alt__3I_3I(*args)
    elif mosek_fusion_Variable._match_pick__3I_3I_3I(*args): # []int32,[]int32,[]int32
      return self._pick__3I_3I_3I(*args)
    elif mosek_fusion_Variable._match_alt_pick__3I_3I_3I(*args): # []int32,[]int32,[]int32
      return self._pick_alt__3I_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list pick('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.pick(array(int32,ndim=1))\n\tmosek.fusion.Variable.pick(array(int32,ndim=2))\n\tmosek.fusion.Variable.pick(array(int32,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.Variable.pick(array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))')
  def set_values(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_set_1values__3J_3DZ(*args): # []int64,[]double,bool
      return self._set_1values__3J_3DZ(*args)
    elif mosek_fusion_Variable._match_alt_set_1values__3J_3DZ(*args): # []int64,[]double,bool
      return self._set_1values_alt__3J_3DZ(*args)
    elif mosek_fusion_Variable._match_set_1values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._set_1values_J_3I_3JI_3DZ(*args)
    elif mosek_fusion_Variable._match_alt_set_1values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._set_1values_alt_J_3I_3JI_3DZ(*args)
    else:
      raise ValueError('Invalid argument list set_values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.set_values(array(int64,ndim=1),array(double,ndim=1),bool)\n\tmosek.fusion.Variable.set_values(int64,array(int32,ndim=1),array(int64,ndim=1),int32,array(double,ndim=1),bool)')
  def asExpr(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_asExpr_(*args): # 
      return self._asExpr_(*args)
    elif mosek_fusion_Variable._match_alt_asExpr_(*args): # 
      return self._asExpr_alt_(*args)
    else:
      raise ValueError('Invalid argument list asExpr('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.asExpr()')
  def index(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_index_I(*args): # int32
      return self._index_I(*args)
    elif mosek_fusion_Variable._match_alt_index_I(*args): # int32
      return self._index_alt_I(*args)
    elif mosek_fusion_Variable._match_index__3I(*args): # []int32
      return self._index__3I(*args)
    elif mosek_fusion_Variable._match_alt_index__3I(*args): # []int32
      return self._index_alt__3I(*args)
    elif mosek_fusion_Variable._match_index_II(*args): # int32,int32
      return self._index_II(*args)
    elif mosek_fusion_Variable._match_alt_index_II(*args): # int32,int32
      return self._index_alt_II(*args)
    elif mosek_fusion_Variable._match_index_III(*args): # int32,int32,int32
      return self._index_III(*args)
    elif mosek_fusion_Variable._match_alt_index_III(*args): # int32,int32,int32
      return self._index_alt_III(*args)
    else:
      raise ValueError('Invalid argument list index('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.index(int32)\n\tmosek.fusion.Variable.index(array(int32,ndim=1))\n\tmosek.fusion.Variable.index(int32,int32)\n\tmosek.fusion.Variable.index(int32,int32,int32)')
  def transpose(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_transpose_(*args): # 
      return self._transpose_(*args)
    elif mosek_fusion_Variable._match_alt_transpose_(*args): # 
      return self._transpose_alt_(*args)
    else:
      raise ValueError('Invalid argument list transpose('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.transpose()')
  def level(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_level_(*args): # 
      return self._level_(*args)
    elif mosek_fusion_Variable._match_alt_level_(*args): # 
      return self._level_alt_(*args)
    else:
      raise ValueError('Invalid argument list level('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.level()')
  def elementName(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_Variable._match_alt_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementName_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementName('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.elementName(int64,mosek.fusion.Utils.StringBuffer)')
  def setLevel(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_setLevel__3D(*args): # []double
      return self._setLevel__3D(*args)
    elif mosek_fusion_Variable._match_alt_setLevel__3D(*args): # []double
      return self._setLevel_alt__3D(*args)
    else:
      raise ValueError('Invalid argument list setLevel('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.setLevel(array(double,ndim=1))')
  def elementDesc(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_Variable._match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementDesc('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.elementDesc(int64,mosek.fusion.Utils.StringBuffer)')
  def size(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_size_(*args): # 
      return self._size_(*args)
    elif mosek_fusion_Variable._match_alt_size_(*args): # 
      return self._size_alt_(*args)
    else:
      raise ValueError('Invalid argument list size('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.size()')
  def shape(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_shape_(*args): # 
      return self._shape_(*args)
    elif mosek_fusion_Variable._match_alt_shape_(*args): # 
      return self._shape_alt_(*args)
    else:
      raise ValueError('Invalid argument list shape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.shape()')
  def makeInteger(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_makeInteger_(*args): # 
      return self._makeInteger_(*args)
    elif mosek_fusion_Variable._match_alt_makeInteger_(*args): # 
      return self._makeInteger_alt_(*args)
    else:
      raise ValueError('Invalid argument list makeInteger('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.makeInteger()')
  def makeContinuous(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_makeContinuous_(*args): # 
      return self._makeContinuous_(*args)
    elif mosek_fusion_Variable._match_alt_makeContinuous_(*args): # 
      return self._makeContinuous_alt_(*args)
    else:
      raise ValueError('Invalid argument list makeContinuous('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.makeContinuous()')
  def __repr__(self): return 'mosek.fusion.Variable'
  @staticmethod
  def _match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_J__(_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  @staticmethod
  def _match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  def _elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   pass
  @staticmethod
  def _match_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_J__(_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  @staticmethod
  def _match_alt_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  def _elementName_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   pass
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   pass
  @staticmethod
  def _match_inst__3JIIJJ_3I_3I_3I(*args):
    if len(args) != 8: return False
    _0,_1,_2,_3,_4,_5,_6,_7, = args
    return (__arg_match__3J__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4) and __arg_match__3I__(_5) and __arg_match__3I__(_6) and __arg_match__3I__(_7))
  @staticmethod
  def _match_alt_inst__3JIIJJ_3I_3I_3I(*args):
    if len(args) != 8: return False
    _0,_1,_2,_3,_4,_5,_6,_7, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4) and __arg_alt_match__3I__(_5) and __arg_alt_match__3I__(_6) and __arg_alt_match__3I__(_7))
  def _inst_alt__3JIIJJ_3I_3I_3I(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.int32(_t__2)
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.int32))
   _6=numpy.array(_t__6,dtype=numpy.dtype(numpy.int32))
   _7=numpy.array(_t__7,dtype=numpy.dtype(numpy.int32))
   _1 = self._inst__3JIIJJ_3I_3I_3I(_0,_1,_2,_3,_4,_5,_6,_7)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__6[:] = _6
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__7[:] = _7
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst__3JIIJJ_3I_3I_3I(self,_0,_1,_2,_3,_4,_5,_6,_7):
   pass
  @staticmethod
  def _match_inst_JJ_3I_3I_3I(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match_J__(_0) and __arg_match_J__(_1) and __arg_match__3I__(_2) and __arg_match__3I__(_3) and __arg_match__3I__(_4))
  @staticmethod
  def _match_alt_inst_JJ_3I_3I_3I(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_J__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match__3I__(_3) and __arg_alt_match__3I__(_4))
  def _inst_alt_JJ_3I_3I_3I(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.int64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int32))
   _1 = self._inst_JJ_3I_3I_3I(_0,_1,_2,_3,_4)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst_JJ_3I_3I_3I(self,_0,_1,_2,_3,_4):
   pass
  @staticmethod
  def _match_shape_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_shape_(*args):
    if len(args) != 0: return False
    return True
  def _shape_alt_(self,):
    return self._shape_()
  def _shape_(self,):
   pass
  @staticmethod
  def _match_getShape_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getShape_(*args):
    if len(args) != 0: return False
    return True
  def _getShape_alt_(self,):
    return self._getShape_()
  def _getShape_(self,):
   pass
  @staticmethod
  def _match_getModel_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getModel_(*args):
    if len(args) != 0: return False
    return True
  def _getModel_alt_(self,):
    return self._getModel_()
  def _getModel_(self,):
   pass
  @staticmethod
  def _match_size_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_size_(*args):
    if len(args) != 0: return False
    return True
  def _size_alt_(self,):
    return self._size_()
  def _size_(self,):
   pass
  @staticmethod
  def _match_setLevel__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_setLevel__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  def _setLevel_alt__3D(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = self._setLevel__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _setLevel__3D(self,_0):
   pass
  @staticmethod
  def _match_set_1values__3J_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3J__(_0) and __arg_match__3D__(_1) and __arg_match_Z__(_2))
  @staticmethod
  def _match_alt_set_1values__3J_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3D__(_1) and __arg_alt_match_Z__(_2))
  def _set_1values_alt__3J_3DZ(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=_t__2
   _1 = self._set_1values__3J_3DZ(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values__3J_3DZ(self,_0,_1,_2):
   pass
  @staticmethod
  def _match_set_1values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match_J__(_0) and __arg_match__3I__(_1) and __arg_match__3J__(_2) and __arg_match_I__(_3) and __arg_match__3D__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_set_1values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match__3D__(_4) and __arg_alt_match_Z__(_5))
  def _set_1values_alt_J_3I_3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = self._set_1values_J_3I_3JI_3DZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values_J_3I_3JI_3DZ(self,_0,_1,_2,_3,_4,_5):
   pass
  @staticmethod
  def _match_dual_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_dual_(*args):
    if len(args) != 0: return False
    return True
  def _dual_alt_(self,):
    return self._dual_()
  def _dual_(self,):
   pass
  @staticmethod
  def _match_level_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_level_(*args):
    if len(args) != 0: return False
    return True
  def _level_alt_(self,):
    return self._level_()
  def _level_(self,):
   pass
  @staticmethod
  def _match_values_I_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match__3D__(_1) and __arg_match_Z__(_2))
  @staticmethod
  def _match_alt_values_I_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match__3D__(_1) and __arg_alt_match_Z__(_2))
  def _values_alt_I_3DZ(self,_t__0,_t__1,_t__2):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=_t__2
   _1 = self._values_I_3DZ(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values_I_3DZ(self,_0,_1,_2):
   pass
  @staticmethod
  def _match_values__3JI_3DZ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match__3J__(_0) and __arg_match_I__(_1) and __arg_match__3D__(_2) and __arg_match_Z__(_3))
  @staticmethod
  def _match_alt_values__3JI_3DZ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match_Z__(_3))
  def _values_alt__3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=_t__3
   _1 = self._values__3JI_3DZ(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values__3JI_3DZ(self,_0,_1,_2,_3):
   pass
  @staticmethod
  def _match_values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match_J__(_0) and __arg_match__3I__(_1) and __arg_match__3J__(_2) and __arg_match_I__(_3) and __arg_match__3D__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match__3D__(_4) and __arg_alt_match_Z__(_5))
  def _values_alt_J_3I_3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = self._values_J_3I_3JI_3DZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values_J_3I_3JI_3DZ(self,_0,_1,_2,_3,_4,_5):
   pass
  @staticmethod
  def _match_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3J__(_0))
  @staticmethod
  def _match_alt_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3J__(_0))
  def _make_1continuous_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1continuous__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1continuous__3J(self,_0):
   pass
  @staticmethod
  def _match_make_1integer__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3J__(_0))
  @staticmethod
  def _match_alt_make_1integer__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3J__(_0))
  def _make_1integer_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1integer__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1integer__3J(self,_0):
   pass
  @staticmethod
  def _match_makeContinuous_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_makeContinuous_(*args):
    if len(args) != 0: return False
    return True
  def _makeContinuous_alt_(self,):
    return self._makeContinuous_()
  def _makeContinuous_(self,):
   pass
  @staticmethod
  def _match_makeInteger_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_makeInteger_(*args):
    if len(args) != 0: return False
    return True
  def _makeInteger_alt_(self,):
    return self._makeInteger_()
  def _makeInteger_(self,):
   pass
  @staticmethod
  def _match_transpose_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_transpose_(*args):
    if len(args) != 0: return False
    return True
  def _transpose_alt_(self,):
    return self._transpose_()
  def _transpose_(self,):
   pass
  @staticmethod
  def _match_pick__3I_3I_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match__3I__(_2))
  @staticmethod
  def _match_alt_pick__3I_3I_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3I__(_2))
  def _pick_alt__3I_3I_3I(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3I_3I_3I(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _pick__3I_3I_3I(self,_0,_1,_2):
   pass
  @staticmethod
  def _match_pick__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_pick__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _pick_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _pick__3I_3I(self,_0,_1):
   pass
  @staticmethod
  def _match_pick__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5I__(_0))
  @staticmethod
  def _match_alt_pick__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5I__(_0))
  def _pick_alt__3_5I(self,_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3_5I(_0)
   return _1
  def _pick__3_5I(self,_0):
   pass
  @staticmethod
  def _match_pick__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_pick__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _pick_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _pick__3I(self,_0):
   pass
  @staticmethod
  def _match_antidiag_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_antidiag_(*args):
    if len(args) != 0: return False
    return True
  def _antidiag_alt_(self,):
    return self._antidiag_()
  def _antidiag_(self,):
   pass
  @staticmethod
  def _match_antidiag_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_antidiag_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _antidiag_alt_I(self,_t__0):
    return self._antidiag_I(numpy.int32(__0))
  def _antidiag_I(self,_0):
   pass
  @staticmethod
  def _match_diag_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_diag_(*args):
    if len(args) != 0: return False
    return True
  def _diag_alt_(self,):
    return self._diag_()
  def _diag_(self,):
   pass
  @staticmethod
  def _match_diag_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_diag_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _diag_alt_I(self,_t__0):
    return self._diag_I(numpy.int32(__0))
  def _diag_I(self,_0):
   pass
  @staticmethod
  def _match_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _index_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._index__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _index__3I(self,_0):
   pass
  @staticmethod
  def _match_index_III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_index_III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  def _index_alt_III(self,_t__0,_t__1,_t__2):
    return self._index_III(numpy.int32(__0),numpy.int32(__1),numpy.int32(__2))
  def _index_III(self,_0,_1,_2):
   pass
  @staticmethod
  def _match_index_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_index_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _index_alt_II(self,_t__0,_t__1):
    return self._index_II(numpy.int32(__0),numpy.int32(__1))
  def _index_II(self,_0,_1):
   pass
  @staticmethod
  def _match_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _index_alt_I(self,_t__0):
    return self._index_I(numpy.int32(__0))
  def _index_I(self,_0):
   pass
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _slice_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._slice__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice__3I_3I(self,_0,_1):
   pass
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _slice_alt_II(self,_t__0,_t__1):
    return self._slice_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_II(self,_0,_1):
   pass
  @staticmethod
  def _match_asExpr_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_asExpr_(*args):
    if len(args) != 0: return False
    return True
  def _asExpr_alt_(self,):
    return self._asExpr_()
  def _asExpr_(self,):
   pass
 return Variable
mosek_fusion_Variable=__mk_mosek_fusion_Variable()
del __mk_mosek_fusion_Variable
#BEFORE CLASS
def __mk_mosek_fusion_SymmetricVariable():
 class SymmetricVariable(mosek_fusion_Variable):
  def __repr__(self): return 'mosek.fusion.SymmetricVariable'
 return SymmetricVariable
mosek_fusion_SymmetricVariable=__mk_mosek_fusion_SymmetricVariable()
del __mk_mosek_fusion_SymmetricVariable
#BEFORE CLASS
def __mk_mosek_fusion_Expression():
 class Expression:
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_Expression._match_eval_(*args): # 
      return self._eval_(*args)
    elif mosek_fusion_Expression._match_alt_eval_(*args): # 
      return self._eval_alt_(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expression.eval()')
  def getModel(self,*args):
    if False: pass
    elif mosek_fusion_Expression._match_getModel_(*args): # 
      return self._getModel_(*args)
    elif mosek_fusion_Expression._match_alt_getModel_(*args): # 
      return self._getModel_alt_(*args)
    else:
      raise ValueError('Invalid argument list getModel('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expression.getModel()')
  def transpose(self,*args):
    if False: pass
    elif mosek_fusion_Expression._match_transpose_(*args): # 
      return self._transpose_(*args)
    elif mosek_fusion_Expression._match_alt_transpose_(*args): # 
      return self._transpose_alt_(*args)
    else:
      raise ValueError('Invalid argument list transpose('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expression.transpose()')
  def getShape(self,*args):
    if False: pass
    elif mosek_fusion_Expression._match_getShape_(*args): # 
      return self._getShape_(*args)
    elif mosek_fusion_Expression._match_alt_getShape_(*args): # 
      return self._getShape_alt_(*args)
    else:
      raise ValueError('Invalid argument list getShape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expression.getShape()')
  def slice(self,*args):
    if False: pass
    elif mosek_fusion_Expression._match_slice_II(*args): # int32,int32
      return self._slice_II(*args)
    elif mosek_fusion_Expression._match_alt_slice_II(*args): # int32,int32
      return self._slice_alt_II(*args)
    elif mosek_fusion_Expression._match_slice__3I_3I(*args): # []int32,[]int32
      return self._slice__3I_3I(*args)
    elif mosek_fusion_Expression._match_alt_slice__3I_3I(*args): # []int32,[]int32
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expression.slice(int32,int32)\n\tmosek.fusion.Expression.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_Expression._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_Expression._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expression.toString()')
  def index(self,*args):
    if False: pass
    elif mosek_fusion_Expression._match_index_I(*args): # int32
      return self._index_I(*args)
    elif mosek_fusion_Expression._match_alt_index_I(*args): # int32
      return self._index_alt_I(*args)
    elif mosek_fusion_Expression._match_index__3I(*args): # []int32
      return self._index__3I(*args)
    elif mosek_fusion_Expression._match_alt_index__3I(*args): # []int32
      return self._index_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list index('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expression.index(int32)\n\tmosek.fusion.Expression.index(array(int32,ndim=1))')
  def pick(self,*args):
    if False: pass
    elif mosek_fusion_Expression._match_pick__3I(*args): # []int32
      return self._pick__3I(*args)
    elif mosek_fusion_Expression._match_alt_pick__3I(*args): # []int32
      return self._pick_alt__3I(*args)
    elif mosek_fusion_Expression._match_pick__3_5I(*args): # [,]int32
      return self._pick__3_5I(*args)
    elif mosek_fusion_Expression._match_alt_pick__3_5I(*args): # [,]int32
      return self._pick_alt__3_5I(*args)
    else:
      raise ValueError('Invalid argument list pick('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expression.pick(array(int32,ndim=1))\n\tmosek.fusion.Expression.pick(array(int32,ndim=2))')
  def shape(self,*args):
    if False: pass
    elif mosek_fusion_Expression._match_shape_(*args): # 
      return self._shape_(*args)
    elif mosek_fusion_Expression._match_alt_shape_(*args): # 
      return self._shape_alt_(*args)
    else:
      raise ValueError('Invalid argument list shape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expression.shape()')
  def __repr__(self): return 'mosek.fusion.Expression'
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   pass
  @staticmethod
  def _match_transpose_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_transpose_(*args):
    if len(args) != 0: return False
    return True
  def _transpose_alt_(self,):
    return self._transpose_()
  def _transpose_(self,):
   pass
  @staticmethod
  def _match_pick__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5I__(_0))
  @staticmethod
  def _match_alt_pick__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5I__(_0))
  def _pick_alt__3_5I(self,_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3_5I(_0)
   return _1
  def _pick__3_5I(self,_0):
   pass
  @staticmethod
  def _match_pick__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_pick__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _pick_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _pick__3I(self,_0):
   pass
  @staticmethod
  def _match_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _index_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._index__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _index__3I(self,_0):
   pass
  @staticmethod
  def _match_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _index_alt_I(self,_t__0):
    return self._index_I(numpy.int32(__0))
  def _index_I(self,_0):
   pass
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _slice_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._slice__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice__3I_3I(self,_0,_1):
   pass
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _slice_alt_II(self,_t__0,_t__1):
    return self._slice_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_II(self,_0,_1):
   pass
  @staticmethod
  def _match_eval_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_eval_(*args):
    if len(args) != 0: return False
    return True
  def _eval_alt_(self,):
    return self._eval_()
  def _eval_(self,):
   pass
  @staticmethod
  def _match_getModel_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getModel_(*args):
    if len(args) != 0: return False
    return True
  def _getModel_alt_(self,):
    return self._getModel_()
  def _getModel_(self,):
   pass
  @staticmethod
  def _match_shape_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_shape_(*args):
    if len(args) != 0: return False
    return True
  def _shape_alt_(self,):
    return self._shape_()
  def _shape_(self,):
   pass
  @staticmethod
  def _match_getShape_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getShape_(*args):
    if len(args) != 0: return False
    return True
  def _getShape_alt_(self,):
    return self._getShape_()
  def _getShape_(self,):
   pass
 return Expression
mosek_fusion_Expression=__mk_mosek_fusion_Expression()
del __mk_mosek_fusion_Expression
#BEFORE CLASS
def __mk_mosek_fusion_FusionException():
 class FusionException(Exception):
  __slots__ = ['_FusionException__msg']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.FusionException.ctor(string)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_FusionException._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_FusionException._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.FusionException.toString()')
  def __repr__(self): return 'mosek.fusion.FusionException'
  @staticmethod
  def _ctor_S(msg_):
    o = FusionException.__new__(FusionException)
    o._ctor_init_S(msg_)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg_, = args
    return (__arg_match_S__(msg_))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg_, = args
    return (__arg_alt_match_S__(msg_))
  def _ctor_alt_init_S(self,msg_):
    self._ctor_init_S(msg_)
  def _ctor_init_S(self,msg_):
   Exception.__init__(self,msg_)
   self.__msg = msg_
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (self.__msg)
 return FusionException
mosek_fusion_FusionException=__mk_mosek_fusion_FusionException()
del __mk_mosek_fusion_FusionException
#BEFORE CLASS
def __mk_mosek_fusion_SolutionError():
 class SolutionError(mosek_fusion_FusionException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_(*args): # 
      self._ctor_init_(*args)
    elif self.__match_alt_ctor_(*args):# 
      self._ctor_alt_init_(*args)
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.SolutionError.ctor()\n\tmosek.fusion.SolutionError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.SolutionError'
  @staticmethod
  def _ctor_():
    o = SolutionError.__new__(SolutionError)
    o._ctor_init_()
    return o
  @staticmethod
  def __match_ctor_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def __match_alt_ctor_(*args):
    if len(args) != 0: return False
    return True
  def _ctor_alt_init_(self,):
    self._ctor_init_()
  def _ctor_init_(self,):
   mosek_fusion_FusionException._ctor_init_S(self,"Solution is invalid or undefined")
  @staticmethod
  def _ctor_S(msg):
    o = SolutionError.__new__(SolutionError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionException._ctor_init_S(self,msg)
 return SolutionError
mosek_fusion_SolutionError=__mk_mosek_fusion_SolutionError()
del __mk_mosek_fusion_SolutionError
#BEFORE CLASS
def __mk_mosek_fusion_UnimplementedError():
 class UnimplementedError(Exception):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.UnimplementedError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.UnimplementedError'
  @staticmethod
  def _ctor_S(msg):
    o = UnimplementedError.__new__(UnimplementedError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   Exception.__init__(self,msg)
 return UnimplementedError
mosek_fusion_UnimplementedError=__mk_mosek_fusion_UnimplementedError()
del __mk_mosek_fusion_UnimplementedError
#BEFORE CLASS
def __mk_mosek_fusion_FatalError():
 class FatalError(Exception):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.FatalError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.FatalError'
  @staticmethod
  def _ctor_S(msg):
    o = FatalError.__new__(FatalError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   Exception.__init__(self,msg)
 return FatalError
mosek_fusion_FatalError=__mk_mosek_fusion_FatalError()
del __mk_mosek_fusion_FatalError
#BEFORE CLASS
def __mk_mosek_fusion_UnexpectedError():
 class UnexpectedError(Exception):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4FusionException_2(*args): # mosek.fusion.FusionException
      self._ctor_init_Lmosek_4fusion_4FusionException_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4FusionException_2(*args):# mosek.fusion.FusionException
      self._ctor_alt_init_Lmosek_4fusion_4FusionException_2(*args)
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.UnexpectedError.ctor(mosek.fusion.FusionException)\n\tmosek.fusion.UnexpectedError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.UnexpectedError'
  @staticmethod
  def _ctor_Lmosek_4fusion_4FusionException_2(e):
    o = UnexpectedError.__new__(UnexpectedError)
    o._ctor_init_Lmosek_4fusion_4FusionException_2(e)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4FusionException_2(*args):
    if len(args) != 1: return False
    e, = args
    return (__arg_match_Lmosek_4fusion_4FusionException_2__(e))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4FusionException_2(*args):
    if len(args) != 1: return False
    e, = args
    return (__arg_alt_match_Lmosek_4fusion_4FusionException_2__(e))
  def _ctor_alt_init_Lmosek_4fusion_4FusionException_2(self,e):
    self._ctor_init_Lmosek_4fusion_4FusionException_2(e)
  def _ctor_init_Lmosek_4fusion_4FusionException_2(self,e):
   Exception.__init__(self,e._toString_())
  @staticmethod
  def _ctor_S(msg):
    o = UnexpectedError.__new__(UnexpectedError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   Exception.__init__(self,msg)
 return UnexpectedError
mosek_fusion_UnexpectedError=__mk_mosek_fusion_UnexpectedError()
del __mk_mosek_fusion_UnexpectedError
#BEFORE CLASS
def __mk_mosek_fusion_FusionRuntimeException():
 class FusionRuntimeException(Exception):
  __slots__ = ['_FusionRuntimeException__msg']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.FusionRuntimeException.ctor(string)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_FusionRuntimeException._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_FusionRuntimeException._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.FusionRuntimeException.toString()')
  def __repr__(self): return 'mosek.fusion.FusionRuntimeException'
  @staticmethod
  def _ctor_S(msg_):
    o = FusionRuntimeException.__new__(FusionRuntimeException)
    o._ctor_init_S(msg_)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg_, = args
    return (__arg_match_S__(msg_))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg_, = args
    return (__arg_alt_match_S__(msg_))
  def _ctor_alt_init_S(self,msg_):
    self._ctor_init_S(msg_)
  def _ctor_init_S(self,msg_):
   Exception.__init__(self,msg_)
   self.__msg = msg_
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (self.__msg)
 return FusionRuntimeException
mosek_fusion_FusionRuntimeException=__mk_mosek_fusion_FusionRuntimeException()
del __mk_mosek_fusion_FusionRuntimeException
#BEFORE CLASS
def __mk_mosek_fusion_SparseFormatError():
 class SparseFormatError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.SparseFormatError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.SparseFormatError'
  @staticmethod
  def _ctor_S(msg):
    o = SparseFormatError.__new__(SparseFormatError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return SparseFormatError
mosek_fusion_SparseFormatError=__mk_mosek_fusion_SparseFormatError()
del __mk_mosek_fusion_SparseFormatError
#BEFORE CLASS
def __mk_mosek_fusion_SliceError():
 class SliceError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_(*args): # 
      self._ctor_init_(*args)
    elif self.__match_alt_ctor_(*args):# 
      self._ctor_alt_init_(*args)
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.SliceError.ctor()\n\tmosek.fusion.SliceError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.SliceError'
  @staticmethod
  def _ctor_():
    o = SliceError.__new__(SliceError)
    o._ctor_init_()
    return o
  @staticmethod
  def __match_ctor_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def __match_alt_ctor_(*args):
    if len(args) != 0: return False
    return True
  def _ctor_alt_init_(self,):
    self._ctor_init_()
  def _ctor_init_(self,):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,"Invalid slice range")
  @staticmethod
  def _ctor_S(msg):
    o = SliceError.__new__(SliceError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return SliceError
mosek_fusion_SliceError=__mk_mosek_fusion_SliceError()
del __mk_mosek_fusion_SliceError
#BEFORE CLASS
def __mk_mosek_fusion_SetDefinitionError():
 class SetDefinitionError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.SetDefinitionError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.SetDefinitionError'
  @staticmethod
  def _ctor_S(msg):
    o = SetDefinitionError.__new__(SetDefinitionError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return SetDefinitionError
mosek_fusion_SetDefinitionError=__mk_mosek_fusion_SetDefinitionError()
del __mk_mosek_fusion_SetDefinitionError
#BEFORE CLASS
def __mk_mosek_fusion_OptimizeError():
 class OptimizeError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.OptimizeError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.OptimizeError'
  @staticmethod
  def _ctor_S(msg):
    o = OptimizeError.__new__(OptimizeError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return OptimizeError
mosek_fusion_OptimizeError=__mk_mosek_fusion_OptimizeError()
del __mk_mosek_fusion_OptimizeError
#BEFORE CLASS
def __mk_mosek_fusion_NameError():
 class NameError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.NameError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.NameError'
  @staticmethod
  def _ctor_S(msg):
    o = NameError.__new__(NameError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return NameError
mosek_fusion_NameError=__mk_mosek_fusion_NameError()
del __mk_mosek_fusion_NameError
#BEFORE CLASS
def __mk_mosek_fusion_ModelError():
 class ModelError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ModelError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.ModelError'
  @staticmethod
  def _ctor_S(msg):
    o = ModelError.__new__(ModelError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return ModelError
mosek_fusion_ModelError=__mk_mosek_fusion_ModelError()
del __mk_mosek_fusion_ModelError
#BEFORE CLASS
def __mk_mosek_fusion_MatrixError():
 class MatrixError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.MatrixError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.MatrixError'
  @staticmethod
  def _ctor_S(msg):
    o = MatrixError.__new__(MatrixError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return MatrixError
mosek_fusion_MatrixError=__mk_mosek_fusion_MatrixError()
del __mk_mosek_fusion_MatrixError
#BEFORE CLASS
def __mk_mosek_fusion_DimensionError():
 class DimensionError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.DimensionError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.DimensionError'
  @staticmethod
  def _ctor_S(msg):
    o = DimensionError.__new__(DimensionError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return DimensionError
mosek_fusion_DimensionError=__mk_mosek_fusion_DimensionError()
del __mk_mosek_fusion_DimensionError
#BEFORE CLASS
def __mk_mosek_fusion_LengthError():
 class LengthError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.LengthError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.LengthError'
  @staticmethod
  def _ctor_S(msg):
    o = LengthError.__new__(LengthError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return LengthError
mosek_fusion_LengthError=__mk_mosek_fusion_LengthError()
del __mk_mosek_fusion_LengthError
#BEFORE CLASS
def __mk_mosek_fusion_RangeError():
 class RangeError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.RangeError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.RangeError'
  @staticmethod
  def _ctor_S(msg):
    o = RangeError.__new__(RangeError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return RangeError
mosek_fusion_RangeError=__mk_mosek_fusion_RangeError()
del __mk_mosek_fusion_RangeError
#BEFORE CLASS
def __mk_mosek_fusion_IndexError():
 class IndexError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.IndexError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.IndexError'
  @staticmethod
  def _ctor_S(msg):
    o = IndexError.__new__(IndexError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return IndexError
mosek_fusion_IndexError=__mk_mosek_fusion_IndexError()
del __mk_mosek_fusion_IndexError
#BEFORE CLASS
def __mk_mosek_fusion_DomainError():
 class DomainError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.DomainError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.DomainError'
  @staticmethod
  def _ctor_S(msg):
    o = DomainError.__new__(DomainError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return DomainError
mosek_fusion_DomainError=__mk_mosek_fusion_DomainError()
del __mk_mosek_fusion_DomainError
#BEFORE CLASS
def __mk_mosek_fusion_ValueConversionError():
 class ValueConversionError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ValueConversionError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.ValueConversionError'
  @staticmethod
  def _ctor_S(msg):
    o = ValueConversionError.__new__(ValueConversionError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return ValueConversionError
mosek_fusion_ValueConversionError=__mk_mosek_fusion_ValueConversionError()
del __mk_mosek_fusion_ValueConversionError
#BEFORE CLASS
def __mk_mosek_fusion_ParameterError():
 class ParameterError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ParameterError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.ParameterError'
  @staticmethod
  def _ctor_S(msg):
    o = ParameterError.__new__(ParameterError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return ParameterError
mosek_fusion_ParameterError=__mk_mosek_fusion_ParameterError()
del __mk_mosek_fusion_ParameterError
#BEFORE CLASS
def __mk_mosek_fusion_ExpressionError():
 class ExpressionError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExpressionError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.ExpressionError'
  @staticmethod
  def _ctor_S(msg):
    o = ExpressionError.__new__(ExpressionError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return ExpressionError
mosek_fusion_ExpressionError=__mk_mosek_fusion_ExpressionError()
del __mk_mosek_fusion_ExpressionError
#BEFORE CLASS
def __mk_mosek_fusion_IOError():
 class IOError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.IOError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.IOError'
  @staticmethod
  def _ctor_S(msg):
    o = IOError.__new__(IOError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return IOError
mosek_fusion_IOError=__mk_mosek_fusion_IOError()
del __mk_mosek_fusion_IOError
def __mk_mosek_fusion_BaseModel():
  import threading
  import mosek
  import mosek.fusion
  import numpy
  
  class BaseModel(object):
    _lock = threading.Lock()
    _global_env = None
    _global_env_counter = 0
  
    @classmethod
    def _globalEnv(self):
      self._lock.acquire()
      try:
        if BaseModel._global_env is None:
          try:
            env = mosek.Env()
            BaseModel._global_env = env
            BaseModel._global_env_counter += 1
          except mosek.Exception,e:
            raise UnexpectedError(e)
        return BaseModel._global_env
      finally:
        self._lock.release()
  
    @classmethod
    def _env_1putlicensecode(self,code):
      self._globalEnv().putlicensecode(code)
  
    @classmethod
    def _env_1putlicensepath(self,path):
      self._globalEnv().putlicensepath(path)
  
    @classmethod
    def _env_1putlicensewait(self,yn):
      if yn:
        self._globalEnv().putlicensewait(1)
      else:
        self._globalEnv().putlicensewait(0)
  
        
    def __callback(self,callbackkey, dinf, iinf, liinf):
      if self.__user_cb is not None:
        try:
          if self.__user_cb(callbackkey,dinf,iinf,liinf):
            self.__break = True
        except:
          self.__break = True
  
      if self.__user_pgs is not None:
        try:
          if self.__user_pgs(callbackkey):
            self.__break = True
        except:
          self.__break = True
          
      return 1 if self.__break else 0
  
    def _ctor_init_SS(self,name,licfile):
      env = self._globalEnv()
      self.__modelname = name
      self.__break = False
      task = mosek.Task(self._global_env, 0, 0);
      self.__user_cb = None
      self.__user_pgs = None
      finished = False
      try:
        task.putintparam(mosek.iparam.log_expand,0);
        #task.putintparam(mosek.iparam.remove_unused_solutions,1);
        self.__task = task
        if name is not None:
          task.puttaskname(name)
  
        self._synched = mosek_fusion_SolutionStatus.Optimal;
  
        self._sol_itr = None
        self._sol_bas = None
        self._sol_itg = None
  
        self.__objname = None
        self.__objexpr = None
  
        # handler for log output.
        def loghandler(text):
          if self.__logwriter is not None:
            self.__logwriter.write(text)
            self.__logwriter.flush()
        self.__loghandler = loghandler
        self.__logwriter = None
        
        task.set_Stream(mosek.streamtype.log,loghandler)
        task.set_InfoCallback(self.__callback)
        finished = True
      finally:
        if not finished:
          self.__task.__del__()
          self.__task = None
          BaseModel._global_env_counter -= 1
  
    def _ctor_init_Lmosek_4fusion_4BaseModel_2(self,m):
      env = self._globalEnv()
      self.__modelname = m.__modelname
      self.__break = False
      self.__user_cb = None
      self.__user_pgs = None
      task = mosek.Task(m.__task)
      finished = False
      try:
        self.__task = task
        #self.__task.putintparam(mosek.iparam.remove_unused_solutions,1);
        self._synched = m._synched;
  
        self._sol_itr = m._sol_itr._clone_() if m._sol_itr is not None else None
        self._sol_bas = m._sol_bas._clone_() if m._sol_bas is not None else None
        self._sol_itg = m._sol_itg._clone_() if m._sol_itg is not None else None
  
        self.__objname = m.__objname
  
        # handler for log output.
        def loghandler(text):
          if self.__logwriter is not None:
            self.__logwriter.write(text)
            self.__logwriter.flush()
        self.__loghandler = loghandler
        self.__logwriter = None
        
        task.set_Stream(mosek.streamtype.log,loghandler)
        task.set_InfoCallback(self.__callback)
        finished = True
      finally:
        if not finished:
          self.__task.__del__()
          self.__task = None
          BaseModel._global_env_counter -= 1
  
    def __del__(self):
        if hasattr(self,'_BaseModel__task'):
          self._lock.acquire()
          try:
            task = self.__task
            BaseModel._global_env_counter -= 1
            task.__del__()
  
            for a in self.__class__.__slots__ + ['_sol_itr','_sol_bas','_sol_itg',
                                                 '_BaseModel__user_cb','_BaseModel__user_pgs','_BaseModel__loghandler','_BaseModel__logwriter','_BaseModel__task']:
              try: delattr(self,a)
              except AttributeError: pass
          finally:
            self._lock.release()
  
    def __enter__(self):
      return self
    def __exit__(self,exc_type,exc_val,exc_tb):
      self.__del__()
    def _dispose_(self):
      self.__del__()
  
    def _task_1setDataCallbackHandler_LSystem_4DataCallbackHandler_2(self,handler):
      self.__user_cb = handler
    def _task_1setCallbackHandler_LSystem_4CallbackHandler_2(self,handler):
      self.__user_pgs = handler
  
    def _task_1setLogHandler_LSystem_4StreamWriter_2(self,handler):
      """
      Set the object to handle log output from the solver.
  
      The handler object must have a write method accepting a string.
      """
      self.__logwriter = handler
  
    def _task_1put_1param_SS(self,name,value):
      self.__task.putnastrparam(name,value)
    def _task_1put_1param_SD(self,name,value):
      self.__task.putnadouparam(name,value)
    def _task_1put_1param_SI(self,name,value):
      self.__task.putnaintparam(name,value)
  
    def _task_1get_1dinf_S(self,name):
      key = mosek_fusion_SolverInfo._getdouinf(name)
      if key is None:
        raise NameError("Invalid double info name '%s'" % name)
      else:
        return self.__task.getdouinf(key)
  
    def _task_1get_1iinf_S(self,name):
      key = mosek_fusion_SolverInfo._getintinf(name)
      if key is None:
        raise NameError("Invalid integer info name '%s'" % name)
      else:
        return self.__task.getintinf(key)
  
    def _task_1get_1liinf_S(self,name):
      key = mosek_fusion_SolverInfo._getlintinf(name)
      if key is None:
        raise NameError("Invalid long integer info name '%s'" % name)
      else:
        return self.__task.getlintinf(key)
  
    def _numVariables_ (self):
      return len(self.__vars)
    def _numConstraints_ (self):
      return len(self.__cons)
    
    def _alloc_1rangedvar_SDD(self,name,lb,ub):
      n = self.__task.getnumvar()
      self.__task.appendvars(1)
      if name is not None:
          self.__task.putvarname(n,name)
      self.__task.putbound(mosek.accmode.var, n, mosek.boundkey.ra, lb, ub)
      return n
    
    def _alloc_1linearvar_SEmosek_4fusion_4RelationKey_2D(self,name,relkey,bnd):
      task = self.__task
      n = task.getnumvar();
      task.appendvars(1)
      if name is not None:
          task.putvarname(n,name)
  
      if   relkey is mosek_fusion_RelationKey.IsFree:
        task.putbound(mosek.accmode.var, n, mosek.boundkey.fr, 0.0, 0.0)
      elif relkey is mosek_fusion_RelationKey.LessThan:
        task.putbound(mosek.accmode.var, n, mosek.boundkey.up, 0.0, bnd)
      elif relkey is mosek_fusion_RelationKey.GreaterThan:
        task.putbound(mosek.accmode.var, n, mosek.boundkey.lo, bnd, 0.0)
      else:
        task.putbound(mosek.accmode.var, n, mosek.boundkey.fx, bnd, bnd)
      return n
  
    def _task_1con_1name_IS(self,idx,name):
      self.__task.putconname(idx,name)
    def _task_1var_1name_IS(self,idx, name):
      self.__task.putvarname(idx,name)
    
    def _task_1cone_1name_IS(self,idx,name):
      self.__task.putconename(idx,name)
  
    def _task_1numcon_(self):
      return self.__task.getnumcon()
    def _task_1numvar_(self):
      return self.__task.getnumvar()
    def _task_1numcone_(self):
      return self.__task.getnumcone()
    
    def __task_putboundslice(self,acc,first,last,bl,bu,bk):  
      num = int(last-first)
      if bl is None: bl = numpy.zeros((num,),float)
      if bu is None: bu = numpy.zeros((num,),float)
      
      bka = [bk] * num
      self.__task.putboundslice(acc,first,last,bka,bl,bu)
    
  
    def __task_putboundlist(self,acc,idxs,bl,bu,bk):
      num = len(idxs)
      if bl is None: bl = numpy.zeros((num,),float)
      if bu is None: bu = numpy.zeros((num,),float)
  
      bka = [bk] * num
      self.__task.putboundlist(acc,idxs,bka,bl,bu)
    
    def _task_1con_1putboundslice_1fx_II_3D(self,first, last, rhs):
      self.__task_putboundslice(mosek.accmode.con, first, last, rhs, rhs, mosek.boundkey.fx);
    
    def _task_1con_1putboundslice_1lo_II_3D(self,first, last, rhs):
      self.__task_putboundslice(mosek.accmode.con, first, last, rhs, rhs, mosek.boundkey.lo);
    
    def _task_1con_1putboundslice_1up_II_3D(self,first, last, rhs):
      self.__task_putboundslice(mosek.accmode.con, first, last, rhs, rhs, mosek.boundkey.up);
    
    def _task_1con_1putboundslice_1ra_II_3D_3D(self,first, last, lb, ub):
      self.__task_putboundslice(mosek.accmode.con, first, last, lb, ub, mosek.boundkey.ra);
    
    def _task_1con_1putboundslice_1fr_II(self,first, last):
      self.__task_putboundslice(mosek.accmode.con, first, last, None, None, mosek.boundkey.fr);
    
    def _task_1var_1putboundslice_1fx_II_3D(self,first, last, rhs):
      self.__task_putboundslice(mosek.accmode.var, first, last, rhs, rhs, mosek.boundkey.fx);
    
    def _task_1var_1putboundslice_1lo_II_3D(self,first, last, rhs):
      self.__task_putboundslice(mosek.accmode.var, first, last, rhs, rhs, mosek.boundkey.lo);
    
    def _task_1var_1putboundslice_1up_II_3D(self,first, last, rhs):
      self.__task_putboundslice(mosek.accmode.var, first, last, rhs, rhs, mosek.boundkey.up);
    
    def _task_1var_1putboundslice_1ra_II_3D_3D(self,first, last, lb, ub):
      self.__task_putboundslice(mosek.accmode.var, first, last, lb, ub, mosek.boundkey.ra);
  
    def _task_1var_1putboundslice_1fr_II(self,first, last):
      self.__task_putboundslice(mosek.accmode.var, first, last, None, None, mosek.boundkey.fr);
                                                                    
    def _task_1con_1putboundlist_1fx__3I_3D(self,idxs, rhs):
      self.__task_putboundlist(mosek.accmode.con, idxs, rhs, rhs, mosek.boundkey.fx);
    
    def _task_1con_1putboundlist_1lo__3I_3D(self,idxs, rhs):
      self.__task_putboundlist(mosek.accmode.con, idxs, rhs, rhs, mosek.boundkey.lo);
    
    def _task_1con_1putboundlist_1up__3I_3D(self,idxs, rhs):
      self.__task_putboundlist(mosek.accmode.con, idxs, rhs, rhs, mosek.boundkey.up);
    
    def _task_1con_1putboundlist_1ra__3I_3D_3D(self,idxs, lb, ub):
      self.__task_putboundlist(mosek.accmode.con, idxs, lb, ub, mosek.boundkey.ra);
  
    def _task_1var_1putintlist__3I(self,idxs):
      self.__task.putvartypelist(idxs,[mosek.variabletype.type_int] * len(idxs))
    def _task_1var_1putcontlist__3I(self,idxs):
      self.__task.putvartypelist(idxs,[mosek.variabletype.type_cont] * len(idxs))
    
    
    def _task_1task_1optimize_ (self):
      try:
        self.__task.optimize()
        self.__task.solutionsummary(streamtype.log)
      except mosek.Error, e:
        raise OptimizeError("Error occurred while optimizeing")
      except mosek.Warning,e:
        pass
    
    def __task_appendvars(self,num):
      idx = self.__task.getnumvar()
      self.__task.appendvars(num)
      return idx
  
    def __task_appendcons(self,num):
      idx = self.__task.getnumcon()
      self.__task.appendcons(num)
      return idx
  
    def __task_appendcones(self,ct,conesize,first,num,d0,d1):
      idx = self.__task.getnumcone()
  
      for k0 in range(d0):
        subj = numpy.arange(0,conesize*d1,d1)+k0*d1*conesize+first
        for k1 in range(d1):
          self.__task.appendcone(ct, 0.0, subj)
          subj += d1
  
      return idx
    
    def _task_1append_1var_I(self,num):
      return self.__task_appendvars(num)
  
    def _task_1append_1con_I(self,num):
      return self.__task_appendcons(num)
  
    def _task_1append_1quadcone_IIIII(self,conesize,first,num,d0,d1):
      return self.__task_appendcones(mosek.conetype.quad, conesize, first,num,d0,d1);
  
    def _task_1append_1rquadcone_IIIII(self,conesize,first,num,d0,d1):
      return self.__task_appendcones(mosek.conetype.rquad, conesize, first,num,d0,d1)
    
    def _task_1putarowslice_II_3J_3I_3D(self,first, last, ptrb, subj, cof):
      num   = last-first
      sub   = numpy.arange(first,last)
      self.__task.putarowlist(sub, ptrb[:-1], ptrb[1:], subj, cof);
  
    def _task_1putaijlist__3I_3I_3DJ(self,subi,subj,cof,num):
      self.__task.putaijlist(subi[:num],subj[:num],cof[:num])
    
    def _task_1putobjectivename_S(self,name):
      self.__task.putobjname("" if name is None else name)
      
    # note: subj must not contain duplicates
    def _task_1putobjective_Z_3I_3DD(self,maximize,subj,cof,cfix):
      c = numpy.zeros((self.__task.getnumvar(),),numpy.float64)
      idxs = numpy.arange(0,len(c),dtype=numpy.int32)
      for i in xrange(len(subj)):
        c[subj[i]] += cof[i]
      self.__task.putclist(idxs,c)
      self.__task.putcfix(cfix)
      self.__task.putobjsense(mosek.objsense.maximize if maximize else mosek.objsense.minimize)
  
  
    def _task_1putbaraij_III(self,i,j,k):
      self.__task.putbaraij(i,j,[k], [1.0])
    def _task_1putbarcj_II(self,j,k):
      self.__task.putbarcj(j,[k],[1.0])
    
    def _task_1putbaraij_II_3I(self,i,j,k):
      self.__task.putbaraij(i,j,k, [1.0]*len(k))
    def _task_1putbarcj_I_3I(self,j,k):
      self.__task.putbarcj(j,k,[1.0]*len(k))
  
    def _task_1append_1barmatrix_I_3I_3I_3D(self,dim,subi, subj, cof):
      return self.__task.appendsparsesymmat(dim,subi,subj,cof)
  
    def _task_1barvardim_I(self,index):
      return self.__task.getdimbarvarj(index)
  
    def _task_1numbarvar_(self):
      return self.__task.getnumbarvar()
  
    def _task_1barvar_1name_IS(self, idx, name):
      self.__task.putbarvarname(idx,name)
  
    def _task_1append_1barvar_II(self,size, num):
      res = self.__task.getnumbarvar()
      self.__task.appendbarvars([size] * num)
      return res
  
    def _task_1setnumvar_I(self,num):
      numvar = self.__task.getnumvar()
      if numvar > num:
        self.__task.removevars(range(num,numvar))
  
  
    def _task_1putxx_1slice_Emosek_4fusion_4SolutionType_2II_3D(self,whichsol,first,last,xx):
      if   whichsol == mosek_fusion_SolutionType.Interior:
        self.__task.putxxslice(mosek.soltype.itr, first,last,xx)
      elif whichsol == mosek_fusion_SolutionType.Integer:
        self.__task.putxxslice(mosek.soltype.itg, first,last,xx)
      elif whichsol == mosek_fusion_SolutionType.Basic:
        self.__task.putxxslice(mosek.soltype.bas, first,last,xx)
      
    def _task_1cleanup_IIII(self,inumvar,inumcon,inumcone,inumbarvar):
      numvar  = self.__task.getnumvar()
      numcon  = self.__task.getnumcon()
      numcone = self.__task.getnumcone()
      numbarvar = self.__task.getnumbarvar()
  
      if inumcone < numcone:
        self.__task.removecones(range(inumcone,numcone))
  
      if inumvar < numvar:
        n    = numvar-inumvar
        vals = numpy.zeros((n,), numpy.float64)
        bk   = [ mosek.boundkey.fx for i in range(n) ]
        self.__task.putvarboundslice(inumvar,numvar,bk, vals, vals)
  
      if (inumcon < numcon):
        idxs = numpy.arange(inumcon,numcon,dtype=numpy.int32)
        self.__task.removecons(idxs)
  
      if (inumbarvar < numbarvar):
        self.__task.removebarvars(range(inumbarvar,numbarvar))
      
    @staticmethod
    def __convertSolutionStatus(soltype,sol,status,prosta):
      pd = { 
          mosek.solsta.optimal :                    mosek_fusion_SolutionStatus.Optimal,
          mosek.solsta.near_optimal :               mosek_fusion_SolutionStatus.NearOptimal,
          mosek.solsta.integer_optimal :            mosek_fusion_SolutionStatus.Optimal,
          mosek.solsta.near_integer_optimal :       mosek_fusion_SolutionStatus.NearOptimal,
          mosek.solsta.prim_and_dual_feas :         mosek_fusion_SolutionStatus.Feasible,
          mosek.solsta.near_prim_and_dual_feas :    mosek_fusion_SolutionStatus.NearFeasible,
          mosek.solsta.prim_feas :                  mosek_fusion_SolutionStatus.Feasible,
          mosek.solsta.near_prim_feas :             mosek_fusion_SolutionStatus.NearFeasible,
          mosek.solsta.dual_feas :                  mosek_fusion_SolutionStatus.Unknown,
          mosek.solsta.near_dual_feas :             mosek_fusion_SolutionStatus.Unknown,
          mosek.solsta.prim_infeas_cer :            mosek_fusion_SolutionStatus.Unknown,
          mosek.solsta.dual_infeas_cer :            mosek_fusion_SolutionStatus.Certificate,
          mosek.solsta.near_prim_infeas_cer :       mosek_fusion_SolutionStatus.Unknown,
          mosek.solsta.near_dual_infeas_cer :       mosek_fusion_SolutionStatus.NearCertificate,
          mosek.solsta.prim_illposed_cer :          mosek_fusion_SolutionStatus.Unknown,
          mosek.solsta.dual_illposed_cer :          mosek_fusion_SolutionStatus.IllposedCert,
      }
  
      dd = {
          mosek.solsta.optimal :                    mosek_fusion_SolutionStatus.Optimal,
          mosek.solsta.near_optimal :               mosek_fusion_SolutionStatus.NearOptimal,
          mosek.solsta.integer_optimal :            mosek_fusion_SolutionStatus.Unknown,
          mosek.solsta.near_integer_optimal :       mosek_fusion_SolutionStatus.Unknown,
          mosek.solsta.prim_and_dual_feas :         mosek_fusion_SolutionStatus.Feasible,
          mosek.solsta.near_prim_and_dual_feas :    mosek_fusion_SolutionStatus.NearFeasible,
          mosek.solsta.prim_feas :                  mosek_fusion_SolutionStatus.Unknown,
          mosek.solsta.near_prim_feas :             mosek_fusion_SolutionStatus.Unknown,
          mosek.solsta.dual_feas :                  mosek_fusion_SolutionStatus.Feasible,
          mosek.solsta.near_dual_feas :             mosek_fusion_SolutionStatus.NearFeasible,
          mosek.solsta.prim_infeas_cer :            mosek_fusion_SolutionStatus.Certificate,
          mosek.solsta.dual_infeas_cer :            mosek_fusion_SolutionStatus.Unknown,
          mosek.solsta.near_prim_infeas_cer :       mosek_fusion_SolutionStatus.NearCertificate,
          mosek.solsta.near_dual_infeas_cer :       mosek_fusion_SolutionStatus.Unknown,
  
          mosek.solsta.prim_illposed_cer :          mosek_fusion_SolutionStatus.IllposedCert,
          mosek.solsta.dual_illposed_cer :          mosek_fusion_SolutionStatus.Unknown,
      }
  
      psd = {
          mosek.prosta.unknown  :                   mosek_fusion_ProblemStatus.Unknown,
          mosek.prosta.prim_and_dual_feas :         mosek_fusion_ProblemStatus.PrimalAndDualFeasible,
          mosek.prosta.prim_feas :                  mosek_fusion_ProblemStatus.PrimalFeasible,
          mosek.prosta.dual_feas :                  mosek_fusion_ProblemStatus.DualFeasible,
          mosek.prosta.prim_infeas :                mosek_fusion_ProblemStatus.PrimalInfeasible,
          mosek.prosta.dual_infeas :                mosek_fusion_ProblemStatus.DualInfeasible,
          mosek.prosta.prim_and_dual_infeas :       mosek_fusion_ProblemStatus.PrimalAndDualInfeasible,
          mosek.prosta.ill_posed :                  mosek_fusion_ProblemStatus.IllPosed,
          mosek.prosta.near_prim_and_dual_feas :    mosek_fusion_ProblemStatus.PrimalAndDualInfeasible,
          mosek.prosta.near_prim_feas :             mosek_fusion_ProblemStatus.PrimalInfeasible,
          mosek.prosta.near_dual_feas :             mosek_fusion_ProblemStatus.DualInfeasible,
          mosek.prosta.prim_infeas_or_unbounded :   mosek_fusion_ProblemStatus.PrimalInfeasibleOrUnbounded,
        }
  
      try: sol.pstatus = pd[status]
      except KeyError: sol.pstatus = mosek_fusion_SolutionStatus.Unknown
      
      try: sol.dstatus = dd[status]
      except KeyError: sol.dstatus = mosek_fusion_SolutionStatus.Unknown
  
      try: sol.probstatus = psd[prosta]
      except KeyError: sol.probstatus = mosek_fusion_SolutionStatus.Unknown
  
  
    @staticmethod
    def _matchargs_task_1write_S(self,*args):
        return True
    def _task_1write_S(self,filename):
        self.__task.putintparam(mosek.iparam.opf_write_solutions, 1)
        self.__task.putintparam(mosek.iparam.write_ignore_incompatible_items, 1)
        self.__task.writedata(filename)
    
    def _task_1write(self,filename):
      return self._writeProblem_S(filename)
   
    def _task_1get_(self):
      return self.__task
        
    def _task_1break_1solve_(self):
      self.__break = True
  
    @staticmethod
    def _matchargs_task_1solve_(self,*args):
      return True
    def _task_1solve_(self):
      task = self.__task
      ok = False
      try:
        trmcode = mosek.rescode.ok
        try:
          self.__break = False
          trmcode = task.optimize()        
        except mosek.Error,e:
          raise mosek_fusion_OptimizeError(e.msg)
        except mosek.Warning,e:
          pass
        
        numcon  = task.getnumcon()
        numvar  = task.getnumvar()
        numcone = task.getnumcone()
        numbarvar = task.getnumbarvar()
        
        sol_bas_def = 0 != task.solutiondef(mosek.soltype.bas)
        sol_itr_def = 0 != task.solutiondef(mosek.soltype.itr)
        sol_itg_def = 0 != task.solutiondef(mosek.soltype.itg)
  
        self._sol_itr = None
        self._sol_bas = None
        self._sol_itg = None 
  
        if sol_itr_def:
          self._sol_itr = mosek_fusion_SolutionStruct(numvar,numcon,numcone,numbarvar)
          sol_itr = self._sol_itr
          prosta,solsta = task.getsolution(
            mosek.soltype.itr,
            #sol_itr.skc,sol_itr.skx,sol_itr.skn,
            None,None,None,
            sol_itr.xc,sol_itr.xx,sol_itr.y,
            sol_itr.slc,sol_itr.suc,
            sol_itr.slx,sol_itr.sux,
            sol_itr.snx)
          for j in xrange(numbarvar):
            barxjdim = task.getdimbarvarj(j)
            self._sol_itr.barx[j] = numpy.zeros(barxjdim * (barxjdim + 1) / 2, numpy.float64)
            self._sol_itr.bars[j] = numpy.zeros(barxjdim * (barxjdim + 1) / 2, numpy.float64)
            task.getbarxj(mosek.soltype.itr, j, self._sol_itr.barx[j])
            task.getbarsj(mosek.soltype.itr, j, self._sol_itr.bars[j])
  
          sol_itr.pobj = task.getprimalobj(mosek.soltype.itr)
          sol_itr.dobj = task.getdualobj  (mosek.soltype.itr)
          self.__convertSolutionStatus(mosek.soltype.itr, sol_itr, solsta,prosta);
          #print "got itr sol, stat = %s/%s" % (sol_itr.pstatus,sol_itr.dstatus)
  
        if sol_bas_def:
          self._sol_bas = mosek_fusion_SolutionStruct(numvar,numcon,numcone,numbarvar);
          sol_bas = self._sol_bas
          prosta,solsta = task.getsolution(
            mosek.soltype.bas,
            #sol_bas.skc,sol_bas.skx,sol_bas.skn,
            None,None,None,
            sol_bas.xc,sol_bas.xx,sol_bas.y,
            sol_bas.slc,sol_bas.suc,
            sol_bas.slx,sol_bas.sux,
            sol_bas.snx)
          
          # NOTE: this probably never happens:
          for j in xrange(numbarvar):
            barxjdim = task.getdimbarvarj(j)
            self._sol_bas.barx[j] = numpy.zeros(barxjdim * (barxjdim + 1) / 2,numpy.float64)
            self._sol_bas.bars[j] = numpy.zeros(barxjdim * (barxjdim + 1) / 2,numpy.float64)
            task.getbarxj(mosek.soltype.bas, j, self._sol_bas.barx[j])
            task.getbarsj(mosek.soltype.bas, j, self._sol_bas.bars[j])
  
          sol_bas.pobj = task.getprimalobj(mosek.soltype.bas)
          sol_bas.dobj = task.getdualobj  (mosek.soltype.bas)
          self.__convertSolutionStatus(mosek.soltype.bas, sol_bas, solsta,prosta);
  
          #print "got bas sol, stat = %s/%s" % (sol_bas.pstatus,sol_bas.dstatus)
  
        if sol_itg_def:
          self._sol_itg = mosek_fusion_SolutionStruct(numvar,numcon,numcone,numbarvar);
          sol_itg = self._sol_itg
          prosta,solsta = task.getsolution(
            mosek.soltype.itg,
            #sol_itg.skc,sol_itg.skx,sol_itg.skn,
            None,None,None,
            sol_itg.xc,sol_itg.xx,sol_itg.y,
            sol_itg.slc,sol_itg.suc,
            sol_itg.slx,sol_itg.sux,
            sol_itg.snx)
  
          # NOTE: this probably wont happen for a long time:
          for j in xrange(numbarvar):
            barxjdim = task.getdimbarvarj(j)
            self._sol_itg.barx[j] = numpy.zeros(barxjdim * (barxjdim + 1) / 2,numpy.float64)
            self._sol_itg.bars[j] = numpy.zeros(barxjdim * (barxjdim + 1) / 2,numpy.float64)
            task.getbarxj(mosek.soltype.itg, j, self._sol_itg.barx[j])
            task.getbarsj(mosek.soltype.itg, j, self._sol_itg.bars[j])
  
          sol_itg.pobj = task.getprimalobj(mosek.soltype.itg)
          self.__convertSolutionStatus(mosek.soltype.itg, sol_itg, solsta,prosta);
        ok = True
      
      finally:
        if not ok: # means exception
          self._sol_itr = None
          self._sol_bas = None
          self._sol_itg = None
  
    @staticmethod
    def _env_1syeig_I_3D_3D(n,a,w): BaseModel._globalEnv().syeig(n,a,w)
    @staticmethod
    def _env_1syevd_I_3D_3D(n,a,w): BaseModel._globalEnv().syevd(n,a,w)
    #@staticmethod
    #def _env_1potrf_I_3D(n,a):      BaseModel._globalEnv().potrf(n,a)
  
  return BaseModel
mosek_fusion_BaseModel=__mk_mosek_fusion_BaseModel()
#BEFORE CLASS
def __mk_mosek_fusion_Model():
 class Model(mosek_fusion_BaseModel):
  __slots__ = ['_Model__task_vars_used','_Model__task_vars_allocated','_Model__con_map','_Model__cons_used','_Model__cons','_vars_used','_vars','_Model__initsol_xx_flag','_Model__initsol_xx','_natbarvarmap_num','_natbarvarmap_Var','_Model__var_map','_Model__natvarmap_num','_Model__natvarmap_idx','_Model__natvarmap_Var','_Model__solutionptr','_Model__acceptable_sol','_Model__model_name']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_(*args): # 
      self._ctor_init_(*args)
    elif self.__match_alt_ctor_(*args):# 
      self._ctor_alt_init_(*args)
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.Model.ctor()\n\tmosek.fusion.Model.ctor(string)')
  def breakSolver(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_breakSolver_(*args): # 
      return self._breakSolver_(*args)
    elif mosek_fusion_Model._match_alt_breakSolver_(*args): # 
      return self._breakSolver_alt_(*args)
    else:
      raise ValueError('Invalid argument list breakSolver('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.breakSolver()')
  def dispose(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_dispose_(*args): # 
      return self._dispose_(*args)
    elif mosek_fusion_Model._match_alt_dispose_(*args): # 
      return self._dispose_alt_(*args)
    else:
      raise ValueError('Invalid argument list dispose('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.dispose()')
  def getVariable(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getVariable_S(*args): # string
      return self._getVariable_S(*args)
    elif mosek_fusion_Model._match_alt_getVariable_S(*args): # string
      return self._getVariable_alt_S(*args)
    elif mosek_fusion_Model._match_getVariable_I(*args): # int32
      return self._getVariable_I(*args)
    elif mosek_fusion_Model._match_alt_getVariable_I(*args): # int32
      return self._getVariable_alt_I(*args)
    else:
      raise ValueError('Invalid argument list getVariable('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getVariable(string)\n\tmosek.fusion.Model.getVariable(int32)')
  def primalObjValue(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_primalObjValue_(*args): # 
      return self._primalObjValue_(*args)
    elif mosek_fusion_Model._match_alt_primalObjValue_(*args): # 
      return self._primalObjValue_alt_(*args)
    else:
      raise ValueError('Invalid argument list primalObjValue('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.primalObjValue()')
  @staticmethod
  def putlicensewait(*args):
    if False: pass
    elif mosek_fusion_Model._match_putlicensewait_Z(*args): # bool
      return mosek_fusion_Model._putlicensewait_Z(*args)
    elif mosek_fusion_Model._match_alt_putlicensewait_Z(*args): # bool
      return mosek_fusion_Model._putlicensewait_alt_Z(*args)
    else:
      raise ValueError('Invalid argument list putlicensewait('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.putlicensewait(bool)')
  def hasVariable(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_hasVariable_S(*args): # string
      return self._hasVariable_S(*args)
    elif mosek_fusion_Model._match_alt_hasVariable_S(*args): # string
      return self._hasVariable_alt_S(*args)
    else:
      raise ValueError('Invalid argument list hasVariable('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.hasVariable(string)')
  def getTask(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getTask_(*args): # 
      return self._getTask_(*args)
    elif mosek_fusion_Model._match_alt_getTask_(*args): # 
      return self._getTask_alt_(*args)
    else:
      raise ValueError('Invalid argument list getTask('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getTask()')
  def solve(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_solve_(*args): # 
      return self._solve_(*args)
    elif mosek_fusion_Model._match_alt_solve_(*args): # 
      return self._solve_alt_(*args)
    else:
      raise ValueError('Invalid argument list solve('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.solve()')
  def getPrimalSolutionStatus(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getPrimalSolutionStatus_(*args): # 
      return self._getPrimalSolutionStatus_(*args)
    elif mosek_fusion_Model._match_alt_getPrimalSolutionStatus_(*args): # 
      return self._getPrimalSolutionStatus_alt_(*args)
    elif mosek_fusion_Model._match_getPrimalSolutionStatus_Emosek_4fusion_4SolutionType_2(*args): # mosek.fusion.SolutionType
      return self._getPrimalSolutionStatus_Emosek_4fusion_4SolutionType_2(*args)
    elif mosek_fusion_Model._match_alt_getPrimalSolutionStatus_Emosek_4fusion_4SolutionType_2(*args): # mosek.fusion.SolutionType
      return self._getPrimalSolutionStatus_alt_Emosek_4fusion_4SolutionType_2(*args)
    else:
      raise ValueError('Invalid argument list getPrimalSolutionStatus('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getPrimalSolutionStatus()\n\tmosek.fusion.Model.getPrimalSolutionStatus(mosek.fusion.SolutionType)')
  def setSolverParam(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_setSolverParam_SS(*args): # string,string
      return self._setSolverParam_SS(*args)
    elif mosek_fusion_Model._match_alt_setSolverParam_SS(*args): # string,string
      return self._setSolverParam_alt_SS(*args)
    elif mosek_fusion_Model._match_setSolverParam_SI(*args): # string,int32
      return self._setSolverParam_SI(*args)
    elif mosek_fusion_Model._match_alt_setSolverParam_SI(*args): # string,int32
      return self._setSolverParam_alt_SI(*args)
    elif mosek_fusion_Model._match_setSolverParam_SD(*args): # string,double
      return self._setSolverParam_SD(*args)
    elif mosek_fusion_Model._match_alt_setSolverParam_SD(*args): # string,double
      return self._setSolverParam_alt_SD(*args)
    else:
      raise ValueError('Invalid argument list setSolverParam('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.setSolverParam(string,string)\n\tmosek.fusion.Model.setSolverParam(string,int32)\n\tmosek.fusion.Model.setSolverParam(string,double)')
  def writeTask(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_writeTask_S(*args): # string
      return self._writeTask_S(*args)
    elif mosek_fusion_Model._match_alt_writeTask_S(*args): # string
      return self._writeTask_alt_S(*args)
    else:
      raise ValueError('Invalid argument list writeTask('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.writeTask(string)')
  def getConstraint(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getConstraint_S(*args): # string
      return self._getConstraint_S(*args)
    elif mosek_fusion_Model._match_alt_getConstraint_S(*args): # string
      return self._getConstraint_alt_S(*args)
    elif mosek_fusion_Model._match_getConstraint_I(*args): # int32
      return self._getConstraint_I(*args)
    elif mosek_fusion_Model._match_alt_getConstraint_I(*args): # int32
      return self._getConstraint_alt_I(*args)
    else:
      raise ValueError('Invalid argument list getConstraint('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getConstraint(string)\n\tmosek.fusion.Model.getConstraint(int32)')
  def dualObjValue(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_dualObjValue_(*args): # 
      return self._dualObjValue_(*args)
    elif mosek_fusion_Model._match_alt_dualObjValue_(*args): # 
      return self._dualObjValue_alt_(*args)
    else:
      raise ValueError('Invalid argument list dualObjValue('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.dualObjValue()')
  def getSolverDoubleInfo(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getSolverDoubleInfo_S(*args): # string
      return self._getSolverDoubleInfo_S(*args)
    elif mosek_fusion_Model._match_alt_getSolverDoubleInfo_S(*args): # string
      return self._getSolverDoubleInfo_alt_S(*args)
    else:
      raise ValueError('Invalid argument list getSolverDoubleInfo('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getSolverDoubleInfo(string)')
  @staticmethod
  def putlicensecode(*args):
    if False: pass
    elif mosek_fusion_Model._match_putlicensecode__3I(*args): # []int32
      return mosek_fusion_Model._putlicensecode__3I(*args)
    elif mosek_fusion_Model._match_alt_putlicensecode__3I(*args): # []int32
      return mosek_fusion_Model._putlicensecode_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list putlicensecode('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.putlicensecode(array(int32,ndim=1))')
  def getSolverIntInfo(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getSolverIntInfo_S(*args): # string
      return self._getSolverIntInfo_S(*args)
    elif mosek_fusion_Model._match_alt_getSolverIntInfo_S(*args): # string
      return self._getSolverIntInfo_alt_S(*args)
    else:
      raise ValueError('Invalid argument list getSolverIntInfo('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getSolverIntInfo(string)')
  def clone(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_clone_(*args): # 
      return self._clone_(*args)
    elif mosek_fusion_Model._match_alt_clone_(*args): # 
      return self._clone_alt_(*args)
    else:
      raise ValueError('Invalid argument list clone('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.clone()')
  def variable(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_variable_(*args): # 
      return self._variable_(*args)
    elif mosek_fusion_Model._match_alt_variable_(*args): # 
      return self._variable_alt_(*args)
    elif mosek_fusion_Model._match_variable_S(*args): # string
      return self._variable_S(*args)
    elif mosek_fusion_Model._match_alt_variable_S(*args): # string
      return self._variable_alt_S(*args)
    elif mosek_fusion_Model._match_variable_Lmosek_4fusion_4LinPSDDomain_2(*args): # mosek.fusion.LinPSDDomain
      return self._variable_Lmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_Lmosek_4fusion_4LinPSDDomain_2(*args): # mosek.fusion.LinPSDDomain
      return self._variable_alt_Lmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.LinearDomain
      return self._variable_Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.LinearDomain
      return self._variable_alt_Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_variable_I(*args): # int32
      return self._variable_I(*args)
    elif mosek_fusion_Model._match_alt_variable_I(*args): # int32
      return self._variable_alt_I(*args)
    elif mosek_fusion_Model._match_variable__3I(*args): # []int32
      return self._variable__3I(*args)
    elif mosek_fusion_Model._match_alt_variable__3I(*args): # []int32
      return self._variable_alt__3I(*args)
    elif mosek_fusion_Model._match_variable_Lmosek_4fusion_4PSDDomain_2(*args): # mosek.fusion.PSDDomain
      return self._variable_Lmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_Lmosek_4fusion_4PSDDomain_2(*args): # mosek.fusion.PSDDomain
      return self._variable_alt_Lmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_Lmosek_4fusion_4QConeDomain_2(*args): # mosek.fusion.QConeDomain
      return self._variable_Lmosek_4fusion_4QConeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_Lmosek_4fusion_4QConeDomain_2(*args): # mosek.fusion.QConeDomain
      return self._variable_alt_Lmosek_4fusion_4QConeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.RangeDomain
      return self._variable_Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.RangeDomain
      return self._variable_alt_Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_ILmosek_4fusion_4LinearDomain_2(*args): # int32,mosek.fusion.LinearDomain
      return self._variable_ILmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_ILmosek_4fusion_4LinearDomain_2(*args): # int32,mosek.fusion.LinearDomain
      return self._variable_alt_ILmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SLmosek_4fusion_4LinearDomain_2(*args): # string,mosek.fusion.LinearDomain
      return self._variable_SLmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SLmosek_4fusion_4LinearDomain_2(*args): # string,mosek.fusion.LinearDomain
      return self._variable_alt_SLmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SLmosek_4fusion_4QConeDomain_2(*args): # string,mosek.fusion.QConeDomain
      return self._variable_SLmosek_4fusion_4QConeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SLmosek_4fusion_4QConeDomain_2(*args): # string,mosek.fusion.QConeDomain
      return self._variable_alt_SLmosek_4fusion_4QConeDomain_2(*args)
    elif mosek_fusion_Model._match_variable__3ILmosek_4fusion_4RangeDomain_2(*args): # []int32,mosek.fusion.RangeDomain
      return self._variable__3ILmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable__3ILmosek_4fusion_4RangeDomain_2(*args): # []int32,mosek.fusion.RangeDomain
      return self._variable_alt__3ILmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_ILmosek_4fusion_4SymmetricLinearDomain_2(*args): # int32,mosek.fusion.SymmetricLinearDomain
      return self._variable_ILmosek_4fusion_4SymmetricLinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_ILmosek_4fusion_4SymmetricLinearDomain_2(*args): # int32,mosek.fusion.SymmetricLinearDomain
      return self._variable_alt_ILmosek_4fusion_4SymmetricLinearDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SI(*args): # string,int32
      return self._variable_SI(*args)
    elif mosek_fusion_Model._match_alt_variable_SI(*args): # string,int32
      return self._variable_alt_SI(*args)
    elif mosek_fusion_Model._match_variable__3ILmosek_4fusion_4LinearDomain_2(*args): # []int32,mosek.fusion.LinearDomain
      return self._variable__3ILmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable__3ILmosek_4fusion_4LinearDomain_2(*args): # []int32,mosek.fusion.LinearDomain
      return self._variable_alt__3ILmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_variable_Lmosek_4fusion_4Set_2Lmosek_4fusion_4QConeDomain_2(*args): # mosek.fusion.Set,mosek.fusion.QConeDomain
      return self._variable_Lmosek_4fusion_4Set_2Lmosek_4fusion_4QConeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_Lmosek_4fusion_4Set_2Lmosek_4fusion_4QConeDomain_2(*args): # mosek.fusion.Set,mosek.fusion.QConeDomain
      return self._variable_alt_Lmosek_4fusion_4Set_2Lmosek_4fusion_4QConeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_ILmosek_4fusion_4LinPSDDomain_2(*args): # int32,mosek.fusion.LinPSDDomain
      return self._variable_ILmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_ILmosek_4fusion_4LinPSDDomain_2(*args): # int32,mosek.fusion.LinPSDDomain
      return self._variable_alt_ILmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_S_3I(*args): # string,[]int32
      return self._variable_S_3I(*args)
    elif mosek_fusion_Model._match_alt_variable_S_3I(*args): # string,[]int32
      return self._variable_alt_S_3I(*args)
    elif mosek_fusion_Model._match_variable_ILmosek_4fusion_4RangeDomain_2(*args): # int32,mosek.fusion.RangeDomain
      return self._variable_ILmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_ILmosek_4fusion_4RangeDomain_2(*args): # int32,mosek.fusion.RangeDomain
      return self._variable_alt_ILmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_Lmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.Set,mosek.fusion.LinearDomain
      return self._variable_Lmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_Lmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.Set,mosek.fusion.LinearDomain
      return self._variable_alt_Lmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_variable_ILmosek_4fusion_4PSDDomain_2(*args): # int32,mosek.fusion.PSDDomain
      return self._variable_ILmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_ILmosek_4fusion_4PSDDomain_2(*args): # int32,mosek.fusion.PSDDomain
      return self._variable_alt_ILmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SLmosek_4fusion_4RangeDomain_2(*args): # string,mosek.fusion.RangeDomain
      return self._variable_SLmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SLmosek_4fusion_4RangeDomain_2(*args): # string,mosek.fusion.RangeDomain
      return self._variable_alt_SLmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SLmosek_4fusion_4LinPSDDomain_2(*args): # string,mosek.fusion.LinPSDDomain
      return self._variable_SLmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SLmosek_4fusion_4LinPSDDomain_2(*args): # string,mosek.fusion.LinPSDDomain
      return self._variable_alt_SLmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_Lmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.Set,mosek.fusion.RangeDomain
      return self._variable_Lmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_Lmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.Set,mosek.fusion.RangeDomain
      return self._variable_alt_Lmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_ILmosek_4fusion_4QConeDomain_2(*args): # int32,mosek.fusion.QConeDomain
      return self._variable_ILmosek_4fusion_4QConeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_ILmosek_4fusion_4QConeDomain_2(*args): # int32,mosek.fusion.QConeDomain
      return self._variable_alt_ILmosek_4fusion_4QConeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SLmosek_4fusion_4PSDDomain_2(*args): # string,mosek.fusion.PSDDomain
      return self._variable_SLmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SLmosek_4fusion_4PSDDomain_2(*args): # string,mosek.fusion.PSDDomain
      return self._variable_alt_SLmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_S_3ILmosek_4fusion_4LinearDomain_2(*args): # string,[]int32,mosek.fusion.LinearDomain
      return self._variable_S_3ILmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_S_3ILmosek_4fusion_4LinearDomain_2(*args): # string,[]int32,mosek.fusion.LinearDomain
      return self._variable_alt_S_3ILmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SILmosek_4fusion_4QConeDomain_2(*args): # string,int32,mosek.fusion.QConeDomain
      return self._variable_SILmosek_4fusion_4QConeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SILmosek_4fusion_4QConeDomain_2(*args): # string,int32,mosek.fusion.QConeDomain
      return self._variable_alt_SILmosek_4fusion_4QConeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_S_3ILmosek_4fusion_4PSDDomain_2(*args): # string,[]int32,mosek.fusion.PSDDomain
      return self._variable_S_3ILmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_S_3ILmosek_4fusion_4PSDDomain_2(*args): # string,[]int32,mosek.fusion.PSDDomain
      return self._variable_alt_S_3ILmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4QConeDomain_2(*args): # string,mosek.fusion.Set,mosek.fusion.QConeDomain
      return self._variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4QConeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4QConeDomain_2(*args): # string,mosek.fusion.Set,mosek.fusion.QConeDomain
      return self._variable_alt_SLmosek_4fusion_4Set_2Lmosek_4fusion_4QConeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2(*args): # string,mosek.fusion.Set,mosek.fusion.RangeDomain
      return self._variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2(*args): # string,mosek.fusion.Set,mosek.fusion.RangeDomain
      return self._variable_alt_SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SILmosek_4fusion_4LinPSDDomain_2(*args): # string,int32,mosek.fusion.LinPSDDomain
      return self._variable_SILmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SILmosek_4fusion_4LinPSDDomain_2(*args): # string,int32,mosek.fusion.LinPSDDomain
      return self._variable_alt_SILmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_S_3ILmosek_4fusion_4RangeDomain_2(*args): # string,[]int32,mosek.fusion.RangeDomain
      return self._variable_S_3ILmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_S_3ILmosek_4fusion_4RangeDomain_2(*args): # string,[]int32,mosek.fusion.RangeDomain
      return self._variable_alt_S_3ILmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_IILmosek_4fusion_4PSDDomain_2(*args): # int32,int32,mosek.fusion.PSDDomain
      return self._variable_IILmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_IILmosek_4fusion_4PSDDomain_2(*args): # int32,int32,mosek.fusion.PSDDomain
      return self._variable_alt_IILmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SILmosek_4fusion_4RangeDomain_2(*args): # string,int32,mosek.fusion.RangeDomain
      return self._variable_SILmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SILmosek_4fusion_4RangeDomain_2(*args): # string,int32,mosek.fusion.RangeDomain
      return self._variable_alt_SILmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SILmosek_4fusion_4PSDDomain_2(*args): # string,int32,mosek.fusion.PSDDomain
      return self._variable_SILmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SILmosek_4fusion_4PSDDomain_2(*args): # string,int32,mosek.fusion.PSDDomain
      return self._variable_alt_SILmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4PSDDomain_2(*args): # string,mosek.fusion.Set,mosek.fusion.PSDDomain
      return self._variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4PSDDomain_2(*args): # string,mosek.fusion.Set,mosek.fusion.PSDDomain
      return self._variable_alt_SLmosek_4fusion_4Set_2Lmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2(*args): # string,mosek.fusion.Set,mosek.fusion.LinearDomain
      return self._variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2(*args): # string,mosek.fusion.Set,mosek.fusion.LinearDomain
      return self._variable_alt_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SILmosek_4fusion_4LinearDomain_2(*args): # string,int32,mosek.fusion.LinearDomain
      return self._variable_SILmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SILmosek_4fusion_4LinearDomain_2(*args): # string,int32,mosek.fusion.LinearDomain
      return self._variable_alt_SILmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_variable_S_3ILmosek_4fusion_4LinPSDDomain_2(*args): # string,[]int32,mosek.fusion.LinPSDDomain
      return self._variable_S_3ILmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_S_3ILmosek_4fusion_4LinPSDDomain_2(*args): # string,[]int32,mosek.fusion.LinPSDDomain
      return self._variable_alt_S_3ILmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SILmosek_4fusion_4SymmetricLinearDomain_2(*args): # string,int32,mosek.fusion.SymmetricLinearDomain
      return self._variable_SILmosek_4fusion_4SymmetricLinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SILmosek_4fusion_4SymmetricLinearDomain_2(*args): # string,int32,mosek.fusion.SymmetricLinearDomain
      return self._variable_alt_SILmosek_4fusion_4SymmetricLinearDomain_2(*args)
    elif mosek_fusion_Model._match_variable_IILmosek_4fusion_4LinPSDDomain_2(*args): # int32,int32,mosek.fusion.LinPSDDomain
      return self._variable_IILmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_IILmosek_4fusion_4LinPSDDomain_2(*args): # int32,int32,mosek.fusion.LinPSDDomain
      return self._variable_alt_IILmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinPSDDomain_2(*args): # string,mosek.fusion.Set,mosek.fusion.LinPSDDomain
      return self._variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinPSDDomain_2(*args): # string,mosek.fusion.Set,mosek.fusion.LinPSDDomain
      return self._variable_alt_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SIILmosek_4fusion_4LinPSDDomain_2(*args): # string,int32,int32,mosek.fusion.LinPSDDomain
      return self._variable_SIILmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SIILmosek_4fusion_4LinPSDDomain_2(*args): # string,int32,int32,mosek.fusion.LinPSDDomain
      return self._variable_alt_SIILmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SIILmosek_4fusion_4PSDDomain_2(*args): # string,int32,int32,mosek.fusion.PSDDomain
      return self._variable_SIILmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SIILmosek_4fusion_4PSDDomain_2(*args): # string,int32,int32,mosek.fusion.PSDDomain
      return self._variable_alt_SIILmosek_4fusion_4PSDDomain_2(*args)
    else:
      raise ValueError('Invalid argument list variable('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.variable()\n\tmosek.fusion.Model.variable(string)\n\tmosek.fusion.Model.variable(mosek.fusion.LinPSDDomain)\n\tmosek.fusion.Model.variable(mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.variable(int32)\n\tmosek.fusion.Model.variable(array(int32,ndim=1))\n\tmosek.fusion.Model.variable(mosek.fusion.PSDDomain)\n\tmosek.fusion.Model.variable(mosek.fusion.QConeDomain)\n\tmosek.fusion.Model.variable(mosek.fusion.RangeDomain)\n\tmosek.fusion.Model.variable(int32,mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.variable(string,mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.variable(string,mosek.fusion.QConeDomain)\n\tmosek.fusion.Model.variable(array(int32,ndim=1),mosek.fusion.RangeDomain)\n\tmosek.fusion.Model.variable(int32,mosek.fusion.SymmetricLinearDomain)\n\tmosek.fusion.Model.variable(string,int32)\n\tmosek.fusion.Model.variable(array(int32,ndim=1),mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.variable(mosek.fusion.Set,mosek.fusion.QConeDomain)\n\tmosek.fusion.Model.variable(int32,mosek.fusion.LinPSDDomain)\n\tmosek.fusion.Model.variable(string,array(int32,ndim=1))\n\tmosek.fusion.Model.variable(int32,mosek.fusion.RangeDomain)\n\tmosek.fusion.Model.variable(mosek.fusion.Set,mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.variable(int32,mosek.fusion.PSDDomain)\n\tmosek.fusion.Model.variable(string,mosek.fusion.RangeDomain)\n\tmosek.fusion.Model.variable(string,mosek.fusion.LinPSDDomain)\n\tmosek.fusion.Model.variable(mosek.fusion.Set,mosek.fusion.RangeDomain)\n\tmosek.fusion.Model.variable(int32,mosek.fusion.QConeDomain)\n\tmosek.fusion.Model.variable(string,mosek.fusion.PSDDomain)\n\tmosek.fusion.Model.variable(string,array(int32,ndim=1),mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.variable(string,int32,mosek.fusion.QConeDomain)\n\tmosek.fusion.Model.variable(string,array(int32,ndim=1),mosek.fusion.PSDDomain)\n\tmosek.fusion.Model.variable(string,mosek.fusion.Set,mosek.fusion.QConeDomain)\n\tmosek.fusion.Model.variable(string,mosek.fusion.Set,mosek.fusion.RangeDomain)\n\tmosek.fusion.Model.variable(string,int32,mosek.fusion.LinPSDDomain)\n\tmosek.fusion.Model.variable(string,array(int32,ndim=1),mosek.fusion.RangeDomain)\n\tmosek.fusion.Model.variable(int32,int32,mosek.fusion.PSDDomain)\n\tmosek.fusion.Model.variable(string,int32,mosek.fusion.RangeDomain)\n\tmosek.fusion.Model.variable(string,int32,mosek.fusion.PSDDomain)\n\tmosek.fusion.Model.variable(string,mosek.fusion.Set,mosek.fusion.PSDDomain)\n\tmosek.fusion.Model.variable(string,mosek.fusion.Set,mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.variable(string,int32,mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.variable(string,array(int32,ndim=1),mosek.fusion.LinPSDDomain)\n\tmosek.fusion.Model.variable(string,int32,mosek.fusion.SymmetricLinearDomain)\n\tmosek.fusion.Model.variable(int32,int32,mosek.fusion.LinPSDDomain)\n\tmosek.fusion.Model.variable(string,mosek.fusion.Set,mosek.fusion.LinPSDDomain)\n\tmosek.fusion.Model.variable(string,int32,int32,mosek.fusion.LinPSDDomain)\n\tmosek.fusion.Model.variable(string,int32,int32,mosek.fusion.PSDDomain)')
  def setCallbackHandler(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_setCallbackHandler_LSystem_4CallbackHandler_2(*args): # System.CallbackHandler
      return self._setCallbackHandler_LSystem_4CallbackHandler_2(*args)
    elif mosek_fusion_Model._match_alt_setCallbackHandler_LSystem_4CallbackHandler_2(*args): # System.CallbackHandler
      return self._setCallbackHandler_alt_LSystem_4CallbackHandler_2(*args)
    else:
      raise ValueError('Invalid argument list setCallbackHandler('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.setCallbackHandler(System.CallbackHandler)')
  def flushNames(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_flushNames_(*args): # 
      return self._flushNames_(*args)
    elif mosek_fusion_Model._match_alt_flushNames_(*args): # 
      return self._flushNames_alt_(*args)
    else:
      raise ValueError('Invalid argument list flushNames('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.flushNames()')
  def hasConstraint(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_hasConstraint_S(*args): # string
      return self._hasConstraint_S(*args)
    elif mosek_fusion_Model._match_alt_hasConstraint_S(*args): # string
      return self._hasConstraint_alt_S(*args)
    else:
      raise ValueError('Invalid argument list hasConstraint('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.hasConstraint(string)')
  def getDualSolutionStatus(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getDualSolutionStatus_(*args): # 
      return self._getDualSolutionStatus_(*args)
    elif mosek_fusion_Model._match_alt_getDualSolutionStatus_(*args): # 
      return self._getDualSolutionStatus_alt_(*args)
    elif mosek_fusion_Model._match_getDualSolutionStatus_Emosek_4fusion_4SolutionType_2(*args): # mosek.fusion.SolutionType
      return self._getDualSolutionStatus_Emosek_4fusion_4SolutionType_2(*args)
    elif mosek_fusion_Model._match_alt_getDualSolutionStatus_Emosek_4fusion_4SolutionType_2(*args): # mosek.fusion.SolutionType
      return self._getDualSolutionStatus_alt_Emosek_4fusion_4SolutionType_2(*args)
    else:
      raise ValueError('Invalid argument list getDualSolutionStatus('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getDualSolutionStatus()\n\tmosek.fusion.Model.getDualSolutionStatus(mosek.fusion.SolutionType)')
  def selectedSolution(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_selectedSolution_Emosek_4fusion_4SolutionType_2(*args): # mosek.fusion.SolutionType
      return self._selectedSolution_Emosek_4fusion_4SolutionType_2(*args)
    elif mosek_fusion_Model._match_alt_selectedSolution_Emosek_4fusion_4SolutionType_2(*args): # mosek.fusion.SolutionType
      return self._selectedSolution_alt_Emosek_4fusion_4SolutionType_2(*args)
    else:
      raise ValueError('Invalid argument list selectedSolution('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.selectedSolution(mosek.fusion.SolutionType)')
  def objective(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_objective_D(*args): # double
      return self._objective_D(*args)
    elif mosek_fusion_Model._match_alt_objective_D(*args): # double
      return self._objective_alt_D(*args)
    elif mosek_fusion_Model._match_objective_SD(*args): # string,double
      return self._objective_SD(*args)
    elif mosek_fusion_Model._match_alt_objective_SD(*args): # string,double
      return self._objective_alt_SD(*args)
    elif mosek_fusion_Model._match_objective_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.ObjectiveSense,mosek.fusion.Variable
      return self._objective_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Model._match_alt_objective_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.ObjectiveSense,mosek.fusion.Variable
      return self._objective_alt_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Model._match_objective_Emosek_4fusion_4ObjectiveSense_2D(*args): # mosek.fusion.ObjectiveSense,double
      return self._objective_Emosek_4fusion_4ObjectiveSense_2D(*args)
    elif mosek_fusion_Model._match_alt_objective_Emosek_4fusion_4ObjectiveSense_2D(*args): # mosek.fusion.ObjectiveSense,double
      return self._objective_alt_Emosek_4fusion_4ObjectiveSense_2D(*args)
    elif mosek_fusion_Model._match_objective_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.ObjectiveSense,mosek.fusion.Expression
      return self._objective_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Model._match_alt_objective_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.ObjectiveSense,mosek.fusion.Expression
      return self._objective_alt_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Model._match_objective_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args): # string,mosek.fusion.ObjectiveSense,mosek.fusion.Expression
      return self._objective_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Model._match_alt_objective_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args): # string,mosek.fusion.ObjectiveSense,mosek.fusion.Expression
      return self._objective_alt_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Model._match_objective_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Variable_2(*args): # string,mosek.fusion.ObjectiveSense,mosek.fusion.Variable
      return self._objective_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Model._match_alt_objective_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Variable_2(*args): # string,mosek.fusion.ObjectiveSense,mosek.fusion.Variable
      return self._objective_alt_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Model._match_objective_SEmosek_4fusion_4ObjectiveSense_2D(*args): # string,mosek.fusion.ObjectiveSense,double
      return self._objective_SEmosek_4fusion_4ObjectiveSense_2D(*args)
    elif mosek_fusion_Model._match_alt_objective_SEmosek_4fusion_4ObjectiveSense_2D(*args): # string,mosek.fusion.ObjectiveSense,double
      return self._objective_alt_SEmosek_4fusion_4ObjectiveSense_2D(*args)
    else:
      raise ValueError('Invalid argument list objective('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.objective(double)\n\tmosek.fusion.Model.objective(string,double)\n\tmosek.fusion.Model.objective(mosek.fusion.ObjectiveSense,mosek.fusion.Variable)\n\tmosek.fusion.Model.objective(mosek.fusion.ObjectiveSense,double)\n\tmosek.fusion.Model.objective(mosek.fusion.ObjectiveSense,mosek.fusion.Expression)\n\tmosek.fusion.Model.objective(string,mosek.fusion.ObjectiveSense,mosek.fusion.Expression)\n\tmosek.fusion.Model.objective(string,mosek.fusion.ObjectiveSense,mosek.fusion.Variable)\n\tmosek.fusion.Model.objective(string,mosek.fusion.ObjectiveSense,double)')
  def constraint(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.Expression,mosek.fusion.LinearDomain
      return self._constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.Expression,mosek.fusion.LinearDomain
      return self._constraint_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(*args): # mosek.fusion.Expression,mosek.fusion.LinPSDDomain
      return self._constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(*args): # mosek.fusion.Expression,mosek.fusion.LinPSDDomain
      return self._constraint_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.Variable,mosek.fusion.LinearDomain
      return self._constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.Variable,mosek.fusion.LinearDomain
      return self._constraint_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args): # mosek.fusion.Expression,mosek.fusion.PSDDomain
      return self._constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args): # mosek.fusion.Expression,mosek.fusion.PSDDomain
      return self._constraint_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(*args): # mosek.fusion.Variable,mosek.fusion.QConeDomain
      return self._constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(*args): # mosek.fusion.Variable,mosek.fusion.QConeDomain
      return self._constraint_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinPSDDomain_2(*args): # mosek.fusion.Variable,mosek.fusion.LinPSDDomain
      return self._constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinPSDDomain_2(*args): # mosek.fusion.Variable,mosek.fusion.LinPSDDomain
      return self._constraint_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.Expression,mosek.fusion.RangeDomain
      return self._constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.Expression,mosek.fusion.RangeDomain
      return self._constraint_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.Variable,mosek.fusion.RangeDomain
      return self._constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.Variable,mosek.fusion.RangeDomain
      return self._constraint_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4PSDDomain_2(*args): # mosek.fusion.Variable,mosek.fusion.PSDDomain
      return self._constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4PSDDomain_2(*args): # mosek.fusion.Variable,mosek.fusion.PSDDomain
      return self._constraint_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(*args): # mosek.fusion.Expression,mosek.fusion.QConeDomain
      return self._constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(*args): # mosek.fusion.Expression,mosek.fusion.QConeDomain
      return self._constraint_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4LinPSDDomain_2(*args): # string,mosek.fusion.Variable,mosek.fusion.LinPSDDomain
      return self._constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4LinPSDDomain_2(*args): # string,mosek.fusion.Variable,mosek.fusion.LinPSDDomain
      return self._constraint_alt_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.Set,mosek.fusion.Expression,mosek.fusion.LinearDomain
      return self._constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.Set,mosek.fusion.Expression,mosek.fusion.LinearDomain
      return self._constraint_alt_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(*args): # string,mosek.fusion.Expression,mosek.fusion.LinPSDDomain
      return self._constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(*args): # string,mosek.fusion.Expression,mosek.fusion.LinPSDDomain
      return self._constraint_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args): # string,mosek.fusion.Expression,mosek.fusion.PSDDomain
      return self._constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args): # string,mosek.fusion.Expression,mosek.fusion.PSDDomain
      return self._constraint_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(*args): # mosek.fusion.Set,mosek.fusion.Expression,mosek.fusion.QConeDomain
      return self._constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(*args): # mosek.fusion.Set,mosek.fusion.Expression,mosek.fusion.QConeDomain
      return self._constraint_alt_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(*args): # string,mosek.fusion.Expression,mosek.fusion.QConeDomain
      return self._constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(*args): # string,mosek.fusion.Expression,mosek.fusion.QConeDomain
      return self._constraint_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.Set,mosek.fusion.Expression,mosek.fusion.RangeDomain
      return self._constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.Set,mosek.fusion.Expression,mosek.fusion.RangeDomain
      return self._constraint_alt_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4PSDDomain_2(*args): # string,mosek.fusion.Variable,mosek.fusion.PSDDomain
      return self._constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4PSDDomain_2(*args): # string,mosek.fusion.Variable,mosek.fusion.PSDDomain
      return self._constraint_alt_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args): # string,mosek.fusion.Expression,mosek.fusion.LinearDomain
      return self._constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args): # string,mosek.fusion.Expression,mosek.fusion.LinearDomain
      return self._constraint_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.Set,mosek.fusion.Variable,mosek.fusion.LinearDomain
      return self._constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.Set,mosek.fusion.Variable,mosek.fusion.LinearDomain
      return self._constraint_alt_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(*args): # mosek.fusion.Set,mosek.fusion.Variable,mosek.fusion.QConeDomain
      return self._constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(*args): # mosek.fusion.Set,mosek.fusion.Variable,mosek.fusion.QConeDomain
      return self._constraint_alt_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args): # string,mosek.fusion.Expression,mosek.fusion.RangeDomain
      return self._constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args): # string,mosek.fusion.Expression,mosek.fusion.RangeDomain
      return self._constraint_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(*args): # string,mosek.fusion.Variable,mosek.fusion.LinearDomain
      return self._constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(*args): # string,mosek.fusion.Variable,mosek.fusion.LinearDomain
      return self._constraint_alt_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(*args): # string,mosek.fusion.Variable,mosek.fusion.QConeDomain
      return self._constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(*args): # string,mosek.fusion.Variable,mosek.fusion.QConeDomain
      return self._constraint_alt_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(*args): # string,mosek.fusion.Variable,mosek.fusion.RangeDomain
      return self._constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(*args): # string,mosek.fusion.Variable,mosek.fusion.RangeDomain
      return self._constraint_alt_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.Set,mosek.fusion.Variable,mosek.fusion.RangeDomain
      return self._constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.Set,mosek.fusion.Variable,mosek.fusion.RangeDomain
      return self._constraint_alt_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(*args): # string,mosek.fusion.Set,mosek.fusion.Variable,mosek.fusion.QConeDomain
      return self._constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(*args): # string,mosek.fusion.Set,mosek.fusion.Variable,mosek.fusion.QConeDomain
      return self._constraint_alt_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args): # string,mosek.fusion.Set,mosek.fusion.Expression,mosek.fusion.RangeDomain
      return self._constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args): # string,mosek.fusion.Set,mosek.fusion.Expression,mosek.fusion.RangeDomain
      return self._constraint_alt_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args): # string,mosek.fusion.Set,mosek.fusion.Expression,mosek.fusion.LinearDomain
      return self._constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args): # string,mosek.fusion.Set,mosek.fusion.Expression,mosek.fusion.LinearDomain
      return self._constraint_alt_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(*args): # string,mosek.fusion.Set,mosek.fusion.Variable,mosek.fusion.RangeDomain
      return self._constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(*args): # string,mosek.fusion.Set,mosek.fusion.Variable,mosek.fusion.RangeDomain
      return self._constraint_alt_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(*args): # string,mosek.fusion.Set,mosek.fusion.Variable,mosek.fusion.LinearDomain
      return self._constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(*args): # string,mosek.fusion.Set,mosek.fusion.Variable,mosek.fusion.LinearDomain
      return self._constraint_alt_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(*args): # string,mosek.fusion.Set,mosek.fusion.Expression,mosek.fusion.QConeDomain
      return self._constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(*args): # string,mosek.fusion.Set,mosek.fusion.Expression,mosek.fusion.QConeDomain
      return self._constraint_alt_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(*args)
    else:
      raise ValueError('Invalid argument list constraint('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.constraint(mosek.fusion.Expression,mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.constraint(mosek.fusion.Expression,mosek.fusion.LinPSDDomain)\n\tmosek.fusion.Model.constraint(mosek.fusion.Variable,mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.constraint(mosek.fusion.Expression,mosek.fusion.PSDDomain)\n\tmosek.fusion.Model.constraint(mosek.fusion.Variable,mosek.fusion.QConeDomain)\n\tmosek.fusion.Model.constraint(mosek.fusion.Variable,mosek.fusion.LinPSDDomain)\n\tmosek.fusion.Model.constraint(mosek.fusion.Expression,mosek.fusion.RangeDomain)\n\tmosek.fusion.Model.constraint(mosek.fusion.Variable,mosek.fusion.RangeDomain)\n\tmosek.fusion.Model.constraint(mosek.fusion.Variable,mosek.fusion.PSDDomain)\n\tmosek.fusion.Model.constraint(mosek.fusion.Expression,mosek.fusion.QConeDomain)\n\tmosek.fusion.Model.constraint(string,mosek.fusion.Variable,mosek.fusion.LinPSDDomain)\n\tmosek.fusion.Model.constraint(mosek.fusion.Set,mosek.fusion.Expression,mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.constraint(string,mosek.fusion.Expression,mosek.fusion.LinPSDDomain)\n\tmosek.fusion.Model.constraint(string,mosek.fusion.Expression,mosek.fusion.PSDDomain)\n\tmosek.fusion.Model.constraint(mosek.fusion.Set,mosek.fusion.Expression,mosek.fusion.QConeDomain)\n\tmosek.fusion.Model.constraint(string,mosek.fusion.Expression,mosek.fusion.QConeDomain)\n\tmosek.fusion.Model.constraint(mosek.fusion.Set,mosek.fusion.Expression,mosek.fusion.RangeDomain)\n\tmosek.fusion.Model.constraint(string,mosek.fusion.Variable,mosek.fusion.PSDDomain)\n\tmosek.fusion.Model.constraint(string,mosek.fusion.Expression,mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.constraint(mosek.fusion.Set,mosek.fusion.Variable,mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.constraint(mosek.fusion.Set,mosek.fusion.Variable,mosek.fusion.QConeDomain)\n\tmosek.fusion.Model.constraint(string,mosek.fusion.Expression,mosek.fusion.RangeDomain)\n\tmosek.fusion.Model.constraint(string,mosek.fusion.Variable,mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.constraint(string,mosek.fusion.Variable,mosek.fusion.QConeDomain)\n\tmosek.fusion.Model.constraint(string,mosek.fusion.Variable,mosek.fusion.RangeDomain)\n\tmosek.fusion.Model.constraint(mosek.fusion.Set,mosek.fusion.Variable,mosek.fusion.RangeDomain)\n\tmosek.fusion.Model.constraint(string,mosek.fusion.Set,mosek.fusion.Variable,mosek.fusion.QConeDomain)\n\tmosek.fusion.Model.constraint(string,mosek.fusion.Set,mosek.fusion.Expression,mosek.fusion.RangeDomain)\n\tmosek.fusion.Model.constraint(string,mosek.fusion.Set,mosek.fusion.Expression,mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.constraint(string,mosek.fusion.Set,mosek.fusion.Variable,mosek.fusion.RangeDomain)\n\tmosek.fusion.Model.constraint(string,mosek.fusion.Set,mosek.fusion.Variable,mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.constraint(string,mosek.fusion.Set,mosek.fusion.Expression,mosek.fusion.QConeDomain)')
  def getProblemStatus(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getProblemStatus_Emosek_4fusion_4SolutionType_2(*args): # mosek.fusion.SolutionType
      return self._getProblemStatus_Emosek_4fusion_4SolutionType_2(*args)
    elif mosek_fusion_Model._match_alt_getProblemStatus_Emosek_4fusion_4SolutionType_2(*args): # mosek.fusion.SolutionType
      return self._getProblemStatus_alt_Emosek_4fusion_4SolutionType_2(*args)
    else:
      raise ValueError('Invalid argument list getProblemStatus('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getProblemStatus(mosek.fusion.SolutionType)')
  def flushSolutions(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_flushSolutions_(*args): # 
      return self._flushSolutions_(*args)
    elif mosek_fusion_Model._match_alt_flushSolutions_(*args): # 
      return self._flushSolutions_alt_(*args)
    else:
      raise ValueError('Invalid argument list flushSolutions('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.flushSolutions()')
  def numVariables(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_numVariables_(*args): # 
      return self._numVariables_(*args)
    elif mosek_fusion_Model._match_alt_numVariables_(*args): # 
      return self._numVariables_alt_(*args)
    else:
      raise ValueError('Invalid argument list numVariables('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.numVariables()')
  def setDataCallbackHandler(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_setDataCallbackHandler_LSystem_4DataCallbackHandler_2(*args): # System.DataCallbackHandler
      return self._setDataCallbackHandler_LSystem_4DataCallbackHandler_2(*args)
    elif mosek_fusion_Model._match_alt_setDataCallbackHandler_LSystem_4DataCallbackHandler_2(*args): # System.DataCallbackHandler
      return self._setDataCallbackHandler_alt_LSystem_4DataCallbackHandler_2(*args)
    else:
      raise ValueError('Invalid argument list setDataCallbackHandler('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.setDataCallbackHandler(System.DataCallbackHandler)')
  def getName(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getName_(*args): # 
      return self._getName_(*args)
    elif mosek_fusion_Model._match_alt_getName_(*args): # 
      return self._getName_alt_(*args)
    else:
      raise ValueError('Invalid argument list getName('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getName()')
  def setLogHandler(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_setLogHandler_LSystem_4StreamWriter_2(*args): # System.StreamWriter
      return self._setLogHandler_LSystem_4StreamWriter_2(*args)
    elif mosek_fusion_Model._match_alt_setLogHandler_LSystem_4StreamWriter_2(*args): # System.StreamWriter
      return self._setLogHandler_alt_LSystem_4StreamWriter_2(*args)
    else:
      raise ValueError('Invalid argument list setLogHandler('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.setLogHandler(System.StreamWriter)')
  def numConstraints(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_numConstraints_(*args): # 
      return self._numConstraints_(*args)
    elif mosek_fusion_Model._match_alt_numConstraints_(*args): # 
      return self._numConstraints_alt_(*args)
    else:
      raise ValueError('Invalid argument list numConstraints('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.numConstraints()')
  def getSolverLIntInfo(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getSolverLIntInfo_S(*args): # string
      return self._getSolverLIntInfo_S(*args)
    elif mosek_fusion_Model._match_alt_getSolverLIntInfo_S(*args): # string
      return self._getSolverLIntInfo_alt_S(*args)
    else:
      raise ValueError('Invalid argument list getSolverLIntInfo('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getSolverLIntInfo(string)')
  def acceptedSolutionStatus(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_acceptedSolutionStatus_Emosek_4fusion_4AccSolutionStatus_2(*args): # mosek.fusion.AccSolutionStatus
      return self._acceptedSolutionStatus_Emosek_4fusion_4AccSolutionStatus_2(*args)
    elif mosek_fusion_Model._match_alt_acceptedSolutionStatus_Emosek_4fusion_4AccSolutionStatus_2(*args): # mosek.fusion.AccSolutionStatus
      return self._acceptedSolutionStatus_alt_Emosek_4fusion_4AccSolutionStatus_2(*args)
    else:
      raise ValueError('Invalid argument list acceptedSolutionStatus('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.acceptedSolutionStatus(mosek.fusion.AccSolutionStatus)')
  def getAcceptedSolutionStatus(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getAcceptedSolutionStatus_(*args): # 
      return self._getAcceptedSolutionStatus_(*args)
    elif mosek_fusion_Model._match_alt_getAcceptedSolutionStatus_(*args): # 
      return self._getAcceptedSolutionStatus_alt_(*args)
    else:
      raise ValueError('Invalid argument list getAcceptedSolutionStatus('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getAcceptedSolutionStatus()')
  @staticmethod
  def putlicensepath(*args):
    if False: pass
    elif mosek_fusion_Model._match_putlicensepath_S(*args): # string
      return mosek_fusion_Model._putlicensepath_S(*args)
    elif mosek_fusion_Model._match_alt_putlicensepath_S(*args): # string
      return mosek_fusion_Model._putlicensepath_alt_S(*args)
    else:
      raise ValueError('Invalid argument list putlicensepath('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.putlicensepath(string)')
  def __repr__(self): return 'mosek.fusion.Model'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2(m):
    o = Model.__new__(Model)
    o._ctor_init_Lmosek_4fusion_4Model_2(m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2(*args):
    if len(args) != 1: return False
    m, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2(*args):
    if len(args) != 1: return False
    m, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2(self,m):
    self._ctor_init_Lmosek_4fusion_4Model_2(m)
  def _ctor_init_Lmosek_4fusion_4Model_2(self,m):
   mosek_fusion_BaseModel._ctor_init_Lmosek_4fusion_4BaseModel_2(self,m)
   self.__model_name = mosek.fusion.Utils.StringBuffer()._a_S((m.__model_name))._a_S("(clone)")._toString_()
   self.__acceptable_sol = (m.__acceptable_sol)
   self.__solutionptr = (m.__solutionptr)
   _0=self
   self._vars = numpy.array([(m._vars)[_1]._clone_Lmosek_4fusion_4Model_2(_0) for _1 in range(0,(m._vars_used))], dtype=numpy.dtype(object))
   self._vars_used = (m._vars_used)
   self.__var_map = (m.__var_map)._clone_()
   self.__task_vars_allocated = (m.__task_vars_allocated)
   self.__task_vars_used = (m.__task_vars_used)
   self.__cons = numpy.array([(m.__cons)[_2]._clone_Lmosek_4fusion_4Model_2(_0) for _2 in range(0,(m.__cons_used))], dtype=numpy.dtype(object))
   self.__cons_used = (m.__cons_used)
   self.__con_map = (m.__con_map)._clone_()
   self.__natvarmap_Var = numpy.array([(m.__natvarmap_Var)[_3] for _3 in range(0,(m.__natvarmap_num))], dtype=numpy.dtype(numpy.int32))
   self.__natvarmap_idx = numpy.array([(m.__natvarmap_idx)[_4] for _4 in range(0,(m.__natvarmap_num))], dtype=numpy.dtype(numpy.int64))
   self.__natvarmap_num = (m.__natvarmap_num)
   self._natbarvarmap_Var = numpy.array([(m.__natvarmap_Var)[_5] for _5 in range(0,(m.__natvarmap_num))], dtype=numpy.dtype(numpy.int32))
   self._natbarvarmap_num = (m._natbarvarmap_num)
   self.__initsol_xx = None
   self.__initsol_xx_flag = None
  @staticmethod
  def _ctor_():
    o = Model.__new__(Model)
    o._ctor_init_()
    return o
  @staticmethod
  def __match_ctor_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def __match_alt_ctor_(*args):
    if len(args) != 0: return False
    return True
  def _ctor_alt_init_(self,):
    self._ctor_init_()
  def _ctor_init_(self,):
   mosek_fusion_BaseModel._ctor_init_SS(self,"","")
   self.__model_name = ""
   self.__acceptable_sol = mosek.fusion.AccSolutionStatus.NearOptimal
   self.__solutionptr = mosek.fusion.SolutionType.Default
   self.__natvarmap_Var = numpy.zeros((1024,), dtype=numpy.dtype(numpy.int32))
   self.__natvarmap_idx = numpy.zeros((1024,), dtype=numpy.dtype(numpy.int64))
   self.__natvarmap_num = 0
   self._natbarvarmap_Var = numpy.zeros((0,), dtype=numpy.dtype(numpy.int32))
   self._natbarvarmap_num = 0
   self.__task_vars_allocated = 0
   self.__task_vars_used = 0
   self.__initsol_xx = None
   self.__initsol_xx_flag = None
   self._vars = numpy.zeros((1024,), dtype=numpy.dtype(object))
   self._vars_used = 0
   self.__var_map = mosek.fusion.Utils.StringIntMap()
   self.__cons = numpy.zeros((1024,), dtype=numpy.dtype(object))
   self.__cons_used = 0
   self.__con_map = mosek.fusion.Utils.StringIntMap()
  @staticmethod
  def _ctor_S(name):
    o = Model.__new__(Model)
    o._ctor_init_S(name)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    name, = args
    return (__arg_match_S__(name))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    name, = args
    return (__arg_alt_match_S__(name))
  def _ctor_alt_init_S(self,name):
    self._ctor_init_S(name)
  def _ctor_init_S(self,name):
   mosek_fusion_BaseModel._ctor_init_SS(self,name,"")
   self.__model_name = name
   self.__acceptable_sol = mosek.fusion.AccSolutionStatus.NearOptimal
   self.__solutionptr = mosek.fusion.SolutionType.Default
   self.__natvarmap_Var = numpy.zeros((1024,), dtype=numpy.dtype(numpy.int32))
   self.__natvarmap_idx = numpy.zeros((1024,), dtype=numpy.dtype(numpy.int64))
   self.__natvarmap_num = 0
   self._natbarvarmap_Var = numpy.zeros((0,), dtype=numpy.dtype(numpy.int32))
   self._natbarvarmap_num = 0
   self.__initsol_xx = None
   self.__initsol_xx_flag = None
   self._vars = numpy.zeros((1024,), dtype=numpy.dtype(object))
   self._vars_used = 0
   self.__var_map = mosek.fusion.Utils.StringIntMap()
   self.__task_vars_allocated = 0
   self.__task_vars_used = 0
   self.__cons = numpy.zeros((1024,), dtype=numpy.dtype(object))
   self.__cons_used = 0
   self.__con_map = mosek.fusion.Utils.StringIntMap()
  @staticmethod
  def _match_putlicensewait_Z(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Z__(_0))
  @staticmethod
  def _match_alt_putlicensewait_Z(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Z__(_0))
  @staticmethod
  def _putlicensewait_alt_Z(_t__0):
    return mosek_fusion_Model._putlicensewait_Z(_0)
  @staticmethod
  def _putlicensewait_Z(_0):
   mosek.fusion.BaseModel._env_1putlicensewait_Z(_0)
  @staticmethod
  def _match_putlicensepath_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_S__(_0))
  @staticmethod
  def _match_alt_putlicensepath_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_S__(_0))
  @staticmethod
  def _putlicensepath_alt_S(_t__0):
    return mosek_fusion_Model._putlicensepath_S(_0)
  @staticmethod
  def _putlicensepath_S(_0):
   mosek.fusion.BaseModel._env_1putlicensepath_S(_0)
  @staticmethod
  def _match_putlicensecode__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_putlicensecode__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  @staticmethod
  def _putlicensecode_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Model._putlicensecode__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _putlicensecode__3I(_0):
   mosek.fusion.BaseModel._env_1putlicensecode__3I(_0)
  @staticmethod
  def __inst_alt__3Lmosek_4fusion_4Variable_2II_3JI_3I_3I_3I(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1=numpy.int32(_t__1)
   _2=numpy.int32(_t__2)
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int64))
   _4=numpy.int32(_t__4)
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.int32))
   _6=numpy.array(_t__6,dtype=numpy.dtype(numpy.int32))
   _7=numpy.array(_t__7,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Model.__inst__3Lmosek_4fusion_4Variable_2II_3JI_3I_3I_3I(_0,_1,_2,_3,_4,_5,_6,_7)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__6[:] = _6
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__7[:] = _7
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __inst__3Lmosek_4fusion_4Variable_2II_3JI_3I_3I_3I(_0,_1,_2,_3,_4,_5,_6,_7):
   _8=numpy.zeros(((int((_0).shape[0]) + 1),), dtype=numpy.dtype(numpy.int64))
   for _9 in range(0,int((_0).shape[0])):
    _8[(_9 + 1)] = (_8[_9] + _0[_9]._size_())
   if (int((_0).shape[0])==1):
    _0[0]._inst__3JIIJJ_3I_3I_3I(_3,_1,_2,0,_4,_5,_6,_7)
   elif (int((_0).shape[0])==2):
    for _10 in range(_1,_2):
     if (_3[_10] < _8[1]):
      _0[0]._inst_JJ_3I_3I_3I(_3[_10],((_4 + _10) - _1),_5,_6,_7)
     else:
      _0[1]._inst_JJ_3I_3I_3I((_3[_10] - _8[1]),((_4 + _10) - _1),_5,_6,_7)
   elif (int((_0).shape[0])==3):
    for _11 in range(_1,_2):
     if (_3[_11] < _8[1]):
      _0[0]._inst_JJ_3I_3I_3I(_3[_11],((_4 + _11) - _1),_5,_6,_7)
     elif (_3[_11] < _8[2]):
      _0[1]._inst_JJ_3I_3I_3I((_3[_11] - _8[1]),((_4 + _11) - _1),_5,_6,_7)
     else:
      _0[2]._inst_JJ_3I_3I_3I((_3[_11] - _8[2]),((_4 + _11) - _1),_5,_6,_7)
   else:
    _12=4
    _13=_8[int((_0).shape[0])]
    _14=0
    _15=int((_0).shape[0])
    _14,_15 = fragments._c_closure_0(_14,_15) # src/fusion/Model.mbi:3307:45-79
    _14 = numpy.int32(_14) # postprocess
    _15 = numpy.int32(_15) # postprocess
    if (False and (((_2 - _1) + _13) < ((_12 * (_2 - _1)) * _14))):
     _16=numpy.zeros(((_13 + 1),), dtype=numpy.dtype(numpy.int32))
     for _17 in range(_1,_2):
      _16[_3[_17]] += 1
     fragments._c_closure_1(_16,_13) # src/fusion/Model.mbi:3312:13-61
     _18=numpy.zeros(((_2 - _1),), dtype=numpy.dtype(numpy.int64))
     for _19 in range(_1,_2):
      _18[(_16[_3[_19]] - _1)] = _19
      _16[_3[_19]] += 1
     _20=0
     _21=0
     while ((_21 < int((_18).shape[0])) and (_20 < int((_0).shape[0]))):
      if (_8[(_20 + 1)] < _3[_18[_21]]):
       _20 += 1
      else:
       _0[_20]._inst_JJ_3I_3I_3I((_3[_18[_21]] - _8[_20]),((_4 + _18[_21]) - _1),_5,_6,_7)
       _21 += 1
    else:
     for _22 in range(_1,_2):
      _23=(int((_8).shape[0]) // 2)
      _23 = fragments._c_closure_2(_22,_23,_3,_8) # src/fusion/Model.mbi:3335:15-3348:16
      _23 = numpy.int32(_23) # postprocess
      _0[_23]._inst_JJ_3I_3I_3I((_3[_22] - _8[_23]),((_4 + _22) - _1),_5,_6,_7)
  @staticmethod
  def __inst_alt__3Lmosek_4fusion_4Variable_2_3J_3I_3I_3I(_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Model.__inst__3Lmosek_4fusion_4Variable_2_3J_3I_3I_3I(_0,_1,_2,_3,_4)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __inst__3Lmosek_4fusion_4Variable_2_3J_3I_3I_3I(_0,_1,_2,_3,_4):
   mosek.fusion.Model.__inst__3Lmosek_4fusion_4Variable_2II_3JI_3I_3I_3I(_0,0,int((_1).shape[0]),_1,0,_2,_3,_4)
  @staticmethod
  def _match_dispose_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_dispose_(*args):
    if len(args) != 0: return False
    return True
  def _dispose_alt_(self,):
    return self._dispose_()
  def _dispose_(self,):
   for _0 in range(0,self._vars_used):
    self._vars[_0] = None
   self._vars_used = 0
   for _1 in range(0,self.__cons_used):
    self.__cons[_1] = None
   self.__cons_used = 0
   mosek_fusion_BaseModel._dispose_(self)
  def _varname_alt_IS(self,_t__0,_t__1):
    return self._varname_IS(numpy.int32(__0),_1)
  def _varname_IS(self,_0,_1):
   self._task_1var_1name_IS(_0,_1)
  def _nativeVarToStr_alt_ILmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._nativeVarToStr_ILmosek_4fusion_4Utils_4StringBuffer_2(numpy.int32(__0),_1)
  def _nativeVarToStr_ILmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   if ((_0 < 0) or (_0 >= self.__natvarmap_num)):
    raise mosek_fusion_IndexError._ctor_S("Native variable index out of bounds")
   self._vars[self.__natvarmap_Var[_0]]._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(self.__natvarmap_idx[_0],_1)
  def _append_1linearvar_alt_Lmosek_4fusion_4ModelVariable_2JEmosek_4fusion_4RelationKey_2D(self,_t__0,_t__1,_t__2,_t__3):
    return self._append_1linearvar_Lmosek_4fusion_4ModelVariable_2JEmosek_4fusion_4RelationKey_2D(_0,numpy.int64(__1),__2,numpy.float64(__3))
  def _append_1linearvar_Lmosek_4fusion_4ModelVariable_2JEmosek_4fusion_4RelationKey_2D(self,_0,_1,_2,_3):
   _4=self.__task_1alloc_1vars_I(1)
   if (_2==mosek.fusion.RelationKey.EqualsTo):
    self._task_1var_1putboundslice_1fx_II_3D(_4,(_4 + 1),numpy.array([_3], dtype=numpy.dtype(numpy.float64)))
   elif (_2==mosek.fusion.RelationKey.LessThan):
    self._task_1var_1putboundslice_1up_II_3D(_4,(_4 + 1),numpy.array([_3], dtype=numpy.dtype(numpy.float64)))
   elif (_2==mosek.fusion.RelationKey.GreaterThan):
    self._task_1var_1putboundslice_1lo_II_3D(_4,(_4 + 1),numpy.array([_3], dtype=numpy.dtype(numpy.float64)))
   elif (_2==mosek.fusion.RelationKey.IsFree):
    self._task_1var_1putboundslice_1fr_II(_4,(_4 + 1))
   self.__natvarmap_1ensure_I(1)
   self.__natvarmap_idx[_4] = _1
   self.__natvarmap_Var[_4] = self._vars_used
   self.__natvarmap_num = (self.__natvarmap_num + 1)
   return numpy.int32(_4)
  def _append_1rangedvar_alt_Lmosek_4fusion_4ModelVariable_2JDD(self,_t__0,_t__1,_t__2,_t__3):
    return self._append_1rangedvar_Lmosek_4fusion_4ModelVariable_2JDD(_0,numpy.int64(__1),numpy.float64(__2),numpy.float64(__3))
  def _append_1rangedvar_Lmosek_4fusion_4ModelVariable_2JDD(self,_0,_1,_2,_3):
   _4=self.__task_1alloc_1vars_I(1)
   self._task_1var_1putboundslice_1ra_II_3D_3D(_4,(_4 + 1),numpy.array([_2], dtype=numpy.dtype(numpy.float64)),numpy.array([_3], dtype=numpy.dtype(numpy.float64)))
   self.__natvarmap_1ensure_I(1)
   self.__natvarmap_idx[_4] = _1
   self.__natvarmap_Var[_4] = self._vars_used
   self.__natvarmap_num = (self.__natvarmap_num + 1)
   return numpy.int32(_4)
  @staticmethod
  def _match_getTask_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getTask_(*args):
    if len(args) != 0: return False
    return True
  def _getTask_alt_(self,):
    return self._getTask_()
  def _getTask_(self,):
   return (self._task_1get_())
  @staticmethod
  def _match_flushNames_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_flushNames_(*args):
    if len(args) != 0: return False
    return True
  def _flushNames_alt_(self,):
    return self._flushNames_()
  def _flushNames_(self,):
   for _0 in range(0,self._vars_used):
    self._vars[_0]._flushNames_()
   for _1 in range(0,self.__cons_used):
    self.__cons[_1]._flushNames_()
  @staticmethod
  def _match_writeTask_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_S__(_0))
  @staticmethod
  def _match_alt_writeTask_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_S__(_0))
  def _writeTask_alt_S(self,_t__0):
    return self._writeTask_S(_0)
  def _writeTask_S(self,_0):
   self._flushNames_()
   self._task_1setnumvar_I(self.__task_vars_used)
   self.__task_vars_allocated = self.__task_vars_used
   self._task_1write_S(_0)
  @staticmethod
  def _match_getSolverLIntInfo_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_S__(_0))
  @staticmethod
  def _match_alt_getSolverLIntInfo_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_S__(_0))
  def _getSolverLIntInfo_alt_S(self,_t__0):
    return self._getSolverLIntInfo_S(_0)
  def _getSolverLIntInfo_S(self,_0):
   return numpy.int64(self._task_1get_1liinf_S(_0))
  @staticmethod
  def _match_getSolverIntInfo_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_S__(_0))
  @staticmethod
  def _match_alt_getSolverIntInfo_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_S__(_0))
  def _getSolverIntInfo_alt_S(self,_t__0):
    return self._getSolverIntInfo_S(_0)
  def _getSolverIntInfo_S(self,_0):
   return numpy.int32(self._task_1get_1iinf_S(_0))
  @staticmethod
  def _match_getSolverDoubleInfo_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_S__(_0))
  @staticmethod
  def _match_alt_getSolverDoubleInfo_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_S__(_0))
  def _getSolverDoubleInfo_alt_S(self,_t__0):
    return self._getSolverDoubleInfo_S(_0)
  def _getSolverDoubleInfo_S(self,_0):
   return numpy.float64(self._task_1get_1dinf_S(_0))
  @staticmethod
  def _match_setCallbackHandler_LSystem_4CallbackHandler_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_LSystem_4CallbackHandler_2__(_0))
  @staticmethod
  def _match_alt_setCallbackHandler_LSystem_4CallbackHandler_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_LSystem_4CallbackHandler_2__(_0))
  def _setCallbackHandler_alt_LSystem_4CallbackHandler_2(self,_t__0):
    return self._setCallbackHandler_LSystem_4CallbackHandler_2(_0)
  def _setCallbackHandler_LSystem_4CallbackHandler_2(self,_0):
   self._task_1setCallbackHandler_LSystem_4CallbackHandler_2(_0)
  @staticmethod
  def _match_setDataCallbackHandler_LSystem_4DataCallbackHandler_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_LSystem_4DataCallbackHandler_2__(_0))
  @staticmethod
  def _match_alt_setDataCallbackHandler_LSystem_4DataCallbackHandler_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_LSystem_4DataCallbackHandler_2__(_0))
  def _setDataCallbackHandler_alt_LSystem_4DataCallbackHandler_2(self,_t__0):
    return self._setDataCallbackHandler_LSystem_4DataCallbackHandler_2(_0)
  def _setDataCallbackHandler_LSystem_4DataCallbackHandler_2(self,_0):
   self._task_1setDataCallbackHandler_LSystem_4DataCallbackHandler_2(_0)
  @staticmethod
  def _match_setLogHandler_LSystem_4StreamWriter_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_LSystem_4StreamWriter_2__(_0))
  @staticmethod
  def _match_alt_setLogHandler_LSystem_4StreamWriter_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_LSystem_4StreamWriter_2__(_0))
  def _setLogHandler_alt_LSystem_4StreamWriter_2(self,_t__0):
    return self._setLogHandler_LSystem_4StreamWriter_2(_0)
  def _setLogHandler_LSystem_4StreamWriter_2(self,_0):
   self._task_1setLogHandler_LSystem_4StreamWriter_2(_0)
  @staticmethod
  def _match_setSolverParam_SD(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_setSolverParam_SD(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_D__(_1))
  def _setSolverParam_alt_SD(self,_t__0,_t__1):
    return self._setSolverParam_SD(_0,numpy.float64(__1))
  def _setSolverParam_SD(self,_0,_1):
   mosek.fusion.Parameters._setParameter_Lmosek_4fusion_4Model_2SD(self,_0,_1)
  @staticmethod
  def _match_setSolverParam_SI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_setSolverParam_SI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_I__(_1))
  def _setSolverParam_alt_SI(self,_t__0,_t__1):
    return self._setSolverParam_SI(_0,numpy.int32(__1))
  def _setSolverParam_SI(self,_0,_1):
   mosek.fusion.Parameters._setParameter_Lmosek_4fusion_4Model_2SI(self,_0,_1)
  @staticmethod
  def _match_setSolverParam_SS(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match_S__(_1))
  @staticmethod
  def _match_alt_setSolverParam_SS(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_S__(_1))
  def _setSolverParam_alt_SS(self,_t__0,_t__1):
    return self._setSolverParam_SS(_0,_1)
  def _setSolverParam_SS(self,_0,_1):
   mosek.fusion.Parameters._setParameter_Lmosek_4fusion_4Model_2SS(self,_0,_1)
  @staticmethod
  def _match_breakSolver_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_breakSolver_(*args):
    if len(args) != 0: return False
    return True
  def _breakSolver_alt_(self,):
    return self._breakSolver_()
  def _breakSolver_(self,):
   self._task_1break_1solve_()
  @staticmethod
  def _match_solve_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_solve_(*args):
    if len(args) != 0: return False
    return True
  def _solve_alt_(self,):
    return self._solve_()
  def _solve_(self,):
   self._task_1setnumvar_I(self.__task_vars_used)
   self.__task_vars_allocated = self.__task_vars_used
   self.__flush_1initsol_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Interior)
   self.__flush_1initsol_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Integer)
   self.__flush_1initsol_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Basic)
   self._task_1solve_()
  @staticmethod
  def _match_flushSolutions_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_flushSolutions_(*args):
    if len(args) != 0: return False
    return True
  def _flushSolutions_alt_(self,):
    return self._flushSolutions_()
  def _flushSolutions_(self,):
   self.__flush_1initsol_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Interior)
   self.__flush_1initsol_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Integer)
   self.__flush_1initsol_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Basic)
  def __flush_1initsol_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self.__flush_1initsol_Emosek_4fusion_4SolutionType_2(__0)
  def __flush_1initsol_Emosek_4fusion_4SolutionType_2(self,_0):
   if (self.__initsol_xx is not None):
    try:
     _1=self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_0,True)
     if ((_1.xx) is not None):
      for _2 in range(0,int((self.__initsol_xx).shape[0])):
       if (not self.__initsol_xx_flag[_2]):
        self.__initsol_xx[_2] = (_1.xx)[_2]
     else:
      fragments._c_closure_3(self.__initsol_xx,self.__initsol_xx_flag) # src/fusion/Model.mbi:2900:13-2904:14
    except mosek_fusion_SolutionError, _3:
     fragments._c_closure_4(self.__initsol_xx,self.__initsol_xx_flag) # src/fusion/Model.mbi:2907:11-2911:12
    self._task_1putxx_1slice_Emosek_4fusion_4SolutionType_2II_3D(_0,0,int((self.__initsol_xx).shape[0]),self.__initsol_xx)
  @staticmethod
  def _match_getDualSolutionStatus_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getDualSolutionStatus_(*args):
    if len(args) != 0: return False
    return True
  def _getDualSolutionStatus_alt_(self,):
    return self._getDualSolutionStatus_()
  def _getDualSolutionStatus_(self,):
   _0=None
   if (self.__solutionptr==mosek.fusion.SolutionType.Default):
    if (self._sol_itg is not None):
     _0 = self._sol_itg
    elif (self._sol_bas is not None):
     _0 = self._sol_bas
    else:
     _0 = self._sol_itr
   elif (self.__solutionptr==mosek.fusion.SolutionType.Interior):
    _0 = self._sol_itr
   elif (self.__solutionptr==mosek.fusion.SolutionType.Basic):
    _0 = self._sol_bas
   elif (self.__solutionptr==mosek.fusion.SolutionType.Integer):
    _0 = self._sol_itg
   if (_0 is None):
    return (mosek.fusion.SolutionStatus.Undefined)
   elif (not self._synched):
    return (mosek.fusion.SolutionStatus.Unknown)
   else:
    return ((_0.dstatus))
  @staticmethod
  def _match_getPrimalSolutionStatus_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getPrimalSolutionStatus_(*args):
    if len(args) != 0: return False
    return True
  def _getPrimalSolutionStatus_alt_(self,):
    return self._getPrimalSolutionStatus_()
  def _getPrimalSolutionStatus_(self,):
   _0=None
   if (self.__solutionptr==mosek.fusion.SolutionType.Default):
    if (self._sol_itg is not None):
     _0 = self._sol_itg
    elif (self._sol_bas is not None):
     _0 = self._sol_bas
    else:
     _0 = self._sol_itr
   elif (self.__solutionptr==mosek.fusion.SolutionType.Basic):
    _0 = self._sol_bas
   elif (self.__solutionptr==mosek.fusion.SolutionType.Integer):
    _0 = self._sol_itg
   else:
    _0 = self._sol_itr
   if (_0 is None):
    return (mosek.fusion.SolutionStatus.Undefined)
   elif (not self._synched):
    return (mosek.fusion.SolutionStatus.Unknown)
   else:
    return ((_0.pstatus))
  @staticmethod
  def _match_dualObjValue_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_dualObjValue_(*args):
    if len(args) != 0: return False
    return True
  def _dualObjValue_alt_(self,):
    return self._dualObjValue_()
  def _dualObjValue_(self,):
   return numpy.float64((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(mosek.fusion.SolutionType.Default,False).dobj))
  @staticmethod
  def _match_primalObjValue_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_primalObjValue_(*args):
    if len(args) != 0: return False
    return True
  def _primalObjValue_alt_(self,):
    return self._primalObjValue_()
  def _primalObjValue_(self,):
   return numpy.float64((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(mosek.fusion.SolutionType.Default,True).pobj))
  def _get_1sol_1cache_alt_Emosek_4fusion_4SolutionType_2ZZ(self,_t__0,_t__1,_t__2):
    return self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2ZZ(__0,_1,_2)
  def _get_1sol_1cache_Emosek_4fusion_4SolutionType_2ZZ(self,_0,_1,_2):
   _3=None
   _4=_0
   if (_4==mosek.fusion.SolutionType.Default):
    _4 = self.__solutionptr
   if (_4==mosek.fusion.SolutionType.Default):
    if (self._sol_itg is not None):
     _3 = self._sol_itg
    elif (self._sol_bas is not None):
     _3 = self._sol_bas
    else:
     _3 = self._sol_itr
   elif (_4==mosek.fusion.SolutionType.Interior):
    _3 = self._sol_itr
   elif (_4==mosek.fusion.SolutionType.Basic):
    _3 = self._sol_bas
   elif (_4==mosek.fusion.SolutionType.Integer):
    _3 = self._sol_itg
   if (_3 is None):
    raise mosek_fusion_SolutionError._ctor_S("Solution not available")
   else:
    if (_2 or ((_1 and _3._isPrimalAcceptable_Emosek_4fusion_4AccSolutionStatus_2(self.__acceptable_sol)) or ((not _1) and _3._isDualAcceptable_Emosek_4fusion_4AccSolutionStatus_2(self.__acceptable_sol)))):
     return (_3)
    else:
     _5=mosek.fusion.Utils.StringBuffer()
     _6=(_3.pstatus)
     if (not _1):
      _6 = (_3.dstatus)
     _5._a_S("Solution status is ")
     if (_6==mosek.fusion.SolutionStatus.Undefined):
      _5._a_S("Undefined")
     elif (_6==mosek.fusion.SolutionStatus.Unknown):
      _5._a_S("Unknown")
     elif (_6==mosek.fusion.SolutionStatus.Optimal):
      _5._a_S("Optimal")
     elif (_6==mosek.fusion.SolutionStatus.NearOptimal):
      _5._a_S("NearOptimal")
     elif (_6==mosek.fusion.SolutionStatus.Feasible):
      _5._a_S("Feasible")
     elif (_6==mosek.fusion.SolutionStatus.NearFeasible):
      _5._a_S("NearFeasible")
     elif (_6==mosek.fusion.SolutionStatus.Certificate):
      _5._a_S("Certificate")
     elif (_6==mosek.fusion.SolutionStatus.NearCertificate):
      _5._a_S("NearCertificate")
     elif (_6==mosek.fusion.SolutionStatus.IllposedCert):
      _5._a_S("IllposedCert")
     _5._a_S(" but at least ")
     if (self.__acceptable_sol==mosek.fusion.AccSolutionStatus.Anything):
      _5._a_S("Anything")
     elif (self.__acceptable_sol==mosek.fusion.AccSolutionStatus.Optimal):
      _5._a_S("Optimal")
     elif (self.__acceptable_sol==mosek.fusion.AccSolutionStatus.NearOptimal):
      _5._a_S("NearOptimal")
     elif (self.__acceptable_sol==mosek.fusion.AccSolutionStatus.Feasible):
      _5._a_S("Feasible")
     elif (self.__acceptable_sol==mosek.fusion.AccSolutionStatus.Certificate):
      _5._a_S("Certificate")
     _5._a_S(" is expected")
     raise mosek_fusion_SolutionError._ctor_S(_5._toString_())
  def _get_1sol_1cache_alt_Emosek_4fusion_4SolutionType_2Z(self,_t__0,_t__1):
    return self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(__0,_1)
  def _get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(self,_0,_1):
   return (self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2ZZ(_0,_1,False))
  def _setSolution_1xx_alt__3I_3D(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = self._setSolution_1xx__3I_3D(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _setSolution_1xx__3I_3D(self,_0,_1):
   self._ensure_1initsol_1xx_()
   fragments._c_closure_5(self.__initsol_xx,self.__initsol_xx_flag,_0,_1) # src/fusion/Model.mbi:2744:9-2748:10
  def _ensure_1initsol_1xx_alt_(self,):
    return self._ensure_1initsol_1xx_()
  def _ensure_1initsol_1xx_(self,):
   if (self.__initsol_xx is None):
    self.__initsol_xx = numpy.zeros((self.__natvarmap_num,), dtype=numpy.dtype(numpy.float64))
    self.__initsol_xx_flag = numpy.array([False for _0 in range(0,self.__natvarmap_num)], dtype=numpy.dtype(numpy.bool))
   elif (int((self.__initsol_xx).shape[0]) < self.__natvarmap_num):
    _1=self.__initsol_xx
    _2=self.__initsol_xx_flag
    self.__initsol_xx = numpy.zeros((self.__natvarmap_num,), dtype=numpy.dtype(numpy.float64))
    self.__initsol_xx_flag = numpy.zeros((self.__natvarmap_num,), dtype=numpy.dtype(numpy.bool))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(_1,0,self.__initsol_xx,0,int((_1).shape[0]))
    fragments._c_closure_6(self.__initsol_xx_flag,_1,_2) # src/fusion/Model.mbi:2737:11-70
  def _getSolution_1bars_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getSolution_1bars_Emosek_4fusion_4SolutionType_2(__0)
  def _getSolution_1bars_Emosek_4fusion_4SolutionType_2(self,_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_0,False).bars))
  def _getSolution_1barx_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getSolution_1barx_Emosek_4fusion_4SolutionType_2(__0)
  def _getSolution_1barx_Emosek_4fusion_4SolutionType_2(self,_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_0,False).barx))
  def _getSolution_1y_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getSolution_1y_Emosek_4fusion_4SolutionType_2(__0)
  def _getSolution_1y_Emosek_4fusion_4SolutionType_2(self,_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_0,False).y))
  def _getSolution_1xc_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getSolution_1xc_Emosek_4fusion_4SolutionType_2(__0)
  def _getSolution_1xc_Emosek_4fusion_4SolutionType_2(self,_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_0,True).xc))
  def _getSolution_1snx_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getSolution_1snx_Emosek_4fusion_4SolutionType_2(__0)
  def _getSolution_1snx_Emosek_4fusion_4SolutionType_2(self,_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_0,False).snx))
  def _getSolution_1suc_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getSolution_1suc_Emosek_4fusion_4SolutionType_2(__0)
  def _getSolution_1suc_Emosek_4fusion_4SolutionType_2(self,_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_0,False).suc))
  def _getSolution_1slc_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getSolution_1slc_Emosek_4fusion_4SolutionType_2(__0)
  def _getSolution_1slc_Emosek_4fusion_4SolutionType_2(self,_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_0,False).slc))
  def _getSolution_1sux_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getSolution_1sux_Emosek_4fusion_4SolutionType_2(__0)
  def _getSolution_1sux_Emosek_4fusion_4SolutionType_2(self,_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_0,False).sux))
  def _getSolution_1slx_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getSolution_1slx_Emosek_4fusion_4SolutionType_2(__0)
  def _getSolution_1slx_Emosek_4fusion_4SolutionType_2(self,_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_0,False).slx))
  def _getSolution_1xx_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getSolution_1xx_Emosek_4fusion_4SolutionType_2(__0)
  def _getSolution_1xx_Emosek_4fusion_4SolutionType_2(self,_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_0,True).xx))
  @staticmethod
  def _match_selectedSolution_Emosek_4fusion_4SolutionType_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Emosek_4fusion_4SolutionType_2__(_0))
  @staticmethod
  def _match_alt_selectedSolution_Emosek_4fusion_4SolutionType_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Emosek_4fusion_4SolutionType_2__(_0))
  def _selectedSolution_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._selectedSolution_Emosek_4fusion_4SolutionType_2(__0)
  def _selectedSolution_Emosek_4fusion_4SolutionType_2(self,_0):
   self.__solutionptr = _0
  @staticmethod
  def _match_getAcceptedSolutionStatus_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getAcceptedSolutionStatus_(*args):
    if len(args) != 0: return False
    return True
  def _getAcceptedSolutionStatus_alt_(self,):
    return self._getAcceptedSolutionStatus_()
  def _getAcceptedSolutionStatus_(self,):
   return (self.__acceptable_sol)
  @staticmethod
  def _match_acceptedSolutionStatus_Emosek_4fusion_4AccSolutionStatus_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Emosek_4fusion_4AccSolutionStatus_2__(_0))
  @staticmethod
  def _match_alt_acceptedSolutionStatus_Emosek_4fusion_4AccSolutionStatus_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Emosek_4fusion_4AccSolutionStatus_2__(_0))
  def _acceptedSolutionStatus_alt_Emosek_4fusion_4AccSolutionStatus_2(self,_t__0):
    return self._acceptedSolutionStatus_Emosek_4fusion_4AccSolutionStatus_2(__0)
  def _acceptedSolutionStatus_Emosek_4fusion_4AccSolutionStatus_2(self,_0):
   self.__acceptable_sol = _0
  @staticmethod
  def _match_getProblemStatus_Emosek_4fusion_4SolutionType_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Emosek_4fusion_4SolutionType_2__(_0))
  @staticmethod
  def _match_alt_getProblemStatus_Emosek_4fusion_4SolutionType_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Emosek_4fusion_4SolutionType_2__(_0))
  def _getProblemStatus_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getProblemStatus_Emosek_4fusion_4SolutionType_2(__0)
  def _getProblemStatus_Emosek_4fusion_4SolutionType_2(self,_0):
   _1=None
   if (_0==mosek.fusion.SolutionType.Default):
    if (self._sol_itg is not None):
     _1 = self._sol_itg
    elif (self._sol_bas is not None):
     _1 = self._sol_bas
    else:
     _1 = self._sol_itr
   elif (_0==mosek.fusion.SolutionType.Interior):
    _1 = self._sol_itr
   elif (_0==mosek.fusion.SolutionType.Basic):
    _1 = self._sol_bas
   elif (_0==mosek.fusion.SolutionType.Integer):
    _1 = self._sol_itg
   if (_1 is None):
    return (mosek.fusion.ProblemStatus.Unknown)
   else:
    return ((_1.probstatus))
  @staticmethod
  def _match_getDualSolutionStatus_Emosek_4fusion_4SolutionType_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Emosek_4fusion_4SolutionType_2__(_0))
  @staticmethod
  def _match_alt_getDualSolutionStatus_Emosek_4fusion_4SolutionType_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Emosek_4fusion_4SolutionType_2__(_0))
  def _getDualSolutionStatus_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getDualSolutionStatus_Emosek_4fusion_4SolutionType_2(__0)
  def _getDualSolutionStatus_Emosek_4fusion_4SolutionType_2(self,_0):
   return (self._getSolutionStatus_Emosek_4fusion_4SolutionType_2Z(_0,False))
  @staticmethod
  def _match_getPrimalSolutionStatus_Emosek_4fusion_4SolutionType_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Emosek_4fusion_4SolutionType_2__(_0))
  @staticmethod
  def _match_alt_getPrimalSolutionStatus_Emosek_4fusion_4SolutionType_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Emosek_4fusion_4SolutionType_2__(_0))
  def _getPrimalSolutionStatus_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getPrimalSolutionStatus_Emosek_4fusion_4SolutionType_2(__0)
  def _getPrimalSolutionStatus_Emosek_4fusion_4SolutionType_2(self,_0):
   return (self._getSolutionStatus_Emosek_4fusion_4SolutionType_2Z(_0,True))
  def _getSolutionStatus_alt_Emosek_4fusion_4SolutionType_2Z(self,_t__0,_t__1):
    return self._getSolutionStatus_Emosek_4fusion_4SolutionType_2Z(__0,_1)
  def _getSolutionStatus_Emosek_4fusion_4SolutionType_2Z(self,_0,_1):
   try:
    _2=self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2ZZ(_0,_1,True)
    if _1:
     return ((_2.pstatus))
    else:
     return ((_2.dstatus))
   except mosek_fusion_SolutionError, _3:
    return (mosek.fusion.SolutionStatus.Undefined)
  def __objective_1_alt_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(self,_t__0,_t__1,_t__2):
    return self.__objective_1_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(_0,__1,_2)
  def __objective_1_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(self,_0,_1,_2):
   self._task_1putobjectivename_S(_0)
   if ((_2._getShape_()._size)!=1):
    raise mosek_fusion_LengthError._ctor_S("Objective expression must be of size 1.")
   if ((_1!=mosek.fusion.ObjectiveSense.Minimize) and (_1!=mosek.fusion.ObjectiveSense.Maximize)):
    raise mosek_fusion_LengthError._ctor_S("Objective sense required.")
   _3=_2._eval_()
   for _4 in range(0,int(((_3.x)).shape[0])):
    if (((_3.x)[_4]._getModel_() is not None) and ((_3.x)[_4]._getModel_() is not self)):
     raise mosek_fusion_ModelError._ctor_S("Expression belong to different models")
   _5=None
   _6=None
   _7=0
   _8=0
   _9=None
   _10=None
   _11=None
   _12=int(((_3.subj)).shape[0])
   _9 = numpy.zeros((_12,), dtype=numpy.dtype(numpy.int32))
   _10 = numpy.zeros((_12,), dtype=numpy.dtype(numpy.int32))
   _11 = numpy.zeros((_12,), dtype=numpy.dtype(numpy.int32))
   mosek.fusion.Model.__inst__3Lmosek_4fusion_4Variable_2_3J_3I_3I_3I((_3.x),(_3.subj),_9,_10,_11)
   _8 = 0
   _8 = fragments._c_closure_7(_12,_8,_9) # src/fusion/Model.mbi:2439:11-2440:56
   _8 = numpy.int32(_8) # postprocess
   _7 = (_12 - _8)
   if (_8 > 0):
    _5 = numpy.zeros((_8,), dtype=numpy.dtype(numpy.int32))
   if (_7==0):
    _5 = _9
    _6 = (_3.cof)
   else:
    _13=0
    _6 = numpy.zeros((_8,), dtype=numpy.dtype(numpy.float64))
    _5 = numpy.zeros((_8,), dtype=numpy.dtype(numpy.int32))
    _14=(_3.ptrb)[0]
    while (_14 < (_3.ptrb)[1]):
     if (_9[_14] >= 0):
      _5[_13] = _9[_14]
      _6[_13] = (_3.cof)[_14]
      _13 += 1
     _14 += 1
   _15=0.0
   if ((_3.bfix) is not None):
    _15 = (_3.bfix)[0]
   self._task_1putobjective_Z_3I_3DD((_1==mosek.fusion.ObjectiveSense.Maximize),_5,_6,_15)
   if (_7 > 0):
    _16=0
    _17=(_3.ptrb)[0]
    while (_17 < (_3.ptrb)[1]):
     if (_9[_17] < 0):
      _16 += 1
     _17 += 1
    if (_16 > 0):
     _18=numpy.zeros((_16,), dtype=numpy.dtype(numpy.int64))
     _19=(_3.ptrb)
     fragments._c_closure_8(_18,_19,_9) # src/fusion/Model.mbi:2491:13-2501:14
     mosek.fusion.Sort._argsort__3J_3IJJ(_18,_9,0,_16)
     _20=0
     while (_20 < _16):
      _21=_20
      _20 += 1
      _20 = fragments._c_closure_9(_18,_20,_16,_9) # src/fusion/Model.mbi:2511:17-124
      _20 = numpy.int32(_20) # postprocess
      _22=(_20 - _21)
      mosek.fusion.Sort._argsort__3J_3I_3IJJ(_18,_10,_11,numpy.int64(_21),numpy.int64(_20))
      _23=1
      _23 = fragments._c_closure_10(_18,_21,_20,_23,_10,_11) # src/fusion/Model.mbi:2524:17-2531:18
      _23 = numpy.int32(_23) # postprocess
      _24=0
      _25=numpy.zeros((_23,), dtype=numpy.dtype(numpy.int32))
      _26=numpy.zeros((_23,), dtype=numpy.dtype(numpy.int32))
      _27=numpy.zeros((_23,), dtype=numpy.dtype(numpy.float64))
      _25[0] = _10[_18[_21]]
      _26[0] = _11[_18[_21]]
      if (_25[0]==_26[0]):
       _27[0] = (_3.cof)[_18[_21]]
      else:
       _27[0] = (0.5 * (_3.cof)[_18[_21]])
      for _28 in range((_21 + 1),_20):
       _29=_18[_28]
       _30=_18[(_28 - 1)]
       if ((_10[_29]!=_10[_30]) or (_11[_29]!=_11[_30])):
        _24 += 1
        _25[_24] = _10[_29]
        _26[_24] = _11[_29]
       if (_25[_24]==_26[_24]):
        _27[_24] = (_27[_24] + (_3.cof)[_29])
       else:
        _27[_24] = (_27[_24] + (0.5 * (_3.cof)[_29]))
      _31=(- (_9[_18[_21]] + 1))
      _32=self._task_1barvardim_I(_31)
      _33=self._task_1append_1barmatrix_I_3I_3I_3D(_32,_25,_26,_27)
      self._task_1putbarcj_II(_31,_33)
  @staticmethod
  def _match_objective_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_D__(_0))
  @staticmethod
  def _match_alt_objective_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_D__(_0))
  def _objective_alt_D(self,_t__0):
    return self._objective_D(numpy.float64(__0))
  def _objective_D(self,_0):
   self.__objective_1_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2("",mosek.fusion.ObjectiveSense.Minimize,mosek.fusion.Expr._constTerm_D(_0))
  @staticmethod
  def _match_objective_Emosek_4fusion_4ObjectiveSense_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Emosek_4fusion_4ObjectiveSense_2__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_objective_Emosek_4fusion_4ObjectiveSense_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Emosek_4fusion_4ObjectiveSense_2__(_0) and __arg_alt_match_D__(_1))
  def _objective_alt_Emosek_4fusion_4ObjectiveSense_2D(self,_t__0,_t__1):
    return self._objective_Emosek_4fusion_4ObjectiveSense_2D(__0,numpy.float64(__1))
  def _objective_Emosek_4fusion_4ObjectiveSense_2D(self,_0,_1):
   self.__objective_1_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2("",_0,mosek.fusion.Expr._constTerm_D(_1))
  @staticmethod
  def _match_objective_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Emosek_4fusion_4ObjectiveSense_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_objective_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Emosek_4fusion_4ObjectiveSense_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  def _objective_alt_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Variable_2(self,_t__0,_t__1):
    return self._objective_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Variable_2(__0,_1)
  def _objective_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Variable_2(self,_0,_1):
   self.__objective_1_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2("",_0,_1._asExpr_())
  @staticmethod
  def _match_objective_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Emosek_4fusion_4ObjectiveSense_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_objective_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Emosek_4fusion_4ObjectiveSense_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  def _objective_alt_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(self,_t__0,_t__1):
    return self._objective_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(__0,_1)
  def _objective_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(self,_0,_1):
   self.__objective_1_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2("",_0,_1)
  @staticmethod
  def _match_objective_SD(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_objective_SD(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_D__(_1))
  def _objective_alt_SD(self,_t__0,_t__1):
    return self._objective_SD(_0,numpy.float64(__1))
  def _objective_SD(self,_0,_1):
   self.__objective_1_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(_0,mosek.fusion.ObjectiveSense.Minimize,mosek.fusion.Expr._constTerm_D(_1))
  @staticmethod
  def _match_objective_SEmosek_4fusion_4ObjectiveSense_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_Emosek_4fusion_4ObjectiveSense_2__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_objective_SEmosek_4fusion_4ObjectiveSense_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Emosek_4fusion_4ObjectiveSense_2__(_1) and __arg_alt_match_D__(_2))
  def _objective_alt_SEmosek_4fusion_4ObjectiveSense_2D(self,_t__0,_t__1,_t__2):
    return self._objective_SEmosek_4fusion_4ObjectiveSense_2D(_0,__1,numpy.float64(__2))
  def _objective_SEmosek_4fusion_4ObjectiveSense_2D(self,_0,_1,_2):
   self.__objective_1_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(_0,_1,mosek.fusion.Expr._constTerm_D(_2))
  @staticmethod
  def _match_objective_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_Emosek_4fusion_4ObjectiveSense_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _match_alt_objective_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Emosek_4fusion_4ObjectiveSense_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2))
  def _objective_alt_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Variable_2(self,_t__0,_t__1,_t__2):
    return self._objective_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Variable_2(_0,__1,_2)
  def _objective_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Variable_2(self,_0,_1,_2):
   self.__objective_1_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(_0,_1,_2._asExpr_())
  @staticmethod
  def _match_objective_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_Emosek_4fusion_4ObjectiveSense_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_objective_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Emosek_4fusion_4ObjectiveSense_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  def _objective_alt_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(self,_t__0,_t__1,_t__2):
    return self._objective_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(_0,__1,_2)
  def _objective_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(self,_0,_1,_2):
   self.__objective_1_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(_0,_1,_2)
  @staticmethod
  def _match_constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4QConeDomain_2__(_1))
  @staticmethod
  def _match_alt_constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4QConeDomain_2__(_1))
  def _constraint_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(self,_t__0,_t__1):
    return self._constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(_0,_1)
  def _constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(self,_0,_1):
   return (self.__constraint_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2("",None,_0._asExpr_(),_1))
  @staticmethod
  def _match_constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4QConeDomain_2__(_2))
  @staticmethod
  def _match_alt_constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4QConeDomain_2__(_2))
  def _constraint_alt_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(self,_t__0,_t__1,_t__2):
    return self._constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(_0,_1,_2)
  def _constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(self,_0,_1,_2):
   return (self.__constraint_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(_0,None,_1._asExpr_(),_2))
  @staticmethod
  def _match_constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Set_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4QConeDomain_2__(_2))
  @staticmethod
  def _match_alt_constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Set_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4QConeDomain_2__(_2))
  def _constraint_alt_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(self,_t__0,_t__1,_t__2):
    return self._constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(_0,_1,_2)
  def _constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(self,_0,_1,_2):
   return (self.__constraint_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2("",_0,_1._asExpr_(),_2))
  @staticmethod
  def _match_constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4Set_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2) and __arg_match_Lmosek_4fusion_4QConeDomain_2__(_3))
  @staticmethod
  def _match_alt_constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4Set_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2) and __arg_alt_match_Lmosek_4fusion_4QConeDomain_2__(_3))
  def _constraint_alt_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(self,_t__0,_t__1,_t__2,_t__3):
    return self._constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(_0,_1,_2,_3)
  def _constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(self,_0,_1,_2,_3):
   return (self.__constraint_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(_0,_1,_2._asExpr_(),_3))
  @staticmethod
  def _match_constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(_1))
  @staticmethod
  def _match_alt_constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_1))
  def _constraint_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(self,_t__0,_t__1):
    return self._constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(_0,_1)
  def _constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(self,_0,_1):
   return (self.__constraint_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2("",None,_0._asExpr_(),_1))
  @staticmethod
  def _match_constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(_2))
  @staticmethod
  def _match_alt_constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_2))
  def _constraint_alt_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(self,_t__0,_t__1,_t__2):
    return self._constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(_0,_1,_2)
  def _constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(self,_0,_1,_2):
   return (self.__constraint_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(_0,None,_1._asExpr_(),_2))
  @staticmethod
  def _match_constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Set_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(_2))
  @staticmethod
  def _match_alt_constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Set_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_2))
  def _constraint_alt_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(self,_t__0,_t__1,_t__2):
    return self._constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(_0,_1,_2)
  def _constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(self,_0,_1,_2):
   return (self.__constraint_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2("",_0,_1._asExpr_(),_2))
  @staticmethod
  def _match_constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4Set_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(_3))
  @staticmethod
  def _match_alt_constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4Set_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_3))
  def _constraint_alt_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(self,_t__0,_t__1,_t__2,_t__3):
    return self._constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(_0,_1,_2,_3)
  def _constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(self,_0,_1,_2,_3):
   return (self.__constraint_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(_0,_1,_2._asExpr_(),_3))
  @staticmethod
  def _match_constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(_1))
  @staticmethod
  def _match_alt_constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_1))
  def _constraint_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(self,_t__0,_t__1):
    return self._constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(_0,_1)
  def _constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(self,_0,_1):
   return (self.__constraint_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2("",None,_0._asExpr_(),_1))
  @staticmethod
  def _match_constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(_2))
  @staticmethod
  def _match_alt_constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_2))
  def _constraint_alt_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(self,_t__0,_t__1,_t__2):
    return self._constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(_0,_1,_2)
  def _constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(self,_0,_1,_2):
   return (self.__constraint_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(_0,None,_1._asExpr_(),_2))
  @staticmethod
  def _match_constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Set_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(_2))
  @staticmethod
  def _match_alt_constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Set_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_2))
  def _constraint_alt_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(self,_t__0,_t__1,_t__2):
    return self._constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(_0,_1,_2)
  def _constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(self,_0,_1,_2):
   return (self.__constraint_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2("",_0,_1._asExpr_(),_2))
  @staticmethod
  def _match_constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4Set_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(_3))
  @staticmethod
  def _match_alt_constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4Set_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_3))
  def _constraint_alt_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(self,_t__0,_t__1,_t__2,_t__3):
    return self._constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(_0,_1,_2,_3)
  def _constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(self,_0,_1,_2,_3):
   return (self.__constraint_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(_0,_1,_2._asExpr_(),_3))
  @staticmethod
  def _match_constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4LinPSDDomain_2__(_1))
  @staticmethod
  def _match_alt_constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4LinPSDDomain_2__(_1))
  def _constraint_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinPSDDomain_2(self,_t__0,_t__1):
    return self._constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinPSDDomain_2(_0,_1)
  def _constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinPSDDomain_2(self,_0,_1):
   return (self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2("",_0._asExpr_(),_1))
  @staticmethod
  def _match_constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4LinPSDDomain_2__(_2))
  @staticmethod
  def _match_alt_constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4LinPSDDomain_2__(_2))
  def _constraint_alt_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4LinPSDDomain_2(self,_t__0,_t__1,_t__2):
    return self._constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4LinPSDDomain_2(_0,_1,_2)
  def _constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4LinPSDDomain_2(self,_0,_1,_2):
   return (self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(_0,_1._asExpr_(),_2))
  @staticmethod
  def _match_constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4PSDDomain_2__(_1))
  @staticmethod
  def _match_alt_constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(_1))
  def _constraint_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4PSDDomain_2(self,_t__0,_t__1):
    return self._constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4PSDDomain_2(_0,_1)
  def _constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4PSDDomain_2(self,_0,_1):
   return (self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2("",_0._asExpr_(),_1))
  @staticmethod
  def _match_constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4PSDDomain_2__(_2))
  @staticmethod
  def _match_alt_constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(_2))
  def _constraint_alt_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4PSDDomain_2(self,_t__0,_t__1,_t__2):
    return self._constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4PSDDomain_2(_0,_1,_2)
  def _constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4PSDDomain_2(self,_0,_1,_2):
   return (self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(_0,_1._asExpr_(),_2))
  @staticmethod
  def _match_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4QConeDomain_2__(_1))
  @staticmethod
  def _match_alt_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4QConeDomain_2__(_1))
  def _constraint_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(self,_t__0,_t__1):
    return self._constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(_0,_1)
  def _constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(self,_0,_1):
   return (self.__constraint_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2("",None,_0,_1))
  @staticmethod
  def _match_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4QConeDomain_2__(_2))
  @staticmethod
  def _match_alt_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4QConeDomain_2__(_2))
  def _constraint_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(self,_t__0,_t__1,_t__2):
    return self._constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(_0,_1,_2)
  def _constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(self,_0,_1,_2):
   return (self.__constraint_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(_0,None,_1,_2))
  @staticmethod
  def _match_constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Set_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4QConeDomain_2__(_2))
  @staticmethod
  def _match_alt_constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Set_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4QConeDomain_2__(_2))
  def _constraint_alt_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(self,_t__0,_t__1,_t__2):
    return self._constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(_0,_1,_2)
  def _constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(self,_0,_1,_2):
   return (self.__constraint_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2("",_0,_1,_2))
  @staticmethod
  def _match_constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4Set_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_match_Lmosek_4fusion_4QConeDomain_2__(_3))
  @staticmethod
  def _match_alt_constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4Set_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_alt_match_Lmosek_4fusion_4QConeDomain_2__(_3))
  def _constraint_alt_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(self,_t__0,_t__1,_t__2,_t__3):
    return self._constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(_0,_1,_2,_3)
  def _constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(self,_0,_1,_2,_3):
   return (self.__constraint_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(_0,_1,_2,_3))
  @staticmethod
  def _match_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(_1))
  @staticmethod
  def _match_alt_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_1))
  def _constraint_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(self,_t__0,_t__1):
    return self._constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(_0,_1)
  def _constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(self,_0,_1):
   return (self.__constraint_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2("",None,_0,_1))
  @staticmethod
  def _match_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(_2))
  @staticmethod
  def _match_alt_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_2))
  def _constraint_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(self,_t__0,_t__1,_t__2):
    return self._constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(_0,_1,_2)
  def _constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(self,_0,_1,_2):
   return (self.__constraint_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(_0,None,_1,_2))
  @staticmethod
  def _match_constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Set_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(_2))
  @staticmethod
  def _match_alt_constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Set_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_2))
  def _constraint_alt_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(self,_t__0,_t__1,_t__2):
    return self._constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(_0,_1,_2)
  def _constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(self,_0,_1,_2):
   return (self.__constraint_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2("",_0,_1,_2))
  @staticmethod
  def _match_constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4Set_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(_3))
  @staticmethod
  def _match_alt_constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4Set_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_3))
  def _constraint_alt_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(self,_t__0,_t__1,_t__2,_t__3):
    return self._constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(_0,_1,_2,_3)
  def _constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(self,_0,_1,_2,_3):
   return (self.__constraint_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(_0,_1,_2,_3))
  @staticmethod
  def _match_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(_1))
  @staticmethod
  def _match_alt_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_1))
  def _constraint_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(self,_t__0,_t__1):
    return self._constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(_0,_1)
  def _constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(self,_0,_1):
   return (self.__constraint_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2("",None,_0,_1))
  @staticmethod
  def _match_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(_2))
  @staticmethod
  def _match_alt_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_2))
  def _constraint_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(self,_t__0,_t__1,_t__2):
    return self._constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(_0,_1,_2)
  def _constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(self,_0,_1,_2):
   return (self.__constraint_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(_0,None,_1,_2))
  @staticmethod
  def _match_constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Set_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(_2))
  @staticmethod
  def _match_alt_constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Set_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_2))
  def _constraint_alt_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(self,_t__0,_t__1,_t__2):
    return self._constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(_0,_1,_2)
  def _constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(self,_0,_1,_2):
   return (self.__constraint_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2("",_0,_1,_2))
  @staticmethod
  def _match_constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4Set_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(_3))
  @staticmethod
  def _match_alt_constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4Set_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_3))
  def _constraint_alt_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(self,_t__0,_t__1,_t__2,_t__3):
    return self._constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(_0,_1,_2,_3)
  def _constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(self,_0,_1,_2,_3):
   return (self.__constraint_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(_0,_1,_2,_3))
  @staticmethod
  def _match_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4LinPSDDomain_2__(_1))
  @staticmethod
  def _match_alt_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4LinPSDDomain_2__(_1))
  def _constraint_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(self,_t__0,_t__1):
    return self._constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(_0,_1)
  def _constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(self,_0,_1):
   return (self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2("",_0,_1))
  @staticmethod
  def _match_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4LinPSDDomain_2__(_2))
  @staticmethod
  def _match_alt_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4LinPSDDomain_2__(_2))
  def _constraint_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(self,_t__0,_t__1,_t__2):
    return self._constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(_0,_1,_2)
  def _constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(self,_0,_1,_2):
   return (self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(_0,_1,_2))
  @staticmethod
  def _match_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4PSDDomain_2__(_1))
  @staticmethod
  def _match_alt_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(_1))
  def _constraint_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(self,_t__0,_t__1):
    return self._constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(_0,_1)
  def _constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(self,_0,_1):
   return (self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2("",_0,_1))
  @staticmethod
  def _match_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4PSDDomain_2__(_2))
  @staticmethod
  def _match_alt_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(_2))
  def _constraint_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(self,_t__0,_t__1,_t__2):
    return self._constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(_0,_1,_2)
  def _constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(self,_0,_1,_2):
   return (self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(_0,_1,_2))
  @staticmethod
  def _match_variable_Lmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4LinPSDDomain_2__(_0))
  @staticmethod
  def _match_alt_variable_Lmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinPSDDomain_2__(_0))
  def _variable_alt_Lmosek_4fusion_4LinPSDDomain_2(self,_t__0):
    return self._variable_Lmosek_4fusion_4LinPSDDomain_2(_0)
  def _variable_Lmosek_4fusion_4LinPSDDomain_2(self,_0):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinPSDDomain_2("",None,_0))
  @staticmethod
  def _match_variable_IILmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match_Lmosek_4fusion_4LinPSDDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_IILmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_Lmosek_4fusion_4LinPSDDomain_2__(_2))
  def _variable_alt_IILmosek_4fusion_4LinPSDDomain_2(self,_t__0,_t__1,_t__2):
    return self._variable_IILmosek_4fusion_4LinPSDDomain_2(numpy.int32(__0),numpy.int32(__1),_2)
  def _variable_IILmosek_4fusion_4LinPSDDomain_2(self,_0,_1,_2):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinPSDDomain_2("",mosek.fusion.Set._make_III(_0,_0,_1),_2))
  @staticmethod
  def _match_variable_ILmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4LinPSDDomain_2__(_1))
  @staticmethod
  def _match_alt_variable_ILmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4LinPSDDomain_2__(_1))
  def _variable_alt_ILmosek_4fusion_4LinPSDDomain_2(self,_t__0,_t__1):
    return self._variable_ILmosek_4fusion_4LinPSDDomain_2(numpy.int32(__0),_1)
  def _variable_ILmosek_4fusion_4LinPSDDomain_2(self,_0,_1):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinPSDDomain_2("",mosek.fusion.Set._make_II(_0,_0),_1))
  @staticmethod
  def _match_variable_SLmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4LinPSDDomain_2__(_1))
  @staticmethod
  def _match_alt_variable_SLmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4LinPSDDomain_2__(_1))
  def _variable_alt_SLmosek_4fusion_4LinPSDDomain_2(self,_t__0,_t__1):
    return self._variable_SLmosek_4fusion_4LinPSDDomain_2(_0,_1)
  def _variable_SLmosek_4fusion_4LinPSDDomain_2(self,_0,_1):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinPSDDomain_2(_0,None,_1))
  @staticmethod
  def _match_variable_SIILmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_S__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2) and __arg_match_Lmosek_4fusion_4LinPSDDomain_2__(_3))
  @staticmethod
  def _match_alt_variable_SIILmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2) and __arg_alt_match_Lmosek_4fusion_4LinPSDDomain_2__(_3))
  def _variable_alt_SIILmosek_4fusion_4LinPSDDomain_2(self,_t__0,_t__1,_t__2,_t__3):
    return self._variable_SIILmosek_4fusion_4LinPSDDomain_2(_0,numpy.int32(__1),numpy.int32(__2),_3)
  def _variable_SIILmosek_4fusion_4LinPSDDomain_2(self,_0,_1,_2,_3):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinPSDDomain_2(_0,mosek.fusion.Set._make_III(_1,_1,_2),_3))
  @staticmethod
  def _match_variable_SILmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_I__(_1) and __arg_match_Lmosek_4fusion_4LinPSDDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_SILmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_Lmosek_4fusion_4LinPSDDomain_2__(_2))
  def _variable_alt_SILmosek_4fusion_4LinPSDDomain_2(self,_t__0,_t__1,_t__2):
    return self._variable_SILmosek_4fusion_4LinPSDDomain_2(_0,numpy.int32(__1),_2)
  def _variable_SILmosek_4fusion_4LinPSDDomain_2(self,_0,_1,_2):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinPSDDomain_2(_0,mosek.fusion.Set._make_II(_1,_1),_2))
  @staticmethod
  def _match_variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4Set_2__(_1) and __arg_match_Lmosek_4fusion_4LinPSDDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4Set_2__(_1) and __arg_alt_match_Lmosek_4fusion_4LinPSDDomain_2__(_2))
  def _variable_alt_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinPSDDomain_2(self,_t__0,_t__1,_t__2):
    return self._variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinPSDDomain_2(_0,_1,_2)
  def _variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinPSDDomain_2(self,_0,_1,_2):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinPSDDomain_2(_0,_1,_2))
  @staticmethod
  def _match_variable_S_3ILmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match__3I__(_1) and __arg_match_Lmosek_4fusion_4LinPSDDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_S_3ILmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match_Lmosek_4fusion_4LinPSDDomain_2__(_2))
  def _variable_alt_S_3ILmosek_4fusion_4LinPSDDomain_2(self,_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=_t__2
   _1 = self._variable_S_3ILmosek_4fusion_4LinPSDDomain_2(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _variable_S_3ILmosek_4fusion_4LinPSDDomain_2(self,_0,_1,_2):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinPSDDomain_2(_0,mosek.fusion.Set._make__3I(_1),_2))
  @staticmethod
  def _match_variable_Lmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4PSDDomain_2__(_0))
  @staticmethod
  def _match_alt_variable_Lmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(_0))
  def _variable_alt_Lmosek_4fusion_4PSDDomain_2(self,_t__0):
    return self._variable_Lmosek_4fusion_4PSDDomain_2(_0)
  def _variable_Lmosek_4fusion_4PSDDomain_2(self,_0):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4PSDDomain_2("",None,_0))
  @staticmethod
  def _match_variable_IILmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match_Lmosek_4fusion_4PSDDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_IILmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(_2))
  def _variable_alt_IILmosek_4fusion_4PSDDomain_2(self,_t__0,_t__1,_t__2):
    return self._variable_IILmosek_4fusion_4PSDDomain_2(numpy.int32(__0),numpy.int32(__1),_2)
  def _variable_IILmosek_4fusion_4PSDDomain_2(self,_0,_1,_2):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4PSDDomain_2("",mosek.fusion.Set._make_III(_0,_0,_1),_2))
  @staticmethod
  def _match_variable_ILmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4PSDDomain_2__(_1))
  @staticmethod
  def _match_alt_variable_ILmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(_1))
  def _variable_alt_ILmosek_4fusion_4PSDDomain_2(self,_t__0,_t__1):
    return self._variable_ILmosek_4fusion_4PSDDomain_2(numpy.int32(__0),_1)
  def _variable_ILmosek_4fusion_4PSDDomain_2(self,_0,_1):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4PSDDomain_2("",mosek.fusion.Set._make_II(_0,_0),_1))
  @staticmethod
  def _match_variable_SLmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4PSDDomain_2__(_1))
  @staticmethod
  def _match_alt_variable_SLmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(_1))
  def _variable_alt_SLmosek_4fusion_4PSDDomain_2(self,_t__0,_t__1):
    return self._variable_SLmosek_4fusion_4PSDDomain_2(_0,_1)
  def _variable_SLmosek_4fusion_4PSDDomain_2(self,_0,_1):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4PSDDomain_2(_0,None,_1))
  @staticmethod
  def _match_variable_SIILmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_S__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2) and __arg_match_Lmosek_4fusion_4PSDDomain_2__(_3))
  @staticmethod
  def _match_alt_variable_SIILmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2) and __arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(_3))
  def _variable_alt_SIILmosek_4fusion_4PSDDomain_2(self,_t__0,_t__1,_t__2,_t__3):
    return self._variable_SIILmosek_4fusion_4PSDDomain_2(_0,numpy.int32(__1),numpy.int32(__2),_3)
  def _variable_SIILmosek_4fusion_4PSDDomain_2(self,_0,_1,_2,_3):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4PSDDomain_2(_0,mosek.fusion.Set._make_III(_1,_1,_2),_3))
  @staticmethod
  def _match_variable_SILmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_I__(_1) and __arg_match_Lmosek_4fusion_4PSDDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_SILmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(_2))
  def _variable_alt_SILmosek_4fusion_4PSDDomain_2(self,_t__0,_t__1,_t__2):
    return self._variable_SILmosek_4fusion_4PSDDomain_2(_0,numpy.int32(__1),_2)
  def _variable_SILmosek_4fusion_4PSDDomain_2(self,_0,_1,_2):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4PSDDomain_2(_0,mosek.fusion.Set._make_II(_1,_1),_2))
  @staticmethod
  def _match_variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4Set_2__(_1) and __arg_match_Lmosek_4fusion_4PSDDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4Set_2__(_1) and __arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(_2))
  def _variable_alt_SLmosek_4fusion_4Set_2Lmosek_4fusion_4PSDDomain_2(self,_t__0,_t__1,_t__2):
    return self._variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4PSDDomain_2(_0,_1,_2)
  def _variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4PSDDomain_2(self,_0,_1,_2):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4PSDDomain_2(_0,_1,_2))
  @staticmethod
  def _match_variable_S_3ILmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match__3I__(_1) and __arg_match_Lmosek_4fusion_4PSDDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_S_3ILmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(_2))
  def _variable_alt_S_3ILmosek_4fusion_4PSDDomain_2(self,_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=_t__2
   _1 = self._variable_S_3ILmosek_4fusion_4PSDDomain_2(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _variable_S_3ILmosek_4fusion_4PSDDomain_2(self,_0,_1,_2):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4PSDDomain_2(_0,mosek.fusion.Set._make__3I(_1),_2))
  @staticmethod
  def _match_variable_ILmosek_4fusion_4SymmetricLinearDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4SymmetricLinearDomain_2__(_1))
  @staticmethod
  def _match_alt_variable_ILmosek_4fusion_4SymmetricLinearDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4SymmetricLinearDomain_2__(_1))
  def _variable_alt_ILmosek_4fusion_4SymmetricLinearDomain_2(self,_t__0,_t__1):
    return self._variable_ILmosek_4fusion_4SymmetricLinearDomain_2(numpy.int32(__0),_1)
  def _variable_ILmosek_4fusion_4SymmetricLinearDomain_2(self,_0,_1):
   return (self.__variable_1_SILmosek_4fusion_4SymmetricLinearDomain_2("",_0,_1))
  @staticmethod
  def _match_variable_SILmosek_4fusion_4SymmetricLinearDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_I__(_1) and __arg_match_Lmosek_4fusion_4SymmetricLinearDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_SILmosek_4fusion_4SymmetricLinearDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_Lmosek_4fusion_4SymmetricLinearDomain_2__(_2))
  def _variable_alt_SILmosek_4fusion_4SymmetricLinearDomain_2(self,_t__0,_t__1,_t__2):
    return self._variable_SILmosek_4fusion_4SymmetricLinearDomain_2(_0,numpy.int32(__1),_2)
  def _variable_SILmosek_4fusion_4SymmetricLinearDomain_2(self,_0,_1,_2):
   return (self.__variable_1_SILmosek_4fusion_4SymmetricLinearDomain_2(_0,_1,_2))
  @staticmethod
  def _match_variable_Lmosek_4fusion_4QConeDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4QConeDomain_2__(_0))
  @staticmethod
  def _match_alt_variable_Lmosek_4fusion_4QConeDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4QConeDomain_2__(_0))
  def _variable_alt_Lmosek_4fusion_4QConeDomain_2(self,_t__0):
    return self._variable_Lmosek_4fusion_4QConeDomain_2(_0)
  def _variable_Lmosek_4fusion_4QConeDomain_2(self,_0):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4QConeDomain_2("",None,_0))
  @staticmethod
  def _match_variable_Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4RangeDomain_2__(_0))
  @staticmethod
  def _match_alt_variable_Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_0))
  def _variable_alt_Lmosek_4fusion_4RangeDomain_2(self,_t__0):
    return self._variable_Lmosek_4fusion_4RangeDomain_2(_0)
  def _variable_Lmosek_4fusion_4RangeDomain_2(self,_0):
   return (self.__ranged_1variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2("",None,_0))
  @staticmethod
  def _match_variable_Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4LinearDomain_2__(_0))
  @staticmethod
  def _match_alt_variable_Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_0))
  def _variable_alt_Lmosek_4fusion_4LinearDomain_2(self,_t__0):
    return self._variable_Lmosek_4fusion_4LinearDomain_2(_0)
  def _variable_Lmosek_4fusion_4LinearDomain_2(self,_0):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2("",None,_0))
  @staticmethod
  def _match_variable__3ILmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(_1))
  @staticmethod
  def _match_alt_variable__3ILmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_1))
  def _variable_alt__3ILmosek_4fusion_4RangeDomain_2(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=_t__1
   _1 = self._variable__3ILmosek_4fusion_4RangeDomain_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _variable__3ILmosek_4fusion_4RangeDomain_2(self,_0,_1):
   return (self.__ranged_1variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2("",mosek.fusion.Set._make__3I(_0),_1))
  @staticmethod
  def _match_variable__3ILmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(_1))
  @staticmethod
  def _match_alt_variable__3ILmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_1))
  def _variable_alt__3ILmosek_4fusion_4LinearDomain_2(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=_t__1
   _1 = self._variable__3ILmosek_4fusion_4LinearDomain_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _variable__3ILmosek_4fusion_4LinearDomain_2(self,_0,_1):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2("",mosek.fusion.Set._make__3I(_0),_1))
  @staticmethod
  def _match_variable_Lmosek_4fusion_4Set_2Lmosek_4fusion_4QConeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Set_2__(_0) and __arg_match_Lmosek_4fusion_4QConeDomain_2__(_1))
  @staticmethod
  def _match_alt_variable_Lmosek_4fusion_4Set_2Lmosek_4fusion_4QConeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Set_2__(_0) and __arg_alt_match_Lmosek_4fusion_4QConeDomain_2__(_1))
  def _variable_alt_Lmosek_4fusion_4Set_2Lmosek_4fusion_4QConeDomain_2(self,_t__0,_t__1):
    return self._variable_Lmosek_4fusion_4Set_2Lmosek_4fusion_4QConeDomain_2(_0,_1)
  def _variable_Lmosek_4fusion_4Set_2Lmosek_4fusion_4QConeDomain_2(self,_0,_1):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4QConeDomain_2("",_0,_1))
  @staticmethod
  def _match_variable_Lmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Set_2__(_0) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(_1))
  @staticmethod
  def _match_alt_variable_Lmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Set_2__(_0) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_1))
  def _variable_alt_Lmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2(self,_t__0,_t__1):
    return self._variable_Lmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2(_0,_1)
  def _variable_Lmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2(self,_0,_1):
   return (self.__ranged_1variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2("",_0,_1))
  @staticmethod
  def _match_variable_Lmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Set_2__(_0) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(_1))
  @staticmethod
  def _match_alt_variable_Lmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Set_2__(_0) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_1))
  def _variable_alt_Lmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2(self,_t__0,_t__1):
    return self._variable_Lmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2(_0,_1)
  def _variable_Lmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2(self,_0,_1):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2("",_0,_1))
  @staticmethod
  def _match_variable_ILmosek_4fusion_4QConeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4QConeDomain_2__(_1))
  @staticmethod
  def _match_alt_variable_ILmosek_4fusion_4QConeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4QConeDomain_2__(_1))
  def _variable_alt_ILmosek_4fusion_4QConeDomain_2(self,_t__0,_t__1):
    return self._variable_ILmosek_4fusion_4QConeDomain_2(numpy.int32(__0),_1)
  def _variable_ILmosek_4fusion_4QConeDomain_2(self,_0,_1):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4QConeDomain_2("",mosek.fusion.Set._make_I(_0),_1))
  @staticmethod
  def _match_variable_ILmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(_1))
  @staticmethod
  def _match_alt_variable_ILmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_1))
  def _variable_alt_ILmosek_4fusion_4RangeDomain_2(self,_t__0,_t__1):
    return self._variable_ILmosek_4fusion_4RangeDomain_2(numpy.int32(__0),_1)
  def _variable_ILmosek_4fusion_4RangeDomain_2(self,_0,_1):
   return (self.__ranged_1variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2("",mosek.fusion.Set._make_I(_0),_1))
  @staticmethod
  def _match_variable_ILmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(_1))
  @staticmethod
  def _match_alt_variable_ILmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_1))
  def _variable_alt_ILmosek_4fusion_4LinearDomain_2(self,_t__0,_t__1):
    return self._variable_ILmosek_4fusion_4LinearDomain_2(numpy.int32(__0),_1)
  def _variable_ILmosek_4fusion_4LinearDomain_2(self,_0,_1):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2("",mosek.fusion.Set._make_I(_0),_1))
  @staticmethod
  def _match_variable__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_variable__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _variable_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._variable__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _variable__3I(self,_0):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2("",mosek.fusion.Set._make__3I(_0),mosek.fusion.Domain._unbounded_()))
  @staticmethod
  def _match_variable_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_variable_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _variable_alt_I(self,_t__0):
    return self._variable_I(numpy.int32(__0))
  def _variable_I(self,_0):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2("",mosek.fusion.Set._make_I(_0),mosek.fusion.Domain._unbounded_()))
  @staticmethod
  def _match_variable_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_variable_(*args):
    if len(args) != 0: return False
    return True
  def _variable_alt_(self,):
    return self._variable_()
  def _variable_(self,):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2("",mosek.fusion.Set._make_I(1),mosek.fusion.Domain._unbounded_()))
  @staticmethod
  def _match_variable_SLmosek_4fusion_4QConeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4QConeDomain_2__(_1))
  @staticmethod
  def _match_alt_variable_SLmosek_4fusion_4QConeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4QConeDomain_2__(_1))
  def _variable_alt_SLmosek_4fusion_4QConeDomain_2(self,_t__0,_t__1):
    return self._variable_SLmosek_4fusion_4QConeDomain_2(_0,_1)
  def _variable_SLmosek_4fusion_4QConeDomain_2(self,_0,_1):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4QConeDomain_2(_0,None,_1))
  @staticmethod
  def _match_variable_SLmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(_1))
  @staticmethod
  def _match_alt_variable_SLmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_1))
  def _variable_alt_SLmosek_4fusion_4RangeDomain_2(self,_t__0,_t__1):
    return self._variable_SLmosek_4fusion_4RangeDomain_2(_0,_1)
  def _variable_SLmosek_4fusion_4RangeDomain_2(self,_0,_1):
   return (self.__ranged_1variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2(_0,None,_1))
  @staticmethod
  def _match_variable_SLmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(_1))
  @staticmethod
  def _match_alt_variable_SLmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_1))
  def _variable_alt_SLmosek_4fusion_4LinearDomain_2(self,_t__0,_t__1):
    return self._variable_SLmosek_4fusion_4LinearDomain_2(_0,_1)
  def _variable_SLmosek_4fusion_4LinearDomain_2(self,_0,_1):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2(_0,None,_1))
  @staticmethod
  def _match_variable_S_3ILmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match__3I__(_1) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_S_3ILmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_2))
  def _variable_alt_S_3ILmosek_4fusion_4RangeDomain_2(self,_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=_t__2
   _1 = self._variable_S_3ILmosek_4fusion_4RangeDomain_2(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _variable_S_3ILmosek_4fusion_4RangeDomain_2(self,_0,_1,_2):
   return (self.__ranged_1variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2(_0,mosek.fusion.Set._make__3I(_1),_2))
  @staticmethod
  def _match_variable_S_3ILmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match__3I__(_1) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_S_3ILmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_2))
  def _variable_alt_S_3ILmosek_4fusion_4LinearDomain_2(self,_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=_t__2
   _1 = self._variable_S_3ILmosek_4fusion_4LinearDomain_2(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _variable_S_3ILmosek_4fusion_4LinearDomain_2(self,_0,_1,_2):
   return (self._variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2(_0,mosek.fusion.Set._make__3I(_1),_2))
  @staticmethod
  def _match_variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4QConeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4Set_2__(_1) and __arg_match_Lmosek_4fusion_4QConeDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4QConeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4Set_2__(_1) and __arg_alt_match_Lmosek_4fusion_4QConeDomain_2__(_2))
  def _variable_alt_SLmosek_4fusion_4Set_2Lmosek_4fusion_4QConeDomain_2(self,_t__0,_t__1,_t__2):
    return self._variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4QConeDomain_2(_0,_1,_2)
  def _variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4QConeDomain_2(self,_0,_1,_2):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4QConeDomain_2(_0,_1,_2))
  @staticmethod
  def _match_variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4Set_2__(_1) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4Set_2__(_1) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_2))
  def _variable_alt_SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2(self,_t__0,_t__1,_t__2):
    return self._variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2(_0,_1,_2)
  def _variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2(self,_0,_1,_2):
   return (self.__ranged_1variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2(_0,_1,_2))
  @staticmethod
  def _match_variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4Set_2__(_1) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4Set_2__(_1) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_2))
  def _variable_alt_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2(self,_t__0,_t__1,_t__2):
    return self._variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2(_0,_1,_2)
  def _variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2(self,_0,_1,_2):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2(_0,_1,_2))
  @staticmethod
  def _match_variable_SILmosek_4fusion_4QConeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_I__(_1) and __arg_match_Lmosek_4fusion_4QConeDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_SILmosek_4fusion_4QConeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_Lmosek_4fusion_4QConeDomain_2__(_2))
  def _variable_alt_SILmosek_4fusion_4QConeDomain_2(self,_t__0,_t__1,_t__2):
    return self._variable_SILmosek_4fusion_4QConeDomain_2(_0,numpy.int32(__1),_2)
  def _variable_SILmosek_4fusion_4QConeDomain_2(self,_0,_1,_2):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4QConeDomain_2(_0,mosek.fusion.Set._make_I(_1),_2))
  @staticmethod
  def _match_variable_SILmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_I__(_1) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_SILmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_2))
  def _variable_alt_SILmosek_4fusion_4RangeDomain_2(self,_t__0,_t__1,_t__2):
    return self._variable_SILmosek_4fusion_4RangeDomain_2(_0,numpy.int32(__1),_2)
  def _variable_SILmosek_4fusion_4RangeDomain_2(self,_0,_1,_2):
   return (self.__ranged_1variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2(_0,mosek.fusion.Set._make_I(_1),_2))
  @staticmethod
  def _match_variable_SILmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_I__(_1) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_SILmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_2))
  def _variable_alt_SILmosek_4fusion_4LinearDomain_2(self,_t__0,_t__1,_t__2):
    return self._variable_SILmosek_4fusion_4LinearDomain_2(_0,numpy.int32(__1),_2)
  def _variable_SILmosek_4fusion_4LinearDomain_2(self,_0,_1,_2):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2(_0,mosek.fusion.Set._make_I(_1),_2))
  @staticmethod
  def _match_variable_S_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_variable_S_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match__3I__(_1))
  def _variable_alt_S_3I(self,_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._variable_S_3I(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _variable_S_3I(self,_0,_1):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2(_0,mosek.fusion.Set._make__3I(_1),mosek.fusion.Domain._unbounded_()))
  @staticmethod
  def _match_variable_SI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_variable_SI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_I__(_1))
  def _variable_alt_SI(self,_t__0,_t__1):
    return self._variable_SI(_0,numpy.int32(__1))
  def _variable_SI(self,_0,_1):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2(_0,mosek.fusion.Set._make_I(_1),mosek.fusion.Domain._unbounded_()))
  @staticmethod
  def _match_variable_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_S__(_0))
  @staticmethod
  def _match_alt_variable_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_S__(_0))
  def _variable_alt_S(self,_t__0):
    return self._variable_S(_0)
  def _variable_S(self,_0):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2(_0,mosek.fusion.Set._make_I(1),mosek.fusion.Domain._unbounded_()))
  def __ranged_1variable_alt_SILmosek_4fusion_4SymmetricRangeDomain_2(self,_t__0,_t__1,_t__2):
    return self.__ranged_1variable_SILmosek_4fusion_4SymmetricRangeDomain_2(_0,numpy.int32(__1),_2)
  def __ranged_1variable_SILmosek_4fusion_4SymmetricRangeDomain_2(self,_0,_1,_2):
   _3=None
   if ((int(len(_0)) > 0) and self._hasVariable_S(_0)):
    raise mosek_fusion_NameError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Duplicate variable name '")._a_S(_0)._a_S("'")._toString_())
   _4=_1
   if (_4 > 0):
    if (((_2._dim) > 0) and ((_2._dim)!=_4)):
     raise mosek_fusion_DimensionError._ctor_S("Mismatching shape and domain")
   else:
    _4 = ((_2._dim) if (((_2._dim) > 0) ) else 1)
   _5=self.__task_vars_used
   _6=self._task_1numcon_()
   _7=self._task_1numcone_()
   _8=self._task_1numbarvar_()
   try:
    _9=None
    _10=((_4 * (_4 + 1)) // 2)
    _11=0
    if (_2._sparse_flag):
     _11 = self.__task_1alloc_1vars_I(_10)
     self.__natvarmap_1ensure_I(_10)
     self.__natvarmap_num = (self.__natvarmap_num + _10)
     _12=numpy.array([_2._get_1lb_1item_J((((_13 * (_13 + 1)) // 2) + _14)) for _13 in range(0,_4) for _14 in range(0,_13)], dtype=numpy.dtype(numpy.float64))
     _15=numpy.array([_2._get_1ub_1item_J((((_16 * (_16 + 1)) // 2) + _17)) for _16 in range(0,_4) for _17 in range(0,_16)], dtype=numpy.dtype(numpy.float64))
     self._task_1var_1putboundslice_1ra_II_3D_3D(_11,(_11 + _10),_12,_15)
     _9 = numpy.zeros((_10,), dtype=numpy.dtype(numpy.int32))
     fragments._c_closure_11(_11,_9,_10) # src/fusion/Model.mbi:2271:13-64
     fragments._c_closure_12(_11,self.__natvarmap_idx,_10) # src/fusion/Model.mbi:2272:13-71
     fragments._c_closure_13(_11,self.__natvarmap_Var,_10,self._vars_used) # src/fusion/Model.mbi:2273:13-72
    _3 = mosek_fusion_SymRangedVariable._ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4RangeDomain_2I_3IJ(self,_0,_2,_4,_9,self._numVariables_())
    if (_2._cardinal_flag):
     _3._makeInteger_()
   finally:
    if (_3 is None):
     self._task_1cleanup_IIII(_5,_6,_7,_8)
   self.__addVariable_SLmosek_4fusion_4ModelVariable_2(_0,_3)
   return (_3)
  def __ranged_1variable_alt_SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2(self,_t__0,_t__1,_t__2):
    return self.__ranged_1variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2(_0,_1,_2)
  def __ranged_1variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2(self,_0,_1,_2):
   _3=None
   if ((int(len(_0)) > 0) and self._hasVariable_S(_0)):
    raise mosek_fusion_NameError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Duplicate variable name '")._a_S(_0)._a_S("'")._toString_())
   if (_1 is not None):
    if (not _2._match_1shape_Lmosek_4fusion_4Set_2(_1)):
     raise mosek_fusion_DimensionError._ctor_S("Mismatching shape and domain")
    _4 = _1
   else:
    _4 = (_2._shape)
    if (_4 is None):
     _4 = mosek_fusion_IntSet._ctor_I(1)
   _5=self.__task_vars_used
   _6=self._task_1numcon_()
   _7=self._task_1numcone_()
   _8=self._task_1numbarvar_()
   try:
    _9=None
    _10=numpy.int32((_4._size))
    _11=0
    if (not (_2._sparse_flag)):
     _11 = self.__task_1alloc_1vars_I(_10)
     self.__natvarmap_1ensure_I(_10)
     self.__natvarmap_num = (self.__natvarmap_num + _10)
     _12=numpy.array([_2._get_1lb_1item_J(_13) for _13 in range(0,_10)], dtype=numpy.dtype(numpy.float64))
     _14=numpy.array([_2._get_1ub_1item_J(_15) for _15 in range(0,_10)], dtype=numpy.dtype(numpy.float64))
     self._task_1var_1putboundslice_1ra_II_3D_3D(_11,(_11 + _10),_12,_14)
     _9 = numpy.zeros((_10,), dtype=numpy.dtype(numpy.int32))
     fragments._c_closure_14(_11,_9,_10) # src/fusion/Model.mbi:2198:13-64
     fragments._c_closure_15(_11,self.__natvarmap_idx,_10) # src/fusion/Model.mbi:2199:13-71
     fragments._c_closure_16(_11,self.__natvarmap_Var,_10,self._vars_used) # src/fusion/Model.mbi:2200:13-72
    _3 = mosek_fusion_RangedVariable._ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2_3IJ(self,_0,_4,_2,_9,self._numVariables_())
    if (_2._cardinal_flag):
     _3._makeInteger_()
   finally:
    if (_3 is None):
     self._task_1cleanup_IIII(_5,_6,_7,_8)
   self.__addVariable_SLmosek_4fusion_4ModelVariable_2(_0,_3)
   return (_3)
  def __variable_1_alt_SLmosek_4fusion_4Set_2Lmosek_4fusion_4QConeDomain_2(self,_t__0,_t__1,_t__2):
    return self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4QConeDomain_2(_0,_1,_2)
  def __variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4QConeDomain_2(self,_0,_1,_2):
   _3=None
   _4=None
   if ((int(len(_0)) > 0) and self._hasVariable_S(_0)):
    raise mosek_fusion_NameError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Duplicate variable name '")._a_S(_0)._a_S("'")._toString_())
   _5=(_1 if ((_1 is not None) ) else ((_2._shape) if (((_2._shape) is not None) ) else mosek_fusion_IntSet._ctor_I(1)))
   if ((not _2._match_1shape_Lmosek_4fusion_4Set_2(_5)) or (_2._getAxis_() >= (_5.nd))):
    raise mosek_fusion_DimensionError._ctor_S("Mismatching shape and domain")
   _6=(_2._getAxis_() if (((_2._shape) is not None) ) else ((_5.nd) - 1))
   _7=_5._dim_I(_6)
   _8=1
   for _9 in range(0,(_5.nd)):
    if (_6!=_9):
     _8 *= _5._dim_I(_9)
   _10=1
   for _11 in range(0,_6):
    _10 *= _5._dim_I(_11)
   _12=1
   for _13 in range((_6 + 1),(_5.nd)):
    _12 *= _5._dim_I(_13)
   if ((((_2._key)==mosek.fusion.QConeKey.InQCone) and (_7 < 2)) or (((_2._key)==mosek.fusion.QConeKey.InRotatedQCone) and (_7 < 3))):
    raise mosek_fusion_DimensionError._ctor_S("Invalid size for cone")
   _14=self.__task_vars_used
   _15=self._task_1numcon_()
   _16=self._task_1numcone_()
   _17=self._task_1numbarvar_()
   try:
    _18=numpy.int32((_5._size))
    _19=self.__task_1alloc_1vars_I(_18)
    self.__natvarmap_1ensure_I(_18)
    self.__natvarmap_num = (self.__natvarmap_num + _18)
    _20=(_19 + _18)
    fragments._c_closure_17(_19,_20,self.__natvarmap_idx) # src/fusion/Model.mbi:2099:11-73
    self._task_1var_1putboundslice_1fr_II(_19,_20)
    if (_2._int_flag):
     self._task_1var_1putintlist__3I(mosek.fusion.Utils.Tools._range_II(_19,_20))
    _22=numpy.array([(_23 + _19) for _23 in range(0,(_8 * _7))], dtype=numpy.dtype(numpy.int32))
    if ((_2._key)==mosek.fusion.QConeKey.InQCone):
     _21 = self._task_1append_1quadcone_IIIII(_7,_19,_8,_10,_12)
    else:
     _21 = self._task_1append_1rquadcone_IIIII(_7,_19,_8,_10,_12)
    _4 = mosek_fusion_ConicVariable._ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4QConeDomain_2Lmosek_4fusion_4Set_2_3IIIIJ(self,_0,_2,_5,_22,_7,_21,_8,self._numVariables_())
    if (_2._int_flag):
     pass
    fragments._c_closure_18(_19,self.__natvarmap_Var,_18,self._vars_used) # src/fusion/Model.mbi:2131:11-68
    _3 = _4
   finally:
    if (_3 is None):
     self.__natvarmap_num = _14
     self._natbarvarmap_num = _17
     self._task_1cleanup_IIII(_14,_15,_16,_17)
   self.__addVariable_SLmosek_4fusion_4ModelVariable_2(_0,_3)
   return (_3)
  def __variable_1_alt_SILmosek_4fusion_4SymmetricLinearDomain_2(self,_t__0,_t__1,_t__2):
    return self.__variable_1_SILmosek_4fusion_4SymmetricLinearDomain_2(_0,numpy.int32(__1),_2)
  def __variable_1_SILmosek_4fusion_4SymmetricLinearDomain_2(self,_0,_1,_2):
   _3=None
   if ((int(len(_0)) > 0) and self._hasVariable_S(_0)):
    raise mosek_fusion_NameError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Duplicate variable name '")._a_S(_0)._a_S("'")._toString_())
   _4=_1
   if (_4 > 0):
    if (((_2._dim) > 0) and ((_2._dim)!=_4)):
     raise mosek_fusion_DimensionError._ctor_S("Mismatching shape and domain")
   else:
    _4 = ((_2._dim) if (((_2._dim) > 0) ) else 1)
   _5=self.__task_vars_used
   _6=self._task_1numcon_()
   _7=self._task_1numcone_()
   _8=self._task_1numbarvar_()
   try:
    _9=None
    _10=(_2._key)
    _11=((_4 * (_4 + 1)) // 2)
    _12=0
    if (not (_2._sparse_flag)):
     _12 = self.__task_1alloc_1vars_I(_11)
     self.__natvarmap_1ensure_I(_11)
     self.__natvarmap_num = (self.__natvarmap_num + _11)
     if (_10==mosek.fusion.RelationKey.IsFree):
      self._task_1var_1putboundslice_1fr_II(_12,(_12 + _11))
     else:
      _13=numpy.zeros((_11,), dtype=numpy.dtype(numpy.float64))
      _14=0
      for _15 in range(0,_4):
       for _16 in range(0,_15):
        _13[_14] = _2._get_1rhs_1item_J(((_15 * _4) + _16))
        _14 += 1
      if (_10==mosek.fusion.RelationKey.LessThan):
       self._task_1var_1putboundslice_1up_II_3D(_12,(_12 + _11),_13)
      elif (_10==mosek.fusion.RelationKey.GreaterThan):
       self._task_1var_1putboundslice_1lo_II_3D(_12,(_12 + _11),_13)
      elif (_10==mosek.fusion.RelationKey.EqualsTo):
       self._task_1var_1putboundslice_1fx_II_3D(_12,(_12 + _11),_13)
     _9 = numpy.array([(_12 + _17) for _17 in range(0,_11)], dtype=numpy.dtype(numpy.int32))
     fragments._c_closure_19(_12,self.__natvarmap_idx,_11) # src/fusion/Model.mbi:2026:13-71
    _3 = mosek_fusion_SymLinearVariable._ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4SymmetricLinearDomain_2I_3IJ(self,_0,_2,_4,_9,self._numVariables_())
    if (_2._cardinal_flag):
     _3._makeInteger_()
    if (not (_2._sparse_flag)):
     fragments._c_closure_20(_12,self.__natvarmap_Var,_11,self._vars_used) # src/fusion/Model.mbi:2035:13-72
   finally:
    if (_3 is None):
     self._task_1cleanup_IIII(_5,_6,_7,_8)
   self.__addVariable_SLmosek_4fusion_4ModelVariable_2(_0,_3)
   return (_3)
  def __variable_1_alt_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2(self,_t__0,_t__1,_t__2):
    return self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2(_0,_1,_2)
  def __variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2(self,_0,_1,_2):
   _3=None
   _4=None
   if ((int(len(_0)) > 0) and self._hasVariable_S(_0)):
    raise mosek_fusion_NameError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Duplicate variable name '")._a_S(_0)._a_S("'")._toString_())
   if (_1 is not None):
    if (not _2._match_1shape_Lmosek_4fusion_4Set_2(_1)):
     raise mosek_fusion_DimensionError._ctor_S("Mismatching shape and domain")
    _5 = _1
   else:
    _5 = (_2._shape)
    if (_5 is None):
     _5 = mosek_fusion_IntSet._ctor_I(1)
   _6=self.__task_vars_used
   _7=self._task_1numcon_()
   _8=self._task_1numcone_()
   _9=self._task_1numbarvar_()
   try:
    _10=None
    _11=(_2._key)
    _12=numpy.int32((_5._size))
    _13=0
    if (not (_2._sparse_flag)):
     _13 = self.__task_1alloc_1vars_I(_12)
     self.__natvarmap_1ensure_I(_12)
     self.__natvarmap_num = (self.__natvarmap_num + _12)
     if (_11==mosek.fusion.RelationKey.IsFree):
      self._task_1var_1putboundslice_1fr_II(_13,(_13 + _12))
     else:
      _14=numpy.zeros((_12,), dtype=numpy.dtype(numpy.float64))
      for _15 in range(0,_12):
       _14[_15] = _2._get_1rhs_1item_J(numpy.int64(_15))
      if (_11==mosek.fusion.RelationKey.LessThan):
       self._task_1var_1putboundslice_1up_II_3D(_13,(_13 + _12),_14)
      elif (_11==mosek.fusion.RelationKey.GreaterThan):
       self._task_1var_1putboundslice_1lo_II_3D(_13,(_13 + _12),_14)
      elif (_11==mosek.fusion.RelationKey.EqualsTo):
       self._task_1var_1putboundslice_1fx_II_3D(_13,(_13 + _12),_14)
     _10 = numpy.array([(_13 + _16) for _16 in range(0,_12)], dtype=numpy.dtype(numpy.int32))
     fragments._c_closure_21(_13,self.__natvarmap_idx,_12) # src/fusion/Model.mbi:1940:13-71
    _4 = mosek_fusion_LinearVariable._ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4LinearDomain_2Lmosek_4fusion_4Set_2_3IJ(self,_0,_2,_5,_10,self._numVariables_())
    if (_2._cardinal_flag):
     pass
    _3 = _4
    if (_2._cardinal_flag):
     _4._makeInteger_()
    if (not (_2._sparse_flag)):
     fragments._c_closure_22(_13,self.__natvarmap_Var,_12,self._vars_used) # src/fusion/Model.mbi:1952:13-72
   finally:
    if (_3 is None):
     self._task_1cleanup_IIII(_6,_7,_8,_9)
   self.__addVariable_SLmosek_4fusion_4ModelVariable_2(_0,_3)
   return (_3)
  def __variable_1_alt_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinPSDDomain_2(self,_t__0,_t__1,_t__2):
    return self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinPSDDomain_2(_0,_1,_2)
  def __variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinPSDDomain_2(self,_0,_1,_2):
   _3=None
   if (_1 is None):
    if ((_2._shape) is None):
     raise mosek_fusion_DimensionError._ctor_S("Missing shape for variable")
    else:
     _3 = (_2._shape)
   elif ((_2._shape) is None):
    _3 = _1
   else:
    if (((_1.nd)!=((_2._shape).nd)) or ((_1._dim_I(0)!=(_2._shape)._dim_I(0)) or (_1._dim_I(1)!=(_2._shape)._dim_I(1)))):
     raise mosek_fusion_DimensionError._ctor_S("Ambiguous dimensions for variable")
    else:
     _3 = _1
   _4=_3._dim_I(0)
   _5=numpy.int32(((mosek.fusion.Utils.Tools._sqrt_D((1 + (8 * _4))) - 1) / 2))
   if (((_5 * (_5 + 1)) // 2)!=_4):
    raise mosek_fusion_DimensionError._ctor_S("Invalid size for semidefinite variable")
   _6=1
   for _7 in range(1,(_3.nd)):
    _6 *= _3._dim_I(_7)
   _8=self._task_1append_1barvar_II(_5,_6)
   _9=mosek_fusion_LinearPSDVariable._ctor_Lmosek_4fusion_4Model_2SILmosek_4fusion_4Set_2IJ(self,_0,_5,_3,_8,self._numVariables_())
   self.__natbarvarmap_1ensure_I(1)
   self._natbarvarmap_Var[self._natbarvarmap_num] = self._vars_used
   self._natbarvarmap_num += 1
   self.__addVariable_SLmosek_4fusion_4ModelVariable_2(_0,_9)
   return (_9)
  def __variable_1_alt_SLmosek_4fusion_4Set_2Lmosek_4fusion_4PSDDomain_2(self,_t__0,_t__1,_t__2):
    return self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4PSDDomain_2(_0,_1,_2)
  def __variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4PSDDomain_2(self,_0,_1,_2):
   if (_1 is not None):
    if (((_1.nd)!=2) and ((_1.nd)!=3)):
     raise mosek_fusion_DimensionError._ctor_S("Invalid shape for semidefinite variables")
    elif (((_1.nd)==2) and (_1._dim_I(0)!=_1._dim_I(1))):
     raise mosek_fusion_DimensionError._ctor_S("Invalid shape for semidefinite variables")
    elif (((_1.nd)==3) and (_1._dim_I(1)!=_1._dim_I(2))):
     raise mosek_fusion_DimensionError._ctor_S("Invalid shape for semidefinite variables")
    _3 = _1._dim_I(1)
    _4 = (1 if (((_1.nd)==2) ) else _1._dim_I(0))
    if ((_2._shape) is not None):
     if ((((_2._shape).nd)!=(_1.nd)) or ((((_1.nd)==2) and (((_2._shape)._dim_I(0)!=_3) or ((_2._shape)._dim_I(1)!=_3))) or (((_1.nd)==3) and (((_2._shape)._dim_I(0)!=_4) or (((_2._shape)._dim_I(1)!=_3) or ((_2._shape)._dim_I(2)!=_3)))))):
      raise mosek_fusion_DomainError._ctor_S("Domain and shape do not match")
   else:
    if ((_2._shape) is None):
     raise mosek_fusion_DomainError._ctor_S("Either domain size of shape must be defined")
    elif ((((_2._shape).nd)!=2) and (((_2._shape).nd)!=3)):
     raise mosek_fusion_DomainError._ctor_S("Invalid domain shape")
    else:
     _3 = (_2._shape)._dim_I(1)
     _4 = (1 if ((((_2._shape).nd)==2) ) else (_2._shape)._dim_I(0))
   _5=self._task_1append_1barvar_II(_3,_4)
   _6=mosek_fusion_PSDVariable._ctor_Lmosek_4fusion_4Model_2SIIIJ(self,_0,_3,_5,_4,self._numVariables_())
   self.__natbarvarmap_1ensure_I(1)
   self._natbarvarmap_Var[self._natbarvarmap_num] = self._vars_used
   self._natbarvarmap_num += 1
   self.__addVariable_SLmosek_4fusion_4ModelVariable_2(_0,_6)
   return (_6)
  def __constraint_1_alt_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(self,_t__0,_t__1,_t__2,_t__3):
    return self.__constraint_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(_0,_1,_2,_3)
  def __constraint_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(self,_0,_1,_2,_3):
   _4=None
   if ((int(len(_0)) > 0) and self._hasConstraint_S(_0)):
    raise mosek_fusion_NameError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Duplicate constraint name '")._a_S(_0)._a_S("'")._toString_())
   _5 = (_1 if ((_1 is not None) ) else _2._getShape_())
   if (not _3._match_1shape_Lmosek_4fusion_4Set_2(_5)):
    raise mosek_fusion_DimensionError._ctor_S("Mismatching shape and domain")
   _6=_2._eval_()
   for _7 in range(0,int(((_6.x)).shape[0])):
    if (((_6.x)[_7]._getModel_() is not None) and ((_6.x)[_7]._getModel_() is not self)):
     raise mosek_fusion_ModelError._ctor_S("Expression belong to different models")
   _8=self.__build_1conA__3JJ_3J_3J_3D_3D_3Lmosek_4fusion_4Variable_2((_6.ptrb),(_5._size),(_6.inst),(_6.subj),(_6.cof),(_6.bfix),(_6.x))
   _9=(int(((_8.ptrb)).shape[0]) - 1)
   _10=self.__task_vars_used
   _11=self._task_1numcone_()
   _12=self._task_1numcon_()
   _13=self._task_1numbarvar_()
   try:
    _14=_9
    _15=self._task_1append_1con_I(_14)
    _16=(_15 + _14)
    if (int(len(_0)) > 0):
     _17=mosek.fusion.Utils.StringBuffer()
     _18=0
     while (_18 < _14):
      _17._clear_()._a_S(_0)._a_S("[")._a_I(_18)._a_S("]")
      self._task_1con_1name_IS((_18 + _15),_17._toString_())
      _18 += 1
    if (((_8.subj) is not None) and (int(((_8.subj)).shape[0]) > 0)):
     self._task_1putarowslice_II_3J_3I_3D(_15,_16,(_8.ptrb),(_8.subj),(_8.cof))
    if ((_8.barsubi) is not None):
     for _19 in range(0,int(((_8.barsubi)).shape[0])):
      self._task_1putbaraij_III(((_8.barsubi)[_19] + _15),(_8.barsubj)[_19],(_8.barmidx)[_19])
    _20=numpy.zeros((_9,), dtype=numpy.dtype(numpy.float64))
    _21=numpy.zeros((_9,), dtype=numpy.dtype(numpy.float64))
    if ((_8.bfix) is not None):
     for _22 in range(0,_9):
      _20[_22] = (_3._get_1lb_1item_J(numpy.int64(_22)) - (_8.bfix)[_22])
      _21[_22] = (_3._get_1ub_1item_J(numpy.int64(_22)) - (_8.bfix)[_22])
    else:
     _23=(int(((_8.ptrb)).shape[0]) - 1)
     for _24 in range(0,_9):
      _20[_24] = _3._get_1lb_1item_J(numpy.int64(_24))
      _21[_24] = _3._get_1ub_1item_J(numpy.int64(_24))
    _25=mosek.fusion.Utils.Tools._range_II(_15,_16)
    self._task_1con_1putboundslice_1ra_II_3D_3D(_15,_16,_20,_21)
    _4 = mosek_fusion_RangedConstraint._ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2_3I_3J_3I_3D_3D_3I_3I_3I(self,_0,_5,_3,_25,(_8.ptrb),(_8.subj),(_8.cof),(_8.bfix),(_8.barsubi),(_8.barsubj),(_8.barmidx))
    self.__addConstraint_SLmosek_4fusion_4ModelConstraint_2(_0,_4)
   finally:
    if (_4 is None):
     self.__natvarmap_num = _10
     self._natbarvarmap_num = _13
     self._task_1cleanup_IIII(_10,_12,_11,_13)
   return (_4)
  def __constraint_1_alt_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(self,_t__0,_t__1,_t__2,_t__3):
    return self.__constraint_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(_0,_1,_2,_3)
  def __constraint_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(self,_0,_1,_2,_3):
   _4=None
   _5=numpy.int32((_2._getShape_()._size))
   if ((int(len(_0)) > 0) and self._hasConstraint_S(_0)):
    raise mosek_fusion_NameError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Duplicate constraint name '")._a_S(_0)._a_S("'")._toString_())
   _6=(_1 if ((_1 is not None) ) else ((_3._shape) if (((_3._shape) is not None) ) else _2._getShape_()))
   if ((((_3._shape) is not None) and (not _3._match_1shape_Lmosek_4fusion_4Set_2(_6))) or ((_2._getShape_() is not None) and (not _6._compare_Lmosek_4fusion_4Set_2(_2._getShape_())))):
    raise mosek_fusion_DimensionError._ctor_S("Mismatching shape and domain")
   _7=(_3._getAxis_() if (((_3._shape) is not None) ) else ((_6.nd) - 1))
   _8=_6._dim_I(_7)
   _9=1
   for _10 in range(0,(_6.nd)):
    if (_7!=_10):
     _9 *= _6._dim_I(_10)
   _11=1
   for _12 in range(0,_7):
    _11 *= _6._dim_I(_12)
   _13=1
   for _14 in range((_7 + 1),(_6.nd)):
    _13 *= _6._dim_I(_14)
   _15=_2._eval_()
   for _16 in range(0,int(((_15.x)).shape[0])):
    if (((_15.x)[_16]._getModel_() is not None) and ((_15.x)[_16]._getModel_() is not self)):
     raise mosek_fusion_ModelError._ctor_S("Expression belong to different models")
   _17=self.__build_1conA__3JJ_3J_3J_3D_3D_3Lmosek_4fusion_4Variable_2((_15.ptrb),(_6._size),(_15.inst),(_15.subj),(_15.cof),(_15.bfix),(_15.x))
   _18=(int(((_17.ptrb)).shape[0]) - 1)
   _19=self.__task_vars_used
   _20=self._task_1numcon_()
   _21=self._task_1numcone_()
   _22=self._task_1numbarvar_()
   try:
    _23=self._task_1append_1con_I(_18)
    _24=(_23 + _18)
    if (((_17.subj) is not None) and (int(((_17.subj)).shape[0]) > 0)):
     self._task_1putarowslice_II_3J_3I_3D(_23,_24,(_17.ptrb),(_17.subj),(_17.cof))
    if ((_17.barsubi) is not None):
     for _25 in range(0,int(((_17.barsubi)).shape[0])):
      self._task_1putbaraij_III(((_17.barsubi)[_25] + _23),(_17.barsubj)[_25],(_17.barmidx)[_25])
    _26=mosek.fusion.Utils.Tools._range_II(_23,_24)
    _27=numpy.zeros(((_24 - _23),), dtype=numpy.dtype(numpy.float64))
    _28=(_8 * _9)
    _29=numpy.zeros((_28,), dtype=numpy.dtype(numpy.float64))
    _30=(_17.bfix)
    _31=(_15.bfix)
    if ((_17.bfix) is None):
     for _32 in range(0,(_24 - _23)):
      _27[_32] = (- (_17.bfix)[_32])
    if ((_15.bfix) is not None):
     for _33 in range(0,_28):
      _29[_33] = (- (_17.bfix)[_33])
    self._task_1con_1putboundslice_1fx_II_3D(_23,_24,_29)
    _34=self.__task_1alloc_1vars_I(_28)
    self.__natvarmap_1ensure_I(_28)
    self.__natvarmap_num = (self.__natvarmap_num + _28)
    _35=(_34 + _28)
    self._task_1putaijlist__3I_3I_3DJ(mosek.fusion.Utils.Tools._range_II(_23,_24),mosek.fusion.Utils.Tools._range_II(_34,_35),numpy.array([(- 1.0) for _36 in range(0,_28)], dtype=numpy.dtype(numpy.float64)),_28)
    self._task_1var_1putboundslice_1fr_II(_34,_35)
    if ((_3._key)==mosek.fusion.QConeKey.InQCone):
     _37 = self._task_1append_1quadcone_IIIII(_8,_34,_9,_11,_13)
    else:
     _37 = self._task_1append_1rquadcone_IIIII(_8,_34,_9,_11,_13)
    _4 = mosek_fusion_ConicConstraint._ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4QConeDomain_2Lmosek_4fusion_4Set_2_3IIIIII_3J_3I_3D_3D_3I_3I_3I(self,_0,_3,_6,mosek.fusion.Utils.Tools._range_II(_23,_24),_34,_35,_8,_37,_9,(_17.ptrb),(_17.subj),(_17.cof),(_17.bfix),(_17.barsubi),(_17.barsubj),(_17.barmidx))
    self.__addConstraint_SLmosek_4fusion_4ModelConstraint_2(_0,_4)
    return (_4)
   finally:
    if (_4 is None):
     self.__natvarmap_num = _19
     self._natbarvarmap_num = _22
     self._task_1cleanup_IIII(_19,_20,_21,_22)
  def __constraint_1_alt_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(self,_t__0,_t__1,_t__2,_t__3):
    return self.__constraint_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(_0,_1,_2,_3)
  def __constraint_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(self,_0,_1,_2,_3):
   _4=None
   _5=numpy.int32((_2._getShape_()._size))
   if ((int(len(_0)) > 0) and self._hasConstraint_S(_0)):
    raise mosek_fusion_NameError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Duplicate constraint name '")._a_S(_0)._a_S("'")._toString_())
   _6 = (_1 if ((_1 is not None) ) else ((_3._shape) if (((_3._shape) is not None) ) else _2._getShape_()))
   if ((((_3._shape) is not None) and (not _3._match_1shape_Lmosek_4fusion_4Set_2(_6))) or ((_2._getShape_() is not None) and (not _6._compare_Lmosek_4fusion_4Set_2(_2._getShape_())))):
    raise mosek_fusion_DimensionError._ctor_S("Mismatching shape and domain")
   _7=_2._eval_()
   for _8 in range(0,int(((_7.x)).shape[0])):
    if (((_7.x)[_8]._getModel_() is not None) and ((_7.x)[_8]._getModel_() is not self)):
     raise mosek_fusion_ModelError._ctor_S("Expression belong to different models")
   _9=self.__build_1conA__3JJ_3J_3J_3D_3D_3Lmosek_4fusion_4Variable_2((_7.ptrb),(_6._size),(_7.inst),(_7.subj),(_7.cof),(_7.bfix),(_7.x))
   _10=(int(((_9.ptrb)).shape[0]) - 1)
   _11=self.__task_vars_used
   _12=self._task_1numcon_()
   _13=self._task_1numcone_()
   _14=self._task_1numbarvar_()
   try:
    _15=_10
    _16=self._task_1append_1con_I(_15)
    _17=(_16 + _15)
    if (((_9.subj) is not None) and (int(((_9.subj)).shape[0]) > 0)):
     self._task_1putarowslice_II_3J_3I_3D(_16,_17,(_9.ptrb),(_9.subj),(_9.cof))
    if ((_9.barsubi) is not None):
     for _18 in range(0,int(((_9.barsubi)).shape[0])):
      self._task_1putbaraij_III(((_9.barsubi)[_18] + _16),(_9.barsubj)[_18],(_9.barmidx)[_18])
    _19=mosek.fusion.Utils.Tools._range_II(_16,_17)
    _20=(numpy.array([_3._get_1rhs_1item_J(_21) for _21 in range(0,(_17 - _16))], dtype=numpy.dtype(numpy.float64)) if (((_9.bfix) is None) ) else numpy.array([(_3._get_1rhs_1item_J(_22) - (_9.bfix)[_22]) for _22 in range(0,(_17 - _16))], dtype=numpy.dtype(numpy.float64)))
    _23=(_3._key)
    if (_23==mosek.fusion.RelationKey.IsFree):
     self._task_1con_1putboundslice_1fr_II(_16,_17)
    elif (_23==mosek.fusion.RelationKey.LessThan):
     self._task_1con_1putboundslice_1up_II_3D(_16,_17,_20)
    elif (_23==mosek.fusion.RelationKey.GreaterThan):
     self._task_1con_1putboundslice_1lo_II_3D(_16,_17,_20)
    else:
     self._task_1con_1putboundslice_1fx_II_3D(_16,_17,_20)
    _4 = mosek_fusion_LinearConstraint._ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4LinearDomain_2Lmosek_4fusion_4Set_2_3I_3J_3I_3D_3D_3I_3I_3I(self,_0,_3,_6,_19,(_9.ptrb),(_9.subj),(_9.cof),(_9.bfix),(_9.barsubi),(_9.barsubj),(_9.barmidx))
    self.__addConstraint_SLmosek_4fusion_4ModelConstraint_2(_0,_4)
    return (_4)
   finally:
    if (_4 is None):
     self.__natvarmap_num = _11
     self._natbarvarmap_num = _14
     self._task_1cleanup_IIII(_11,_12,_13,_14)
  def __build_1conA_alt__3JJ_3J_3J_3D_3D_3Lmosek_4fusion_4Variable_2(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int64))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.float64))
   _6=numpy.array(_t__6,dtype=numpy.dtype(object))
   _1 = self.__build_1conA__3JJ_3J_3J_3D_3D_3Lmosek_4fusion_4Variable_2(_0,_1,_2,_3,_4,_5,_6)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__6[:] = _6
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __build_1conA__3JJ_3J_3J_3D_3D_3Lmosek_4fusion_4Variable_2(self,_0,_1,_2,_3,_4,_5,_6):
   _7=None
   _8=numpy.zeros(((_1 + 1),), dtype=numpy.dtype(numpy.int64))
   _9=None
   _10=(_2 if ((_2 is not None) ) else numpy.array([_11 for _11 in range(0,(int((_0).shape[0]) - 1))], dtype=numpy.dtype(numpy.int64)))
   _12=_5
   _13=0
   _14=0
   _19=int((_3).shape[0])
   _15 = numpy.zeros((_19,), dtype=numpy.dtype(numpy.int32))
   _16 = numpy.zeros((_19,), dtype=numpy.dtype(numpy.int32))
   _17 = numpy.zeros((_19,), dtype=numpy.dtype(numpy.int32))
   _20=numpy.zeros((_19,), dtype=numpy.dtype(numpy.int32))
   mosek.fusion.Model.__inst__3Lmosek_4fusion_4Variable_2_3J_3I_3I_3I(_6,_3,_15,_16,_17)
   _18 = mosek.fusion.Utils.Tools._range_J(long((_3).shape[0]))
   if (_19 > (3 * int((_0).shape[0]))):
    for _21 in range(0,(int((_0).shape[0]) - 1)):
     mosek.fusion.Sort._argsort__3J_3IJJZ(_18,_15,_0[_21],_0[(_21 + 1)],True)
     fragments._c_closure_23(_0,_21,_20) # src/fusion/Model.mbi:1172:15-1173:32
   else:
    fragments._c_closure_24(_0,_20) # src/fusion/Model.mbi:1177:13-1179:32
    mosek.fusion.Sort._argsort__3J_3I_3IJJZ(_18,_20,_15,0,int((_18).shape[0]),True)
   _14 = 0
   _13 = 0
   _13,_14 = fragments._c_closure_25(_19,_13,_14,_18,_20,_15) # src/fusion/Model.mbi:1191:11-1202:12
   _13 = numpy.int32(_13) # postprocess
   _14 = numpy.int32(_14) # postprocess
   if (_14==_19):
    _7 = _15
    _9 = _4
    if (int((_10).shape[0])==_1):
     _8 = _0
    else:
     fragments._c_closure_26(_10,_0,_8) # src/fusion/Model.mbi:1214:13-1223:14
   else:
    _22=0
    _23=0
    _7 = numpy.zeros((_14,), dtype=numpy.dtype(numpy.int32))
    _9 = numpy.zeros((_14,), dtype=numpy.dtype(numpy.float64))
    _24=0
    _24 = fragments._c_closure_27(_9,_4,_24,_10,_0,_18,_8,_7,_15) # src/fusion/Model.mbi:1234:13-1263:16
    _24 = numpy.int32(_24) # postprocess
   _25=_8
   _26=None
   _27=None
   _28=None
   _29=0
   if (_13 > 0):
    _29 = fragments._c_closure_28(_0,_29,_18,_15) # src/fusion/Model.mbi:1281:11-1292:12
    _29 = numpy.int32(_29) # postprocess
    if (_29 > 0):
     _30=0
     _26 = numpy.zeros((_29,), dtype=numpy.dtype(numpy.int32))
     _27 = numpy.zeros((_29,), dtype=numpy.dtype(numpy.int32))
     _28 = numpy.zeros((_29,), dtype=numpy.dtype(numpy.int32))
     for _31 in range(0,(int((_0).shape[0]) - 1)):
      _32=_0[_31]
      while ((_32 < _0[(_31 + 1)]) and (_15[_18[_32]] < 0)):
       _33=_32
       _34=_15[_18[_32]]
       _32 += 1
       _32 = fragments._c_closure_29(_34,_0,_31,_32,_18,_15) # src/fusion/Model.mbi:1309:17-79
       _32 = numpy.int64(_32) # postprocess
       _35=(- (_34 + 1))
       _36=self._task_1barvardim_I(_35)
       fragments._c_closure_30(_33,_4,_32,_18,_16,_17) # src/fusion/Model.mbi:1315:17-1327:18
       if ((_32 - _33) > 1):
        if ((_32 - _33) < (2 * _36)):
         mosek.fusion.Sort._argsort__3J_3I_3IJJZ(_18,_16,_17,_33,_32,True)
        else:
         mosek.fusion.Sort._argbucketsort__3J_3IJJII(_18,_17,_33,_32,0,_36)
         mosek.fusion.Sort._argbucketsort__3J_3IJJII(_18,_16,_33,_32,0,_36)
       _37=1
       _37 = fragments._c_closure_31(_33,_32,_18,_16,_17,_37) # src/fusion/Model.mbi:1342:17-1345:23
       _37 = numpy.int32(_37) # postprocess
       _38=numpy.zeros((_37,), dtype=numpy.dtype(numpy.int32))
       _39=numpy.zeros((_37,), dtype=numpy.dtype(numpy.int32))
       _40=numpy.zeros((_37,), dtype=numpy.dtype(numpy.float64))
       fragments._c_closure_32(_33,_40,_38,_39,_4,_32,_18,_16,_17) # src/fusion/Model.mbi:1351:17-1367:18
       _26[_30] = numpy.int32(_10[_31])
       _27[_30] = _35
       _28[_30] = self._task_1append_1barmatrix_I_3I_3I_3D(_36,_38,_39,_40)
       _30 += 1
   _41=numpy.zeros((_1,), dtype=numpy.dtype(numpy.float64))
   fragments._c_closure_33(_41,_5,_10) # src/fusion/Model.mbi:1380:9-1382:39
   return (mosek_fusion_ConNZStruct._ctor__3J_3I_3D_3D_3I_3I_3I(_8,_7,_9,_41,_26,_27,_28))
  def __constraint_1_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(self,_t__0,_t__1,_t__2):
    return self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(_0,_1,_2)
  def __constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(self,_0,_1,_2):
   _3=None
   _4=numpy.int32((_1._getShape_()._size))
   if ((int(len(_0)) > 0) and self._hasConstraint_S(_0)):
    raise mosek_fusion_NameError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Duplicate constraint name '")._a_S(_0)._a_S("'")._toString_())
   _5=((_2._shape) if (((_2._shape) is not None) ) else _1._getShape_())
   if ((((_2._shape) is not None) and (not (_2._shape)._compare_Lmosek_4fusion_4Set_2(_5))) or ((_1._getShape_() is not None) and (not _5._compare_Lmosek_4fusion_4Set_2(_1._getShape_())))):
    raise mosek_fusion_DimensionError._ctor_S("Mismatching shape and domain")
   _6=numpy.int32(((mosek.fusion.Utils.Tools._sqrt_D((1 + (8 * _5._dim_I(0)))) - 1) / 2))
   if (((_6 * (_6 + 1)) // 2)!=_5._dim_I(0)):
    raise mosek_fusion_DimensionError._ctor_S("Invalid size for semidefinite variable")
   _7=0
   _8=_5._dim_I(0)
   _9=1
   for _10 in range(1,(_5.nd)):
    _9 *= _5._dim_I(_10)
   _11=_1._eval_()
   for _12 in range(0,int(((_11.x)).shape[0])):
    if (((_11.x)[_12]._getModel_() is not None) and ((_11.x)[_12]._getModel_() is not self)):
     raise mosek_fusion_ModelError._ctor_S("Expression belong to different models")
   _13=self.__build_1conA__3JJ_3J_3J_3D_3D_3Lmosek_4fusion_4Variable_2((_11.ptrb),(_5._size),(_11.inst),(_11.subj),(_11.cof),(_11.bfix),(_11.x))
   _14=(int(((_13.ptrb)).shape[0]) - 1)
   _15=self.__task_vars_used
   _16=self._task_1numcon_()
   _17=self._task_1numcone_()
   _18=self._task_1numbarvar_()
   try:
    _19=self._task_1append_1con_I(_14)
    _20=(_19 + _14)
    if (((_13.subj) is not None) and (int(((_13.subj)).shape[0]) > 0)):
     self._task_1putarowslice_II_3J_3I_3D(_19,_20,(_13.ptrb),(_13.subj),(_13.cof))
    if ((_13.barsubi) is not None):
     for _21 in range(0,int(((_13.barsubi)).shape[0])):
      self._task_1putbaraij_III(((_13.barsubi)[_21] + _19),(_13.barsubj)[_21],(_13.barmidx)[_21])
    _22=mosek.fusion.Utils.Tools._range_II(_19,_20)
    _23=(numpy.zeros(((_20 - _19),), dtype=numpy.dtype(numpy.float64)) if (((_13.bfix) is None) ) else numpy.array([(- (_13.bfix)[_24]) for _24 in range(0,(_20 - _19))], dtype=numpy.dtype(numpy.float64)))
    _25=(_8 * _9)
    _26=(numpy.array([(- (_13.bfix)[_27]) for _27 in range(0,_25)], dtype=numpy.dtype(numpy.float64)) if (((_11.bfix) is not None) ) else numpy.zeros((_25,), dtype=numpy.dtype(numpy.float64)))
    self._task_1con_1putboundslice_1fx_II_3D(_19,_20,_26)
    _28=self._task_1append_1barvar_II(_6,_9)
    _29=numpy.zeros((1,), dtype=numpy.dtype(numpy.int32))
    _30=numpy.zeros((1,), dtype=numpy.dtype(numpy.int32))
    _31=numpy.zeros((1,), dtype=numpy.dtype(numpy.float64))
    _32=0
    for _33 in range(0,_6):
     _30[0] = _33
     for _34 in range(_33,_6):
      _29[0] = _34
      _31[0] = (- (1.0 if ((_34==_33) ) else 0.5))
      _35=self._task_1append_1barmatrix_I_3I_3I_3D(_6,_29,_30,_31)
      for _36 in range(0,_9):
       self._task_1putbaraij_III(((_19 + _32) + (_36 * _8)),(_28 + _36),_35)
      _32 += 1
    _3 = mosek_fusion_LinearPSDConstraint._ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2_3IIII_3J_3I_3D_3D_3I_3I_3I(self,_0,_5,mosek.fusion.Utils.Tools._range_II(_19,_20),_8,_28,_9,(_13.ptrb),(_13.subj),(_13.cof),(_13.bfix),(_13.barsubi),(_13.barsubj),(_13.barmidx))
    self.__addConstraint_SLmosek_4fusion_4ModelConstraint_2(_0,_3)
   finally:
    if (_3 is None):
     self.__natvarmap_num = _15
     self._natbarvarmap_num = _18
     self._task_1cleanup_IIII(_15,_16,_17,_18)
   return (_3)
  def __constraint_1_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(self,_t__0,_t__1,_t__2):
    return self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(_0,_1,_2)
  def __constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(self,_0,_1,_2):
   if ((_2._key)==mosek.fusion.PSDKey.IsSymPSD):
    return (self.__nonsym_1psdconstraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(_0,_1,_2))
   elif ((_2._key)==mosek.fusion.PSDKey.IsTrilPSD):
    _4=_1._eval_()
    for _5 in range(0,int(((_4.x)).shape[0])):
     if (((_4.x)[_5]._getModel_() is not None) and ((_4.x)[_5]._getModel_() is not self)):
      raise mosek_fusion_ModelError._ctor_S("Expression belong to different models")
    if (not (((((_4.shape).nd)==2) and ((_4.shape)._dim_I(0)==(_4.shape)._dim_I(1))) or ((((_4.shape).nd)==3) and ((_4.shape)._dim_I(1)==(_4.shape)._dim_I(2))))):
     raise mosek_fusion_DomainError._ctor_S("Invalid expression shape for semidefinite constraint")
    _6=(1 if ((((_4.shape).nd)==2) ) else (_4.shape)._dim_I(0))
    _7=((_4.shape)._dim_I(0) if ((((_4.shape).nd)==2) ) else (_4.shape)._dim_I(1))
    _8=(((_6 * _7) * (_7 + 1)) // 2)
    if (((_2._shape) is not None) and ((((_2._shape).nd)!=((_4.shape).nd)) or (((((_2._shape).nd)==2) and (((_2._shape)._dim_I(0)!=_7) or ((_2._shape)._dim_I(1)!=_7))) or ((((_2._shape).nd)==3) and (((_2._shape)._dim_I(0)!=_6) or (((_2._shape)._dim_I(1)!=_7) or ((_2._shape)._dim_I(2)!=_7))))))):
     raise mosek_fusion_DomainError._ctor_S("Expression shape does not match domain")
    _9=numpy.zeros((_8,), dtype=numpy.dtype(numpy.int64))
    fragments._c_closure_34(_6,_7,_9) # src/fusion/Model.mbi:972:11-981:12
    _10=(_4.bfix)
    if (_10 is None):
     _10 = numpy.zeros(((int(((_4.ptrb)).shape[0]) - 1),), dtype=numpy.dtype(numpy.float64))
    return (self.__sdptrilcon_SII_3J_3J_3J_3J_3D_3D_3Lmosek_4fusion_4Variable_2(_0,_7,_6,(_4.ptrb),(_4.inst),_9,(_4.subj),(_4.cof),_10,(_4.x)))
   else:
    raise mosek_fusion_UnexpectedError._ctor_S("Invalid domain")
  def __nonsym_1psdconstraint_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(self,_t__0,_t__1,_t__2):
    return self.__nonsym_1psdconstraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(_0,_1,_2)
  def __nonsym_1psdconstraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(self,_0,_1,_2):
   _3=_1._eval_()
   if ((((_3.shape).nd)==2) and ((_3.shape)._dim_I(0)!=(_3.shape)._dim_I(1))):
    raise mosek_fusion_DomainError._ctor_S("Invalid expression shape for semidefinite constraint")
   elif ((((_3.shape).nd)==3) and ((_3.shape)._dim_I(1)!=(_3.shape)._dim_I(2))):
    raise mosek_fusion_DomainError._ctor_S("Invalid expression shape for semidefinite constraint")
   _4=(_3.shape)._dim_I(1)
   _5=(1 if ((((_3.shape).nd)==2) ) else (_3.shape)._dim_I(0))
   _6=(((_5 * _4) * (_4 + 1)) // 2)
   if ((_2._shape) is not None):
    if (((_2._shape).nd)!=((_3.shape).nd)):
     raise mosek_fusion_DomainError._ctor_S("Expression shape does not match domain")
    elif ((((_2._shape).nd)==2) and (((_2._shape)._dim_I(0)!=_4) or ((_2._shape)._dim_I(1)!=_4))):
     raise mosek_fusion_DomainError._ctor_S("Expression shape does not match domain")
    elif ((((_2._shape).nd)==3) and (((_2._shape)._dim_I(1)!=_4) or (((_2._shape)._dim_I(2)!=_4) or ((_2._shape)._dim_I(0)!=_5)))):
     raise mosek_fusion_DomainError._ctor_S("Expression shape does not match domain")
   if (((_3.inst) is None) or (int(((_3.inst)).shape[0])==_6)):
    _7=_6
    _8=numpy.zeros((_7,), dtype=numpy.dtype(numpy.int64))
    _9=numpy.zeros(((_7 + 1),), dtype=numpy.dtype(numpy.int64))
    _10=numpy.zeros((int(((_3.subj)).shape[0]),), dtype=numpy.dtype(numpy.float64))
    _11=numpy.zeros((int(((_3.subj)).shape[0]),), dtype=numpy.dtype(numpy.int64))
    _12=numpy.array([_13 for _13 in range(0,_7)], dtype=numpy.dtype(numpy.int64))
    _14=None
    _15=0
    for _16 in range(0,_5):
     for _17 in range(0,_4):
      for _18 in range(0,(_17 + 1)):
       _19=numpy.int64(((((_16 * _4) * _4) + (_17 * _4)) + _18))
       _20=numpy.int64(((((_16 * _4) * _4) + (_18 * _4)) + _17))
       if (_17==_18):
        _9[(_15 + 1)] = ((_3.ptrb)[(_19 + 1)] - (_3.ptrb)[_19])
       else:
        _9[(_15 + 1)] = ((((_3.ptrb)[(_19 + 1)] - (_3.ptrb)[_19]) + (_3.ptrb)[(_20 + 1)]) - (_3.ptrb)[_20])
       _8[_15] = _19
       _15 += 1
    fragments._c_closure_35(_6,_9) # src/fusion/Model.mbi:796:13-69
    if ((_3.bfix) is not None):
     _14 = numpy.zeros((int((_8).shape[0]),), dtype=numpy.dtype(numpy.float64))
     _21=0
     for _22 in range(0,_5):
      for _23 in range(0,_4):
       for _24 in range(0,(_23 + 1)):
        _25=numpy.int64(((((_22 * _4) * _4) + (_23 * _4)) + _24))
        _26=numpy.int64(((((_22 * _4) * _4) + (_24 * _4)) + _23))
        if (_23==_24):
         _14[_21] = (_3.bfix)[_25]
        else:
         _14[_21] = (0.5 * ((_3.bfix)[_25] + (_3.bfix)[_26]))
        _21 += 1
    _27=0
    for _28 in range(0,_5):
     for _29 in range(0,_4):
      for _30 in range(0,(_29 + 1)):
       _31=((((_28 * _4) * _4) + (_29 * _4)) + _30)
       _32=((((_28 * _4) * _4) + (_30 * _4)) + _29)
       if (_29==_30):
        mosek.fusion.Utils.Tools._arraycopy__3JJ_3JJJ((_3.subj),(_3.ptrb)[_31],_11,_9[_27],((_3.ptrb)[(_31 + 1)] - (_3.ptrb)[_31]))
        mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ((_3.cof),(_3.ptrb)[_31],_10,_9[_27],((_3.ptrb)[(_31 + 1)] - (_3.ptrb)[_31]))
       else:
        _33=((_3.ptrb)[(_31 + 1)] - (_3.ptrb)[_31])
        _34=((_3.ptrb)[(_32 + 1)] - (_3.ptrb)[_32])
        mosek.fusion.Utils.Tools._arraycopy__3JJ_3JJJ((_3.subj),(_3.ptrb)[_31],_11,_9[_27],_33)
        mosek.fusion.Utils.Tools._arraycopy__3JJ_3JJJ((_3.subj),(_3.ptrb)[_32],_11,(_9[_27] + _33),_34)
        for _35 in range(0,_33):
         _10[(_9[_27] + _35)] = (0.5 * (_3.cof)[((_3.ptrb)[_31] + _35)])
        for _36 in range(0,_34):
         _10[((_9[_27] + _33) + _36)] = (0.5 * (_3.cof)[((_3.ptrb)[_32] + _36)])
       _27 += 1
    return (self.__sdptrilcon_SII_3J_3J_3J_3J_3D_3D_3Lmosek_4fusion_4Variable_2(_0,_4,_5,_9,_8,_12,_11,_10,_14,(_3.x)))
   else:
    _37=(_4 * _4)
    _38=mosek.fusion.Utils.Tools._arraycopy__3J((_3.inst))
    for _39 in range(0,int((_38).shape[0])):
     _40=((_3.inst)[_39] // _37)
     _41=(((_3.inst)[_39] // _4) % _4)
     _42=((_3.inst)[_39] % _4)
     if (_42 > _41):
      _38[_39] = (((_40 * _37) + (_42 * _4)) + _41)
     else:
      _38[_39] = (_3.inst)[_39]
     if (_41!=_42):
      for _43 in range((_3.ptrb)[_39],(_3.ptrb)[(_39 + 1)]):
       (_3.cof)[_43] /= 2
      if ((_3.bfix) is not None):
       (_3.bfix)[_39] /= 2
    _44=numpy.array([_45 for _45 in range(0,int((_38).shape[0]))], dtype=numpy.dtype(numpy.int64))
    _46=numpy.zeros((((_5 * _4) + 1),), dtype=numpy.dtype(numpy.int64))
    mosek.fusion.Sort._argTransposeSort__3J_3JIII_3J(_44,_46,_5,_4,_4,_38)
    mosek.fusion.Sort._argTransposeSort__3J_3JIII_3J(_44,_46,(_5 * _4),_4,1,_38)
    _47=0
    _47 = fragments._c_closure_36(_47,_38,_44) # src/fusion/Model.mbi:882:11-888:12
    _47 = numpy.int32(_47) # postprocess
    if (int((_38).shape[0])==_47):
     return (self.__sdptrilcon_SII_3J_3J_3J_3J_3D_3D_3Lmosek_4fusion_4Variable_2(_0,_4,_5,(_3.ptrb),_38,_44,(_3.subj),(_3.cof),(_3.bfix),(_3.x)))
    else:
     _48=numpy.zeros(((_47 + 1),), dtype=numpy.dtype(numpy.int64))
     _49=numpy.zeros((_47,), dtype=numpy.dtype(numpy.int64))
     _50=numpy.zeros((int(((_3.subj)).shape[0]),), dtype=numpy.dtype(numpy.int64))
     _51=numpy.zeros((int(((_3.subj)).shape[0]),), dtype=numpy.dtype(numpy.float64))
     _52=numpy.zeros((_47,), dtype=numpy.dtype(numpy.float64))
     _53=0
     _54=0
     for _55 in range(0,int((_44).shape[0])):
      if ((_55 > 0) and (_38[_44[_55]]!=_38[_44[(_55 - 1)]])):
       _53 += 1
      _56=((_3.ptrb)[(_44[_55] + 1)] - (_3.ptrb)[_44[_55]])
      mosek.fusion.Utils.Tools._arraycopy__3JJ_3JJJ((_3.subj),(_3.ptrb)[_44[_55]],_50,_54,_56)
      mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ((_3.cof),(_3.ptrb)[_44[_55]],_51,_54,_56)
      _54 += _56
      _48[(_53 + 1)] = _54
      _49[_53] = _38[_44[_55]]
     if ((_3.bfix) is not None):
      _57=0
      for _58 in range(0,int((_44).shape[0])):
       if ((_58 > 0) and (_38[_44[_58]]!=_38[_44[(_58 - 1)]])):
        _57 += 1
       _59=(((_3.inst)[_44[_58]] // _4) % _4)
       _60=((_3.inst)[_44[_58]] % _4)
       _52[_57] += (_3.bfix)[_44[_58]]
     return (self.__sdptrilcon_SII_3J_3J_3J_3J_3D_3D_3Lmosek_4fusion_4Variable_2(_0,_4,_5,_48,_49,mosek.fusion.Utils.Tools._range_J(long((_49).shape[0])),_50,_51,_52,(_3.x)))
  def __sdptrilcon_alt_SII_3J_3J_3J_3J_3D_3D_3Lmosek_4fusion_4Variable_2(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7,_t__8,_t__9):
   _0=_t__0
   _1=numpy.int32(_t__1)
   _2=numpy.int32(_t__2)
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int64))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int64))
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.int64))
   _6=numpy.array(_t__6,dtype=numpy.dtype(numpy.int64))
   _7=numpy.array(_t__7,dtype=numpy.dtype(numpy.float64))
   _8=numpy.array(_t__8,dtype=numpy.dtype(numpy.float64))
   _9=numpy.array(_t__9,dtype=numpy.dtype(object))
   _1 = self.__sdptrilcon_SII_3J_3J_3J_3J_3D_3D_3Lmosek_4fusion_4Variable_2(_0,_1,_2,_3,_4,_5,_6,_7,_8,_9)
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__6[:] = _6
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__7[:] = _7
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__8[:] = _8
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__9[:] = _9
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __sdptrilcon_SII_3J_3J_3J_3J_3D_3D_3Lmosek_4fusion_4Variable_2(self,_0,_1,_2,_3,_4,_5,_6,_7,_8,_9):
   _10=None
   _11=0
   _11 = fragments._c_closure_37(_11,_5,_3) # src/fusion/Model.mbi:511:31-110
   _11 = numpy.int64(_11) # postprocess
   _12=numpy.zeros((_11,), dtype=numpy.dtype(numpy.int32))
   _13=numpy.zeros((_11,), dtype=numpy.dtype(numpy.int32))
   _14=numpy.zeros((_11,), dtype=numpy.dtype(numpy.int32))
   _15=numpy.zeros(((int((_5).shape[0]) + 1),), dtype=numpy.dtype(numpy.int64))
   _16=0
   for _17 in range(0,int((_5).shape[0])):
    mosek.fusion.Model.__inst__3Lmosek_4fusion_4Variable_2II_3JI_3I_3I_3I(_9,numpy.int32(_3[_5[_17]]),numpy.int32(_3[(_5[_17] + 1)]),_6,_16,_12,_13,_14)
    _16 = (_16 + numpy.int32((_3[(_5[_17] + 1)] - _3[_5[_17]])))
    _15[(_17 + 1)] = _16
   _18=(_2 * ((_1 * (_1 + 1)) // 2))
   _19=0
   _19 = fragments._c_closure_38(_11,_19,_12) # src/fusion/Model.mbi:536:9-64
   _19 = numpy.int64(_19) # postprocess
   _20=(_11 - _19)
   _21=mosek.fusion.Utils.Tools._range_J(_11)
   for _22 in range(0,int((_5).shape[0])):
    mosek.fusion.CommonTools._argQsort__3J_3I_3IJJ(_21,_12,None,_15[_22],_15[(_22 + 1)])
   _23=0
   _23 = fragments._c_closure_39(_23,_5,_21,_15,_12) # src/fusion/Model.mbi:546:9-555:10
   _23 = numpy.int64(_23) # postprocess
   _24=numpy.zeros((int((_5).shape[0]),), dtype=numpy.dtype(numpy.int64))
   fragments._c_closure_40(_4,_1,_5,_24) # src/fusion/Model.mbi:560:9-577:10
   _25=self.__task_vars_used
   _26=self._task_1numcon_()
   _27=self._task_1numcone_()
   _28=self._task_1numbarvar_()
   try:
    _29=self._task_1append_1con_I(_18)
    _30=(_29 + _18)
    _31=numpy.zeros(((_18 + 1),), dtype=numpy.dtype(numpy.int64))
    _32=numpy.zeros((_23,), dtype=numpy.dtype(numpy.int32))
    _33=numpy.zeros((_23,), dtype=numpy.dtype(numpy.float64))
    if (_20 > 0):
     _34=0
     _34 = fragments._c_closure_41(_33,_18,_5,_21,_24,_31,_34,_32,_15,_12,_7) # src/fusion/Model.mbi:598:13-628:14
     _34 = numpy.int64(_34) # postprocess
     self._task_1putarowslice_II_3J_3I_3D(_29,_30,_31,_32,_33)
    _35=numpy.zeros((_18,), dtype=numpy.dtype(numpy.float64))
    fragments._c_closure_42(_35,_8,_5,_24) # src/fusion/Model.mbi:635:11-636:69
    self._task_1con_1putboundslice_1fx_II_3D(_29,_30,_35)
    if (_19 > 0):
     for _36 in range(0,int((_5).shape[0])):
      _37=_3[_5[_36]]
      _38=_3[(_5[_36] + 1)]
      _39=_37
      _39 = fragments._c_closure_43(_38,_39,_21,_12) # src/fusion/Model.mbi:646:28-76
      _39 = numpy.int64(_39) # postprocess
      if (_37 < _39):
       _40=_12[_21[_37]]
       while (_37 < _39):
        _41=_37
        _37 = fragments._c_closure_44(_40,_37,_39,_21,_12) # src/fusion/Model.mbi:654:19-77
        _37 = numpy.int64(_37) # postprocess
        _42=(- (_40 + 1))
        mosek.fusion.CommonTools._argQsort__3J_3I_3IJJ(_21,_13,_14,_41,_37)
        _43=1
        _43 = fragments._c_closure_45(_43,_37,_41,_21,_13,_14) # src/fusion/Model.mbi:660:19-663:36
        _43 = numpy.int32(_43) # postprocess
        _44=numpy.zeros((_43,), dtype=numpy.dtype(numpy.int32))
        _45=numpy.zeros((_43,), dtype=numpy.dtype(numpy.int32))
        _46=numpy.zeros((_43,), dtype=numpy.dtype(numpy.float64))
        fragments._c_closure_46(_44,_45,_46,_37,_41,_21,_13,_14,_7) # src/fusion/Model.mbi:667:19-682:20
        _47=self._task_1barvardim_I(_42)
        _48=self._task_1append_1barmatrix_I_3I_3I_3D(_47,_44,_45,_46)
        self._task_1putbaraij_III(numpy.int32((_24[_36] + _29)),_42,_48)
    _49=self._task_1append_1barvar_II(_1,_2)
    _50=numpy.zeros((1,), dtype=numpy.dtype(numpy.int32))
    _51=numpy.zeros((1,), dtype=numpy.dtype(numpy.int32))
    _52=numpy.zeros((1,), dtype=numpy.dtype(numpy.float64))
    for _53 in range(0,_1):
     for _54 in range(0,(_53 + 1)):
      _50[0] = _53
      _51[0] = _54
      _52[0] = (- (1.0 if ((_53==_54) ) else 0.5))
      _55=self._task_1append_1barmatrix_I_3I_3I_3D(_1,_50,_51,_52)
      for _56 in range(0,_2):
       _57=(((((_56 * _1) * (_1 + 1)) // 2) + ((_53 * (_53 + 1)) // 2)) + _54)
       self._task_1putbaraij_III((_29 + _57),(_49 + _56),_55)
    _58=None
    if (_2==1):
     _58 = mosek_fusion_NDSet._ctor_II(_1,_1)
    else:
     _58 = mosek_fusion_NDSet._ctor_III(_1,_1,_2)
    _10 = mosek_fusion_PSDConstraint._ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2_3IIII_3J_3I_3D_3D_3I_3I_3I(self,_0,_58,mosek.fusion.Utils.Tools._range_II(_29,_30),_1,_49,_2,_31,_32,_33,_35,None,None,None)
    self.__natbarvarmap_1ensure_I(_2)
    self._natbarvarmap_num += _2
    self.__addConstraint_SLmosek_4fusion_4ModelConstraint_2(_0,_10)
    return (_10)
   finally:
    if (_10 is None):
     self._natbarvarmap_num = _28
     self.__natvarmap_num = _25
     self._task_1cleanup_IIII(_25,_26,_27,_28)
  def __addConstraint_alt_SLmosek_4fusion_4ModelConstraint_2(self,_t__0,_t__1):
    return self.__addConstraint_SLmosek_4fusion_4ModelConstraint_2(_0,_1)
  def __addConstraint_SLmosek_4fusion_4ModelConstraint_2(self,_0,_1):
   if (self.__cons_used >= int((self.__cons).shape[0])):
    _2=((int((self.__cons).shape[0]) * 2) if ((int((self.__cons).shape[0]) > 100) ) else 100)
    _3=self.__cons
    self.__cons = numpy.zeros((_2,), dtype=numpy.dtype(object))
    for _4 in range(0,self.__cons_used):
     self.__cons[_4] = _3[_4]
   self.__cons[self.__cons_used] = _1
   if (int(len(_0)) > 0):
    self.__con_map._setItem_SI(_0,self.__cons_used)
   self.__cons_used += 1
  def __addVariable_alt_SLmosek_4fusion_4ModelVariable_2(self,_t__0,_t__1):
    return self.__addVariable_SLmosek_4fusion_4ModelVariable_2(_0,_1)
  def __addVariable_SLmosek_4fusion_4ModelVariable_2(self,_0,_1):
   if (self._vars_used >= int((self._vars).shape[0])):
    _2=((int((self._vars).shape[0]) * 2) if ((int((self._vars).shape[0]) > 100) ) else 100)
    _3=self._vars
    self._vars = numpy.zeros((_2,), dtype=numpy.dtype(object))
    for _4 in range(0,self._vars_used):
     self._vars[_4] = _3[_4]
   self._vars[self._vars_used] = _1
   if (int(len(_0)) > 0):
    self.__var_map._setItem_SI(_0,self._vars_used)
   self._vars_used += 1
  @staticmethod
  def _match_numConstraints_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_numConstraints_(*args):
    if len(args) != 0: return False
    return True
  def _numConstraints_alt_(self,):
    return self._numConstraints_()
  def _numConstraints_(self,):
   return numpy.int32(self.__cons_used)
  @staticmethod
  def _match_numVariables_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_numVariables_(*args):
    if len(args) != 0: return False
    return True
  def _numVariables_alt_(self,):
    return self._numVariables_()
  def _numVariables_(self,):
   return numpy.int32(self._vars_used)
  @staticmethod
  def _match_hasConstraint_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_S__(_0))
  @staticmethod
  def _match_alt_hasConstraint_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_S__(_0))
  def _hasConstraint_alt_S(self,_t__0):
    return self._hasConstraint_S(_0)
  def _hasConstraint_S(self,_0):
   return (self.__con_map._hasItem_S(_0))
  @staticmethod
  def _match_hasVariable_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_S__(_0))
  @staticmethod
  def _match_alt_hasVariable_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_S__(_0))
  def _hasVariable_alt_S(self,_t__0):
    return self._hasVariable_S(_0)
  def _hasVariable_S(self,_0):
   return (self.__var_map._hasItem_S(_0))
  @staticmethod
  def _match_getConstraint_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_getConstraint_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _getConstraint_alt_I(self,_t__0):
    return self._getConstraint_I(numpy.int32(__0))
  def _getConstraint_I(self,_0):
   return ((self.__cons[_0] if (((_0 >= 0) and (_0 < self.__cons_used)) ) else None))
  @staticmethod
  def _match_getConstraint_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_S__(_0))
  @staticmethod
  def _match_alt_getConstraint_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_S__(_0))
  def _getConstraint_alt_S(self,_t__0):
    return self._getConstraint_S(_0)
  def _getConstraint_S(self,_0):
   return ((self.__cons[self.__con_map._getItem_S(_0)] if (self.__con_map._hasItem_S(_0) ) else None))
  @staticmethod
  def _match_getVariable_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_getVariable_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _getVariable_alt_I(self,_t__0):
    return self._getVariable_I(numpy.int32(__0))
  def _getVariable_I(self,_0):
   return ((self._vars[_0] if (((_0 >= 0) and (_0 < self._vars_used)) ) else None))
  @staticmethod
  def _match_getVariable_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_S__(_0))
  @staticmethod
  def _match_alt_getVariable_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_S__(_0))
  def _getVariable_alt_S(self,_t__0):
    return self._getVariable_S(_0)
  def _getVariable_S(self,_0):
   return ((self._vars[self.__var_map._getItem_S(_0)] if (self.__var_map._hasItem_S(_0) ) else None))
  @staticmethod
  def _match_getName_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getName_(*args):
    if len(args) != 0: return False
    return True
  def _getName_alt_(self,):
    return self._getName_()
  def _getName_(self,):
   return (self.__model_name)
  @staticmethod
  def _match_clone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_clone_(*args):
    if len(args) != 0: return False
    return True
  def _clone_alt_(self,):
    return self._clone_()
  def _clone_(self,):
   return (mosek_fusion_Model._ctor_Lmosek_4fusion_4Model_2(self))
  def __natbarvarmap_1ensure_alt_I(self,_t__0):
    return self.__natbarvarmap_1ensure_I(numpy.int32(__0))
  def __natbarvarmap_1ensure_I(self,_0):
   if ((self._natbarvarmap_num + _0) > int((self._natbarvarmap_Var).shape[0])):
    _1=(2 * int((self._natbarvarmap_Var).shape[0]))
    if (_1 < (self._natbarvarmap_num + _0)):
     _1 = (self._natbarvarmap_num + _0)
    _2=numpy.zeros((_1,), dtype=numpy.dtype(numpy.int32))
    _3=numpy.zeros((_1,), dtype=numpy.dtype(numpy.int32))
    fragments._c_closure_47(self._natbarvarmap_Var,self._natbarvarmap_num,_2) # src/fusion/Model.mbi:312:11-82
    self._natbarvarmap_Var = _2
  def __natvarmap_1ensure_alt_I(self,_t__0):
    return self.__natvarmap_1ensure_I(numpy.int32(__0))
  def __natvarmap_1ensure_I(self,_0):
   if ((self.__natvarmap_num + _0) > int((self.__natvarmap_idx).shape[0])):
    _1=(2 * int((self.__natvarmap_idx).shape[0]))
    if (_1 < (self.__natvarmap_num + _0)):
     _1 = (self.__natvarmap_num + _0)
    _2=numpy.zeros((_1,), dtype=numpy.dtype(numpy.int64))
    mosek.fusion.Utils.Tools._arraycopy__3JI_3JII(self.__natvarmap_idx,0,_2,0,self.__natvarmap_num)
    _3=numpy.zeros((_1,), dtype=numpy.dtype(numpy.int32))
    fragments._c_closure_48(self.__natvarmap_Var,self.__natvarmap_num,_3) # src/fusion/Model.mbi:294:11-295:47
    self.__natvarmap_idx = _2
    self.__natvarmap_Var = _3
  def __task_1alloc_1vars_alt_I(self,_t__0):
    return self.__task_1alloc_1vars_I(numpy.int32(__0))
  def __task_1alloc_1vars_I(self,_0):
   if ((self.__task_vars_allocated - self.__task_vars_used) < _0):
    _1=(1000 if ((((_0 + self.__task_vars_used) - self.__task_vars_allocated) < 1000) ) else _0)
    self._task_1append_1var_I(_1)
    self.__task_vars_allocated += _1
   _2=self.__task_vars_used
   self.__task_vars_used += _0
   return numpy.int32(_2)
 return Model
mosek_fusion_Model=__mk_mosek_fusion_Model()
del __mk_mosek_fusion_Model
def __mk_mosek_fusion_Debug():
  class Debug:
    @staticmethod 
    def _o_(): return Debug()
    def p(self,v): 
      sys.stdout.write(str(v))
      return self
    _p_S = p
    _p_I = p
    _p_J = p
    _p_D = p
    _p_Z = p
  
    def p_array (self,v):
      if v is None:
          sys.stdout.write('None')
      else:
          sys.stdout.write('[ %s ]' % ','.join([str(i) for i in v]))
      return self
  
    _p__3I = p_array
    _p__3J = p_array
    _p__3D = p_array
  
    def _lf_(self): 
      sys.stdout.write("\n")
      return self
  
  return Debug
mosek_fusion_Debug=__mk_mosek_fusion_Debug()
#BEFORE CLASS
def __mk_mosek_fusion_Sort():
 class Sort(object):
  @staticmethod
  def argsort(*args):
    if False: pass
    elif mosek_fusion_Sort._match_argsort__3J_3J(*args): # []int64,[]int64
      return mosek_fusion_Sort._argsort__3J_3J(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3J(*args): # []int64,[]int64
      return mosek_fusion_Sort._argsort_alt__3J_3J(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3I(*args): # []int64,[]int32
      return mosek_fusion_Sort._argsort__3J_3I(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3I(*args): # []int64,[]int32
      return mosek_fusion_Sort._argsort_alt__3J_3I(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3I_3I(*args): # []int64,[]int32,[]int32
      return mosek_fusion_Sort._argsort__3J_3I_3I(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3I_3I(*args): # []int64,[]int32,[]int32
      return mosek_fusion_Sort._argsort_alt__3J_3I_3I(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3J_3J(*args): # []int64,[]int64,[]int64
      return mosek_fusion_Sort._argsort__3J_3J_3J(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3J_3J(*args): # []int64,[]int64,[]int64
      return mosek_fusion_Sort._argsort_alt__3J_3J_3J(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3JJJ(*args): # []int64,[]int64,int64,int64
      return mosek_fusion_Sort._argsort__3J_3JJJ(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3JJJ(*args): # []int64,[]int64,int64,int64
      return mosek_fusion_Sort._argsort_alt__3J_3JJJ(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3IJJ(*args): # []int64,[]int32,int64,int64
      return mosek_fusion_Sort._argsort__3J_3IJJ(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3IJJ(*args): # []int64,[]int32,int64,int64
      return mosek_fusion_Sort._argsort_alt__3J_3IJJ(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3I_3IJJ(*args): # []int64,[]int32,[]int32,int64,int64
      return mosek_fusion_Sort._argsort__3J_3I_3IJJ(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3I_3IJJ(*args): # []int64,[]int32,[]int32,int64,int64
      return mosek_fusion_Sort._argsort_alt__3J_3I_3IJJ(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3IJJZ(*args): # []int64,[]int32,int64,int64,bool
      return mosek_fusion_Sort._argsort__3J_3IJJZ(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3IJJZ(*args): # []int64,[]int32,int64,int64,bool
      return mosek_fusion_Sort._argsort_alt__3J_3IJJZ(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3JJJZ(*args): # []int64,[]int64,int64,int64,bool
      return mosek_fusion_Sort._argsort__3J_3JJJZ(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3JJJZ(*args): # []int64,[]int64,int64,int64,bool
      return mosek_fusion_Sort._argsort_alt__3J_3JJJZ(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3J_3JJJ(*args): # []int64,[]int64,[]int64,int64,int64
      return mosek_fusion_Sort._argsort__3J_3J_3JJJ(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3J_3JJJ(*args): # []int64,[]int64,[]int64,int64,int64
      return mosek_fusion_Sort._argsort_alt__3J_3J_3JJJ(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3I_3IJJZ(*args): # []int64,[]int32,[]int32,int64,int64,bool
      return mosek_fusion_Sort._argsort__3J_3I_3IJJZ(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3I_3IJJZ(*args): # []int64,[]int32,[]int32,int64,int64,bool
      return mosek_fusion_Sort._argsort_alt__3J_3I_3IJJZ(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3J_3JJJZ(*args): # []int64,[]int64,[]int64,int64,int64,bool
      return mosek_fusion_Sort._argsort__3J_3J_3JJJZ(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3J_3JJJZ(*args): # []int64,[]int64,[]int64,int64,int64,bool
      return mosek_fusion_Sort._argsort_alt__3J_3J_3JJJZ(*args)
    else:
      raise ValueError('Invalid argument list argsort('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int64,ndim=1))\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int32,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int64,ndim=1),array(int64,ndim=1))\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int64,ndim=1),int64,int64)\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int32,ndim=1),int64,int64)\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int32,ndim=1),array(int32,ndim=1),int64,int64)\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int32,ndim=1),int64,int64,bool)\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int64,ndim=1),int64,int64,bool)\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int64,ndim=1),array(int64,ndim=1),int64,int64)\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int32,ndim=1),array(int32,ndim=1),int64,int64,bool)\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int64,ndim=1),array(int64,ndim=1),int64,int64,bool)')
  @staticmethod
  def argTransposeSort(*args):
    if False: pass
    elif mosek_fusion_Sort._match_argTransposeSort__3J_3JIII_3J(*args): # []int64,[]int64,int32,int32,int32,[]int64
      return mosek_fusion_Sort._argTransposeSort__3J_3JIII_3J(*args)
    elif mosek_fusion_Sort._match_alt_argTransposeSort__3J_3JIII_3J(*args): # []int64,[]int64,int32,int32,int32,[]int64
      return mosek_fusion_Sort._argTransposeSort_alt__3J_3JIII_3J(*args)
    else:
      raise ValueError('Invalid argument list argTransposeSort('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Sort.argTransposeSort(array(int64,ndim=1),array(int64,ndim=1),int32,int32,int32,array(int64,ndim=1))')
  @staticmethod
  def issorted(*args):
    if False: pass
    elif mosek_fusion_Sort._match_issorted__3J_3IJJZ(*args): # []int64,[]int32,int64,int64,bool
      return mosek_fusion_Sort._issorted__3J_3IJJZ(*args)
    elif mosek_fusion_Sort._match_alt_issorted__3J_3IJJZ(*args): # []int64,[]int32,int64,int64,bool
      return mosek_fusion_Sort._issorted_alt__3J_3IJJZ(*args)
    elif mosek_fusion_Sort._match_issorted__3J_3JJJZ(*args): # []int64,[]int64,int64,int64,bool
      return mosek_fusion_Sort._issorted__3J_3JJJZ(*args)
    elif mosek_fusion_Sort._match_alt_issorted__3J_3JJJZ(*args): # []int64,[]int64,int64,int64,bool
      return mosek_fusion_Sort._issorted_alt__3J_3JJJZ(*args)
    elif mosek_fusion_Sort._match_issorted__3J_3I_3IJJZ(*args): # []int64,[]int32,[]int32,int64,int64,bool
      return mosek_fusion_Sort._issorted__3J_3I_3IJJZ(*args)
    elif mosek_fusion_Sort._match_alt_issorted__3J_3I_3IJJZ(*args): # []int64,[]int32,[]int32,int64,int64,bool
      return mosek_fusion_Sort._issorted_alt__3J_3I_3IJJZ(*args)
    elif mosek_fusion_Sort._match_issorted__3J_3J_3JJJZ(*args): # []int64,[]int64,[]int64,int64,int64,bool
      return mosek_fusion_Sort._issorted__3J_3J_3JJJZ(*args)
    elif mosek_fusion_Sort._match_alt_issorted__3J_3J_3JJJZ(*args): # []int64,[]int64,[]int64,int64,int64,bool
      return mosek_fusion_Sort._issorted_alt__3J_3J_3JJJZ(*args)
    else:
      raise ValueError('Invalid argument list issorted('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Sort.issorted(array(int64,ndim=1),array(int32,ndim=1),int64,int64,bool)\n\tmosek.fusion.Sort.issorted(array(int64,ndim=1),array(int64,ndim=1),int64,int64,bool)\n\tmosek.fusion.Sort.issorted(array(int64,ndim=1),array(int32,ndim=1),array(int32,ndim=1),int64,int64,bool)\n\tmosek.fusion.Sort.issorted(array(int64,ndim=1),array(int64,ndim=1),array(int64,ndim=1),int64,int64,bool)')
  @staticmethod
  def argbucketsort(*args):
    if False: pass
    elif mosek_fusion_Sort._match_argbucketsort__3J_3IJJII(*args): # []int64,[]int32,int64,int64,int32,int32
      return mosek_fusion_Sort._argbucketsort__3J_3IJJII(*args)
    elif mosek_fusion_Sort._match_alt_argbucketsort__3J_3IJJII(*args): # []int64,[]int32,int64,int64,int32,int32
      return mosek_fusion_Sort._argbucketsort_alt__3J_3IJJII(*args)
    elif mosek_fusion_Sort._match_argbucketsort__3J_3JJJJJ(*args): # []int64,[]int64,int64,int64,int64,int64
      return mosek_fusion_Sort._argbucketsort__3J_3JJJJJ(*args)
    elif mosek_fusion_Sort._match_alt_argbucketsort__3J_3JJJJJ(*args): # []int64,[]int64,int64,int64,int64,int64
      return mosek_fusion_Sort._argbucketsort_alt__3J_3JJJJJ(*args)
    else:
      raise ValueError('Invalid argument list argbucketsort('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Sort.argbucketsort(array(int64,ndim=1),array(int32,ndim=1),int64,int64,int32,int32)\n\tmosek.fusion.Sort.argbucketsort(array(int64,ndim=1),array(int64,ndim=1),int64,int64,int64,int64)')
  @staticmethod
  def getminmax(*args):
    if False: pass
    elif mosek_fusion_Sort._match_getminmax__3J_3I_3IJJ_3I(*args): # []int64,[]int32,[]int32,int64,int64,[]int32
      return mosek_fusion_Sort._getminmax__3J_3I_3IJJ_3I(*args)
    elif mosek_fusion_Sort._match_alt_getminmax__3J_3I_3IJJ_3I(*args): # []int64,[]int32,[]int32,int64,int64,[]int32
      return mosek_fusion_Sort._getminmax_alt__3J_3I_3IJJ_3I(*args)
    elif mosek_fusion_Sort._match_getminmax__3J_3J_3JJJ_3J(*args): # []int64,[]int64,[]int64,int64,int64,[]int64
      return mosek_fusion_Sort._getminmax__3J_3J_3JJJ_3J(*args)
    elif mosek_fusion_Sort._match_alt_getminmax__3J_3J_3JJJ_3J(*args): # []int64,[]int64,[]int64,int64,int64,[]int64
      return mosek_fusion_Sort._getminmax_alt__3J_3J_3JJJ_3J(*args)
    else:
      raise ValueError('Invalid argument list getminmax('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Sort.getminmax(array(int64,ndim=1),array(int32,ndim=1),array(int32,ndim=1),int64,int64,array(int32,ndim=1))\n\tmosek.fusion.Sort.getminmax(array(int64,ndim=1),array(int64,ndim=1),array(int64,ndim=1),int64,int64,array(int64,ndim=1))')
  def __repr__(self): return 'mosek.fusion.Sort'
  @staticmethod
  def _match_argTransposeSort__3J_3JIII_3J(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match__3J__(_0) and __arg_match__3J__(_1) and __arg_match_I__(_2) and __arg_match_I__(_3) and __arg_match_I__(_4) and __arg_match__3J__(_5))
  @staticmethod
  def _match_alt_argTransposeSort__3J_3JIII_3J(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match_I__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match_I__(_4) and __arg_alt_match__3J__(_5))
  @staticmethod
  def _argTransposeSort_alt__3J_3JIII_3J(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.int32(_t__2)
   _3=numpy.int32(_t__3)
   _4=numpy.int32(_t__4)
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.int64))
   _1 = mosek_fusion_Sort._argTransposeSort__3J_3JIII_3J(_0,_1,_2,_3,_4,_5)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argTransposeSort__3J_3JIII_3J(_0,_1,_2,_3,_4,_5):
   fragments._c_closure_49(_2,_4,_1) # src/fusion/Sort.mbi:251:9-44
   for _6 in range(0,int((_5).shape[0])):
    _1[((((_5[_0[_6]] // (_3 * _4)) * _4) + (_5[_0[_6]] % _4)) + 1)] += 1
   fragments._c_closure_50(_2,_4,_1) # src/fusion/Sort.mbi:253:9-62
   _7=numpy.array([_0[_8] for _8 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int64))
   for _9 in range(0,long((_5).shape[0])):
    _10=(((_5[_7[_9]] // (_3 * _4)) * _4) + (_5[_7[_9]] % _4))
    _0[_1[_10]] = _7[_9]
    _1[_10] += 1
  @staticmethod
  def _match_argsort__3J_3J(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3J__(_0) and __arg_match__3J__(_1))
  @staticmethod
  def _match_alt_argsort__3J_3J(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3J__(_1))
  @staticmethod
  def _argsort_alt__3J_3J(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _1 = mosek_fusion_Sort._argsort__3J_3J(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argsort__3J_3J(_0,_1):
   mosek.fusion.Sort._argsort__3J_3JJJZ(_0,_1,0,int((_0).shape[0]),False)
  @staticmethod
  def _match_argsort__3J_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3J__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_argsort__3J_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _argsort_alt__3J_3I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Sort._argsort__3J_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argsort__3J_3I(_0,_1):
   mosek.fusion.Sort._argsort__3J_3IJJZ(_0,_1,0,int((_0).shape[0]),False)
  @staticmethod
  def _match_argsort__3J_3J_3J(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3J__(_0) and __arg_match__3J__(_1) and __arg_match__3J__(_2))
  @staticmethod
  def _match_alt_argsort__3J_3J_3J(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match__3J__(_2))
  @staticmethod
  def _argsort_alt__3J_3J_3J(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _1 = mosek_fusion_Sort._argsort__3J_3J_3J(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argsort__3J_3J_3J(_0,_1,_2):
   mosek.fusion.Sort._argsort__3J_3J_3JJJZ(_0,_1,_2,0,int((_0).shape[0]),False)
  @staticmethod
  def _match_argsort__3J_3I_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3J__(_0) and __arg_match__3I__(_1) and __arg_match__3I__(_2))
  @staticmethod
  def _match_alt_argsort__3J_3I_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3I__(_2))
  @staticmethod
  def _argsort_alt__3J_3I_3I(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Sort._argsort__3J_3I_3I(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argsort__3J_3I_3I(_0,_1,_2):
   mosek.fusion.Sort._argsort__3J_3I_3IJJZ(_0,_1,_2,0,int((_0).shape[0]),False)
  @staticmethod
  def _match_argsort__3J_3JJJ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match__3J__(_0) and __arg_match__3J__(_1) and __arg_match_J__(_2) and __arg_match_J__(_3))
  @staticmethod
  def _match_alt_argsort__3J_3JJJ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match_J__(_2) and __arg_alt_match_J__(_3))
  @staticmethod
  def _argsort_alt__3J_3JJJ(_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.int64(_t__2)
   _3=numpy.int64(_t__3)
   _1 = mosek_fusion_Sort._argsort__3J_3JJJ(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argsort__3J_3JJJ(_0,_1,_2,_3):
   mosek.fusion.Sort._argsort__3J_3JJJZ(_0,_1,_2,_3,False)
  @staticmethod
  def _match_argsort__3J_3IJJ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match__3J__(_0) and __arg_match__3I__(_1) and __arg_match_J__(_2) and __arg_match_J__(_3))
  @staticmethod
  def _match_alt_argsort__3J_3IJJ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match_J__(_2) and __arg_alt_match_J__(_3))
  @staticmethod
  def _argsort_alt__3J_3IJJ(_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.int64(_t__2)
   _3=numpy.int64(_t__3)
   _1 = mosek_fusion_Sort._argsort__3J_3IJJ(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argsort__3J_3IJJ(_0,_1,_2,_3):
   mosek.fusion.Sort._argsort__3J_3IJJZ(_0,_1,_2,_3,False)
  @staticmethod
  def _match_argsort__3J_3J_3JJJ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match__3J__(_0) and __arg_match__3J__(_1) and __arg_match__3J__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4))
  @staticmethod
  def _match_alt_argsort__3J_3J_3JJJ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4))
  @staticmethod
  def _argsort_alt__3J_3J_3JJJ(_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _1 = mosek_fusion_Sort._argsort__3J_3J_3JJJ(_0,_1,_2,_3,_4)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argsort__3J_3J_3JJJ(_0,_1,_2,_3,_4):
   mosek.fusion.Sort._argsort__3J_3J_3JJJZ(_0,_1,_2,_3,_4,False)
  @staticmethod
  def _match_argsort__3J_3I_3IJJ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match__3J__(_0) and __arg_match__3I__(_1) and __arg_match__3I__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4))
  @staticmethod
  def _match_alt_argsort__3J_3I_3IJJ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4))
  @staticmethod
  def _argsort_alt__3J_3I_3IJJ(_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _1 = mosek_fusion_Sort._argsort__3J_3I_3IJJ(_0,_1,_2,_3,_4)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argsort__3J_3I_3IJJ(_0,_1,_2,_3,_4):
   mosek.fusion.Sort._argsort__3J_3I_3IJJZ(_0,_1,_2,_3,_4,False)
  @staticmethod
  def _match_argsort__3J_3JJJZ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match__3J__(_0) and __arg_match__3J__(_1) and __arg_match_J__(_2) and __arg_match_J__(_3) and __arg_match_Z__(_4))
  @staticmethod
  def _match_alt_argsort__3J_3JJJZ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match_J__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_Z__(_4))
  @staticmethod
  def _argsort_alt__3J_3JJJZ(_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.int64(_t__2)
   _3=numpy.int64(_t__3)
   _4=_t__4
   _1 = mosek_fusion_Sort._argsort__3J_3JJJZ(_0,_1,_2,_3,_4)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argsort__3J_3JJJZ(_0,_1,_2,_3,_4):
   if ((not _4) or ((_3 - _2) < 16)):
    mosek.fusion.Utils.Tools._argsort__3J_3JJJ(_0,_1,_2,_3)
   elif (not mosek.fusion.Sort._issorted__3J_3JJJZ(_0,_1,_2,_3,_4)):
    _5=numpy.zeros((4,), dtype=numpy.dtype(numpy.int64))
    _6=2
    mosek.fusion.Sort._getminmax__3J_3J_3JJJ_3J(_0,_1,None,_2,_3,_5)
    if ((_5[1] - _5[0]) < (_6 * (_3 - _2))):
     mosek.fusion.Sort._argbucketsort__3J_3JJJJJ(_0,_1,_2,_3,_5[0],_5[1])
    else:
     mosek.fusion.Utils.Tools._argsort__3J_3JJJ(_0,_1,_2,_3)
  @staticmethod
  def _match_argsort__3J_3IJJZ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match__3J__(_0) and __arg_match__3I__(_1) and __arg_match_J__(_2) and __arg_match_J__(_3) and __arg_match_Z__(_4))
  @staticmethod
  def _match_alt_argsort__3J_3IJJZ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match_J__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_Z__(_4))
  @staticmethod
  def _argsort_alt__3J_3IJJZ(_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.int64(_t__2)
   _3=numpy.int64(_t__3)
   _4=_t__4
   _1 = mosek_fusion_Sort._argsort__3J_3IJJZ(_0,_1,_2,_3,_4)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argsort__3J_3IJJZ(_0,_1,_2,_3,_4):
   if ((not _4) or ((_3 - _2) < 16)):
    mosek.fusion.Utils.Tools._argsort__3J_3IJJ(_0,_1,_2,_3)
   elif (not mosek.fusion.Sort._issorted__3J_3IJJZ(_0,_1,_2,_3,_4)):
    _5=numpy.zeros((4,), dtype=numpy.dtype(numpy.int32))
    _6=2
    mosek.fusion.Sort._getminmax__3J_3I_3IJJ_3I(_0,_1,None,_2,_3,_5)
    if ((_5[1] - _5[0]) < (_6 * (_3 - _2))):
     mosek.fusion.Sort._argbucketsort__3J_3IJJII(_0,_1,_2,_3,_5[0],_5[1])
    else:
     mosek.fusion.Utils.Tools._argsort__3J_3IJJ(_0,_1,_2,_3)
  @staticmethod
  def _match_argsort__3J_3J_3JJJZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match__3J__(_0) and __arg_match__3J__(_1) and __arg_match__3J__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_argsort__3J_3J_3JJJZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4) and __arg_alt_match_Z__(_5))
  @staticmethod
  def _argsort_alt__3J_3J_3JJJZ(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _5=_t__5
   _1 = mosek_fusion_Sort._argsort__3J_3J_3JJJZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argsort__3J_3J_3JJJZ(_0,_1,_2,_3,_4,_5):
   if ((not _5) or ((_4 - _3) < 16)):
    mosek.fusion.Utils.Tools._argsort__3J_3J_3JJJ(_0,_1,_2,_3,_4)
   elif (not mosek.fusion.Sort._issorted__3J_3J_3JJJZ(_0,_1,_2,_3,_4,_5)):
    _6=numpy.zeros((4,), dtype=numpy.dtype(numpy.int64))
    _7=2
    mosek.fusion.Sort._getminmax__3J_3J_3JJJ_3J(_0,_1,_2,_3,_4,_6)
    if (((_6[1] - _6[0]) < (_7 * (_4 - _3))) and ((_6[3] - _6[2]) < (_7 * (_4 - _3)))):
     mosek.fusion.Sort._argbucketsort__3J_3JJJJJ(_0,_2,_3,_4,_6[2],_6[3])
     mosek.fusion.Sort._argbucketsort__3J_3JJJJJ(_0,_1,_3,_4,_6[0],_6[1])
    else:
     mosek.fusion.Utils.Tools._argsort__3J_3J_3JJJ(_0,_1,_2,_3,_4)
  @staticmethod
  def _match_argsort__3J_3I_3IJJZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match__3J__(_0) and __arg_match__3I__(_1) and __arg_match__3I__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_argsort__3J_3I_3IJJZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4) and __arg_alt_match_Z__(_5))
  @staticmethod
  def _argsort_alt__3J_3I_3IJJZ(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _5=_t__5
   _1 = mosek_fusion_Sort._argsort__3J_3I_3IJJZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argsort__3J_3I_3IJJZ(_0,_1,_2,_3,_4,_5):
   if ((not _5) or ((_4 - _3) < 16)):
    mosek.fusion.Utils.Tools._argsort__3J_3I_3IJJ(_0,_1,_2,_3,_4)
   elif (not mosek.fusion.Sort._issorted__3J_3I_3IJJZ(_0,_1,_2,_3,_4,_5)):
    _6=numpy.zeros((4,), dtype=numpy.dtype(numpy.int32))
    _7=2
    mosek.fusion.Sort._getminmax__3J_3I_3IJJ_3I(_0,_1,_2,_3,_4,_6)
    if (((_6[1] - _6[0]) < (_7 * (_4 - _3))) and ((_6[3] - _6[2]) < (_7 * (_4 - _3)))):
     mosek.fusion.Sort._argbucketsort__3J_3IJJII(_0,_2,_3,_4,_6[2],_6[3])
     mosek.fusion.Sort._argbucketsort__3J_3IJJII(_0,_1,_3,_4,_6[0],_6[1])
    else:
     mosek.fusion.Utils.Tools._argsort__3J_3I_3IJJ(_0,_1,_2,_3,_4)
  @staticmethod
  def _match_argbucketsort__3J_3JJJJJ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match__3J__(_0) and __arg_match__3J__(_1) and __arg_match_J__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4) and __arg_match_J__(_5))
  @staticmethod
  def _match_alt_argbucketsort__3J_3JJJJJ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match_J__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4) and __arg_alt_match_J__(_5))
  @staticmethod
  def _argbucketsort_alt__3J_3JJJJJ(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.int64(_t__2)
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _5=numpy.int64(_t__5)
   _1 = mosek_fusion_Sort._argbucketsort__3J_3JJJJJ(_0,_1,_2,_3,_4,_5)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argbucketsort__3J_3JJJJJ(_0,_1,_2,_3,_4,_5):
   mosek.fusion.Utils.Tools._bucketsort__3JJJ_3JJJ(_0,_2,_3,_1,_4,_5)
  @staticmethod
  def _match_argbucketsort__3J_3IJJII(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match__3J__(_0) and __arg_match__3I__(_1) and __arg_match_J__(_2) and __arg_match_J__(_3) and __arg_match_I__(_4) and __arg_match_I__(_5))
  @staticmethod
  def _match_alt_argbucketsort__3J_3IJJII(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match_J__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_I__(_4) and __arg_alt_match_I__(_5))
  @staticmethod
  def _argbucketsort_alt__3J_3IJJII(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.int64(_t__2)
   _3=numpy.int64(_t__3)
   _4=numpy.int32(_t__4)
   _5=numpy.int32(_t__5)
   _1 = mosek_fusion_Sort._argbucketsort__3J_3IJJII(_0,_1,_2,_3,_4,_5)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argbucketsort__3J_3IJJII(_0,_1,_2,_3,_4,_5):
   mosek.fusion.Utils.Tools._bucketsort__3JJJ_3III(_0,_2,_3,_1,_4,_5)
  @staticmethod
  def _match_getminmax__3J_3J_3JJJ_3J(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match__3J__(_0) and __arg_match__3J__(_1) and __arg_match__3J__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4) and __arg_match__3J__(_5))
  @staticmethod
  def _match_alt_getminmax__3J_3J_3JJJ_3J(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4) and __arg_alt_match__3J__(_5))
  @staticmethod
  def _getminmax_alt__3J_3J_3JJJ_3J(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.int64))
   _1 = mosek_fusion_Sort._getminmax__3J_3J_3JJJ_3J(_0,_1,_2,_3,_4,_5)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _getminmax__3J_3J_3JJJ_3J(_0,_1,_2,_3,_4,_5):
   fragments._c_closure_51(_3,_0,_4,_5,_1,_2) # src/fusion/Sort.mbi:62:7-80:8
  @staticmethod
  def _match_getminmax__3J_3I_3IJJ_3I(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match__3J__(_0) and __arg_match__3I__(_1) and __arg_match__3I__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4) and __arg_match__3I__(_5))
  @staticmethod
  def _match_alt_getminmax__3J_3I_3IJJ_3I(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4) and __arg_alt_match__3I__(_5))
  @staticmethod
  def _getminmax_alt__3J_3I_3IJJ_3I(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Sort._getminmax__3J_3I_3IJJ_3I(_0,_1,_2,_3,_4,_5)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _getminmax__3J_3I_3IJJ_3I(_0,_1,_2,_3,_4,_5):
   fragments._c_closure_52(_3,_0,_4,_5,_1,_2) # src/fusion/Sort.mbi:41:7-59:8
  @staticmethod
  def _match_issorted__3J_3JJJZ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match__3J__(_0) and __arg_match__3J__(_1) and __arg_match_J__(_2) and __arg_match_J__(_3) and __arg_match_Z__(_4))
  @staticmethod
  def _match_alt_issorted__3J_3JJJZ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match_J__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_Z__(_4))
  @staticmethod
  def _issorted_alt__3J_3JJJZ(_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.int64(_t__2)
   _3=numpy.int64(_t__3)
   _4=_t__4
   _1 = mosek_fusion_Sort._issorted__3J_3JJJZ(_0,_1,_2,_3,_4)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _issorted__3J_3JJJZ(_0,_1,_2,_3,_4):
   for _5 in range(_2,(_3 - 1)):
    if (_1[_0[_5]] > _1[_0[(_5 + 1)]]):
     return (False)
   return (True)
  @staticmethod
  def _match_issorted__3J_3IJJZ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match__3J__(_0) and __arg_match__3I__(_1) and __arg_match_J__(_2) and __arg_match_J__(_3) and __arg_match_Z__(_4))
  @staticmethod
  def _match_alt_issorted__3J_3IJJZ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match_J__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_Z__(_4))
  @staticmethod
  def _issorted_alt__3J_3IJJZ(_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.int64(_t__2)
   _3=numpy.int64(_t__3)
   _4=_t__4
   _1 = mosek_fusion_Sort._issorted__3J_3IJJZ(_0,_1,_2,_3,_4)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _issorted__3J_3IJJZ(_0,_1,_2,_3,_4):
   for _5 in range(_2,(_3 - 1)):
    if (_1[_0[_5]] > _1[_0[(_5 + 1)]]):
     return (False)
   return (True)
  @staticmethod
  def _match_issorted__3J_3J_3JJJZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match__3J__(_0) and __arg_match__3J__(_1) and __arg_match__3J__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_issorted__3J_3J_3JJJZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4) and __arg_alt_match_Z__(_5))
  @staticmethod
  def _issorted_alt__3J_3J_3JJJZ(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _5=_t__5
   _1 = mosek_fusion_Sort._issorted__3J_3J_3JJJZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _issorted__3J_3J_3JJJZ(_0,_1,_2,_3,_4,_5):
   for _6 in range(_3,(_4 - 1)):
    if ((_1[_0[_6]] > _1[_0[(_6 + 1)]]) or ((_1[_0[(_6 + 1)]]==_1[_0[_6]]) and (_2[_0[_6]] > _2[_0[(_6 + 1)]]))):
     return (False)
   return (True)
  @staticmethod
  def _match_issorted__3J_3I_3IJJZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match__3J__(_0) and __arg_match__3I__(_1) and __arg_match__3I__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_issorted__3J_3I_3IJJZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4) and __arg_alt_match_Z__(_5))
  @staticmethod
  def _issorted_alt__3J_3I_3IJJZ(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _5=_t__5
   _1 = mosek_fusion_Sort._issorted__3J_3I_3IJJZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _issorted__3J_3I_3IJJZ(_0,_1,_2,_3,_4,_5):
   for _6 in range(_3,(_4 - 1)):
    if ((_1[_0[_6]] > _1[_0[(_6 + 1)]]) or ((_1[_0[_6]]==_1[_0[(_6 + 1)]]) and (_2[_0[_6]] > _2[_0[(_6 + 1)]]))):
     return (False)
   return (True)
 return Sort
mosek_fusion_Sort=__mk_mosek_fusion_Sort()
del __mk_mosek_fusion_Sort
#BEFORE CLASS
def __mk_mosek_fusion_IndexCounter():
 class IndexCounter(object):
  __slots__ = ['_IndexCounter__start','_IndexCounter__dims','_IndexCounter__strides','_IndexCounter__st','_IndexCounter__ii','_IndexCounter__n']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Set_2(*args): # mosek.fusion.Set
      self._ctor_init_Lmosek_4fusion_4Set_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Set_2(*args):# mosek.fusion.Set
      self._ctor_alt_init_Lmosek_4fusion_4Set_2(*args)
    elif self.__match_ctor_J_3ILmosek_4fusion_4Set_2(*args): # int64,[]int32,mosek.fusion.Set
      self._ctor_init_J_3ILmosek_4fusion_4Set_2(*args)
    elif self.__match_alt_ctor_J_3ILmosek_4fusion_4Set_2(*args):# int64,[]int32,mosek.fusion.Set
      self._ctor_alt_init_J_3ILmosek_4fusion_4Set_2(*args)
    elif self.__match_ctor_J_3I_3J(*args): # int64,[]int32,[]int64
      self._ctor_init_J_3I_3J(*args)
    elif self.__match_alt_ctor_J_3I_3J(*args):# int64,[]int32,[]int64
      self._ctor_alt_init_J_3I_3J(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.IndexCounter.ctor(mosek.fusion.Set)\n\tmosek.fusion.IndexCounter.ctor(int64,array(int32,ndim=1),mosek.fusion.Set)\n\tmosek.fusion.IndexCounter.ctor(int64,array(int32,ndim=1),array(int64,ndim=1))')
  def reset(self,*args):
    if False: pass
    elif mosek_fusion_IndexCounter._match_reset_(*args): # 
      return self._reset_(*args)
    elif mosek_fusion_IndexCounter._match_alt_reset_(*args): # 
      return self._reset_alt_(*args)
    else:
      raise ValueError('Invalid argument list reset('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.IndexCounter.reset()')
  def getIndex(self,*args):
    if False: pass
    elif mosek_fusion_IndexCounter._match_getIndex_(*args): # 
      return self._getIndex_(*args)
    elif mosek_fusion_IndexCounter._match_alt_getIndex_(*args): # 
      return self._getIndex_alt_(*args)
    else:
      raise ValueError('Invalid argument list getIndex('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.IndexCounter.getIndex()')
  def get(self,*args):
    if False: pass
    elif mosek_fusion_IndexCounter._match_get_(*args): # 
      return self._get_(*args)
    elif mosek_fusion_IndexCounter._match_alt_get_(*args): # 
      return self._get_alt_(*args)
    else:
      raise ValueError('Invalid argument list get('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.IndexCounter.get()')
  def atEnd(self,*args):
    if False: pass
    elif mosek_fusion_IndexCounter._match_atEnd_(*args): # 
      return self._atEnd_(*args)
    elif mosek_fusion_IndexCounter._match_alt_atEnd_(*args): # 
      return self._atEnd_alt_(*args)
    else:
      raise ValueError('Invalid argument list atEnd('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.IndexCounter.atEnd()')
  def next(self,*args):
    if False: pass
    elif mosek_fusion_IndexCounter._match_next_(*args): # 
      return self._next_(*args)
    elif mosek_fusion_IndexCounter._match_alt_next_(*args): # 
      return self._next_alt_(*args)
    else:
      raise ValueError('Invalid argument list next('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.IndexCounter.next()')
  def inc(self,*args):
    if False: pass
    elif mosek_fusion_IndexCounter._match_inc_(*args): # 
      return self._inc_(*args)
    elif mosek_fusion_IndexCounter._match_alt_inc_(*args): # 
      return self._inc_alt_(*args)
    else:
      raise ValueError('Invalid argument list inc('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.IndexCounter.inc()')
  def __repr__(self): return 'mosek.fusion.IndexCounter'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Set_2(shape):
    o = IndexCounter.__new__(IndexCounter)
    o._ctor_init_Lmosek_4fusion_4Set_2(shape)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Set_2(*args):
    if len(args) != 1: return False
    shape, = args
    return (__arg_match_Lmosek_4fusion_4Set_2__(shape))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Set_2(*args):
    if len(args) != 1: return False
    shape, = args
    return (__arg_alt_match_Lmosek_4fusion_4Set_2__(shape))
  def _ctor_alt_init_Lmosek_4fusion_4Set_2(self,shape):
    self._ctor_init_Lmosek_4fusion_4Set_2(shape)
  def _ctor_init_Lmosek_4fusion_4Set_2(self,shape):
   object.__init__(self)
   self.__n = (shape.nd)
   self.__ii = numpy.zeros((self.__n,), dtype=numpy.dtype(numpy.int32))
   self.__st = numpy.zeros((self.__n,), dtype=numpy.dtype(numpy.int64))
   self.__start = 0
   self.__strides = numpy.zeros((self.__n,), dtype=numpy.dtype(numpy.int64))
   for _0 in range(0,self.__n):
    self.__strides[_0] = shape._stride_I(_0)
   self.__dims = numpy.zeros((self.__n,), dtype=numpy.dtype(numpy.int32))
   for _1 in range(0,self.__n):
    self.__dims[_1] = shape._dim_I(_1)
  @staticmethod
  def _ctor_J_3ILmosek_4fusion_4Set_2(start_,dims_,shape):
    o = IndexCounter.__new__(IndexCounter)
    o._ctor_init_J_3ILmosek_4fusion_4Set_2(start_,dims_,shape)
    return o
  @staticmethod
  def __match_ctor_J_3ILmosek_4fusion_4Set_2(*args):
    if len(args) != 3: return False
    start_,dims_,shape, = args
    return (__arg_match_J__(start_) and __arg_match__3I__(dims_) and __arg_match_Lmosek_4fusion_4Set_2__(shape))
  @staticmethod
  def __match_alt_ctor_J_3ILmosek_4fusion_4Set_2(*args):
    if len(args) != 3: return False
    start_,dims_,shape, = args
    return (__arg_alt_match_J__(start_) and __arg_alt_match__3I__(dims_) and __arg_alt_match_Lmosek_4fusion_4Set_2__(shape))
  def _ctor_alt_init_J_3ILmosek_4fusion_4Set_2(self,start_,dims_,shape):
    self._ctor_init_J_3ILmosek_4fusion_4Set_2(numpy.int64(start_),numpy.array(dims_,dtype=numpy.dtype(numpy.int32)),shape)
  def _ctor_init_J_3ILmosek_4fusion_4Set_2(self,start_,dims_,shape):
   object.__init__(self)
   self.__n = int((dims_).shape[0])
   self.__ii = numpy.zeros((self.__n,), dtype=numpy.dtype(numpy.int32))
   self.__st = numpy.zeros((self.__n,), dtype=numpy.dtype(numpy.int64))
   fragments._c_closure_53(self.__n,self.__st,start_) # src/fusion/CommonUtil.mbi:382:22-57
   self.__strides = numpy.zeros((self.__n,), dtype=numpy.dtype(numpy.int64))
   for _0 in range(0,self.__n):
    self.__strides[_0] = shape._stride_I(_0)
   self.__dims = dims_
   self.__start = start_
  @staticmethod
  def _ctor_J_3I_3J(start_,dims_,strides_):
    o = IndexCounter.__new__(IndexCounter)
    o._ctor_init_J_3I_3J(start_,dims_,strides_)
    return o
  @staticmethod
  def __match_ctor_J_3I_3J(*args):
    if len(args) != 3: return False
    start_,dims_,strides_, = args
    return (__arg_match_J__(start_) and __arg_match__3I__(dims_) and __arg_match__3J__(strides_))
  @staticmethod
  def __match_alt_ctor_J_3I_3J(*args):
    if len(args) != 3: return False
    start_,dims_,strides_, = args
    return (__arg_alt_match_J__(start_) and __arg_alt_match__3I__(dims_) and __arg_alt_match__3J__(strides_))
  def _ctor_alt_init_J_3I_3J(self,start_,dims_,strides_):
    self._ctor_init_J_3I_3J(numpy.int64(start_),numpy.array(dims_,dtype=numpy.dtype(numpy.int32)),numpy.array(strides_,dtype=numpy.dtype(numpy.int64)))
  def _ctor_init_J_3I_3J(self,start_,dims_,strides_):
   object.__init__(self)
   self.__n = int((dims_).shape[0])
   self.__ii = numpy.zeros((self.__n,), dtype=numpy.dtype(numpy.int32))
   self.__st = numpy.zeros((self.__n,), dtype=numpy.dtype(numpy.int64))
   fragments._c_closure_54(self.__n,self.__st,start_) # src/fusion/CommonUtil.mbi:368:22-57
   self.__strides = strides_
   self.__dims = dims_
   self.__start = start_
  @staticmethod
  def _match_atEnd_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_atEnd_(*args):
    if len(args) != 0: return False
    return True
  def _atEnd_alt_(self,):
    return self._atEnd_()
  def _atEnd_(self,):
   return ((self.__ii[(self.__n - 1)] >= self.__dims[(self.__n - 1)]))
  @staticmethod
  def _match_getIndex_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getIndex_(*args):
    if len(args) != 0: return False
    return True
  def _getIndex_alt_(self,):
    return self._getIndex_()
  def _getIndex_(self,):
   return (self.__ii)
  @staticmethod
  def _match_next_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_next_(*args):
    if len(args) != 0: return False
    return True
  def _next_alt_(self,):
    return self._next_()
  def _next_(self,):
   _0=self._get_()
   self._inc_()
   return numpy.int64(_0)
  @staticmethod
  def _match_get_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_get_(*args):
    if len(args) != 0: return False
    return True
  def _get_alt_(self,):
    return self._get_()
  def _get_(self,):
   return numpy.int64(self.__st[0])
  @staticmethod
  def _match_inc_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_inc_(*args):
    if len(args) != 0: return False
    return True
  def _inc_alt_(self,):
    return self._inc_()
  def _inc_(self,):
   self.__ii[0] += 1
   self.__st[0] = (self.__st[0] + self.__strides[(self.__n - 1)])
   _0 = 0
   while ((_0 < (self.__n - 1)) and (self.__ii[_0]==self.__dims[((self.__n - _0) - 1)])):
    self.__ii[_0] = 0
    self.__ii[(_0 + 1)] += 1
    self.__st[(_0 + 1)] = (self.__st[(_0 + 1)] + self.__strides[((self.__n - _0) - 2)])
    _0 += 1
   fragments._c_closure_55(_0,self.__st) # src/fusion/CommonUtil.mbi:417:9-42
  @staticmethod
  def _match_reset_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_reset_(*args):
    if len(args) != 0: return False
    return True
  def _reset_alt_(self,):
    return self._reset_()
  def _reset_(self,):
   self.__st = numpy.zeros((self.__n,), dtype=numpy.dtype(numpy.int64))
   fragments._c_closure_56(self.__n,self.__st,self.__start) # src/fusion/CommonUtil.mbi:403:22-56
 return IndexCounter
mosek_fusion_IndexCounter=__mk_mosek_fusion_IndexCounter()
del __mk_mosek_fusion_IndexCounter
#BEFORE CLASS
def __mk_mosek_fusion_CommonTools():
 class CommonTools(object):
  @staticmethod
  def argQsort(*args):
    if False: pass
    elif mosek_fusion_CommonTools._match_argQsort__3J_3I_3IJJ(*args): # []int64,[]int32,[]int32,int64,int64
      return mosek_fusion_CommonTools._argQsort__3J_3I_3IJJ(*args)
    elif mosek_fusion_CommonTools._match_alt_argQsort__3J_3I_3IJJ(*args): # []int64,[]int32,[]int32,int64,int64
      return mosek_fusion_CommonTools._argQsort_alt__3J_3I_3IJJ(*args)
    elif mosek_fusion_CommonTools._match_argQsort__3J_3J_3JJJ(*args): # []int64,[]int64,[]int64,int64,int64
      return mosek_fusion_CommonTools._argQsort__3J_3J_3JJJ(*args)
    elif mosek_fusion_CommonTools._match_alt_argQsort__3J_3J_3JJJ(*args): # []int64,[]int64,[]int64,int64,int64
      return mosek_fusion_CommonTools._argQsort_alt__3J_3J_3JJJ(*args)
    else:
      raise ValueError('Invalid argument list argQsort('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CommonTools.argQsort(array(int64,ndim=1),array(int32,ndim=1),array(int32,ndim=1),int64,int64)\n\tmosek.fusion.CommonTools.argQsort(array(int64,ndim=1),array(int64,ndim=1),array(int64,ndim=1),int64,int64)')
  @staticmethod
  def argMSort(*args):
    if False: pass
    elif mosek_fusion_CommonTools._match_argMSort__3I_3I(*args): # []int32,[]int32
      return mosek_fusion_CommonTools._argMSort__3I_3I(*args)
    elif mosek_fusion_CommonTools._match_alt_argMSort__3I_3I(*args): # []int32,[]int32
      return mosek_fusion_CommonTools._argMSort_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list argMSort('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CommonTools.argMSort(array(int32,ndim=1),array(int32,ndim=1))')
  @staticmethod
  def tripletSort(*args):
    if False: pass
    elif mosek_fusion_CommonTools._match_tripletSort__3I_3I_3D_3_3I_3_3I_3_3DJII(*args): # []int32,[]int32,[]double,[][]int32,[][]int32,[][]double,int64,int32,int32
      return mosek_fusion_CommonTools._tripletSort__3I_3I_3D_3_3I_3_3I_3_3DJII(*args)
    elif mosek_fusion_CommonTools._match_alt_tripletSort__3I_3I_3D_3_3I_3_3I_3_3DJII(*args): # []int32,[]int32,[]double,[][]int32,[][]int32,[][]double,int64,int32,int32
      return mosek_fusion_CommonTools._tripletSort_alt__3I_3I_3D_3_3I_3_3I_3_3DJII(*args)
    else:
      raise ValueError('Invalid argument list tripletSort('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CommonTools.tripletSort(array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1),array(array(int32,ndim=1),ndim=1),array(array(int32,ndim=1),ndim=1),array(array(double,ndim=1),ndim=1),int64,int32,int32)')
  @staticmethod
  def transposeTriplets(*args):
    if False: pass
    elif mosek_fusion_CommonTools._match_transposeTriplets__3I_3I_3D_3_3I_3_3I_3_3DJII(*args): # []int32,[]int32,[]double,[][]int32,[][]int32,[][]double,int64,int32,int32
      return mosek_fusion_CommonTools._transposeTriplets__3I_3I_3D_3_3I_3_3I_3_3DJII(*args)
    elif mosek_fusion_CommonTools._match_alt_transposeTriplets__3I_3I_3D_3_3I_3_3I_3_3DJII(*args): # []int32,[]int32,[]double,[][]int32,[][]int32,[][]double,int64,int32,int32
      return mosek_fusion_CommonTools._transposeTriplets_alt__3I_3I_3D_3_3I_3_3I_3_3DJII(*args)
    elif mosek_fusion_CommonTools._match_transposeTriplets__3I_3I_3D_3_3J_3_3J_3_3DJII(*args): # []int32,[]int32,[]double,[][]int64,[][]int64,[][]double,int64,int32,int32
      return mosek_fusion_CommonTools._transposeTriplets__3I_3I_3D_3_3J_3_3J_3_3DJII(*args)
    elif mosek_fusion_CommonTools._match_alt_transposeTriplets__3I_3I_3D_3_3J_3_3J_3_3DJII(*args): # []int32,[]int32,[]double,[][]int64,[][]int64,[][]double,int64,int32,int32
      return mosek_fusion_CommonTools._transposeTriplets_alt__3I_3I_3D_3_3J_3_3J_3_3DJII(*args)
    else:
      raise ValueError('Invalid argument list transposeTriplets('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CommonTools.transposeTriplets(array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1),array(array(int32,ndim=1),ndim=1),array(array(int32,ndim=1),ndim=1),array(array(double,ndim=1),ndim=1),int64,int32,int32)\n\tmosek.fusion.CommonTools.transposeTriplets(array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1),array(array(int64,ndim=1),ndim=1),array(array(int64,ndim=1),ndim=1),array(array(double,ndim=1),ndim=1),int64,int32,int32)')
  @staticmethod
  def ndIncr(*args):
    if False: pass
    elif mosek_fusion_CommonTools._match_ndIncr__3I_3I_3I(*args): # []int32,[]int32,[]int32
      return mosek_fusion_CommonTools._ndIncr__3I_3I_3I(*args)
    elif mosek_fusion_CommonTools._match_alt_ndIncr__3I_3I_3I(*args): # []int32,[]int32,[]int32
      return mosek_fusion_CommonTools._ndIncr_alt__3I_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list ndIncr('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CommonTools.ndIncr(array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))')
  def __repr__(self): return 'mosek.fusion.CommonTools'
  @staticmethod
  def _match_ndIncr__3I_3I_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match__3I__(_2))
  @staticmethod
  def _match_alt_ndIncr__3I_3I_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3I__(_2))
  @staticmethod
  def _ndIncr_alt__3I_3I_3I(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_CommonTools._ndIncr__3I_3I_3I(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _ndIncr__3I_3I_3I(_0,_1,_2):
   _3=(int((_0).shape[0]) - 1)
   _0[_3] += 1
   while ((_3 > 0) and (_0[_3] >= _2[_3])):
    _0[_3] = _1[_3]
    _0[(_3 - 1)] += 1
  @staticmethod
  def _match_transposeTriplets__3I_3I_3D_3_3J_3_3J_3_3DJII(*args):
    if len(args) != 9: return False
    _0,_1,_2,_3,_4,_5,_6,_7,_8, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match__3D__(_2) and __arg_match__3_3J__(_3) and __arg_match__3_3J__(_4) and __arg_match__3_3D__(_5) and __arg_match_J__(_6) and __arg_match_I__(_7) and __arg_match_I__(_8))
  @staticmethod
  def _match_alt_transposeTriplets__3I_3I_3D_3_3J_3_3J_3_3DJII(*args):
    if len(args) != 9: return False
    _0,_1,_2,_3,_4,_5,_6,_7,_8, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match__3_3J__(_3) and __arg_alt_match__3_3J__(_4) and __arg_alt_match__3_3D__(_5) and __arg_alt_match_J__(_6) and __arg_alt_match_I__(_7) and __arg_alt_match_I__(_8))
  @staticmethod
  def _transposeTriplets_alt__3I_3I_3D_3_3J_3_3J_3_3DJII(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7,_t__8):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=_monty.makeJaggedArray(_t__3,(1,1),numpy.dtype(numpy.int64))
   _4=_monty.makeJaggedArray(_t__4,(1,1),numpy.dtype(numpy.int64))
   _5=_monty.makeJaggedArray(_t__5,(1,1),numpy.dtype(numpy.float64))
   _6=numpy.int64(_t__6)
   _7=numpy.int32(_t__7)
   _8=numpy.int32(_t__8)
   _1 = mosek_fusion_CommonTools._transposeTriplets__3I_3I_3D_3_3J_3_3J_3_3DJII(_0,_1,_2,_3,_4,_5,_6,_7,_8)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _transposeTriplets__3I_3I_3D_3_3J_3_3J_3_3DJII(_0,_1,_2,_3,_4,_5,_6,_7,_8):
   _9=numpy.zeros(((_7 + 2),), dtype=numpy.dtype(numpy.int64))
   _10=numpy.zeros(((_8 + 2),), dtype=numpy.dtype(numpy.int64))
   fragments._c_closure_57(_10,_6,_9,_0,_1) # src/fusion/CommonUtil.mbi:305:9-309:10
   fragments._c_closure_58(_7,_9) # src/fusion/CommonUtil.mbi:311:9-79
   fragments._c_closure_59(_10,_8) # src/fusion/CommonUtil.mbi:312:9-79
   _11=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int64))
   _12=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int64))
   _13=numpy.zeros((_6,), dtype=numpy.dtype(numpy.float64))
   fragments._c_closure_60(_10,_7,_9,_1,_11,_12,_13,_2) # src/fusion/CommonUtil.mbi:318:9-330:10
   _3[0] = _12
   _4[0] = _11
   _5[0] = _13
  @staticmethod
  def _match_transposeTriplets__3I_3I_3D_3_3I_3_3I_3_3DJII(*args):
    if len(args) != 9: return False
    _0,_1,_2,_3,_4,_5,_6,_7,_8, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match__3D__(_2) and __arg_match__3_3I__(_3) and __arg_match__3_3I__(_4) and __arg_match__3_3D__(_5) and __arg_match_J__(_6) and __arg_match_I__(_7) and __arg_match_I__(_8))
  @staticmethod
  def _match_alt_transposeTriplets__3I_3I_3D_3_3I_3_3I_3_3DJII(*args):
    if len(args) != 9: return False
    _0,_1,_2,_3,_4,_5,_6,_7,_8, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match__3_3I__(_3) and __arg_alt_match__3_3I__(_4) and __arg_alt_match__3_3D__(_5) and __arg_alt_match_J__(_6) and __arg_alt_match_I__(_7) and __arg_alt_match_I__(_8))
  @staticmethod
  def _transposeTriplets_alt__3I_3I_3D_3_3I_3_3I_3_3DJII(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7,_t__8):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=_monty.makeJaggedArray(_t__3,(1,1),numpy.dtype(numpy.int32))
   _4=_monty.makeJaggedArray(_t__4,(1,1),numpy.dtype(numpy.int32))
   _5=_monty.makeJaggedArray(_t__5,(1,1),numpy.dtype(numpy.float64))
   _6=numpy.int64(_t__6)
   _7=numpy.int32(_t__7)
   _8=numpy.int32(_t__8)
   _1 = mosek_fusion_CommonTools._transposeTriplets__3I_3I_3D_3_3I_3_3I_3_3DJII(_0,_1,_2,_3,_4,_5,_6,_7,_8)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _transposeTriplets__3I_3I_3D_3_3I_3_3I_3_3DJII(_0,_1,_2,_3,_4,_5,_6,_7,_8):
   _9=numpy.zeros(((_7 + 2),), dtype=numpy.dtype(numpy.int64))
   _10=numpy.zeros(((_8 + 2),), dtype=numpy.dtype(numpy.int64))
   fragments._c_closure_61(_10,_6,_9,_0,_1) # src/fusion/CommonUtil.mbi:257:9-261:10
   fragments._c_closure_62(_7,_9) # src/fusion/CommonUtil.mbi:263:9-79
   fragments._c_closure_63(_10,_8) # src/fusion/CommonUtil.mbi:264:9-79
   _11=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int32))
   _12=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int32))
   _13=numpy.zeros((_6,), dtype=numpy.dtype(numpy.float64))
   fragments._c_closure_64(_10,_7,_9,_1,_11,_12,_13,_2) # src/fusion/CommonUtil.mbi:270:9-282:10
   _3[0] = _12
   _4[0] = _11
   _5[0] = _13
  @staticmethod
  def _match_tripletSort__3I_3I_3D_3_3I_3_3I_3_3DJII(*args):
    if len(args) != 9: return False
    _0,_1,_2,_3,_4,_5,_6,_7,_8, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match__3D__(_2) and __arg_match__3_3I__(_3) and __arg_match__3_3I__(_4) and __arg_match__3_3D__(_5) and __arg_match_J__(_6) and __arg_match_I__(_7) and __arg_match_I__(_8))
  @staticmethod
  def _match_alt_tripletSort__3I_3I_3D_3_3I_3_3I_3_3DJII(*args):
    if len(args) != 9: return False
    _0,_1,_2,_3,_4,_5,_6,_7,_8, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match__3_3I__(_3) and __arg_alt_match__3_3I__(_4) and __arg_alt_match__3_3D__(_5) and __arg_alt_match_J__(_6) and __arg_alt_match_I__(_7) and __arg_alt_match_I__(_8))
  @staticmethod
  def _tripletSort_alt__3I_3I_3D_3_3I_3_3I_3_3DJII(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7,_t__8):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=_monty.makeJaggedArray(_t__3,(1,1),numpy.dtype(numpy.int32))
   _4=_monty.makeJaggedArray(_t__4,(1,1),numpy.dtype(numpy.int32))
   _5=_monty.makeJaggedArray(_t__5,(1,1),numpy.dtype(numpy.float64))
   _6=numpy.int64(_t__6)
   _7=numpy.int32(_t__7)
   _8=numpy.int32(_t__8)
   _1 = mosek_fusion_CommonTools._tripletSort__3I_3I_3D_3_3I_3_3I_3_3DJII(_0,_1,_2,_3,_4,_5,_6,_7,_8)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _tripletSort__3I_3I_3D_3_3I_3_3I_3_3DJII(_0,_1,_2,_3,_4,_5,_6,_7,_8):
   _9=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int32))
   _10=numpy.zeros(((_8 + 2),), dtype=numpy.dtype(numpy.int64))
   fragments._c_closure_65(_10,_6,_1) # src/fusion/CommonUtil.mbi:132:9-76
   fragments._c_closure_66(_10,_8) # src/fusion/CommonUtil.mbi:133:9-70
   fragments._c_closure_67(_9,_10,_6,_1) # src/fusion/CommonUtil.mbi:134:9-139:10
   _11=numpy.zeros(((_7 + 2),), dtype=numpy.dtype(numpy.int64))
   _12=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int32))
   fragments._c_closure_68(_6,_11,_0) # src/fusion/CommonUtil.mbi:145:9-83
   fragments._c_closure_69(_7,_11) # src/fusion/CommonUtil.mbi:146:9-79
   fragments._c_closure_70(_9,_10,_8,_12,_11,_0) # src/fusion/CommonUtil.mbi:147:9-155:10
   _13=1
   _13 = fragments._c_closure_71(_6,_13,_12,_0,_1) # src/fusion/CommonUtil.mbi:161:9-177:10
   _13 = numpy.int32(_13) # postprocess
   _14=numpy.zeros((_13,), dtype=numpy.dtype(numpy.int32))
   _15=numpy.zeros((_13,), dtype=numpy.dtype(numpy.int32))
   _16=numpy.zeros((_13,), dtype=numpy.dtype(numpy.float64))
   _17=_12[0]
   _14[0] = _0[_17]
   _15[0] = _1[_17]
   _16[0] = _2[_17]
   _18=1
   _18 = fragments._c_closure_72(_18,_6,_12,_0,_1,_14,_15,_16,_2) # src/fusion/CommonUtil.mbi:192:9-209:10
   _18 = numpy.int32(_18) # postprocess
   _3[0] = _14
   _4[0] = _15
   _5[0] = _16
  @staticmethod
  def _match_argMSort__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_argMSort__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _argMSort_alt__3I_3I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_CommonTools._argMSort__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argMSort__3I_3I(_0,_1):
   _2=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int32))
   _3=False
   _4=1
   while (_4 < int((_0).shape[0])):
    _3 = (not _3)
    for _5 in range(0,int((_0).shape[0]),(_4 * 2)):
     if _3:
      mosek.fusion.CommonTools.__mergeInto__3I_3I_3IIII(_0,_2,_1,_5,(_5 + _4),(_5 + (2 * _4)))
     else:
      mosek.fusion.CommonTools.__mergeInto__3I_3I_3IIII(_2,_0,_1,_5,(_5 + _4),(_5 + (2 * _4)))
    _4 *= 2
   if _3:
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(_2,0,_0,0,int((_0).shape[0]))
  @staticmethod
  def __mergeInto_alt__3I_3I_3IIII(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.int32(_t__3)
   _4=numpy.int32(_t__4)
   _5=numpy.int32(_t__5)
   _1 = mosek_fusion_CommonTools.__mergeInto__3I_3I_3IIII(_0,_1,_2,_3,_4,_5)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __mergeInto__3I_3I_3IIII(_0,_1,_2,_3,_4,_5):
   fragments._c_closure_73(_3,_4,_5,_0,_1,_2) # src/fusion/CommonUtil.mbi:36:7-54:8
  @staticmethod
  def _match_argQsort__3J_3J_3JJJ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match__3J__(_0) and __arg_match__3J__(_1) and __arg_match__3J__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4))
  @staticmethod
  def _match_alt_argQsort__3J_3J_3JJJ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4))
  @staticmethod
  def _argQsort_alt__3J_3J_3JJJ(_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _1 = mosek_fusion_CommonTools._argQsort__3J_3J_3JJJ(_0,_1,_2,_3,_4)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argQsort__3J_3J_3JJJ(_0,_1,_2,_3,_4):
   if (_2 is None):
    mosek.fusion.Utils.Tools._argsort__3J_3JJJ(_0,_1,_3,_4)
   else:
    mosek.fusion.Utils.Tools._argsort__3J_3J_3JJJ(_0,_1,_2,_3,_4)
  @staticmethod
  def _match_argQsort__3J_3I_3IJJ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match__3J__(_0) and __arg_match__3I__(_1) and __arg_match__3I__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4))
  @staticmethod
  def _match_alt_argQsort__3J_3I_3IJJ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4))
  @staticmethod
  def _argQsort_alt__3J_3I_3IJJ(_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _1 = mosek_fusion_CommonTools._argQsort__3J_3I_3IJJ(_0,_1,_2,_3,_4)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argQsort__3J_3I_3IJJ(_0,_1,_2,_3,_4):
   if (_2 is None):
    mosek.fusion.Utils.Tools._argsort__3J_3IJJ(_0,_1,_3,_4)
   else:
    mosek.fusion.Utils.Tools._argsort__3J_3I_3IJJ(_0,_1,_2,_3,_4)
 return CommonTools
mosek_fusion_CommonTools=__mk_mosek_fusion_CommonTools()
del __mk_mosek_fusion_CommonTools
#BEFORE CLASS
def __mk_mosek_fusion_SolutionStruct():
 class SolutionStruct(object):
  __slots__ = ['snx','sux','slx','bars','barx','y','suc','slc','xx','xc','dobj','pobj','probstatus','dstatus','pstatus','sol_numbarvar','sol_numcone','sol_numvar','sol_numcon']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4SolutionStruct_2(*args): # mosek.fusion.SolutionStruct
      self._ctor_init_Lmosek_4fusion_4SolutionStruct_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4SolutionStruct_2(*args):# mosek.fusion.SolutionStruct
      self._ctor_alt_init_Lmosek_4fusion_4SolutionStruct_2(*args)
    elif self.__match_ctor_IIII(*args): # int32,int32,int32,int32
      self._ctor_init_IIII(*args)
    elif self.__match_alt_ctor_IIII(*args):# int32,int32,int32,int32
      self._ctor_alt_init_IIII(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.SolutionStruct.ctor(mosek.fusion.SolutionStruct)\n\tmosek.fusion.SolutionStruct.ctor(int32,int32,int32,int32)')
  def clone(self,*args):
    if False: pass
    elif mosek_fusion_SolutionStruct._match_clone_(*args): # 
      return self._clone_(*args)
    elif mosek_fusion_SolutionStruct._match_alt_clone_(*args): # 
      return self._clone_alt_(*args)
    else:
      raise ValueError('Invalid argument list clone('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SolutionStruct.clone()')
  def isPrimalAcceptable(self,*args):
    if False: pass
    elif mosek_fusion_SolutionStruct._match_isPrimalAcceptable_Emosek_4fusion_4AccSolutionStatus_2(*args): # mosek.fusion.AccSolutionStatus
      return self._isPrimalAcceptable_Emosek_4fusion_4AccSolutionStatus_2(*args)
    elif mosek_fusion_SolutionStruct._match_alt_isPrimalAcceptable_Emosek_4fusion_4AccSolutionStatus_2(*args): # mosek.fusion.AccSolutionStatus
      return self._isPrimalAcceptable_alt_Emosek_4fusion_4AccSolutionStatus_2(*args)
    else:
      raise ValueError('Invalid argument list isPrimalAcceptable('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SolutionStruct.isPrimalAcceptable(mosek.fusion.AccSolutionStatus)')
  def resize(self,*args):
    if False: pass
    elif mosek_fusion_SolutionStruct._match_resize_IIII(*args): # int32,int32,int32,int32
      return self._resize_IIII(*args)
    elif mosek_fusion_SolutionStruct._match_alt_resize_IIII(*args): # int32,int32,int32,int32
      return self._resize_alt_IIII(*args)
    else:
      raise ValueError('Invalid argument list resize('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SolutionStruct.resize(int32,int32,int32,int32)')
  def isDualAcceptable(self,*args):
    if False: pass
    elif mosek_fusion_SolutionStruct._match_isDualAcceptable_Emosek_4fusion_4AccSolutionStatus_2(*args): # mosek.fusion.AccSolutionStatus
      return self._isDualAcceptable_Emosek_4fusion_4AccSolutionStatus_2(*args)
    elif mosek_fusion_SolutionStruct._match_alt_isDualAcceptable_Emosek_4fusion_4AccSolutionStatus_2(*args): # mosek.fusion.AccSolutionStatus
      return self._isDualAcceptable_alt_Emosek_4fusion_4AccSolutionStatus_2(*args)
    else:
      raise ValueError('Invalid argument list isDualAcceptable('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SolutionStruct.isDualAcceptable(mosek.fusion.AccSolutionStatus)')
  def __repr__(self): return 'mosek.fusion.SolutionStruct'
  @staticmethod
  def _ctor_IIII(numvar,numcon,numcone,numbarvar):
    o = SolutionStruct.__new__(SolutionStruct)
    o._ctor_init_IIII(numvar,numcon,numcone,numbarvar)
    return o
  @staticmethod
  def __match_ctor_IIII(*args):
    if len(args) != 4: return False
    numvar,numcon,numcone,numbarvar, = args
    return (__arg_match_I__(numvar) and __arg_match_I__(numcon) and __arg_match_I__(numcone) and __arg_match_I__(numbarvar))
  @staticmethod
  def __match_alt_ctor_IIII(*args):
    if len(args) != 4: return False
    numvar,numcon,numcone,numbarvar, = args
    return (__arg_alt_match_I__(numvar) and __arg_alt_match_I__(numcon) and __arg_alt_match_I__(numcone) and __arg_alt_match_I__(numbarvar))
  def _ctor_alt_init_IIII(self,numvar,numcon,numcone,numbarvar):
    self._ctor_init_IIII(numpy.int32(numvar),numpy.int32(numcon),numpy.int32(numcone),numpy.int32(numbarvar))
  def _ctor_init_IIII(self,numvar,numcon,numcone,numbarvar):
   object.__init__(self)
   self.pobj = 0.0
   self.dobj = 0.0
   self.pstatus = mosek.fusion.SolutionStatus.Unknown
   self.dstatus = mosek.fusion.SolutionStatus.Unknown
   self.probstatus = mosek.fusion.ProblemStatus.Unknown
   self.sol_numvar = numvar
   self.sol_numcon = numcon
   self.sol_numcone = numcone
   self.sol_numbarvar = numbarvar
   self.slx = None
   self.sux = None
   self.xx = None
   self.slc = None
   self.suc = None
   self.y = None
   self.xc = None
   self.snx = None
   self.barx = None
   self.bars = None
   if (numvar > 0):
    self.slx = numpy.zeros((numvar,), dtype=numpy.dtype(numpy.float64))
    self.sux = numpy.zeros((numvar,), dtype=numpy.dtype(numpy.float64))
    self.xx = numpy.zeros((numvar,), dtype=numpy.dtype(numpy.float64))
   if (numbarvar > 0):
    self.barx = numpy.zeros((numbarvar,), dtype=numpy.dtype(object))
    self.bars = numpy.zeros((numbarvar,), dtype=numpy.dtype(object))
   if (numcon > 0):
    self.slc = numpy.zeros((numcon,), dtype=numpy.dtype(numpy.float64))
    self.suc = numpy.zeros((numcon,), dtype=numpy.dtype(numpy.float64))
    self.y = numpy.zeros((numcon,), dtype=numpy.dtype(numpy.float64))
    self.xc = numpy.zeros((numcon,), dtype=numpy.dtype(numpy.float64))
   if (numcone > 0):
    self.snx = numpy.zeros((numvar,), dtype=numpy.dtype(numpy.float64))
  @staticmethod
  def _ctor_Lmosek_4fusion_4SolutionStruct_2(that):
    o = SolutionStruct.__new__(SolutionStruct)
    o._ctor_init_Lmosek_4fusion_4SolutionStruct_2(that)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4SolutionStruct_2(*args):
    if len(args) != 1: return False
    that, = args
    return (__arg_match_Lmosek_4fusion_4SolutionStruct_2__(that))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4SolutionStruct_2(*args):
    if len(args) != 1: return False
    that, = args
    return (__arg_alt_match_Lmosek_4fusion_4SolutionStruct_2__(that))
  def _ctor_alt_init_Lmosek_4fusion_4SolutionStruct_2(self,that):
    self._ctor_init_Lmosek_4fusion_4SolutionStruct_2(that)
  def _ctor_init_Lmosek_4fusion_4SolutionStruct_2(self,that):
   object.__init__(self)
   self.sol_numcon = (that.sol_numcon)
   self.sol_numvar = (that.sol_numvar)
   self.sol_numcone = (that.sol_numcone)
   self.sol_numbarvar = (that.sol_numbarvar)
   self.pstatus = (that.pstatus)
   self.dstatus = (that.dstatus)
   self.probstatus = (that.probstatus)
   self.pobj = (that.pobj)
   self.dobj = (that.dobj)
   self.xc = (mosek.fusion.Utils.Tools._arraycopy__3D((that.xc)) if (((that.xc) is not None) ) else None)
   self.xx = (mosek.fusion.Utils.Tools._arraycopy__3D((that.xx)) if (((that.xx) is not None) ) else None)
   self.slc = (mosek.fusion.Utils.Tools._arraycopy__3D((that.slx)) if (((that.slc) is not None) ) else None)
   self.suc = (mosek.fusion.Utils.Tools._arraycopy__3D((that.sux)) if (((that.suc) is not None) ) else None)
   self.y = (mosek.fusion.Utils.Tools._arraycopy__3D((that.y)) if (((that.y) is not None) ) else None)
   if ((that.barx) is not None):
    self.barx = _monty.initJaggedArray([mosek.fusion.Utils.Tools._arraycopy__3D((that.barx)[_0]) for _0 in range(0,int(((that.barx)).shape[0]))], 1)
   else:
    self.barx = None
   if ((that.bars) is not None):
    self.bars = _monty.initJaggedArray([mosek.fusion.Utils.Tools._arraycopy__3D((that.bars)[_1]) for _1 in range(0,int(((that.bars)).shape[0]))], 1)
   else:
    self.bars = None
   self.slx = (mosek.fusion.Utils.Tools._arraycopy__3D((that.slx)) if (((that.slx) is not None) ) else None)
   self.sux = (mosek.fusion.Utils.Tools._arraycopy__3D((that.sux)) if (((that.sux) is not None) ) else None)
   self.snx = (mosek.fusion.Utils.Tools._arraycopy__3D((that.snx)) if (((that.snx) is not None) ) else None)
  @staticmethod
  def _match_clone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_clone_(*args):
    if len(args) != 0: return False
    return True
  def _clone_alt_(self,):
    return self._clone_()
  def _clone_(self,):
   return (mosek_fusion_SolutionStruct._ctor_Lmosek_4fusion_4SolutionStruct_2(self))
  @staticmethod
  def _match_resize_IIII(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2) and __arg_match_I__(_3))
  @staticmethod
  def _match_alt_resize_IIII(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2) and __arg_alt_match_I__(_3))
  def _resize_alt_IIII(self,_t__0,_t__1,_t__2,_t__3):
    return self._resize_IIII(numpy.int32(__0),numpy.int32(__1),numpy.int32(__2),numpy.int32(__3))
  def _resize_IIII(self,_0,_1,_2,_3):
   if (_3 < 0):
    pass
   elif (_3 <= self.sol_numbarvar):
    self.sol_numbarvar = _3
   elif (_0 <= int((self.barx).shape[0])):
    for _4 in range(self.sol_numvar,_0):
     self.barx[_4] = None
     self.bars[_4] = None
   else:
    if ((self.sol_numbarvar * 2) > (_3 + 100)):
     _5 = (self.sol_numbarvar * 2)
    else:
     _5 = (_3 + 100)
    _6=numpy.zeros((_5,), dtype=numpy.dtype(object))
    for _7 in range(0,int((self.barx).shape[0])):
     _6[_7] = self.barx[_7]
    self.barx = _6
    _8=numpy.zeros((_5,), dtype=numpy.dtype(object))
    for _9 in range(0,int((self.bars).shape[0])):
     _8[_9] = self.bars[_9]
    self.bars = _8
    self.sol_numbarvar = _3
   if (_0 < 0):
    pass
   elif (_0 <= self.sol_numvar):
    self.sol_numvar = _0
   elif (_0 <= int((self.xx).shape[0])):
    self.sol_numvar = fragments._c_closure_74(_0,self.slx,self.sol_numvar,self.sux,self.xx) # src/fusion/Model.mbi:3526:11-3535:12
    self.sol_numvar = numpy.int32(self.sol_numvar) # postprocess
   else:
    if ((self.sol_numvar * 2) > (_0 + 100)):
     _10 = (self.sol_numvar * 2)
    else:
     _10 = (_0 + 100)
    _11=numpy.zeros((_10,), dtype=numpy.dtype(numpy.float64))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.slx,0,_11,0,int((self.slx).shape[0]))
    self.slx = _11
    _12=numpy.zeros((_10,), dtype=numpy.dtype(numpy.float64))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.sux,0,_12,0,int((self.sux).shape[0]))
    self.sux = _12
    _13=numpy.zeros((_10,), dtype=numpy.dtype(numpy.float64))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.xx,0,_13,0,int((self.xx).shape[0]))
    self.xx = _13
    fragments._c_closure_75(_0,self.slx,self.sol_numvar,self.sux,self.xx) # src/fusion/Model.mbi:3555:15-3561:16
    self.sol_numvar = _0
   if (_1 < 0):
    pass
   elif (_1 <= self.sol_numcon):
    self.sol_numcon = _1
   elif (_1 <= int((self.xx).shape[0])):
    self.sol_numcon = fragments._c_closure_76(_1,self.slc,self.sol_numcon,self.suc,self.xc,self.y) # src/fusion/Model.mbi:3576:11-3587:12
    self.sol_numcon = numpy.int32(self.sol_numcon) # postprocess
   else:
    if ((self.sol_numcon * 2) > (_1 + 100)):
     _14 = (self.sol_numcon * 2)
    else:
     _14 = (_1 + 100)
    _15=numpy.zeros((_14,), dtype=numpy.dtype(numpy.float64))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.slc,0,_15,0,int((self.slc).shape[0]))
    self.slc = _15
    _16=numpy.zeros((_14,), dtype=numpy.dtype(numpy.float64))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.suc,0,_16,0,int((self.suc).shape[0]))
    self.suc = _16
    _17=numpy.zeros((_14,), dtype=numpy.dtype(numpy.float64))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.xc,0,_17,0,int((self.xc).shape[0]))
    self.xc = _17
    _18=numpy.zeros((_14,), dtype=numpy.dtype(numpy.float64))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.y,0,_18,0,int((self.y).shape[0]))
    self.y = _18
    fragments._c_closure_77(_1,self.slc,self.sol_numcon,self.suc,self.xc,self.y) # src/fusion/Model.mbi:3614:15-3620:16
    self.sol_numcon = _1
   if (_2 < 0):
    pass
   elif (_2 <= self.sol_numcone):
    self.sol_numcone = _2
   elif (_2 <= int((self.xx).shape[0])):
    self.sol_numcone = fragments._c_closure_78(_2,self.snx,self.sol_numcone) # src/fusion/Model.mbi:3636:11-3644:12
    self.sol_numcone = numpy.int32(self.sol_numcone) # postprocess
   else:
    if ((self.sol_numcone * 2) > (_2 + 100)):
     _19 = (self.sol_numcone * 2)
    else:
     _19 = (_2 + 100)
    _20=numpy.zeros((_19,), dtype=numpy.dtype(numpy.float64))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.snx,0,_20,0,int((self.snx).shape[0]))
    self.snx = _20
    fragments._c_closure_79(_2,self.snx,self.sol_numcone) # src/fusion/Model.mbi:3660:15-3664:16
    self.sol_numcone = _2
  @staticmethod
  def _match_isDualAcceptable_Emosek_4fusion_4AccSolutionStatus_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Emosek_4fusion_4AccSolutionStatus_2__(_0))
  @staticmethod
  def _match_alt_isDualAcceptable_Emosek_4fusion_4AccSolutionStatus_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Emosek_4fusion_4AccSolutionStatus_2__(_0))
  def _isDualAcceptable_alt_Emosek_4fusion_4AccSolutionStatus_2(self,_t__0):
    return self._isDualAcceptable_Emosek_4fusion_4AccSolutionStatus_2(__0)
  def _isDualAcceptable_Emosek_4fusion_4AccSolutionStatus_2(self,_0):
   return (self.__isAcceptable_Emosek_4fusion_4SolutionStatus_2Emosek_4fusion_4AccSolutionStatus_2(self.dstatus,_0))
  @staticmethod
  def _match_isPrimalAcceptable_Emosek_4fusion_4AccSolutionStatus_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Emosek_4fusion_4AccSolutionStatus_2__(_0))
  @staticmethod
  def _match_alt_isPrimalAcceptable_Emosek_4fusion_4AccSolutionStatus_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Emosek_4fusion_4AccSolutionStatus_2__(_0))
  def _isPrimalAcceptable_alt_Emosek_4fusion_4AccSolutionStatus_2(self,_t__0):
    return self._isPrimalAcceptable_Emosek_4fusion_4AccSolutionStatus_2(__0)
  def _isPrimalAcceptable_Emosek_4fusion_4AccSolutionStatus_2(self,_0):
   return (self.__isAcceptable_Emosek_4fusion_4SolutionStatus_2Emosek_4fusion_4AccSolutionStatus_2(self.pstatus,_0))
  def __isAcceptable_alt_Emosek_4fusion_4SolutionStatus_2Emosek_4fusion_4AccSolutionStatus_2(self,_t__0,_t__1):
    return self.__isAcceptable_Emosek_4fusion_4SolutionStatus_2Emosek_4fusion_4AccSolutionStatus_2(__0,__1)
  def __isAcceptable_Emosek_4fusion_4SolutionStatus_2Emosek_4fusion_4AccSolutionStatus_2(self,_0,_1):
   if (_1==mosek.fusion.AccSolutionStatus.Anything):
    return (True)
   elif (_1==mosek.fusion.AccSolutionStatus.Optimal):
    return ((_0==mosek.fusion.SolutionStatus.Optimal))
   elif (_1==mosek.fusion.AccSolutionStatus.NearOptimal):
    return (((_0==mosek.fusion.SolutionStatus.Optimal) or (_0==mosek.fusion.SolutionStatus.NearOptimal)))
   elif (_1==mosek.fusion.AccSolutionStatus.Feasible):
    return (((_0==mosek.fusion.SolutionStatus.Optimal) or ((_0==mosek.fusion.SolutionStatus.NearOptimal) or (_0==mosek.fusion.SolutionStatus.Feasible))))
   elif (_1==mosek.fusion.AccSolutionStatus.Certificate):
    return ((_0==mosek.fusion.SolutionStatus.Certificate))
   return (False)
 return SolutionStruct
mosek_fusion_SolutionStruct=__mk_mosek_fusion_SolutionStruct()
del __mk_mosek_fusion_SolutionStruct
#BEFORE CLASS
def __mk_mosek_fusion_ConNZStruct():
 class ConNZStruct(object):
  __slots__ = ['barmidx','barsubj','barsubi','bfix','cof','subj','ptrb']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor__3J_3I_3D_3D_3I_3I_3I(*args): # []int64,[]int32,[]double,[]double,[]int32,[]int32,[]int32
      self._ctor_init__3J_3I_3D_3D_3I_3I_3I(*args)
    elif self.__match_alt_ctor__3J_3I_3D_3D_3I_3I_3I(*args):# []int64,[]int32,[]double,[]double,[]int32,[]int32,[]int32
      self._ctor_alt_init__3J_3I_3D_3D_3I_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ConNZStruct.ctor(array(int64,ndim=1),array(int32,ndim=1),array(double,ndim=1),array(double,ndim=1),array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))')
  def __repr__(self): return 'mosek.fusion.ConNZStruct'
  @staticmethod
  def _ctor__3J_3I_3D_3D_3I_3I_3I(ptrb_,subj_,cof_,bfix_,barsubi_,barsubj_,barmidx_):
    o = ConNZStruct.__new__(ConNZStruct)
    o._ctor_init__3J_3I_3D_3D_3I_3I_3I(ptrb_,subj_,cof_,bfix_,barsubi_,barsubj_,barmidx_)
    return o
  @staticmethod
  def __match_ctor__3J_3I_3D_3D_3I_3I_3I(*args):
    if len(args) != 7: return False
    ptrb_,subj_,cof_,bfix_,barsubi_,barsubj_,barmidx_, = args
    return (__arg_match__3J__(ptrb_) and __arg_match__3I__(subj_) and __arg_match__3D__(cof_) and __arg_match__3D__(bfix_) and __arg_match__3I__(barsubi_) and __arg_match__3I__(barsubj_) and __arg_match__3I__(barmidx_))
  @staticmethod
  def __match_alt_ctor__3J_3I_3D_3D_3I_3I_3I(*args):
    if len(args) != 7: return False
    ptrb_,subj_,cof_,bfix_,barsubi_,barsubj_,barmidx_, = args
    return (__arg_alt_match__3J__(ptrb_) and __arg_alt_match__3I__(subj_) and __arg_alt_match__3D__(cof_) and __arg_alt_match__3D__(bfix_) and __arg_alt_match__3I__(barsubi_) and __arg_alt_match__3I__(barsubj_) and __arg_alt_match__3I__(barmidx_))
  def _ctor_alt_init__3J_3I_3D_3D_3I_3I_3I(self,ptrb_,subj_,cof_,bfix_,barsubi_,barsubj_,barmidx_):
    self._ctor_init__3J_3I_3D_3D_3I_3I_3I(numpy.array(ptrb_,dtype=numpy.dtype(numpy.int64)),numpy.array(subj_,dtype=numpy.dtype(numpy.int32)),numpy.array(cof_,dtype=numpy.dtype(numpy.float64)),numpy.array(bfix_,dtype=numpy.dtype(numpy.float64)),numpy.array(barsubi_,dtype=numpy.dtype(numpy.int32)),numpy.array(barsubj_,dtype=numpy.dtype(numpy.int32)),numpy.array(barmidx_,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init__3J_3I_3D_3D_3I_3I_3I(self,ptrb_,subj_,cof_,bfix_,barsubi_,barsubj_,barmidx_):
   object.__init__(self)
   self.ptrb = ptrb_
   self.subj = subj_
   self.cof = cof_
   self.bfix = bfix_
   self.barsubi = barsubi_
   self.barsubj = barsubj_
   self.barmidx = barmidx_
 return ConNZStruct
mosek_fusion_ConNZStruct=__mk_mosek_fusion_ConNZStruct()
del __mk_mosek_fusion_ConNZStruct
#BEFORE CLASS
def __mk_mosek_fusion_BaseVariable():
 class BaseVariable(mosek_fusion_Variable,object):
  __slots__ = ['_model','_shape_p']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Set_2(*args): # mosek.fusion.Model,mosek.fusion.Set
      self._ctor_init_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Set_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Set_2(*args):# mosek.fusion.Model,mosek.fusion.Set
      self._ctor_alt_init_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Set_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.BaseVariable.ctor(mosek.fusion.Model,mosek.fusion.Set)')
  def shape(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_shape_(*args): # 
      return self._shape_(*args)
    elif mosek_fusion_BaseVariable._match_alt_shape_(*args): # 
      return self._shape_alt_(*args)
    else:
      raise ValueError('Invalid argument list shape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.shape()')
  def getShape(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_getShape_(*args): # 
      return self._getShape_(*args)
    elif mosek_fusion_BaseVariable._match_alt_getShape_(*args): # 
      return self._getShape_alt_(*args)
    else:
      raise ValueError('Invalid argument list getShape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.getShape()')
  def slice(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_slice_II(*args): # int32,int32
      return self._slice_II(*args)
    elif mosek_fusion_BaseVariable._match_alt_slice_II(*args): # int32,int32
      return self._slice_alt_II(*args)
    elif mosek_fusion_BaseVariable._match_slice__3I_3I(*args): # []int32,[]int32
      return self._slice__3I_3I(*args)
    elif mosek_fusion_BaseVariable._match_alt_slice__3I_3I(*args): # []int32,[]int32
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.slice(int32,int32)\n\tmosek.fusion.BaseVariable.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def transpose(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_transpose_(*args): # 
      return self._transpose_(*args)
    elif mosek_fusion_BaseVariable._match_alt_transpose_(*args): # 
      return self._transpose_alt_(*args)
    else:
      raise ValueError('Invalid argument list transpose('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.transpose()')
  def antidiag(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_antidiag_(*args): # 
      return self._antidiag_(*args)
    elif mosek_fusion_BaseVariable._match_alt_antidiag_(*args): # 
      return self._antidiag_alt_(*args)
    elif mosek_fusion_BaseVariable._match_antidiag_I(*args): # int32
      return self._antidiag_I(*args)
    elif mosek_fusion_BaseVariable._match_alt_antidiag_I(*args): # int32
      return self._antidiag_alt_I(*args)
    else:
      raise ValueError('Invalid argument list antidiag('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.antidiag()\n\tmosek.fusion.BaseVariable.antidiag(int32)')
  def elementDesc(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_BaseVariable._match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementDesc('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.elementDesc(int64,mosek.fusion.Utils.StringBuffer)')
  def pick(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_pick__3I(*args): # []int32
      return self._pick__3I(*args)
    elif mosek_fusion_BaseVariable._match_alt_pick__3I(*args): # []int32
      return self._pick_alt__3I(*args)
    elif mosek_fusion_BaseVariable._match_pick__3_5I(*args): # [,]int32
      return self._pick__3_5I(*args)
    elif mosek_fusion_BaseVariable._match_alt_pick__3_5I(*args): # [,]int32
      return self._pick_alt__3_5I(*args)
    elif mosek_fusion_BaseVariable._match_pick__3I_3I(*args): # []int32,[]int32
      return self._pick__3I_3I(*args)
    elif mosek_fusion_BaseVariable._match_alt_pick__3I_3I(*args): # []int32,[]int32
      return self._pick_alt__3I_3I(*args)
    elif mosek_fusion_BaseVariable._match_pick__3I_3I_3I(*args): # []int32,[]int32,[]int32
      return self._pick__3I_3I_3I(*args)
    elif mosek_fusion_BaseVariable._match_alt_pick__3I_3I_3I(*args): # []int32,[]int32,[]int32
      return self._pick_alt__3I_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list pick('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.pick(array(int32,ndim=1))\n\tmosek.fusion.BaseVariable.pick(array(int32,ndim=2))\n\tmosek.fusion.BaseVariable.pick(array(int32,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.BaseVariable.pick(array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))')
  def size(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_size_(*args): # 
      return self._size_(*args)
    elif mosek_fusion_BaseVariable._match_alt_size_(*args): # 
      return self._size_alt_(*args)
    else:
      raise ValueError('Invalid argument list size('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.size()')
  def dual(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_dual_(*args): # 
      return self._dual_(*args)
    elif mosek_fusion_BaseVariable._match_alt_dual_(*args): # 
      return self._dual_alt_(*args)
    else:
      raise ValueError('Invalid argument list dual('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.dual()')
  def getModel(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_getModel_(*args): # 
      return self._getModel_(*args)
    elif mosek_fusion_BaseVariable._match_alt_getModel_(*args): # 
      return self._getModel_alt_(*args)
    else:
      raise ValueError('Invalid argument list getModel('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.getModel()')
  def elementName(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_BaseVariable._match_alt_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementName_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementName('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.elementName(int64,mosek.fusion.Utils.StringBuffer)')
  def inst(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_inst_JJ_3I_3I_3I(*args): # int64,int64,[]int32,[]int32,[]int32
      return self._inst_JJ_3I_3I_3I(*args)
    elif mosek_fusion_BaseVariable._match_alt_inst_JJ_3I_3I_3I(*args): # int64,int64,[]int32,[]int32,[]int32
      return self._inst_alt_JJ_3I_3I_3I(*args)
    elif mosek_fusion_BaseVariable._match_inst__3JIIJJ_3I_3I_3I(*args): # []int64,int32,int32,int64,int64,[]int32,[]int32,[]int32
      return self._inst__3JIIJJ_3I_3I_3I(*args)
    elif mosek_fusion_BaseVariable._match_alt_inst__3JIIJJ_3I_3I_3I(*args): # []int64,int32,int32,int64,int64,[]int32,[]int32,[]int32
      return self._inst_alt__3JIIJJ_3I_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list inst('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.inst(int64,int64,array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.BaseVariable.inst(array(int64,ndim=1),int32,int32,int64,int64,array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))')
  def level(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_level_(*args): # 
      return self._level_(*args)
    elif mosek_fusion_BaseVariable._match_alt_level_(*args): # 
      return self._level_alt_(*args)
    else:
      raise ValueError('Invalid argument list level('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.level()')
  def set_values(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_set_1values__3J_3DZ(*args): # []int64,[]double,bool
      return self._set_1values__3J_3DZ(*args)
    elif mosek_fusion_BaseVariable._match_alt_set_1values__3J_3DZ(*args): # []int64,[]double,bool
      return self._set_1values_alt__3J_3DZ(*args)
    elif mosek_fusion_BaseVariable._match_set_1values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._set_1values_J_3I_3JI_3DZ(*args)
    elif mosek_fusion_BaseVariable._match_alt_set_1values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._set_1values_alt_J_3I_3JI_3DZ(*args)
    else:
      raise ValueError('Invalid argument list set_values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.set_values(array(int64,ndim=1),array(double,ndim=1),bool)\n\tmosek.fusion.BaseVariable.set_values(int64,array(int32,ndim=1),array(int64,ndim=1),int32,array(double,ndim=1),bool)')
  def make_continuous(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_make_1continuous__3J(*args): # []int64
      return self._make_1continuous__3J(*args)
    elif mosek_fusion_BaseVariable._match_alt_make_1continuous__3J(*args): # []int64
      return self._make_1continuous_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_continuous('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.make_continuous(array(int64,ndim=1))')
  def makeContinuous(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_makeContinuous_(*args): # 
      return self._makeContinuous_(*args)
    elif mosek_fusion_BaseVariable._match_alt_makeContinuous_(*args): # 
      return self._makeContinuous_alt_(*args)
    else:
      raise ValueError('Invalid argument list makeContinuous('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.makeContinuous()')
  def asExpr(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_asExpr_(*args): # 
      return self._asExpr_(*args)
    elif mosek_fusion_BaseVariable._match_alt_asExpr_(*args): # 
      return self._asExpr_alt_(*args)
    else:
      raise ValueError('Invalid argument list asExpr('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.asExpr()')
  def make_integer(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_make_1integer__3J(*args): # []int64
      return self._make_1integer__3J(*args)
    elif mosek_fusion_BaseVariable._match_alt_make_1integer__3J(*args): # []int64
      return self._make_1integer_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_integer('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.make_integer(array(int64,ndim=1))')
  def setLevel(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_setLevel__3D(*args): # []double
      return self._setLevel__3D(*args)
    elif mosek_fusion_BaseVariable._match_alt_setLevel__3D(*args): # []double
      return self._setLevel_alt__3D(*args)
    else:
      raise ValueError('Invalid argument list setLevel('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.setLevel(array(double,ndim=1))')
  def values(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_I_3DZ(*args)
    elif mosek_fusion_BaseVariable._match_alt_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_alt_I_3DZ(*args)
    elif mosek_fusion_BaseVariable._match_values__3JI_3DZ(*args): # []int64,int32,[]double,bool
      return self._values__3JI_3DZ(*args)
    elif mosek_fusion_BaseVariable._match_alt_values__3JI_3DZ(*args): # []int64,int32,[]double,bool
      return self._values_alt__3JI_3DZ(*args)
    elif mosek_fusion_BaseVariable._match_values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._values_J_3I_3JI_3DZ(*args)
    elif mosek_fusion_BaseVariable._match_alt_values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._values_alt_J_3I_3JI_3DZ(*args)
    else:
      raise ValueError('Invalid argument list values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.values(int32,array(double,ndim=1),bool)\n\tmosek.fusion.BaseVariable.values(array(int64,ndim=1),int32,array(double,ndim=1),bool)\n\tmosek.fusion.BaseVariable.values(int64,array(int32,ndim=1),array(int64,ndim=1),int32,array(double,ndim=1),bool)')
  def diag(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_diag_(*args): # 
      return self._diag_(*args)
    elif mosek_fusion_BaseVariable._match_alt_diag_(*args): # 
      return self._diag_alt_(*args)
    elif mosek_fusion_BaseVariable._match_diag_I(*args): # int32
      return self._diag_I(*args)
    elif mosek_fusion_BaseVariable._match_alt_diag_I(*args): # int32
      return self._diag_alt_I(*args)
    else:
      raise ValueError('Invalid argument list diag('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.diag()\n\tmosek.fusion.BaseVariable.diag(int32)')
  def makeInteger(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_makeInteger_(*args): # 
      return self._makeInteger_(*args)
    elif mosek_fusion_BaseVariable._match_alt_makeInteger_(*args): # 
      return self._makeInteger_alt_(*args)
    else:
      raise ValueError('Invalid argument list makeInteger('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.makeInteger()')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_BaseVariable._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.toString()')
  def index(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_index_I(*args): # int32
      return self._index_I(*args)
    elif mosek_fusion_BaseVariable._match_alt_index_I(*args): # int32
      return self._index_alt_I(*args)
    elif mosek_fusion_BaseVariable._match_index__3I(*args): # []int32
      return self._index__3I(*args)
    elif mosek_fusion_BaseVariable._match_alt_index__3I(*args): # []int32
      return self._index_alt__3I(*args)
    elif mosek_fusion_BaseVariable._match_index_II(*args): # int32,int32
      return self._index_II(*args)
    elif mosek_fusion_BaseVariable._match_alt_index_II(*args): # int32,int32
      return self._index_alt_II(*args)
    elif mosek_fusion_BaseVariable._match_index_III(*args): # int32,int32,int32
      return self._index_III(*args)
    elif mosek_fusion_BaseVariable._match_alt_index_III(*args): # int32,int32,int32
      return self._index_alt_III(*args)
    else:
      raise ValueError('Invalid argument list index('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.index(int32)\n\tmosek.fusion.BaseVariable.index(array(int32,ndim=1))\n\tmosek.fusion.BaseVariable.index(int32,int32)\n\tmosek.fusion.BaseVariable.index(int32,int32,int32)')
  def __repr__(self): return 'mosek.fusion.BaseVariable'
  @staticmethod
  def _ctor_Lmosek_4fusion_4BaseVariable_2Lmosek_4fusion_4Model_2(v,m):
    o = BaseVariable.__new__(BaseVariable)
    o._ctor_init_Lmosek_4fusion_4BaseVariable_2Lmosek_4fusion_4Model_2(v,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4BaseVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_match_Lmosek_4fusion_4BaseVariable_2__(v) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4BaseVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4BaseVariable_2__(v) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4BaseVariable_2Lmosek_4fusion_4Model_2(self,v,m):
    self._ctor_init_Lmosek_4fusion_4BaseVariable_2Lmosek_4fusion_4Model_2(v,m)
  def _ctor_init_Lmosek_4fusion_4BaseVariable_2Lmosek_4fusion_4Model_2(self,v,m):
   object.__init__(self)
   self._model = m
   self._shape_p = (v._shape_p)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Set_2(m,shape):
    o = BaseVariable.__new__(BaseVariable)
    o._ctor_init_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Set_2(m,shape)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Set_2(*args):
    if len(args) != 2: return False
    m,shape, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(m) and __arg_match_Lmosek_4fusion_4Set_2__(shape))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Set_2(*args):
    if len(args) != 2: return False
    m,shape, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(m) and __arg_alt_match_Lmosek_4fusion_4Set_2__(shape))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Set_2(self,m,shape):
    self._ctor_init_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Set_2(m,shape)
  def _ctor_init_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Set_2(self,m,shape):
   object.__init__(self)
   self._model = m
   self._shape_p = shape
  @staticmethod
  def _match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_J__(_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  @staticmethod
  def _match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  def _elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(_0,_1)
   return (_1)
  @staticmethod
  def _match_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_J__(_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  @staticmethod
  def _match_alt_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  def _elementName_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   pass
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("Variable( (")._a_I(self._shape_p._dim_I(0))
   for _1 in range(1,(self._shape_p.nd)):
    _0._a_S(",")._a_I(self._shape_p._dim_I(_1))
   _0._a_S(" )")
   if ((self._shape_p._size) < 51):
    for _2 in range(0,(self._shape_p._size)):
     _0._a_S(",\n  ")
     self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(_2,_0)
   else:
    for _3 in range(0,25):
     _0._a_S(",\n  ")
     self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(_3,_0)
    _0._a_S("... (")._a_J(((self._shape_p._size) - 50))._a_S(" elements left out)")
    for _4 in range(((self._shape_p._size) - 25),(self._shape_p._size)):
     _0._a_S(",\n  ")
     self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(_4,_0)
   _0._a_S(" )")
   return (_0._toString_())
  @staticmethod
  def _match_inst__3JIIJJ_3I_3I_3I(*args):
    if len(args) != 8: return False
    _0,_1,_2,_3,_4,_5,_6,_7, = args
    return (__arg_match__3J__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4) and __arg_match__3I__(_5) and __arg_match__3I__(_6) and __arg_match__3I__(_7))
  @staticmethod
  def _match_alt_inst__3JIIJJ_3I_3I_3I(*args):
    if len(args) != 8: return False
    _0,_1,_2,_3,_4,_5,_6,_7, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4) and __arg_alt_match__3I__(_5) and __arg_alt_match__3I__(_6) and __arg_alt_match__3I__(_7))
  def _inst_alt__3JIIJJ_3I_3I_3I(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.int32(_t__2)
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.int32))
   _6=numpy.array(_t__6,dtype=numpy.dtype(numpy.int32))
   _7=numpy.array(_t__7,dtype=numpy.dtype(numpy.int32))
   _1 = self._inst__3JIIJJ_3I_3I_3I(_0,_1,_2,_3,_4,_5,_6,_7)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__6[:] = _6
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__7[:] = _7
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst__3JIIJJ_3I_3I_3I(self,_0,_1,_2,_3,_4,_5,_6,_7):
   for _8 in range(_1,_2):
    self._inst_JJ_3I_3I_3I((_0[_8] - _3),((_4 + _8) - _1),_5,_6,_7)
  @staticmethod
  def _match_inst_JJ_3I_3I_3I(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match_J__(_0) and __arg_match_J__(_1) and __arg_match__3I__(_2) and __arg_match__3I__(_3) and __arg_match__3I__(_4))
  @staticmethod
  def _match_alt_inst_JJ_3I_3I_3I(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_J__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match__3I__(_3) and __arg_alt_match__3I__(_4))
  def _inst_alt_JJ_3I_3I_3I(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.int64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int32))
   _1 = self._inst_JJ_3I_3I_3I(_0,_1,_2,_3,_4)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst_JJ_3I_3I_3I(self,_0,_1,_2,_3,_4):
   pass
  @staticmethod
  def _match_set_1values__3J_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3J__(_0) and __arg_match__3D__(_1) and __arg_match_Z__(_2))
  @staticmethod
  def _match_alt_set_1values__3J_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3D__(_1) and __arg_alt_match_Z__(_2))
  def _set_1values_alt__3J_3DZ(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=_t__2
   _1 = self._set_1values__3J_3DZ(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values__3J_3DZ(self,_0,_1,_2):
   pass
  @staticmethod
  def _match_set_1values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match_J__(_0) and __arg_match__3I__(_1) and __arg_match__3J__(_2) and __arg_match_I__(_3) and __arg_match__3D__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_set_1values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match__3D__(_4) and __arg_alt_match_Z__(_5))
  def _set_1values_alt_J_3I_3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = self._set_1values_J_3I_3JI_3DZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values_J_3I_3JI_3DZ(self,_0,_1,_2,_3,_4,_5):
   pass
  @staticmethod
  def _match_values_I_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match__3D__(_1) and __arg_match_Z__(_2))
  @staticmethod
  def _match_alt_values_I_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match__3D__(_1) and __arg_alt_match_Z__(_2))
  def _values_alt_I_3DZ(self,_t__0,_t__1,_t__2):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=_t__2
   _1 = self._values_I_3DZ(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values_I_3DZ(self,_0,_1,_2):
   _3=numpy.zeros(((self._shape_p.nd),), dtype=numpy.dtype(numpy.int64))
   _4=numpy.zeros(((self._shape_p.nd),), dtype=numpy.dtype(numpy.int32))
   for _5 in range(0,(self._shape_p.nd)):
    _3[_5] = self._shape_p._stride_I(_5)
   for _6 in range(0,(self._shape_p.nd)):
    _4[_6] = self._shape_p._dim_I(_6)
   self._values_J_3I_3JI_3DZ(0,_4,_3,_0,_1,_2)
  @staticmethod
  def _match_values__3JI_3DZ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match__3J__(_0) and __arg_match_I__(_1) and __arg_match__3D__(_2) and __arg_match_Z__(_3))
  @staticmethod
  def _match_alt_values__3JI_3DZ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match_Z__(_3))
  def _values_alt__3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=_t__3
   _1 = self._values__3JI_3DZ(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values__3JI_3DZ(self,_0,_1,_2,_3):
   pass
  @staticmethod
  def _match_values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match_J__(_0) and __arg_match__3I__(_1) and __arg_match__3J__(_2) and __arg_match_I__(_3) and __arg_match__3D__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match__3D__(_4) and __arg_alt_match_Z__(_5))
  def _values_alt_J_3I_3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = self._values_J_3I_3JI_3DZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values_J_3I_3JI_3DZ(self,_0,_1,_2,_3,_4,_5):
   pass
  @staticmethod
  def _match_setLevel__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_setLevel__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  def _setLevel_alt__3D(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = self._setLevel__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _setLevel__3D(self,_0):
   if ((self._shape_p._size) > int((_0).shape[0])):
    raise mosek_fusion_LengthError._ctor_S("Invalid length of solution values vector")
   self._set_1values_J_3I_3JI_3DZ(0,numpy.array([self._shape_p._dim_I(_1) for _1 in range(0,(self._shape_p.nd))], dtype=numpy.dtype(numpy.int32)),numpy.array([self._shape_p._stride_I(_2) for _2 in range(0,(self._shape_p.nd))], dtype=numpy.dtype(numpy.int64)),0,_0,True)
  @staticmethod
  def _match_getModel_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getModel_(*args):
    if len(args) != 0: return False
    return True
  def _getModel_alt_(self,):
    return self._getModel_()
  def _getModel_(self,):
   return (self._model)
  @staticmethod
  def _match_shape_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_shape_(*args):
    if len(args) != 0: return False
    return True
  def _shape_alt_(self,):
    return self._shape_()
  def _shape_(self,):
   return (self._shape_p)
  @staticmethod
  def _match_getShape_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getShape_(*args):
    if len(args) != 0: return False
    return True
  def _getShape_alt_(self,):
    return self._getShape_()
  def _getShape_(self,):
   return (self._shape_p)
  @staticmethod
  def _match_size_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_size_(*args):
    if len(args) != 0: return False
    return True
  def _size_alt_(self,):
    return self._size_()
  def _size_(self,):
   return numpy.int64((self._shape_p._size))
  @staticmethod
  def _match_dual_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_dual_(*args):
    if len(args) != 0: return False
    return True
  def _dual_alt_(self,):
    return self._dual_()
  def _dual_(self,):
   _0=numpy.zeros(((self._shape_p._size),), dtype=numpy.dtype(numpy.float64))
   if ((self._shape_p._size) > 0):
    self._values_I_3DZ(0,_0,False)
   return (_0)
  @staticmethod
  def _match_level_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_level_(*args):
    if len(args) != 0: return False
    return True
  def _level_alt_(self,):
    return self._level_()
  def _level_(self,):
   _0=numpy.zeros(((self._shape_p._size),), dtype=numpy.dtype(numpy.float64))
   if ((self._shape_p._size) > 0):
    self._values_I_3DZ(0,_0,True)
   return (_0)
  @staticmethod
  def _match_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3J__(_0))
  @staticmethod
  def _match_alt_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3J__(_0))
  def _make_1continuous_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1continuous__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1continuous__3J(self,_0):
   pass
  @staticmethod
  def _match_make_1integer__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3J__(_0))
  @staticmethod
  def _match_alt_make_1integer__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3J__(_0))
  def _make_1integer_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1integer__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1integer__3J(self,_0):
   pass
  @staticmethod
  def _match_makeContinuous_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_makeContinuous_(*args):
    if len(args) != 0: return False
    return True
  def _makeContinuous_alt_(self,):
    return self._makeContinuous_()
  def _makeContinuous_(self,):
   self._make_1continuous__3J(numpy.array([_0 for _0 in range(0,self._size_())], dtype=numpy.dtype(numpy.int64)))
  @staticmethod
  def _match_makeInteger_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_makeInteger_(*args):
    if len(args) != 0: return False
    return True
  def _makeInteger_alt_(self,):
    return self._makeInteger_()
  def _makeInteger_(self,):
   self._make_1integer__3J(numpy.array([_0 for _0 in range(0,self._size_())], dtype=numpy.dtype(numpy.int64)))
  @staticmethod
  def _match_transpose_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_transpose_(*args):
    if len(args) != 0: return False
    return True
  def _transpose_alt_(self,):
    return self._transpose_()
  def _transpose_(self,):
   if ((self._shape_p.nd) > 2):
    raise mosek_fusion_DimensionError._ctor_S("Invalid shape for operation")
   return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2J_3J(self,mosek.fusion.Set._make_II(self._shape_p._dim_I(1),self._shape_p._dim_I(0)),0,numpy.array([self._shape_p._stride_I(1),self._shape_p._stride_I(0)], dtype=numpy.dtype(numpy.int64))))
  @staticmethod
  def _match_index_III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_index_III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  def _index_alt_III(self,_t__0,_t__1,_t__2):
    return self._index_III(numpy.int32(__0),numpy.int32(__1),numpy.int32(__2))
  def _index_III(self,_0,_1,_2):
   return (self._index__3I(numpy.array([_0,_1,_2], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_index_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_index_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _index_alt_II(self,_t__0,_t__1):
    return self._index_II(numpy.int32(__0),numpy.int32(__1))
  def _index_II(self,_0,_1):
   return (self._index__3I(numpy.array([_0,_1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _index_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._index__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _index__3I(self,_0):
   if ((self._shape_p.nd)!=int((_0).shape[0])):
    raise mosek_fusion_IndexError._ctor_S("Invalid index")
   return (mosek_fusion_PickVariable._ctor_Lmosek_4fusion_4Variable_2_3J(self,numpy.array([self._shape_p._linearidx__3I(_0)], dtype=numpy.dtype(numpy.int64))))
  @staticmethod
  def _match_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _index_alt_I(self,_t__0):
    return self._index_I(numpy.int32(__0))
  def _index_I(self,_0):
   return (self._pick__3I(numpy.array([_0], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_pick__3I_3I_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match__3I__(_2))
  @staticmethod
  def _match_alt_pick__3I_3I_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3I__(_2))
  def _pick_alt__3I_3I_3I(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3I_3I_3I(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _pick__3I_3I_3I(self,_0,_1,_2):
   if ((self._shape_p.nd)!=3):
    raise mosek_fusion_IndexError._ctor_S("Invalid index")
   if ((int((_0).shape[0])!=int((_1).shape[0])) or (int((_0).shape[0])!=int((_2).shape[0]))):
    raise mosek_fusion_LengthError._ctor_S("Mismatching argument lengths")
   return (mosek_fusion_PickVariable._ctor_Lmosek_4fusion_4Variable_2_3J(self,numpy.array([self._shape_p._linearidx__3I(numpy.array([_0[_3],_1[_3],_2[_3]], dtype=numpy.dtype(numpy.int32))) for _3 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int64))))
  @staticmethod
  def _match_pick__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_pick__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _pick_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _pick__3I_3I(self,_0,_1):
   if ((self._shape_p.nd)!=2):
    raise mosek_fusion_IndexError._ctor_S("Invalid index")
   if (int((_0).shape[0])!=int((_1).shape[0])):
    raise mosek_fusion_LengthError._ctor_S("Mismatching argument lengths")
   return (mosek_fusion_PickVariable._ctor_Lmosek_4fusion_4Variable_2_3J(self,numpy.array([self._shape_p._linearidx__3I(numpy.array([_0[_2],_1[_2]], dtype=numpy.dtype(numpy.int32))) for _2 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int64))))
  @staticmethod
  def _match_pick__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5I__(_0))
  @staticmethod
  def _match_alt_pick__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5I__(_0))
  def _pick_alt__3_5I(self,_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3_5I(_0)
   return _1
  def _pick__3_5I(self,_0):
   if ((self._shape_p.nd)!=int((_0).shape[1])):
    raise mosek_fusion_IndexError._ctor_S("Invalid index")
   return (mosek_fusion_PickVariable._ctor_Lmosek_4fusion_4Variable_2_3J(self,numpy.array([self._shape_p._linearidx__3I(numpy.array([_0[_1,_2] for _2 in range(0,int((_0).shape[1]))], dtype=numpy.dtype(numpy.int32))) for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int64))))
  @staticmethod
  def _match_pick__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_pick__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _pick_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _pick__3I(self,_0):
   if ((self._shape_p.nd)!=1):
    raise mosek_fusion_IndexError._ctor_S("Invalid index")
   return (mosek_fusion_PickVariable._ctor_Lmosek_4fusion_4Variable_2_3J(self,numpy.array([_0[_1] for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int64))))
  @staticmethod
  def _match_antidiag_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_antidiag_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _antidiag_alt_I(self,_t__0):
    return self._antidiag_I(numpy.int32(__0))
  def _antidiag_I(self,_0):
   if ((self._shape_p.nd)!=2):
    raise mosek_fusion_DimensionError._ctor_S("antidiag() only works on two-dimensional objects")
   if (_0 >= 0):
    return (self.__general_1diag__3I_3I(numpy.array([0,((self._shape_p._dim_I(1) - 1) - _0)], dtype=numpy.dtype(numpy.int32)),numpy.array([1,(- 1)], dtype=numpy.dtype(numpy.int32))))
   else:
    return (self.__general_1diag__3I_3I(numpy.array([(- _0),(self._shape_p._dim_I(1) - 1)], dtype=numpy.dtype(numpy.int32)),numpy.array([1,(- 1)], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_antidiag_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_antidiag_(*args):
    if len(args) != 0: return False
    return True
  def _antidiag_alt_(self,):
    return self._antidiag_()
  def _antidiag_(self,):
   if ((self._shape_p.nd)!=2):
    raise mosek_fusion_DimensionError._ctor_S("antidiag() only works on two-dimensional objects")
   return (self.__general_1diag__3I_3I(numpy.array([0,(self._shape_p._dim_I(1) - 1)], dtype=numpy.dtype(numpy.int32)),numpy.array([1,(- 1)], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_diag_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_diag_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _diag_alt_I(self,_t__0):
    return self._diag_I(numpy.int32(__0))
  def _diag_I(self,_0):
   if ((self._shape_p.nd)!=2):
    raise mosek_fusion_DimensionError._ctor_S("diag() only works on two-dimensional objects")
   if (_0 >= 0):
    return (self.__general_1diag__3I_3I(numpy.array([0,_0], dtype=numpy.dtype(numpy.int32)),numpy.array([1,1], dtype=numpy.dtype(numpy.int32))))
   else:
    return (self.__general_1diag__3I_3I(numpy.array([(- _0),0], dtype=numpy.dtype(numpy.int32)),numpy.array([1,1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_diag_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_diag_(*args):
    if len(args) != 0: return False
    return True
  def _diag_alt_(self,):
    return self._diag_()
  def _diag_(self,):
   if ((self._shape_p.nd)!=2):
    raise mosek_fusion_DimensionError._ctor_S("diag() only works on two-dimensional objects")
   return (self.__general_1diag__3I_3I(numpy.array([0,0], dtype=numpy.dtype(numpy.int32)),numpy.array([1,1], dtype=numpy.dtype(numpy.int32))))
  def __general_1diag_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self.__general_1diag__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __general_1diag__3I_3I(self,_0,_1):
   if (((self._shape_p.nd)!=int((_0).shape[0])) or ((self._shape_p.nd)!=int((_1).shape[0]))):
    raise mosek_fusion_DimensionError._ctor_S("Invalid start or step definition")
   for _2 in range(0,(self._shape_p.nd)):
    if ((_0[_2] < 0) or (_0[_2] >= self._shape_p._dim_I(_2))):
     raise mosek_fusion_LengthError._ctor_S("Start element is out of bounds")
   _3=0
   for _4 in range(0,(self._shape_p.nd)):
    _3 += (self._shape_p._stride_I(_4) * _0[_4])
   _5=numpy.array([(((((self._shape_p._dim_I(_6) - _0[_6]) - 1) // _1[_6]) + 1) if ((_1[_6] > 0) ) else (((_0[_6] // (- _1[_6])) + 1) if ((_1[_6] < 0) ) else 0)) for _6 in range(0,(self._shape_p.nd))], dtype=numpy.dtype(numpy.int32))
   _7=_5[0]
   for _8 in range(1,(self._shape_p.nd)):
    _7 = (_7 if ((_7 < _5[_8]) ) else _5[_8])
   _9=0
   for _10 in range(0,(self._shape_p.nd)):
    _9 += (_1[_10] * self._shape_p._stride_I(_10))
   return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2J_3J(self,mosek.fusion.Set._make_I(_7),_3,numpy.array([_9], dtype=numpy.dtype(numpy.int64))))
  @staticmethod
  def _match_asExpr_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_asExpr_(*args):
    if len(args) != 0: return False
    return True
  def _asExpr_alt_(self,):
    return self._asExpr_()
  def _asExpr_(self,):
   return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(numpy.array([_0 for _0 in range(0,((self._shape_p._size) + 1))], dtype=numpy.dtype(numpy.int64)),numpy.array([self], dtype=numpy.dtype(object)),numpy.array([_1 for _1 in range(0,(self._shape_p._size))], dtype=numpy.dtype(numpy.int64)),numpy.array([1.0 for _2 in range(0,(self._shape_p._size))], dtype=numpy.dtype(numpy.float64)),None,self._shape_p,None,1))
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _slice_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._slice__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice__3I_3I(self,_0,_1):
   return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2J_3J(self,mosek.fusion.Set._make__3I(numpy.array([(_1[_2] - _0[_2]) for _2 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32))),self._shape_p._linearidx__3I(_0),numpy.array([self._shape_p._stride_I(_3) for _3 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int64))))
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _slice_alt_II(self,_t__0,_t__1):
    return self._slice_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_II(self,_0,_1):
   return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2J_3J(self,mosek.fusion.Set._make_I((_1 - _0)),_0,numpy.array([1], dtype=numpy.dtype(numpy.int64))))
 return BaseVariable
mosek_fusion_BaseVariable=__mk_mosek_fusion_BaseVariable()
del __mk_mosek_fusion_BaseVariable
#BEFORE CLASS
def __mk_mosek_fusion_CompoundVariable():
 class CompoundVariable(mosek_fusion_BaseVariable):
  __slots__ = ['_CompoundVariable__stackdim','_CompoundVariable__varsb','_CompoundVariable__vars']
  def asExpr(self,*args):
    if False: pass
    elif mosek_fusion_CompoundVariable._match_asExpr_(*args): # 
      return self._asExpr_(*args)
    elif mosek_fusion_CompoundVariable._match_alt_asExpr_(*args): # 
      return self._asExpr_alt_(*args)
    else:
      raise ValueError('Invalid argument list asExpr('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CompoundVariable.asExpr()')
  def set_values(self,*args):
    if False: pass
    elif mosek_fusion_CompoundVariable._match_set_1values__3J_3DZ(*args): # []int64,[]double,bool
      return self._set_1values__3J_3DZ(*args)
    elif mosek_fusion_CompoundVariable._match_alt_set_1values__3J_3DZ(*args): # []int64,[]double,bool
      return self._set_1values_alt__3J_3DZ(*args)
    elif mosek_fusion_CompoundVariable._match_set_1values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._set_1values_J_3I_3JI_3DZ(*args)
    elif mosek_fusion_CompoundVariable._match_alt_set_1values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._set_1values_alt_J_3I_3JI_3DZ(*args)
    else:
      raise ValueError('Invalid argument list set_values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CompoundVariable.set_values(array(int64,ndim=1),array(double,ndim=1),bool)\n\tmosek.fusion.CompoundVariable.set_values(int64,array(int32,ndim=1),array(int64,ndim=1),int32,array(double,ndim=1),bool)')
  def elementDesc(self,*args):
    if False: pass
    elif mosek_fusion_CompoundVariable._match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_CompoundVariable._match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementDesc('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CompoundVariable.elementDesc(int64,mosek.fusion.Utils.StringBuffer)')
  def values(self,*args):
    if False: pass
    elif mosek_fusion_CompoundVariable._match_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_I_3DZ(*args)
    elif mosek_fusion_CompoundVariable._match_alt_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_alt_I_3DZ(*args)
    elif mosek_fusion_CompoundVariable._match_values__3JI_3DZ(*args): # []int64,int32,[]double,bool
      return self._values__3JI_3DZ(*args)
    elif mosek_fusion_CompoundVariable._match_alt_values__3JI_3DZ(*args): # []int64,int32,[]double,bool
      return self._values_alt__3JI_3DZ(*args)
    elif mosek_fusion_CompoundVariable._match_values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._values_J_3I_3JI_3DZ(*args)
    elif mosek_fusion_CompoundVariable._match_alt_values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._values_alt_J_3I_3JI_3DZ(*args)
    else:
      raise ValueError('Invalid argument list values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CompoundVariable.values(int32,array(double,ndim=1),bool)\n\tmosek.fusion.CompoundVariable.values(array(int64,ndim=1),int32,array(double,ndim=1),bool)\n\tmosek.fusion.CompoundVariable.values(int64,array(int32,ndim=1),array(int64,ndim=1),int32,array(double,ndim=1),bool)')
  def slice(self,*args):
    if False: pass
    elif mosek_fusion_CompoundVariable._match_slice_II(*args): # int32,int32
      return self._slice_II(*args)
    elif mosek_fusion_CompoundVariable._match_alt_slice_II(*args): # int32,int32
      return self._slice_alt_II(*args)
    elif mosek_fusion_CompoundVariable._match_slice__3I_3I(*args): # []int32,[]int32
      return self._slice__3I_3I(*args)
    elif mosek_fusion_CompoundVariable._match_alt_slice__3I_3I(*args): # []int32,[]int32
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CompoundVariable.slice(int32,int32)\n\tmosek.fusion.CompoundVariable.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def inst(self,*args):
    if False: pass
    elif mosek_fusion_CompoundVariable._match_inst_JJ_3I_3I_3I(*args): # int64,int64,[]int32,[]int32,[]int32
      return self._inst_JJ_3I_3I_3I(*args)
    elif mosek_fusion_CompoundVariable._match_alt_inst_JJ_3I_3I_3I(*args): # int64,int64,[]int32,[]int32,[]int32
      return self._inst_alt_JJ_3I_3I_3I(*args)
    elif mosek_fusion_CompoundVariable._match_inst__3JIIJJ_3I_3I_3I(*args): # []int64,int32,int32,int64,int64,[]int32,[]int32,[]int32
      return self._inst__3JIIJJ_3I_3I_3I(*args)
    elif mosek_fusion_CompoundVariable._match_alt_inst__3JIIJJ_3I_3I_3I(*args): # []int64,int32,int32,int64,int64,[]int32,[]int32,[]int32
      return self._inst_alt__3JIIJJ_3I_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list inst('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CompoundVariable.inst(int64,int64,array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.CompoundVariable.inst(array(int64,ndim=1),int32,int32,int64,int64,array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))')
  def make_continuous(self,*args):
    if False: pass
    elif mosek_fusion_CompoundVariable._match_make_1continuous__3J(*args): # []int64
      return self._make_1continuous__3J(*args)
    elif mosek_fusion_CompoundVariable._match_alt_make_1continuous__3J(*args): # []int64
      return self._make_1continuous_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_continuous('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CompoundVariable.make_continuous(array(int64,ndim=1))')
  def make_integer(self,*args):
    if False: pass
    elif mosek_fusion_CompoundVariable._match_make_1integer__3J(*args): # []int64
      return self._make_1integer__3J(*args)
    elif mosek_fusion_CompoundVariable._match_alt_make_1integer__3J(*args): # []int64
      return self._make_1integer_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_integer('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CompoundVariable.make_integer(array(int64,ndim=1))')
  def elementName(self,*args):
    if False: pass
    elif mosek_fusion_CompoundVariable._match_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_CompoundVariable._match_alt_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementName_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementName('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CompoundVariable.elementName(int64,mosek.fusion.Utils.StringBuffer)')
  def __repr__(self): return 'mosek.fusion.CompoundVariable'
  @staticmethod
  def _ctor__3Lmosek_4fusion_4Variable_2I(v,dim):
    o = CompoundVariable.__new__(CompoundVariable)
    o._ctor_init__3Lmosek_4fusion_4Variable_2I(v,dim)
    return o
  @staticmethod
  def __match_ctor__3Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    v,dim, = args
    return (__arg_match__3Lmosek_4fusion_4Variable_2__(v) and __arg_match_I__(dim))
  @staticmethod
  def __match_alt_ctor__3Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    v,dim, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Variable_2__(v) and __arg_alt_match_I__(dim))
  def _ctor_alt_init__3Lmosek_4fusion_4Variable_2I(self,v,dim):
    self._ctor_init__3Lmosek_4fusion_4Variable_2I(numpy.array(v,dtype=numpy.dtype(object)),numpy.int32(dim))
  def _ctor_init__3Lmosek_4fusion_4Variable_2I(self,v,dim):
   mosek_fusion_BaseVariable._ctor_init_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Set_2(self,mosek.fusion.CompoundVariable.__model_1from_1var__3Lmosek_4fusion_4Variable_2(v),mosek.fusion.CompoundVariable.__compute_1shape__3Lmosek_4fusion_4Variable_2I(v,dim))
   _0=0
   _1=0
   for _2 in range(0,int((v).shape[0])):
    if ((v[_2]._getShape_()._size)==1):
     _0 += 1
     _1 += 1
    elif ((v[_2]._getShape_()._size) > 1):
     _0 += 1
     _1 += v[_2]._getShape_()._dim_I(dim)
   self.__vars = numpy.zeros((_0,), dtype=numpy.dtype(object))
   self.__varsb = numpy.zeros(((_0 + 1),), dtype=numpy.dtype(numpy.int32))
   self.__varsb[0] = 0
   self.__stackdim = dim
   _3=0
   for _4 in range(0,int((v).shape[0])):
    if ((v[_4]._getShape_()._size) > 0):
     self.__vars[_3] = v[_4]
     if ((v[_4]._getShape_()._size)==1):
      self.__varsb[(_3 + 1)] = (self.__varsb[_3] + 1)
     else:
      self.__varsb[(_3 + 1)] = (self.__varsb[_3] + v[_4]._getShape_()._dim_I(dim))
     _3 += 1
  @staticmethod
  def _match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_J__(_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  @staticmethod
  def _match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  def _elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   if ((_0 < 0) or (_0 >= (self._shape_p._size))):
    raise mosek_fusion_IndexError._ctor_S("Index out of bounds")
   _2=self._shape_p._idxtokey_J(_0)
   _3=0
   _3 = fragments._c_closure_80(_3,_2,self.__stackdim,self.__varsb) # src/fusion/CompoundVariable.mbi:620:20-60
   _3 = numpy.int32(_3) # postprocess
   _2[self.__stackdim] = (_2[self.__stackdim] - self.__varsb[_3])
   self.__vars[_3]._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(self.__vars[_3]._getShape_()._linearidx__3I(_2),_1)
   return (_1)
  @staticmethod
  def _match_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_J__(_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  @staticmethod
  def _match_alt_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  def _elementName_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   if ((_0 < 0) or (_0 >= (self._shape_p._size))):
    raise mosek_fusion_IndexError._ctor_S("Index out of bounds")
   _2=self._shape_p._idxtokey_J(_0)
   _3=0
   _3 = fragments._c_closure_81(_3,_2,self.__stackdim,self.__varsb) # src/fusion/CompoundVariable.mbi:608:20-60
   _3 = numpy.int32(_3) # postprocess
   _2[self.__stackdim] = (_2[self.__stackdim] - self.__varsb[_3])
   self.__vars[_3]._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(self.__vars[_3]._getShape_()._linearidx__3I(_2),_1)
  @staticmethod
  def _match_inst_JJ_3I_3I_3I(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match_J__(_0) and __arg_match_J__(_1) and __arg_match__3I__(_2) and __arg_match__3I__(_3) and __arg_match__3I__(_4))
  @staticmethod
  def _match_alt_inst_JJ_3I_3I_3I(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_J__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match__3I__(_3) and __arg_alt_match__3I__(_4))
  def _inst_alt_JJ_3I_3I_3I(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.int64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int32))
   _1 = self._inst_JJ_3I_3I_3I(_0,_1,_2,_3,_4)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst_JJ_3I_3I_3I(self,_0,_1,_2,_3,_4):
   if ((_0 < 0) or (_0 >= (self._shape_p._size))):
    raise mosek_fusion_IndexError._ctor_S("Index out of bounds")
   _5=self._shape_p._idxtokey_J(_0)
   _6=0
   _6 = fragments._c_closure_82(_6,_5,self.__stackdim,self.__varsb) # src/fusion/CompoundVariable.mbi:595:20-60
   _6 = numpy.int32(_6) # postprocess
   _5[self.__stackdim] = (_5[self.__stackdim] - self.__varsb[_6])
   self.__vars[_6]._inst_JJ_3I_3I_3I(self.__vars[_6]._getShape_()._linearidx__3I(_5),_1,_2,_3,_4)
  @staticmethod
  def _match_set_1values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match_J__(_0) and __arg_match__3I__(_1) and __arg_match__3J__(_2) and __arg_match_I__(_3) and __arg_match__3D__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_set_1values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match__3D__(_4) and __arg_alt_match_Z__(_5))
  def _set_1values_alt_J_3I_3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = self._set_1values_J_3I_3JI_3DZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values_J_3I_3JI_3DZ(self,_0,_1,_2,_3,_4,_5):
   _6=int((_2).shape[0])
   _7=_1[0]
   _7 = fragments._c_closure_83(_1,_7) # src/fusion/CompoundVariable.mbi:527:9-70
   _7 = numpy.int32(_7) # postprocess
   _8=numpy.array([_0 for _9 in range(0,int((_1).shape[0]))], dtype=numpy.dtype(numpy.int64))
   _10=numpy.zeros((int((_1).shape[0]),), dtype=numpy.dtype(numpy.int32))
   _11=numpy.zeros(((self._shape_p.nd),), dtype=numpy.dtype(numpy.int32))
   _12=numpy.zeros(((self._shape_p.nd),), dtype=numpy.dtype(numpy.int64))
   _12[((self._shape_p.nd) - 1)] = 1
   for _13 in range(1,(self._shape_p.nd)):
    _12[(((self._shape_p.nd) - _13) - 1)] = (_12[((self._shape_p.nd) - _13)] * self._shape_p._dim_I(((self._shape_p.nd) - _13)))
   _14=numpy.zeros((1,), dtype=numpy.dtype(numpy.int64))
   _15=numpy.zeros((1,), dtype=numpy.dtype(numpy.float64))
   for _16 in range(0,_7):
    _17=_8[0]
    for _18 in range(0,(self._shape_p.nd)):
     _11[_18] = numpy.int32((_17 // _12[_18]))
     _17 = (_17 - (numpy.int64(_11[_18]) * _12[_18]))
    _19=0
    _19 = fragments._c_closure_84(_11,self.__stackdim,self.__varsb,_19) # src/fusion/CompoundVariable.mbi:559:13-61
    _19 = numpy.int32(_19) # postprocess
    _11[self.__stackdim] = (_11[self.__stackdim] - self.__varsb[_19])
    _14[0] = self.__vars[_19]._getShape_()._linearidx__3I(_11)
    _15[0] = _4[(_3 + _16)]
    self.__vars[_19]._set_1values__3J_3DZ(_14,_15,_5)
    _10[0] += 1
    _8[0] = (_8[0] + _2[(_6 - 1)])
    _20=0
    _20 = 0
    while ((_20 < (_6 - 1)) and (_10[_20]==_1[_20])):
     _10[_20] = 0
     _10[(_20 + 1)] += 1
     _20 += 1
    fragments._c_closure_85(_20,_8) # src/fusion/CompoundVariable.mbi:576:13-577:28
  @staticmethod
  def _match_set_1values__3J_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3J__(_0) and __arg_match__3D__(_1) and __arg_match_Z__(_2))
  @staticmethod
  def _match_alt_set_1values__3J_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3D__(_1) and __arg_alt_match_Z__(_2))
  def _set_1values_alt__3J_3DZ(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=_t__2
   _1 = self._set_1values__3J_3DZ(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values__3J_3DZ(self,_0,_1,_2):
   _3=numpy.zeros((1,), dtype=numpy.dtype(numpy.int64))
   _4=numpy.zeros((1,), dtype=numpy.dtype(numpy.float64))
   _5=numpy.zeros(((self._shape_p.nd),), dtype=numpy.dtype(numpy.int32))
   for _6 in range(0,int((_0).shape[0])):
    _7=numpy.int64(_0[_6])
    for _8 in range(0,(self._shape_p.nd)):
     _5[_8] = numpy.int32((_7 // self._shape_p._stride_I(_8)))
     _7 = (_7 - (numpy.int64(_5[_8]) * self._shape_p._stride_I(_8)))
    _9=0
    _9 = fragments._c_closure_86(_5,self.__stackdim,self.__varsb,_9) # src/fusion/CompoundVariable.mbi:506:13-61
    _9 = numpy.int32(_9) # postprocess
    _5[self.__stackdim] = (_5[self.__stackdim] - self.__varsb[_9])
    _3[0] = self.__vars[_9]._getShape_()._linearidx__3I(_5)
    _4[0] = _1[_6]
    self.__vars[_9]._set_1values__3J_3DZ(_3,_4,_2)
  @staticmethod
  def _match_values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match_J__(_0) and __arg_match__3I__(_1) and __arg_match__3J__(_2) and __arg_match_I__(_3) and __arg_match__3D__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match__3D__(_4) and __arg_alt_match_Z__(_5))
  def _values_alt_J_3I_3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = self._values_J_3I_3JI_3DZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values_J_3I_3JI_3DZ(self,_0,_1,_2,_3,_4,_5):
   _6=int((_2).shape[0])
   _7=_1[0]
   _7 = fragments._c_closure_87(_1,_7) # src/fusion/CompoundVariable.mbi:428:9-59
   _7 = numpy.int32(_7) # postprocess
   _8=numpy.array([_0 for _9 in range(0,int((_1).shape[0]))], dtype=numpy.dtype(numpy.int64))
   _10=numpy.zeros((int((_1).shape[0]),), dtype=numpy.dtype(numpy.int32))
   _11=numpy.zeros(((self._shape_p.nd),), dtype=numpy.dtype(numpy.int32))
   _12=numpy.zeros((1,), dtype=numpy.dtype(numpy.int64))
   for _13 in range(0,_7):
    _14=_8[0]
    for _15 in range(0,(self._shape_p.nd)):
     _11[(((self._shape_p.nd) - _15) - 1)] = numpy.int32((_14 % self._shape_p._dim_I((((self._shape_p.nd) - _15) - 1))))
     _14 /= self._shape_p._dim_I((((self._shape_p.nd) - _15) - 1))
    _16=0
    _16 = fragments._c_closure_88(_11,self.__stackdim,self.__varsb,_16) # src/fusion/CompoundVariable.mbi:457:13-61
    _16 = numpy.int32(_16) # postprocess
    _11[self.__stackdim] = (_11[self.__stackdim] - self.__varsb[_16])
    _12[0] = self.__vars[_16]._getShape_()._linearidx__3I(_11)
    self.__vars[_16]._values__3JI_3DZ(_12,(_3 + _13),_4,_5)
    _10[0] += 1
    _17=0
    _17 = 0
    while ((_17 < (_6 - 1)) and (_10[_17]==_1[((_6 - 1) - _17)])):
     _10[_17] = 0
     _10[(_17 + 1)] += 1
     _17 += 1
    _8[_17] += _2[((_6 - _17) - 1)]
    fragments._c_closure_89(_17,_8) # src/fusion/CompoundVariable.mbi:475:13-476:30
  @staticmethod
  def _match_values__3JI_3DZ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match__3J__(_0) and __arg_match_I__(_1) and __arg_match__3D__(_2) and __arg_match_Z__(_3))
  @staticmethod
  def _match_alt_values__3JI_3DZ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match_Z__(_3))
  def _values_alt__3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=_t__3
   _1 = self._values__3JI_3DZ(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values__3JI_3DZ(self,_0,_1,_2,_3):
   _4=numpy.zeros((1,), dtype=numpy.dtype(numpy.int64))
   _5=numpy.zeros(((self._shape_p.nd),), dtype=numpy.dtype(numpy.int32))
   for _6 in range(0,int((_0).shape[0])):
    _7=numpy.int64(_0[_6])
    for _8 in range(0,(self._shape_p.nd)):
     _5[_8] = numpy.int32((_7 // self._shape_p._stride_I(_8)))
     _7 = (_7 - (numpy.int64(_5[_8]) * self._shape_p._stride_I(_8)))
    _9=0
    _9 = fragments._c_closure_90(_5,self.__stackdim,self.__varsb,_9) # src/fusion/CompoundVariable.mbi:410:13-61
    _9 = numpy.int32(_9) # postprocess
    _5[self.__stackdim] = (_5[self.__stackdim] - self.__varsb[_9])
    _4[0] = self.__vars[_9]._getShape_()._linearidx__3I(_5)
    self.__vars[_9]._values__3JI_3DZ(_4,(_1 + _6),_2,_3)
  @staticmethod
  def _match_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3J__(_0))
  @staticmethod
  def _match_alt_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3J__(_0))
  def _make_1continuous_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1continuous__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1continuous__3J(self,_0):
   _1=numpy.zeros((1,), dtype=numpy.dtype(numpy.int64))
   _2=numpy.zeros(((self._shape_p.nd),), dtype=numpy.dtype(numpy.int32))
   for _3 in range(0,int((_0).shape[0])):
    _4=numpy.int64(_0[_3])
    for _5 in range(0,(self._shape_p.nd)):
     _2[_5] = numpy.int32((_4 // self._shape_p._stride_I(_5)))
     _4 = (_4 - (numpy.int64(_2[_5]) * self._shape_p._stride_I(_5)))
    _6=0
    _6 = fragments._c_closure_91(_2,self.__stackdim,self.__varsb,_6) # src/fusion/CompoundVariable.mbi:373:13-61
    _6 = numpy.int32(_6) # postprocess
    _2[self.__stackdim] = (_2[self.__stackdim] - self.__varsb[_6])
    _1[0] = self.__vars[_6]._getShape_()._linearidx__3I(_2)
    self.__vars[_6]._make_1continuous__3J(_1)
  @staticmethod
  def _match_make_1integer__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3J__(_0))
  @staticmethod
  def _match_alt_make_1integer__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3J__(_0))
  def _make_1integer_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1integer__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1integer__3J(self,_0):
   _1=numpy.zeros((1,), dtype=numpy.dtype(numpy.int64))
   _2=numpy.zeros(((self._shape_p.nd),), dtype=numpy.dtype(numpy.int32))
   for _3 in range(0,int((_0).shape[0])):
    _4=numpy.int64(_0[_3])
    for _5 in range(0,(self._shape_p.nd)):
     _2[_5] = numpy.int32((_4 // self._shape_p._stride_I(_5)))
     _4 = (_4 - (numpy.int64(_2[_5]) * self._shape_p._stride_I(_5)))
    _6=0
    _6 = fragments._c_closure_92(_2,self.__stackdim,self.__varsb,_6) # src/fusion/CompoundVariable.mbi:346:13-61
    _6 = numpy.int32(_6) # postprocess
    _2[self.__stackdim] = (_2[self.__stackdim] - self.__varsb[_6])
    _1[0] = self.__vars[_6]._getShape_()._linearidx__3I(_2)
    self.__vars[_6]._make_1integer__3J(_1)
  @staticmethod
  def _match_asExpr_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_asExpr_(*args):
    if len(args) != 0: return False
    return True
  def _asExpr_alt_(self,):
    return self._asExpr_()
  def _asExpr_(self,):
   _0=mosek.fusion.Utils.Tools._range_JJ(0,((self._shape_p._size) + 1))
   _1=mosek.fusion.Utils.Tools._ones_I(numpy.int32((self._shape_p._size)))
   _2=numpy.zeros(((self._shape_p._size),), dtype=numpy.dtype(numpy.int64))
   if (self.__stackdim < 1):
    for _3 in range(0,numpy.int32((self._shape_p._size))):
     _2[_3] = _3
   elif (self.__stackdim >= (self._shape_p.nd)):
    _4=0
    _5=(self.__vars[0]._getShape_()._size)
    for _6 in range(0,_5):
     for _7 in range(0,int((self.__vars).shape[0])):
      _2[_4] = ((_7 * _5) + _6)
      _4 += 1
   else:
    _8=1
    for _9 in range(0,self.__stackdim):
     _8 *= self._shape_p._dim_I(_9)
    _10=numpy.zeros((int((self.__vars).shape[0]),), dtype=numpy.dtype(numpy.int64))
    _11=numpy.zeros(((int((self.__vars).shape[0]) + 1),), dtype=numpy.dtype(numpy.int64))
    for _12 in range(1,(int((self.__vars).shape[0]) + 1)):
     _11[_12] = (_11[(_12 - 1)] + (self.__vars[(_12 - 1)]._getShape_()._size))
    _13=0
    for _14 in range(0,_8):
     _15=0
     for _16 in range(0,int((self.__vars).shape[0])):
      for _17 in range(0,self.__vars[_16]._getShape_()._stride_I((self.__stackdim - 1))):
       _2[_13] = ((_11[_16] + _10[_16]) + _17)
       _13 += 1
      _10[_16] += self.__vars[_16]._getShape_()._stride_I((self.__stackdim - 1))
   _18=numpy.array([self.__vars[_19] for _19 in range(0,int((self.__vars).shape[0]))], dtype=numpy.dtype(object))
   return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(_0,_18,_2,_1,None,self._shape_p,None,1))
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _slice_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._slice__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice__3I_3I(self,_0,_1):
   if (int((_0).shape[0])!=int((_1).shape[0])):
    raise mosek_fusion_LengthError._ctor_S("Mismatching array lengths")
   elif (int((_0).shape[0])!=(self._shape_p.nd)):
    raise mosek_fusion_SliceError._ctor_S("Slice has wrong number of dimensions")
   else:
    for _2 in range(0,int((_0).shape[0])):
     if ((_0[_2] < 0) or ((_0[_2] > _1[_2]) or (_1[_2] > self._shape_p._dim_I(_2)))):
      raise mosek_fusion_SliceError._ctor_S("Slice index is out of bounds")
   _3=False
   _3 = fragments._c_closure_93(_0,_3,_1) # src/fusion/CompoundVariable.mbi:197:9-201:10
   if _3:
    _4=int((_0).shape[0])
    _5=numpy.zeros((_4,), dtype=numpy.dtype(numpy.int32))
    fragments._c_closure_94(_0,_1,_4,_5) # src/fusion/CompoundVariable.mbi:206:11-210:30
    return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2J_3J(self,mosek_fusion_NDSet._ctor__3I(_5),0,numpy.zeros((_4,), dtype=numpy.dtype(numpy.int64))))
   elif (int((_0).shape[0])==1):
    return (self._slice_II(_0[0],_1[0]))
   else:
    _6=(self._shape_p.nd)
    _7=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int32))
    _8=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int32))
    _9,_11,_10,_12 = fragments._c_closure_95(_0,_9,_11,_1,_10,_12,self.__stackdim,self.__varsb) # src/fusion/CompoundVariable.mbi:223:11-231:12
    _9 = numpy.int32(_9) # postprocess
    _11 = numpy.int32(_11) # postprocess
    _10 = numpy.int32(_10) # postprocess
    _12 = numpy.int32(_12) # postprocess
    fragments._c_closure_96(_0,_1,_6,_7,_8) # src/fusion/CompoundVariable.mbi:233:11-237:12
    if (_9==_11):
     _7[self.__stackdim] = _10
     _8[self.__stackdim] = _12
     return (self.__vars[_9]._slice__3I_3I(_7,_8))
    else:
     _13=numpy.zeros((((_11 - _9) + 1),), dtype=numpy.dtype(object))
     _7[self.__stackdim] = _10
     _8[self.__stackdim] = self.__vars[_9]._getShape_()._dim_I(self.__stackdim)
     _13[0] = self.__vars[_9]._slice__3I_3I(_7,_8)
     _7[self.__stackdim] = 0
     _8[self.__stackdim] = _12
     _13[(int((_13).shape[0]) - 1)] = self.__vars[_11]._slice__3I_3I(_7,_8)
     for _14 in range(1,(int((_13).shape[0]) - 1)):
      _7[self.__stackdim] = 0
      _8[self.__stackdim] = self.__vars[(_14 + _9)]._getShape_()._dim_I(self.__stackdim)
      _13[_14] = self.__vars[(_14 + _9)]._slice__3I_3I(_7,_8)
     return (mosek_fusion_CompoundVariable._ctor__3Lmosek_4fusion_4Variable_2I(_13,self.__stackdim))
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _slice_alt_II(self,_t__0,_t__1):
    return self._slice_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_II(self,_0,_1):
   if ((self._shape_p.nd)!=1):
    raise mosek_fusion_SliceError._ctor_S("Slice has wrong number of dimensions")
   elif (_0 > _1):
    raise mosek_fusion_SliceError._ctor_S("Invalid slice range")
   elif ((_0 < 0) or (_1 > self._shape_p._dim_I(0))):
    raise mosek_fusion_SliceError._ctor_S("Slice index is out of bounds")
   if (_0==_1):
    return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2J_3J(self,mosek_fusion_IntSet._ctor_I(0),0,numpy.array([0], dtype=numpy.dtype(numpy.int64))))
   _2,_4,_3,_5 = fragments._c_closure_97(_0,_2,_4,_1,_3,_5,self.__varsb) # src/fusion/CompoundVariable.mbi:149:9-157:10
   _2 = numpy.int32(_2) # postprocess
   _4 = numpy.int32(_4) # postprocess
   _3 = numpy.int32(_3) # postprocess
   _5 = numpy.int32(_5) # postprocess
   if (_2==_4):
    return (self.__vars[_2]._slice_II(_3,_5))
   else:
    _6=numpy.zeros((((_4 - _2) + 1),), dtype=numpy.dtype(object))
    if (_3 > 0):
     _6[0] = self.__vars[_2]._slice_II(_3,self.__vars[_2]._getShape_()._dim_I(0))
    else:
     _6[0] = self.__vars[_2]
    if (_5 < self.__vars[_4]._getShape_()._dim_I(0)):
     _6[(int((_6).shape[0]) - 1)] = self.__vars[_4]._slice_II(0,_5)
    else:
     _6[(int((_6).shape[0]) - 1)] = self.__vars[_4]
    _7=1
    while (_7 < (int((_6).shape[0]) - 1)):
     _6[_7] = self.__vars[(_2 + _7)]
     _7 += 1
    return (mosek_fusion_CompoundVariable._ctor__3Lmosek_4fusion_4Variable_2I(_6,0))
  @staticmethod
  def __compute_1shape_alt__3Lmosek_4fusion_4Variable_2I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_CompoundVariable.__compute_1shape__3Lmosek_4fusion_4Variable_2I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __compute_1shape__3Lmosek_4fusion_4Variable_2I(_0,_1):
   _2=_0[0]._getShape_()
   _3=0
   for _4 in range(0,int((_0).shape[0])):
    _5=_0[_4]
    if ((_5._getShape_()._size) > 0):
     if ((_5._getShape_().nd)!=(_2.nd)):
      raise mosek_fusion_DimensionError._ctor_S("Mismatching variable shape")
     for _6 in range(0,(_2.nd)):
      if ((_6!=_1) and (_2._dim_I(_6)!=_5._getShape_()._dim_I(_6))):
       raise mosek_fusion_DimensionError._ctor_S("Mismatching variable shape")
     _3 = (_3 + _5._getShape_()._dim_I(_1))
   if ((_2.nd)==1):
    return (mosek_fusion_IntSet._ctor_I(_3))
   else:
    _7=numpy.array([_2._dim_I(_8) for _8 in range(0,(_2.nd))], dtype=numpy.dtype(numpy.int32))
    _7[_1] = _3
    return (mosek_fusion_NDSet._ctor__3I(_7))
  @staticmethod
  def __model_1from_1var_alt__3Lmosek_4fusion_4Variable_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_CompoundVariable.__model_1from_1var__3Lmosek_4fusion_4Variable_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __model_1from_1var__3Lmosek_4fusion_4Variable_2(_0):
   return ((None if (((_0 is None) or (int((_0).shape[0])==0)) ) else _0[0]._getModel_()))
 return CompoundVariable
mosek_fusion_CompoundVariable=__mk_mosek_fusion_CompoundVariable()
del __mk_mosek_fusion_CompoundVariable
#BEFORE CLASS
def __mk_mosek_fusion_RepeatVariable():
 class RepeatVariable(mosek_fusion_BaseVariable):
  __slots__ = ['_RepeatVariable__d2','_RepeatVariable__d1','_RepeatVariable__d0','_RepeatVariable__dim','_RepeatVariable__count','_RepeatVariable__xsize','_RepeatVariable__xdims','_RepeatVariable__x']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Variable_2II(*args): # mosek.fusion.Variable,int32,int32
      self._ctor_init_Lmosek_4fusion_4Variable_2II(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Variable_2II(*args):# mosek.fusion.Variable,int32,int32
      self._ctor_alt_init_Lmosek_4fusion_4Variable_2II(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.RepeatVariable.ctor(mosek.fusion.Variable,int32,int32)')
  def values(self,*args):
    if False: pass
    elif mosek_fusion_RepeatVariable._match_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_I_3DZ(*args)
    elif mosek_fusion_RepeatVariable._match_alt_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_alt_I_3DZ(*args)
    elif mosek_fusion_RepeatVariable._match_values__3JI_3DZ(*args): # []int64,int32,[]double,bool
      return self._values__3JI_3DZ(*args)
    elif mosek_fusion_RepeatVariable._match_alt_values__3JI_3DZ(*args): # []int64,int32,[]double,bool
      return self._values_alt__3JI_3DZ(*args)
    elif mosek_fusion_RepeatVariable._match_values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._values_J_3I_3JI_3DZ(*args)
    elif mosek_fusion_RepeatVariable._match_alt_values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._values_alt_J_3I_3JI_3DZ(*args)
    else:
      raise ValueError('Invalid argument list values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RepeatVariable.values(int32,array(double,ndim=1),bool)\n\tmosek.fusion.RepeatVariable.values(array(int64,ndim=1),int32,array(double,ndim=1),bool)\n\tmosek.fusion.RepeatVariable.values(int64,array(int32,ndim=1),array(int64,ndim=1),int32,array(double,ndim=1),bool)')
  def inst(self,*args):
    if False: pass
    elif mosek_fusion_RepeatVariable._match_inst_JJ_3I_3I_3I(*args): # int64,int64,[]int32,[]int32,[]int32
      return self._inst_JJ_3I_3I_3I(*args)
    elif mosek_fusion_RepeatVariable._match_alt_inst_JJ_3I_3I_3I(*args): # int64,int64,[]int32,[]int32,[]int32
      return self._inst_alt_JJ_3I_3I_3I(*args)
    elif mosek_fusion_RepeatVariable._match_inst__3JIIJJ_3I_3I_3I(*args): # []int64,int32,int32,int64,int64,[]int32,[]int32,[]int32
      return self._inst__3JIIJJ_3I_3I_3I(*args)
    elif mosek_fusion_RepeatVariable._match_alt_inst__3JIIJJ_3I_3I_3I(*args): # []int64,int32,int32,int64,int64,[]int32,[]int32,[]int32
      return self._inst_alt__3JIIJJ_3I_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list inst('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RepeatVariable.inst(int64,int64,array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.RepeatVariable.inst(array(int64,ndim=1),int32,int32,int64,int64,array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))')
  def make_continuous(self,*args):
    if False: pass
    elif mosek_fusion_RepeatVariable._match_make_1continuous__3J(*args): # []int64
      return self._make_1continuous__3J(*args)
    elif mosek_fusion_RepeatVariable._match_alt_make_1continuous__3J(*args): # []int64
      return self._make_1continuous_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_continuous('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RepeatVariable.make_continuous(array(int64,ndim=1))')
  def make_integer(self,*args):
    if False: pass
    elif mosek_fusion_RepeatVariable._match_make_1integer__3J(*args): # []int64
      return self._make_1integer__3J(*args)
    elif mosek_fusion_RepeatVariable._match_alt_make_1integer__3J(*args): # []int64
      return self._make_1integer_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_integer('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RepeatVariable.make_integer(array(int64,ndim=1))')
  def elementName(self,*args):
    if False: pass
    elif mosek_fusion_RepeatVariable._match_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_RepeatVariable._match_alt_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementName_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementName('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RepeatVariable.elementName(int64,mosek.fusion.Utils.StringBuffer)')
  def set_values(self,*args):
    if False: pass
    elif mosek_fusion_RepeatVariable._match_set_1values__3J_3DZ(*args): # []int64,[]double,bool
      return self._set_1values__3J_3DZ(*args)
    elif mosek_fusion_RepeatVariable._match_alt_set_1values__3J_3DZ(*args): # []int64,[]double,bool
      return self._set_1values_alt__3J_3DZ(*args)
    elif mosek_fusion_RepeatVariable._match_set_1values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._set_1values_J_3I_3JI_3DZ(*args)
    elif mosek_fusion_RepeatVariable._match_alt_set_1values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._set_1values_alt_J_3I_3JI_3DZ(*args)
    else:
      raise ValueError('Invalid argument list set_values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RepeatVariable.set_values(array(int64,ndim=1),array(double,ndim=1),bool)\n\tmosek.fusion.RepeatVariable.set_values(int64,array(int32,ndim=1),array(int64,ndim=1),int32,array(double,ndim=1),bool)')
  def elementDesc(self,*args):
    if False: pass
    elif mosek_fusion_RepeatVariable._match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_RepeatVariable._match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementDesc('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RepeatVariable.elementDesc(int64,mosek.fusion.Utils.StringBuffer)')
  def __repr__(self): return 'mosek.fusion.RepeatVariable'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Variable_2II(x,dim,count):
    o = RepeatVariable.__new__(RepeatVariable)
    o._ctor_init_Lmosek_4fusion_4Variable_2II(x,dim,count)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Variable_2II(*args):
    if len(args) != 3: return False
    x,dim,count, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(x) and __arg_match_I__(dim) and __arg_match_I__(count))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Variable_2II(*args):
    if len(args) != 3: return False
    x,dim,count, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(x) and __arg_alt_match_I__(dim) and __arg_alt_match_I__(count))
  def _ctor_alt_init_Lmosek_4fusion_4Variable_2II(self,x,dim,count):
    self._ctor_init_Lmosek_4fusion_4Variable_2II(x,numpy.int32(dim),numpy.int32(count))
  def _ctor_init_Lmosek_4fusion_4Variable_2II(self,x,dim,count):
   mosek_fusion_BaseVariable._ctor_init_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Set_2(self,x._getModel_(),mosek.fusion.RepeatVariable.__compute_1shape_Lmosek_4fusion_4Variable_2II(x,dim,count))
   _0=x._getShape_()
   (self.__x) = x
   (self.__count) = count
   self.__xsize = _0._getSize_()
   if (dim >= 0):
    _1=(_0.nd)
    if (_1 <= dim):
     _1 = (dim + 1)
    (self.__dim) = dim
    (self.__xdims) = numpy.array([_0._dim_I(_2) for _2 in range(0,_1)], dtype=numpy.dtype(numpy.int32))
   else:
    (self.__dim) = 0
    self.__xdims = numpy.zeros((((_0.nd) + 1),), dtype=numpy.dtype(numpy.int32))
    self.__xdims[0] = 1
    for _3 in range(0,(_0.nd)):
     self.__xdims[(_3 + 1)] = _0._dim_I(_3)
   (self.__d0) = 1
   (self.__d1) = 1
   (self.__d2) = 1
   self.__d0 = fragments._c_closure_98(self.__d0,dim,self.__xdims) # src/fusion/RepeatVariable.monty:80:11-47
   self.__d0 = numpy.int64(self.__d0) # postprocess
   self.__d1 = (self.__xdims[(self.__dim)] * count)
   self.__d2 = fragments._c_closure_99(self.__d2,dim,self.__xdims) # src/fusion/RepeatVariable.monty:82:11-58
   self.__d2 = numpy.int64(self.__d2) # postprocess
  @staticmethod
  def _match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_J__(_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  @staticmethod
  def _match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  def _elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   if (self.__dim==0):
    return (self.__x._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2((_0 % self.__xsize),_1))
   elif (self.__dim >= (self.__x._getShape_().nd)):
    return (self.__x._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2((_0 // self.__xsize),_1))
   else:
    _2=self.__d0
    _3=(self.__xdims[self.__dim] * self.__d2)
    _4=(_0 % _3)
    _5=(_0 // (_3 * self.__count))
    return (self.__x._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(((_5 * _3) + _4),_1))
  @staticmethod
  def _match_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_J__(_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  @staticmethod
  def _match_alt_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  def _elementName_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   if (self.__dim==0):
    self.__x._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2((_0 % self.__xsize),_1)
   elif (self.__dim >= (self.__x._getShape_().nd)):
    self.__x._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2((_0 // self.__xsize),_1)
   else:
    _2=self.__d0
    _3=(self.__x._getShape_()._dim_I(self.__dim) * self.__d2)
    _4=(_0 % _3)
    _5=(_0 // (_3 * self.__count))
    self.__x._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(((_5 * _3) + _4),_1)
  @staticmethod
  def _match_inst_JJ_3I_3I_3I(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match_J__(_0) and __arg_match_J__(_1) and __arg_match__3I__(_2) and __arg_match__3I__(_3) and __arg_match__3I__(_4))
  @staticmethod
  def _match_alt_inst_JJ_3I_3I_3I(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_J__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match__3I__(_3) and __arg_alt_match__3I__(_4))
  def _inst_alt_JJ_3I_3I_3I(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.int64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int32))
   _1 = self._inst_JJ_3I_3I_3I(_0,_1,_2,_3,_4)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst_JJ_3I_3I_3I(self,_0,_1,_2,_3,_4):
   if (self.__dim==0):
    self.__x._inst_JJ_3I_3I_3I((_0 % self.__xsize),_1,_2,_4,_3)
   elif ((self.__d1 * self.__d2)==1):
    self.__x._inst_JJ_3I_3I_3I((_0 // self.__count),_1,_2,_4,_3)
   else:
    _5=self.__d0
    _6=(self.__x._getShape_()._dim_I(self.__dim) * self.__d2)
    _7=(_0 % _6)
    _8=(_0 // (_6 * self.__count))
    self.__x._inst_JJ_3I_3I_3I(((_8 * _6) + _7),_1,_2,_4,_3)
  @staticmethod
  def _match_set_1values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match_J__(_0) and __arg_match__3I__(_1) and __arg_match__3J__(_2) and __arg_match_I__(_3) and __arg_match__3D__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_set_1values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match__3D__(_4) and __arg_alt_match_Z__(_5))
  def _set_1values_alt_J_3I_3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = self._set_1values_J_3I_3JI_3DZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values_J_3I_3JI_3DZ(self,_0,_1,_2,_3,_4,_5):
   if ((int((_1).shape[0])!=(self._shape_p.nd)) or (int((_2).shape[0])!=(self._shape_p.nd))):
    raise mosek_fusion_IndexError._ctor_S("Lengths of nsize and strides are not correct")
   _6=int((_2).shape[0])
   _7=_1[0]
   _7 = fragments._c_closure_100(_1,_7) # src/fusion/RepeatVariable.monty:239:9-70
   _7 = numpy.int32(_7) # postprocess
   _8=numpy.array([_0 for _9 in range(0,int((_1).shape[0]))], dtype=numpy.dtype(numpy.int64))
   _10=self._shape_p._idxtokey_J(_0)
   _11=numpy.zeros((_7,), dtype=numpy.dtype(numpy.float64))
   _12=numpy.zeros((_7,), dtype=numpy.dtype(numpy.int64))
   for _13 in range(0,_7):
    _11[_13] = _4[(_13 + _3)]
    _14=(_8[0] % self.__d2)
    _15=((_8[0] // self.__d2) % self.__xdims[self.__dim])
    _16=(_8[0] // (self.__d1 * self.__d2))
    _12[_13] = ((((_14 * self.__d2) + _15) * self.__xdims[self.__dim]) + _16)
    _10[0] += 1
    _8[0] = (_8[0] + _2[(_6 - 1)])
    _17=0
    while ((_17 < (_6 - 1)) and (_10[_17]==_1[_17])):
     _10[_17] = 0
     _10[(_17 + 1)] += 1
     _17 += 1
    fragments._c_closure_101(_17,_8) # src/fusion/RepeatVariable.monty:267:13-268:28
   self._set_1values__3J_3DZ(_12,_11,_5)
  @staticmethod
  def _match_set_1values__3J_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3J__(_0) and __arg_match__3D__(_1) and __arg_match_Z__(_2))
  @staticmethod
  def _match_alt_set_1values__3J_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3D__(_1) and __arg_alt_match_Z__(_2))
  def _set_1values_alt__3J_3DZ(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=_t__2
   _1 = self._set_1values__3J_3DZ(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values__3J_3DZ(self,_0,_1,_2):
   if (self.__dim==0):
    self.__x._set_1values__3J_3DZ(numpy.array([(_0[_3] % self.__xsize) for _3 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int64)),_1,_2)
   elif ((self.__d1 * self.__d2)==1):
    self.__x._set_1values__3J_3DZ(numpy.array([(_0[_4] // self.__count) for _4 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int64)),_1,_2)
   else:
    _5=self.__d0
    _6=(self.__x._getShape_()._dim_I(self.__dim) * self.__d2)
    _7=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int64))
    fragments._c_closure_102(self.__count,_6,_0,_7) # src/fusion/RepeatVariable.monty:215:11-220:12
    self.__x._set_1values__3J_3DZ(_7,_1,_2)
  @staticmethod
  def _match_values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match_J__(_0) and __arg_match__3I__(_1) and __arg_match__3J__(_2) and __arg_match_I__(_3) and __arg_match__3D__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match__3D__(_4) and __arg_alt_match_Z__(_5))
  def _values_alt_J_3I_3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = self._values_J_3I_3JI_3DZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values_J_3I_3JI_3DZ(self,_0,_1,_2,_3,_4,_5):
   if ((int((_1).shape[0])!=(self._shape_p.nd)) or (int((_2).shape[0])!=(self._shape_p.nd))):
    raise mosek_fusion_IndexError._ctor_S("Lengths of nsize and strides are not correct")
   _6=int((_2).shape[0])
   _7=_1[0]
   _7 = fragments._c_closure_103(_1,_7) # src/fusion/RepeatVariable.monty:168:9-70
   _7 = numpy.int32(_7) # postprocess
   _8=numpy.array([_0 for _9 in range(0,int((_1).shape[0]))], dtype=numpy.dtype(numpy.int64))
   _10=self._shape_p._idxtokey_J(_0)
   _11=numpy.zeros((_7,), dtype=numpy.dtype(numpy.int64))
   for _12 in range(0,_7):
    _13=(_8[0] % self.__d2)
    _14=((_8[0] // self.__d2) % self.__xdims[self.__dim])
    _15=(_8[0] // (self.__d1 * self.__d2))
    _11[_12] = ((((_13 * self.__d2) + _14) * self.__xdims[self.__dim]) + _15)
    _10[0] += 1
    _8[0] = (_8[0] + _2[(_6 - 1)])
    _16=0
    while ((_16 < (_6 - 1)) and (_10[_16]==_1[_16])):
     _10[_16] = 0
     _10[(_16 + 1)] += 1
     _16 += 1
    fragments._c_closure_104(_16,_8) # src/fusion/RepeatVariable.monty:194:13-195:28
   self._values__3JI_3DZ(_11,_3,_4,_5)
  @staticmethod
  def _match_values__3JI_3DZ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match__3J__(_0) and __arg_match_I__(_1) and __arg_match__3D__(_2) and __arg_match_Z__(_3))
  @staticmethod
  def _match_alt_values__3JI_3DZ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match_Z__(_3))
  def _values_alt__3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=_t__3
   _1 = self._values__3JI_3DZ(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values__3JI_3DZ(self,_0,_1,_2,_3):
   if (self.__d0==1):
    self.__x._values__3JI_3DZ(numpy.array([(_0[_4] % self.__xsize) for _4 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int64)),_1,_2,_3)
   elif ((self.__d1 * self.__d2)==1):
    self.__x._values__3JI_3DZ(numpy.array([(_0[_5] // self.__count) for _5 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int64)),_1,_2,_3)
   else:
    _6=self.__d0
    _7=(self.__x._getShape_()._dim_I(self.__dim) * self.__d2)
    _8=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int64))
    fragments._c_closure_105(self.__count,_7,_0,_8) # src/fusion/RepeatVariable.monty:145:11-150:12
    self.__x._values__3JI_3DZ(_8,_1,_2,_3)
  @staticmethod
  def _match_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3J__(_0))
  @staticmethod
  def _match_alt_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3J__(_0))
  def _make_1continuous_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1continuous__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1continuous__3J(self,_0):
   if (self.__d0==1):
    self.__x._make_1continuous__3J(numpy.array([(_0[_1] % self.__xsize) for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int64)))
   elif ((self.__d1 * self.__d2)==1):
    self.__x._make_1continuous__3J(numpy.array([(_0[_2] // self.__count) for _2 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int64)))
   else:
    _3=self.__d0
    _4=(self.__x._getShape_()._dim_I(self.__dim) * self.__d2)
    _5=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int64))
    fragments._c_closure_106(self.__count,_4,_0,_5) # src/fusion/RepeatVariable.monty:120:11-125:12
    self.__x._make_1continuous__3J(_5)
  @staticmethod
  def _match_make_1integer__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3J__(_0))
  @staticmethod
  def _match_alt_make_1integer__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3J__(_0))
  def _make_1integer_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1integer__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1integer__3J(self,_0):
   if (self.__dim==0):
    self.__x._make_1integer__3J(numpy.array([(_0[_1] % self.__xsize) for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int64)))
   elif ((self.__d1 * self.__d2)==1):
    self.__x._make_1integer__3J(numpy.array([(_0[_2] // self.__count) for _2 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int64)))
   else:
    _3=self.__d0
    _4=(self.__x._getShape_()._dim_I(self.__dim) * self.__d2)
    _5=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int64))
    fragments._c_closure_107(self.__count,_4,_0,_5) # src/fusion/RepeatVariable.monty:98:11-103:12
    self.__x._make_1integer__3J(_5)
  @staticmethod
  def __compute_1shape_alt_Lmosek_4fusion_4Variable_2II(_t__0,_t__1,_t__2):
    return mosek_fusion_RepeatVariable.__compute_1shape_Lmosek_4fusion_4Variable_2II(_0,numpy.int32(__1),numpy.int32(__2))
  @staticmethod
  def __compute_1shape_Lmosek_4fusion_4Variable_2II(_0,_1,_2):
   _3=_0._getShape_()
   if (_1 >= 0):
    if (((_3.nd)==1) and (_1==0)):
     return (mosek.fusion.Set._make_I((_3._dim_I(0) * _2)))
    elif (_1 < (_3.nd)):
     _4=numpy.array([_3._dim_I(_5) for _5 in range(0,(_3.nd))], dtype=numpy.dtype(numpy.int32))
     _4[_1] *= _2
     return (mosek.fusion.Set._make__3I(_4))
    else:
     _6=numpy.zeros(((_1 + 1),), dtype=numpy.dtype(numpy.int32))
     for _7 in range(0,(_3.nd)):
      _6[_7] = _3._dim_I(_7)
     for _8 in range((_3.nd),_1):
      _6[_8] = 1
     _6[_1] = _2
     return (mosek.fusion.Set._make__3I(_6))
   else:
    _9=numpy.zeros((((_3.nd) + 1),), dtype=numpy.dtype(numpy.int32))
    _9[0] = _2
    for _10 in range(0,(_3.nd)):
     _9[(_10 + 1)] = _3._dim_I(_10)
    return (mosek.fusion.Set._make__3I(_9))
 return RepeatVariable
mosek_fusion_RepeatVariable=__mk_mosek_fusion_RepeatVariable()
del __mk_mosek_fusion_RepeatVariable
#BEFORE CLASS
def __mk_mosek_fusion_PickVariable():
 class PickVariable(mosek_fusion_BaseVariable):
  __slots__ = ['_PickVariable__indexes','_PickVariable__origin']
  def values(self,*args):
    if False: pass
    elif mosek_fusion_PickVariable._match_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_I_3DZ(*args)
    elif mosek_fusion_PickVariable._match_alt_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_alt_I_3DZ(*args)
    elif mosek_fusion_PickVariable._match_values__3JI_3DZ(*args): # []int64,int32,[]double,bool
      return self._values__3JI_3DZ(*args)
    elif mosek_fusion_PickVariable._match_alt_values__3JI_3DZ(*args): # []int64,int32,[]double,bool
      return self._values_alt__3JI_3DZ(*args)
    elif mosek_fusion_PickVariable._match_values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._values_J_3I_3JI_3DZ(*args)
    elif mosek_fusion_PickVariable._match_alt_values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._values_alt_J_3I_3JI_3DZ(*args)
    else:
      raise ValueError('Invalid argument list values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.PickVariable.values(int32,array(double,ndim=1),bool)\n\tmosek.fusion.PickVariable.values(array(int64,ndim=1),int32,array(double,ndim=1),bool)\n\tmosek.fusion.PickVariable.values(int64,array(int32,ndim=1),array(int64,ndim=1),int32,array(double,ndim=1),bool)')
  def make_integer(self,*args):
    if False: pass
    elif mosek_fusion_PickVariable._match_make_1integer__3J(*args): # []int64
      return self._make_1integer__3J(*args)
    elif mosek_fusion_PickVariable._match_alt_make_1integer__3J(*args): # []int64
      return self._make_1integer_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_integer('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.PickVariable.make_integer(array(int64,ndim=1))')
  def set_values(self,*args):
    if False: pass
    elif mosek_fusion_PickVariable._match_set_1values__3J_3DZ(*args): # []int64,[]double,bool
      return self._set_1values__3J_3DZ(*args)
    elif mosek_fusion_PickVariable._match_alt_set_1values__3J_3DZ(*args): # []int64,[]double,bool
      return self._set_1values_alt__3J_3DZ(*args)
    elif mosek_fusion_PickVariable._match_set_1values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._set_1values_J_3I_3JI_3DZ(*args)
    elif mosek_fusion_PickVariable._match_alt_set_1values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._set_1values_alt_J_3I_3JI_3DZ(*args)
    else:
      raise ValueError('Invalid argument list set_values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.PickVariable.set_values(array(int64,ndim=1),array(double,ndim=1),bool)\n\tmosek.fusion.PickVariable.set_values(int64,array(int32,ndim=1),array(int64,ndim=1),int32,array(double,ndim=1),bool)')
  def inst(self,*args):
    if False: pass
    elif mosek_fusion_PickVariable._match_inst_JJ_3I_3I_3I(*args): # int64,int64,[]int32,[]int32,[]int32
      return self._inst_JJ_3I_3I_3I(*args)
    elif mosek_fusion_PickVariable._match_alt_inst_JJ_3I_3I_3I(*args): # int64,int64,[]int32,[]int32,[]int32
      return self._inst_alt_JJ_3I_3I_3I(*args)
    elif mosek_fusion_PickVariable._match_inst__3JIIJJ_3I_3I_3I(*args): # []int64,int32,int32,int64,int64,[]int32,[]int32,[]int32
      return self._inst__3JIIJJ_3I_3I_3I(*args)
    elif mosek_fusion_PickVariable._match_alt_inst__3JIIJJ_3I_3I_3I(*args): # []int64,int32,int32,int64,int64,[]int32,[]int32,[]int32
      return self._inst_alt__3JIIJJ_3I_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list inst('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.PickVariable.inst(int64,int64,array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.PickVariable.inst(array(int64,ndim=1),int32,int32,int64,int64,array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))')
  def slice(self,*args):
    if False: pass
    elif mosek_fusion_PickVariable._match_slice_II(*args): # int32,int32
      return self._slice_II(*args)
    elif mosek_fusion_PickVariable._match_alt_slice_II(*args): # int32,int32
      return self._slice_alt_II(*args)
    elif mosek_fusion_PickVariable._match_slice__3I_3I(*args): # []int32,[]int32
      return self._slice__3I_3I(*args)
    elif mosek_fusion_PickVariable._match_alt_slice__3I_3I(*args): # []int32,[]int32
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.PickVariable.slice(int32,int32)\n\tmosek.fusion.PickVariable.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def elementDesc(self,*args):
    if False: pass
    elif mosek_fusion_PickVariable._match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_PickVariable._match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementDesc('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.PickVariable.elementDesc(int64,mosek.fusion.Utils.StringBuffer)')
  def elementName(self,*args):
    if False: pass
    elif mosek_fusion_PickVariable._match_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_PickVariable._match_alt_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementName_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementName('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.PickVariable.elementName(int64,mosek.fusion.Utils.StringBuffer)')
  def make_continuous(self,*args):
    if False: pass
    elif mosek_fusion_PickVariable._match_make_1continuous__3J(*args): # []int64
      return self._make_1continuous__3J(*args)
    elif mosek_fusion_PickVariable._match_alt_make_1continuous__3J(*args): # []int64
      return self._make_1continuous_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_continuous('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.PickVariable.make_continuous(array(int64,ndim=1))')
  def __repr__(self): return 'mosek.fusion.PickVariable'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Variable_2_3J(origin,idxs):
    o = PickVariable.__new__(PickVariable)
    o._ctor_init_Lmosek_4fusion_4Variable_2_3J(origin,idxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Variable_2_3J(*args):
    if len(args) != 2: return False
    origin,idxs, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(origin) and __arg_match__3J__(idxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Variable_2_3J(*args):
    if len(args) != 2: return False
    origin,idxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(origin) and __arg_alt_match__3J__(idxs))
  def _ctor_alt_init_Lmosek_4fusion_4Variable_2_3J(self,origin,idxs):
    self._ctor_init_Lmosek_4fusion_4Variable_2_3J(origin,numpy.array(idxs,dtype=numpy.dtype(numpy.int64)))
  def _ctor_init_Lmosek_4fusion_4Variable_2_3J(self,origin,idxs):
   mosek_fusion_BaseVariable._ctor_init_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Set_2(self,origin._getModel_(),mosek.fusion.Set._make_I(int((idxs).shape[0])))
   (self.__origin) = origin
   _0=origin._getShape_()._getSize_()
   for _1 in range(0,int((idxs).shape[0])):
    if ((idxs[_1] < 0) or (idxs[_1] >= _0)):
     raise mosek_fusion_IndexError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Index (")._a_J(idxs[_1])._a_S(") is out of bounds")._toString_())
   (self.__indexes) = idxs
  @staticmethod
  def _match_inst_JJ_3I_3I_3I(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match_J__(_0) and __arg_match_J__(_1) and __arg_match__3I__(_2) and __arg_match__3I__(_3) and __arg_match__3I__(_4))
  @staticmethod
  def _match_alt_inst_JJ_3I_3I_3I(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_J__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match__3I__(_3) and __arg_alt_match__3I__(_4))
  def _inst_alt_JJ_3I_3I_3I(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.int64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int32))
   _1 = self._inst_JJ_3I_3I_3I(_0,_1,_2,_3,_4)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst_JJ_3I_3I_3I(self,_0,_1,_2,_3,_4):
   self.__origin._inst_JJ_3I_3I_3I(self.__indexes[_0],_1,_2,_3,_4)
  @staticmethod
  def _match_set_1values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match_J__(_0) and __arg_match__3I__(_1) and __arg_match__3J__(_2) and __arg_match_I__(_3) and __arg_match__3D__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_set_1values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match__3D__(_4) and __arg_alt_match_Z__(_5))
  def _set_1values_alt_J_3I_3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = self._set_1values_J_3I_3JI_3DZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values_J_3I_3JI_3DZ(self,_0,_1,_2,_3,_4,_5):
   self._set_1values__3J_3DZ(numpy.array([(_0 + (_2[0] * _6)) for _6 in range(0,_1[0])], dtype=numpy.dtype(numpy.int64)),(_4 if ((_3==0) ) else numpy.array([_4[(_7 + _3)] for _7 in range(0,_1[0])], dtype=numpy.dtype(numpy.float64))),_5)
  @staticmethod
  def _match_set_1values__3J_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3J__(_0) and __arg_match__3D__(_1) and __arg_match_Z__(_2))
  @staticmethod
  def _match_alt_set_1values__3J_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3D__(_1) and __arg_alt_match_Z__(_2))
  def _set_1values_alt__3J_3DZ(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=_t__2
   _1 = self._set_1values__3J_3DZ(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values__3J_3DZ(self,_0,_1,_2):
   self.__origin._set_1values__3J_3DZ(numpy.array([self.__indexes[_0[_3]] for _3 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int64)),_1,_2)
  @staticmethod
  def _match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_J__(_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  @staticmethod
  def _match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  def _elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   return (self.__origin._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(self.__indexes[_0],_1))
  @staticmethod
  def _match_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_J__(_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  @staticmethod
  def _match_alt_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  def _elementName_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   self.__origin._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(self.__indexes[_0],_1)
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _slice_alt_II(self,_t__0,_t__1):
    return self._slice_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_II(self,_0,_1):
   return (mosek_fusion_PickVariable._ctor_Lmosek_4fusion_4Variable_2_3J(self.__origin,numpy.array([self.__indexes[_2] for _2 in range(_0,_1)], dtype=numpy.dtype(numpy.int64))))
  @staticmethod
  def _match_values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match_J__(_0) and __arg_match__3I__(_1) and __arg_match__3J__(_2) and __arg_match_I__(_3) and __arg_match__3D__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match__3D__(_4) and __arg_alt_match_Z__(_5))
  def _values_alt_J_3I_3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = self._values_J_3I_3JI_3DZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values_J_3I_3JI_3DZ(self,_0,_1,_2,_3,_4,_5):
   _6=numpy.array([(_0 + (_7 * _2[0])) for _7 in range(0,_1[0])], dtype=numpy.dtype(numpy.int64))
   self._values__3JI_3DZ(_6,_3,_4,_5)
  @staticmethod
  def _match_values__3JI_3DZ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match__3J__(_0) and __arg_match_I__(_1) and __arg_match__3D__(_2) and __arg_match_Z__(_3))
  @staticmethod
  def _match_alt_values__3JI_3DZ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match_Z__(_3))
  def _values_alt__3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=_t__3
   _1 = self._values__3JI_3DZ(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values__3JI_3DZ(self,_0,_1,_2,_3):
   _4=numpy.array([self.__indexes[_0[_5]] for _5 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int64))
   self.__origin._values__3JI_3DZ(_4,_1,_2,_3)
  @staticmethod
  def _match_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3J__(_0))
  @staticmethod
  def _match_alt_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3J__(_0))
  def _make_1continuous_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1continuous__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1continuous__3J(self,_0):
   self.__origin._make_1continuous__3J(numpy.array([self.__indexes[_0[_1]] for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int64)))
  @staticmethod
  def _match_make_1integer__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3J__(_0))
  @staticmethod
  def _match_alt_make_1integer__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3J__(_0))
  def _make_1integer_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1integer__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1integer__3J(self,_0):
   self.__origin._make_1integer__3J(numpy.array([self.__indexes[_0[_1]] for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int64)))
 return PickVariable
mosek_fusion_PickVariable=__mk_mosek_fusion_PickVariable()
del __mk_mosek_fusion_PickVariable
#BEFORE CLASS
def __mk_mosek_fusion_SliceVariable():
 class SliceVariable(mosek_fusion_BaseVariable):
  __slots__ = ['_SliceVariable__strides','_SliceVariable__first','_SliceVariable__origin']
  def elementDesc(self,*args):
    if False: pass
    elif mosek_fusion_SliceVariable._match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_SliceVariable._match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementDesc('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SliceVariable.elementDesc(int64,mosek.fusion.Utils.StringBuffer)')
  def make_continuous(self,*args):
    if False: pass
    elif mosek_fusion_SliceVariable._match_make_1continuous__3J(*args): # []int64
      return self._make_1continuous__3J(*args)
    elif mosek_fusion_SliceVariable._match_alt_make_1continuous__3J(*args): # []int64
      return self._make_1continuous_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_continuous('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SliceVariable.make_continuous(array(int64,ndim=1))')
  def make_integer(self,*args):
    if False: pass
    elif mosek_fusion_SliceVariable._match_make_1integer__3J(*args): # []int64
      return self._make_1integer__3J(*args)
    elif mosek_fusion_SliceVariable._match_alt_make_1integer__3J(*args): # []int64
      return self._make_1integer_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_integer('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SliceVariable.make_integer(array(int64,ndim=1))')
  def slice(self,*args):
    if False: pass
    elif mosek_fusion_SliceVariable._match_slice_II(*args): # int32,int32
      return self._slice_II(*args)
    elif mosek_fusion_SliceVariable._match_alt_slice_II(*args): # int32,int32
      return self._slice_alt_II(*args)
    elif mosek_fusion_SliceVariable._match_slice__3I_3I(*args): # []int32,[]int32
      return self._slice__3I_3I(*args)
    elif mosek_fusion_SliceVariable._match_alt_slice__3I_3I(*args): # []int32,[]int32
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SliceVariable.slice(int32,int32)\n\tmosek.fusion.SliceVariable.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def inst(self,*args):
    if False: pass
    elif mosek_fusion_SliceVariable._match_inst_JJ_3I_3I_3I(*args): # int64,int64,[]int32,[]int32,[]int32
      return self._inst_JJ_3I_3I_3I(*args)
    elif mosek_fusion_SliceVariable._match_alt_inst_JJ_3I_3I_3I(*args): # int64,int64,[]int32,[]int32,[]int32
      return self._inst_alt_JJ_3I_3I_3I(*args)
    elif mosek_fusion_SliceVariable._match_inst__3JIIJJ_3I_3I_3I(*args): # []int64,int32,int32,int64,int64,[]int32,[]int32,[]int32
      return self._inst__3JIIJJ_3I_3I_3I(*args)
    elif mosek_fusion_SliceVariable._match_alt_inst__3JIIJJ_3I_3I_3I(*args): # []int64,int32,int32,int64,int64,[]int32,[]int32,[]int32
      return self._inst_alt__3JIIJJ_3I_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list inst('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SliceVariable.inst(int64,int64,array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.SliceVariable.inst(array(int64,ndim=1),int32,int32,int64,int64,array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))')
  def elementName(self,*args):
    if False: pass
    elif mosek_fusion_SliceVariable._match_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_SliceVariable._match_alt_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementName_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementName('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SliceVariable.elementName(int64,mosek.fusion.Utils.StringBuffer)')
  def set_values(self,*args):
    if False: pass
    elif mosek_fusion_SliceVariable._match_set_1values__3J_3DZ(*args): # []int64,[]double,bool
      return self._set_1values__3J_3DZ(*args)
    elif mosek_fusion_SliceVariable._match_alt_set_1values__3J_3DZ(*args): # []int64,[]double,bool
      return self._set_1values_alt__3J_3DZ(*args)
    elif mosek_fusion_SliceVariable._match_set_1values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._set_1values_J_3I_3JI_3DZ(*args)
    elif mosek_fusion_SliceVariable._match_alt_set_1values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._set_1values_alt_J_3I_3JI_3DZ(*args)
    else:
      raise ValueError('Invalid argument list set_values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SliceVariable.set_values(array(int64,ndim=1),array(double,ndim=1),bool)\n\tmosek.fusion.SliceVariable.set_values(int64,array(int32,ndim=1),array(int64,ndim=1),int32,array(double,ndim=1),bool)')
  def values(self,*args):
    if False: pass
    elif mosek_fusion_SliceVariable._match_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_I_3DZ(*args)
    elif mosek_fusion_SliceVariable._match_alt_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_alt_I_3DZ(*args)
    elif mosek_fusion_SliceVariable._match_values__3JI_3DZ(*args): # []int64,int32,[]double,bool
      return self._values__3JI_3DZ(*args)
    elif mosek_fusion_SliceVariable._match_alt_values__3JI_3DZ(*args): # []int64,int32,[]double,bool
      return self._values_alt__3JI_3DZ(*args)
    elif mosek_fusion_SliceVariable._match_values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._values_J_3I_3JI_3DZ(*args)
    elif mosek_fusion_SliceVariable._match_alt_values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._values_alt_J_3I_3JI_3DZ(*args)
    else:
      raise ValueError('Invalid argument list values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SliceVariable.values(int32,array(double,ndim=1),bool)\n\tmosek.fusion.SliceVariable.values(array(int64,ndim=1),int32,array(double,ndim=1),bool)\n\tmosek.fusion.SliceVariable.values(int64,array(int32,ndim=1),array(int64,ndim=1),int32,array(double,ndim=1),bool)')
  def __repr__(self): return 'mosek.fusion.SliceVariable'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2J_3J(origin,shape,first,strides):
    o = SliceVariable.__new__(SliceVariable)
    o._ctor_init_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2J_3J(origin,shape,first,strides)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2J_3J(*args):
    if len(args) != 4: return False
    origin,shape,first,strides, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(origin) and __arg_match_Lmosek_4fusion_4Set_2__(shape) and __arg_match_J__(first) and __arg_match__3J__(strides))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2J_3J(*args):
    if len(args) != 4: return False
    origin,shape,first,strides, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(origin) and __arg_alt_match_Lmosek_4fusion_4Set_2__(shape) and __arg_alt_match_J__(first) and __arg_alt_match__3J__(strides))
  def _ctor_alt_init_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2J_3J(self,origin,shape,first,strides):
    self._ctor_init_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2J_3J(origin,shape,numpy.int64(first),numpy.array(strides,dtype=numpy.dtype(numpy.int64)))
  def _ctor_init_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2J_3J(self,origin,shape,first,strides):
   mosek_fusion_BaseVariable._ctor_init_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Set_2(self,origin._getModel_(),shape)
   (self.__origin) = origin
   (self.__first) = first
   (self.__strides) = strides
  @staticmethod
  def _match_inst_JJ_3I_3I_3I(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match_J__(_0) and __arg_match_J__(_1) and __arg_match__3I__(_2) and __arg_match__3I__(_3) and __arg_match__3I__(_4))
  @staticmethod
  def _match_alt_inst_JJ_3I_3I_3I(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_J__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match__3I__(_3) and __arg_alt_match__3I__(_4))
  def _inst_alt_JJ_3I_3I_3I(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.int64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int32))
   _1 = self._inst_JJ_3I_3I_3I(_0,_1,_2,_3,_4)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst_JJ_3I_3I_3I(self,_0,_1,_2,_3,_4):
   if ((_0 < 0) or (_0 >= (self._shape_p._size))):
    raise mosek_fusion_IndexError._ctor_S("Index out of bounds")
   _5=self.__first
   _6=_0
   for _7 in range(0,(self._shape_p.nd)):
    _8=(_6 // self._shape_p._stride_I(_7))
    _6 = (_6 - (_8 * self._shape_p._stride_I(_7)))
    _5 = (_5 + (self.__strides[_7] * _8))
   self.__origin._inst_JJ_3I_3I_3I(_5,_1,_2,_3,_4)
  @staticmethod
  def _match_set_1values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match_J__(_0) and __arg_match__3I__(_1) and __arg_match__3J__(_2) and __arg_match_I__(_3) and __arg_match__3D__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_set_1values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match__3D__(_4) and __arg_alt_match_Z__(_5))
  def _set_1values_alt_J_3I_3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = self._set_1values_J_3I_3JI_3DZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values_J_3I_3JI_3DZ(self,_0,_1,_2,_3,_4,_5):
   if ((_0==0) and ((int((_1).shape[0])==1) and ((_1[0]==(self._shape_p._size)) and (_2[0]==1)))):
    _6=numpy.array([self._shape_p._dim_I(_7) for _7 in range(0,(self._shape_p.nd))], dtype=numpy.dtype(numpy.int32))
    self.__origin._set_1values_J_3I_3JI_3DZ(self.__first,_6,self.__strides,_3,_4,_5)
   else:
    _8=int((_1).shape[0])
    _9=(_8==(self._shape_p.nd))
    _10=0
    while ((_10 < _8) and _9):
     _9 = (_2[_10]==self._shape_p._stride_I(_10))
     _10 += 1
    if _9:
     _11=self.__first
     _12=_0
     for _13 in range(0,((self._shape_p.nd) - 1)):
      _14=(_12 // _2[_13])
      _12 = (_12 - (_2[_13] * _14))
      _11 = (_11 + (self._shape_p._stride_I(_13) * _14))
     self.__origin._set_1values_J_3I_3JI_3DZ(_11,_1,self.__strides,_3,_4,_5)
    else:
     _15=1
     _15 = fragments._c_closure_108(_1,_15) # src/fusion/SliceVariable.mbi:331:33-96
     _15 = numpy.int64(_15) # postprocess
     _16=numpy.zeros((_15,), dtype=numpy.dtype(numpy.int64))
     _17=numpy.zeros((int((_1).shape[0]),), dtype=numpy.dtype(numpy.int32))
     _18=numpy.zeros((int((_1).shape[0]),), dtype=numpy.dtype(numpy.int64))
     for _19 in range(0,_15):
      _16[_19] = (self.__origin._getShape_()._linearidx__3I(self._shape_p._idxtokey_J((_0 + _18[0]))) + self.__first)
      _20=0
      _17[0] += 1
      _18[0] = (_18[0] + _2[(_8 - 1)])
      while ((_20 < (_8 - 1)) and (_17[_20] >= _1[((_8 - _20) - 1)])):
       _18[(_20 + 1)] = (_18[(_20 + 1)] + _2[((_8 - _20) - 2)])
       _17[_20] = 0
       _17[(_20 + 1)] += 1
       _20 += 1
      fragments._c_closure_109(_20,_18) # src/fusion/SliceVariable.mbi:352:20-55
     self.__origin._set_1values__3J_3DZ(_16,(_4 if ((_3==0) ) else numpy.array([_4[(_21 + _3)] for _21 in range(0,_15)], dtype=numpy.dtype(numpy.float64))),_5)
  @staticmethod
  def _match_set_1values__3J_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3J__(_0) and __arg_match__3D__(_1) and __arg_match_Z__(_2))
  @staticmethod
  def _match_alt_set_1values__3J_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3D__(_1) and __arg_alt_match_Z__(_2))
  def _set_1values_alt__3J_3DZ(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=_t__2
   _1 = self._set_1values__3J_3DZ(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values__3J_3DZ(self,_0,_1,_2):
   _3=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int64))
   for _4 in range(0,int((_0).shape[0])):
    _5=self._shape_p._idxtokey_J(_0[_4])
    _6=self.__first
    for _7 in range(0,(self._shape_p.nd)):
     _6 = (_6 + (numpy.int64(_5[_7]) * self.__strides[_7]))
    _3[_4] = _6
   self.__origin._set_1values__3J_3DZ(_3,_1,_2)
  @staticmethod
  def _match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_J__(_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  @staticmethod
  def _match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  def _elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   if ((_0 < 0) or (_0 >= (self._shape_p._size))):
    raise mosek_fusion_IndexError._ctor_S("Index out of bounds")
   _2=self.__first
   _3=_0
   for _4 in range(0,(self._shape_p.nd)):
    _5=(_3 // self._shape_p._stride_I(_4))
    _3 = (_3 - (_5 * self._shape_p._stride_I(_4)))
    _2 = (_2 + (self.__strides[_4] * _5))
   self.__origin._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(_2,_1)
   return (_1)
  @staticmethod
  def _match_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_J__(_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  @staticmethod
  def _match_alt_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  def _elementName_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   if ((_0 < 0) or (_0 >= (self._shape_p._size))):
    raise mosek_fusion_IndexError._ctor_S("Index out of bounds")
   _2=self.__first
   _3=_0
   for _4 in range(0,(self._shape_p.nd)):
    _5=(_3 // self._shape_p._stride_I(_4))
    _3 = (_3 - (_5 * self._shape_p._stride_I(_4)))
    _2 = (_2 + (self.__strides[_4] * _5))
   self.__origin._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(_2,_1)
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _slice_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._slice__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice__3I_3I(self,_0,_1):
   _2=self._shape_p._slice__3I_3I(_0,_1)
   _3=self.__first
   _3 = fragments._c_closure_110(_0,_3,self.__strides) # src/fusion/SliceVariable.mbi:215:9-216:56
   _3 = numpy.int64(_3) # postprocess
   return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2J_3J(self.__origin,_2,_3,self.__strides))
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _slice_alt_II(self,_t__0,_t__1):
    return self._slice_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_II(self,_0,_1):
   return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2J_3J(self.__origin,self._shape_p._slice_II(_0,_1),(self.__first + numpy.int64(_0)),self.__strides))
  @staticmethod
  def _match_values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match_J__(_0) and __arg_match__3I__(_1) and __arg_match__3J__(_2) and __arg_match_I__(_3) and __arg_match__3D__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match__3D__(_4) and __arg_alt_match_Z__(_5))
  def _values_alt_J_3I_3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = self._values_J_3I_3JI_3DZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values_J_3I_3JI_3DZ(self,_0,_1,_2,_3,_4,_5):
   if ((_0==0) and ((int((_1).shape[0])==1) and ((_1[0]==(self._shape_p._size)) and (_2[0]==1)))):
    _6=numpy.array([self._shape_p._dim_I(_7) for _7 in range(0,(self._shape_p.nd))], dtype=numpy.dtype(numpy.int32))
    self.__origin._values_J_3I_3JI_3DZ(self.__first,_6,self.__strides,_3,_4,_5)
   else:
    _8=int((_1).shape[0])
    _9=(_8==(self._shape_p.nd))
    _10=0
    while ((_10 < _8) and _9):
     _9 = (_2[_10]==self._shape_p._stride_I(_10))
     _10 += 1
    if _9:
     _11=self.__first
     _12=_0
     for _13 in range(0,((self._shape_p.nd) - 1)):
      _14=(_12 // _2[_13])
      _12 = (_12 - (_2[_13] * _14))
      _11 = (_11 + (self._shape_p._stride_I(_13) * _14))
     self.__origin._values_J_3I_3JI_3DZ(_11,_1,self.__strides,_3,_4,_5)
    else:
     _15=1
     _15 = fragments._c_closure_111(_1,_15) # src/fusion/SliceVariable.mbi:168:33-96
     _15 = numpy.int64(_15) # postprocess
     _16=numpy.zeros((_15,), dtype=numpy.dtype(numpy.int64))
     _17=numpy.zeros((int((_1).shape[0]),), dtype=numpy.dtype(numpy.int32))
     _18=numpy.zeros((int((_1).shape[0]),), dtype=numpy.dtype(numpy.int64))
     for _19 in range(0,_15):
      _16[_19] = (self.__origin._getShape_()._linearidx__3I(self._shape_p._idxtokey_J((_0 + _18[0]))) + self.__first)
      _20=0
      _17[0] += 1
      _18[0] = (_18[0] + _2[(_8 - 1)])
      while ((_20 < (_8 - 1)) and (_17[_20] >= _1[((_8 - _20) - 1)])):
       _18[(_20 + 1)] = (_18[(_20 + 1)] + _2[((_8 - _20) - 2)])
       _17[_20] = 0
       _17[(_20 + 1)] += 1
       _20 += 1
      fragments._c_closure_112(_20,_18) # src/fusion/SliceVariable.mbi:189:20-55
     self.__origin._values__3JI_3DZ(_16,_3,_4,_5)
  @staticmethod
  def _match_values__3JI_3DZ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match__3J__(_0) and __arg_match_I__(_1) and __arg_match__3D__(_2) and __arg_match_Z__(_3))
  @staticmethod
  def _match_alt_values__3JI_3DZ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match_Z__(_3))
  def _values_alt__3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=_t__3
   _1 = self._values__3JI_3DZ(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values__3JI_3DZ(self,_0,_1,_2,_3):
   _4=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int64))
   for _5 in range(0,int((_0).shape[0])):
    _6=self._shape_p._idxtokey_J(_0[_5])
    _7=self.__first
    for _8 in range(0,(self._shape_p.nd)):
     _7 = (_7 + (numpy.int64(_6[_8]) * self.__strides[_8]))
    _4[_5] = _7
   self.__origin._values__3JI_3DZ(_4,_1,_2,_3)
  @staticmethod
  def _match_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3J__(_0))
  @staticmethod
  def _match_alt_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3J__(_0))
  def _make_1continuous_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1continuous__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1continuous__3J(self,_0):
   _1=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int64))
   for _2 in range(0,int((_0).shape[0])):
    _3=self._shape_p._idxtokey_J(_0[_2])
    _4=self.__first
    for _5 in range(0,(self._shape_p.nd)):
     _4 = (_4 + (numpy.int64(_3[_5]) * self.__strides[_5]))
    _1[_2] = _4
   self.__origin._make_1continuous__3J(_1)
  @staticmethod
  def _match_make_1integer__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3J__(_0))
  @staticmethod
  def _match_alt_make_1integer__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3J__(_0))
  def _make_1integer_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1integer__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1integer__3J(self,_0):
   _1=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int64))
   for _2 in range(0,int((_0).shape[0])):
    _3=self._shape_p._idxtokey_J(_0[_2])
    _4=self.__first
    for _5 in range(0,(self._shape_p.nd)):
     _4 = (_4 + (numpy.int64(_3[_5]) * self.__strides[_5]))
    _1[_2] = _4
   self.__origin._make_1integer__3J(_1)
 return SliceVariable
mosek_fusion_SliceVariable=__mk_mosek_fusion_SliceVariable()
del __mk_mosek_fusion_SliceVariable
#BEFORE CLASS
def __mk_mosek_fusion_BoundInterfaceVariable():
 class BoundInterfaceVariable(mosek_fusion_SliceVariable):
  __slots__ = ['_BoundInterfaceVariable__originvar','_BoundInterfaceVariable__islower']
  def __repr__(self): return 'mosek.fusion.BoundInterfaceVariable'
  @staticmethod
  def _ctor_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Set_2J_3JZ(origin_,shape_,first_,strides_,islower_):
    o = BoundInterfaceVariable.__new__(BoundInterfaceVariable)
    o._ctor_init_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Set_2J_3JZ(origin_,shape_,first_,strides_,islower_)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Set_2J_3JZ(*args):
    if len(args) != 5: return False
    origin_,shape_,first_,strides_,islower_, = args
    return (__arg_match_Lmosek_4fusion_4RangedVariable_2__(origin_) and __arg_match_Lmosek_4fusion_4Set_2__(shape_) and __arg_match_J__(first_) and __arg_match__3J__(strides_) and __arg_match_Z__(islower_))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Set_2J_3JZ(*args):
    if len(args) != 5: return False
    origin_,shape_,first_,strides_,islower_, = args
    return (__arg_alt_match_Lmosek_4fusion_4RangedVariable_2__(origin_) and __arg_alt_match_Lmosek_4fusion_4Set_2__(shape_) and __arg_alt_match_J__(first_) and __arg_alt_match__3J__(strides_) and __arg_alt_match_Z__(islower_))
  def _ctor_alt_init_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Set_2J_3JZ(self,origin_,shape_,first_,strides_,islower_):
    self._ctor_init_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Set_2J_3JZ(origin_,shape_,numpy.int64(first_),numpy.array(strides_,dtype=numpy.dtype(numpy.int64)),islower_)
  def _ctor_init_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Set_2J_3JZ(self,origin_,shape_,first_,strides_,islower_):
   mosek_fusion_SliceVariable._ctor_init_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2J_3J(self,origin_,shape_,first_,strides_)
   self.__originvar = origin_
   self.__islower = islower_
  def _slice_1_alt_Lmosek_4fusion_4Set_2J_3J(self,_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.int64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _1 = self._slice_1_Lmosek_4fusion_4Set_2J_3J(_0,_1,_2)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice_1_Lmosek_4fusion_4Set_2J_3J(self,_0,_1,_2):
   return (mosek_fusion_BoundInterfaceVariable._ctor_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Set_2J_3JZ(self.__originvar,_0,_1,_2,self.__islower))
  def _dual_1values_alt_J_3I_3JI_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1values_J_3I_3JI_3D(_0,_1,_2,_3,_4)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1values_J_3I_3JI_3D(self,_0,_1,_2,_3,_4):
   if self.__islower:
    self.__originvar._dual_1l_J_3I_3JI_3D(_0,_1,_2,_3,_4)
   else:
    self.__originvar._dual_1u_J_3I_3JI_3D(_0,_1,_2,_3,_4)
  def _dual_1values_alt__3JI_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1values__3JI_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1values__3JI_3D(self,_0,_1,_2):
   if self.__islower:
    self.__originvar._dual_1l__3JI_3D(_0,_1,_2)
   else:
    self.__originvar._dual_1u__3JI_3D(_0,_1,_2)
 return BoundInterfaceVariable
mosek_fusion_BoundInterfaceVariable=__mk_mosek_fusion_BoundInterfaceVariable()
del __mk_mosek_fusion_BoundInterfaceVariable
#BEFORE CLASS
def __mk_mosek_fusion_ModelVariable():
 class ModelVariable(mosek_fusion_BaseVariable):
  __slots__ = ['_varid','_name']
  def elementName(self,*args):
    if False: pass
    elif mosek_fusion_ModelVariable._match_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_ModelVariable._match_alt_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementName_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementName('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ModelVariable.elementName(int64,mosek.fusion.Utils.StringBuffer)')
  def slice(self,*args):
    if False: pass
    elif mosek_fusion_ModelVariable._match_slice_II(*args): # int32,int32
      return self._slice_II(*args)
    elif mosek_fusion_ModelVariable._match_alt_slice_II(*args): # int32,int32
      return self._slice_alt_II(*args)
    elif mosek_fusion_ModelVariable._match_slice__3I_3I(*args): # []int32,[]int32
      return self._slice__3I_3I(*args)
    elif mosek_fusion_ModelVariable._match_alt_slice__3I_3I(*args): # []int32,[]int32
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ModelVariable.slice(int32,int32)\n\tmosek.fusion.ModelVariable.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def __repr__(self): return 'mosek.fusion.ModelVariable'
  @staticmethod
  def _ctor_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(v,m):
    o = ModelVariable.__new__(ModelVariable)
    o._ctor_init_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(v,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_match_Lmosek_4fusion_4ModelVariable_2__(v) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4ModelVariable_2__(v) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(self,v,m):
    self._ctor_init_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(v,m)
  def _ctor_init_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(self,v,m):
   mosek_fusion_BaseVariable._ctor_init_Lmosek_4fusion_4BaseVariable_2Lmosek_4fusion_4Model_2(self,v,m)
   self._name = (v._name)
   self._varid = (v._varid)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2J(model_,name_,shape_p,varid_):
    o = ModelVariable.__new__(ModelVariable)
    o._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2J(model_,name_,shape_p,varid_)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2J(*args):
    if len(args) != 4: return False
    model_,name_,shape_p,varid_, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model_) and __arg_match_S__(name_) and __arg_match_Lmosek_4fusion_4Set_2__(shape_p) and __arg_match_J__(varid_))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2J(*args):
    if len(args) != 4: return False
    model_,name_,shape_p,varid_, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model_) and __arg_alt_match_S__(name_) and __arg_alt_match_Lmosek_4fusion_4Set_2__(shape_p) and __arg_alt_match_J__(varid_))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2J(self,model_,name_,shape_p,varid_):
    self._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2J(model_,name_,shape_p,numpy.int64(varid_))
  def _ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2J(self,model_,name_,shape_p,varid_):
   mosek_fusion_BaseVariable._ctor_init_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Set_2(self,model_,shape_p)
   self._name = name_
   self._varid = varid_
  def _flushNames_alt_(self,):
    return self._flushNames_()
  def _flushNames_(self,):
   pass
  @staticmethod
  def _match_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_J__(_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  @staticmethod
  def _match_alt_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  def _elementName_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   _1._a_S(("_" if ((int(len(self._name))==0) ) else self._name))._a_S("[")._a_S(self._shape_p._indexToString_J(_0))._a_S("]")
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _slice_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._slice__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice__3I_3I(self,_0,_1):
   if (int((_0).shape[0])!=int((_1).shape[0])):
    raise mosek_fusion_LengthError._ctor_S("Mismatching array lengths")
   _2=self._shape_p._slice__3I_3I(_0,_1)
   _3=numpy.zeros(((self._shape_p.nd),), dtype=numpy.dtype(numpy.int64))
   _3[((self._shape_p.nd) - 1)] = 1
   _4=((self._shape_p.nd) - 1)
   while (_4 > 0):
    _3[(_4 - 1)] = (_3[_4] * self._shape_p._dim_I(_4))
    _4 = (_4 - 1)
   _5=0
   _5 = fragments._c_closure_113(_0,_5,_3) # src/fusion/ModelVariable.mbi:76:9-77:57
   _5 = numpy.int64(_5) # postprocess
   return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2J_3J(self,_2,_5,_3))
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _slice_alt_II(self,_t__0,_t__1):
    return self._slice_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_II(self,_0,_1):
   if ((self._shape_p.nd)!=1):
    raise mosek_fusion_DimensionError._ctor_S("Wrong size of slice")
   _2=numpy.array([1], dtype=numpy.dtype(numpy.int64))
   return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2J_3J(self,self._shape_p._slice_II(_0,_1),numpy.int64(_0),_2))
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   pass
 return ModelVariable
mosek_fusion_ModelVariable=__mk_mosek_fusion_ModelVariable()
del __mk_mosek_fusion_ModelVariable
#BEFORE CLASS
def __mk_mosek_fusion_SymRangedVariable():
 class SymRangedVariable(mosek_fusion_SymmetricVariable,mosek_fusion_ModelVariable):
  __slots__ = ['_dim','_SymRangedVariable__names_flushed','_SymRangedVariable__nativeidxs','_SymRangedVariable__dom','_SymRangedVariable__idxmap']
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_SymRangedVariable._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_SymRangedVariable._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymRangedVariable.toString()')
  def inst(self,*args):
    if False: pass
    elif mosek_fusion_SymRangedVariable._match_inst_JJ_3I_3I_3I(*args): # int64,int64,[]int32,[]int32,[]int32
      return self._inst_JJ_3I_3I_3I(*args)
    elif mosek_fusion_SymRangedVariable._match_alt_inst_JJ_3I_3I_3I(*args): # int64,int64,[]int32,[]int32,[]int32
      return self._inst_alt_JJ_3I_3I_3I(*args)
    elif mosek_fusion_SymRangedVariable._match_inst__3JIIJJ_3I_3I_3I(*args): # []int64,int32,int32,int64,int64,[]int32,[]int32,[]int32
      return self._inst__3JIIJJ_3I_3I_3I(*args)
    elif mosek_fusion_SymRangedVariable._match_alt_inst__3JIIJJ_3I_3I_3I(*args): # []int64,int32,int32,int64,int64,[]int32,[]int32,[]int32
      return self._inst_alt__3JIIJJ_3I_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list inst('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymRangedVariable.inst(int64,int64,array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.SymRangedVariable.inst(array(int64,ndim=1),int32,int32,int64,int64,array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))')
  def values(self,*args):
    if False: pass
    elif mosek_fusion_SymRangedVariable._match_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_I_3DZ(*args)
    elif mosek_fusion_SymRangedVariable._match_alt_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_alt_I_3DZ(*args)
    elif mosek_fusion_SymRangedVariable._match_values__3JI_3DZ(*args): # []int64,int32,[]double,bool
      return self._values__3JI_3DZ(*args)
    elif mosek_fusion_SymRangedVariable._match_alt_values__3JI_3DZ(*args): # []int64,int32,[]double,bool
      return self._values_alt__3JI_3DZ(*args)
    elif mosek_fusion_SymRangedVariable._match_values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._values_J_3I_3JI_3DZ(*args)
    elif mosek_fusion_SymRangedVariable._match_alt_values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._values_alt_J_3I_3JI_3DZ(*args)
    else:
      raise ValueError('Invalid argument list values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymRangedVariable.values(int32,array(double,ndim=1),bool)\n\tmosek.fusion.SymRangedVariable.values(array(int64,ndim=1),int32,array(double,ndim=1),bool)\n\tmosek.fusion.SymRangedVariable.values(int64,array(int32,ndim=1),array(int64,ndim=1),int32,array(double,ndim=1),bool)')
  def set_values(self,*args):
    if False: pass
    elif mosek_fusion_SymRangedVariable._match_set_1values__3J_3DZ(*args): # []int64,[]double,bool
      return self._set_1values__3J_3DZ(*args)
    elif mosek_fusion_SymRangedVariable._match_alt_set_1values__3J_3DZ(*args): # []int64,[]double,bool
      return self._set_1values_alt__3J_3DZ(*args)
    elif mosek_fusion_SymRangedVariable._match_set_1values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._set_1values_J_3I_3JI_3DZ(*args)
    elif mosek_fusion_SymRangedVariable._match_alt_set_1values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._set_1values_alt_J_3I_3JI_3DZ(*args)
    else:
      raise ValueError('Invalid argument list set_values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymRangedVariable.set_values(array(int64,ndim=1),array(double,ndim=1),bool)\n\tmosek.fusion.SymRangedVariable.set_values(int64,array(int32,ndim=1),array(int64,ndim=1),int32,array(double,ndim=1),bool)')
  def make_continuous(self,*args):
    if False: pass
    elif mosek_fusion_SymRangedVariable._match_make_1continuous__3J(*args): # []int64
      return self._make_1continuous__3J(*args)
    elif mosek_fusion_SymRangedVariable._match_alt_make_1continuous__3J(*args): # []int64
      return self._make_1continuous_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_continuous('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymRangedVariable.make_continuous(array(int64,ndim=1))')
  def make_integer(self,*args):
    if False: pass
    elif mosek_fusion_SymRangedVariable._match_make_1integer__3J(*args): # []int64
      return self._make_1integer__3J(*args)
    elif mosek_fusion_SymRangedVariable._match_alt_make_1integer__3J(*args): # []int64
      return self._make_1integer_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_integer('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymRangedVariable.make_integer(array(int64,ndim=1))')
  def __repr__(self): return 'mosek.fusion.SymRangedVariable'
  @staticmethod
  def _ctor_Lmosek_4fusion_4SymRangedVariable_2Lmosek_4fusion_4Model_2(v,m):
    o = SymRangedVariable.__new__(SymRangedVariable)
    o._ctor_init_Lmosek_4fusion_4SymRangedVariable_2Lmosek_4fusion_4Model_2(v,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4SymRangedVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_match_Lmosek_4fusion_4SymRangedVariable_2__(v) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4SymRangedVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4SymRangedVariable_2__(v) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4SymRangedVariable_2Lmosek_4fusion_4Model_2(self,v,m):
    self._ctor_init_Lmosek_4fusion_4SymRangedVariable_2Lmosek_4fusion_4Model_2(v,m)
  def _ctor_init_Lmosek_4fusion_4SymRangedVariable_2Lmosek_4fusion_4Model_2(self,v,m):
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(self,v,m)
   self.__nativeidxs = (numpy.array([(v.__nativeidxs)[_0] for _0 in range(0,int(((v.__nativeidxs)).shape[0]))], dtype=numpy.dtype(numpy.int32)) if (((v.__nativeidxs) is not None) ) else None)
   self.__idxmap = ((v.__idxmap)._clone_() if (((v.__idxmap) is not None) ) else None)
   self.__dom = (v.__dom)
   (self._dim) = (v._dim)
   self.__names_flushed = (v.__names_flushed)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4RangeDomain_2I_3IJ(model_,name_,dom_,dim,nativeidxs_,varid_):
    o = SymRangedVariable.__new__(SymRangedVariable)
    o._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4RangeDomain_2I_3IJ(model_,name_,dom_,dim,nativeidxs_,varid_)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4RangeDomain_2I_3IJ(*args):
    if len(args) != 6: return False
    model_,name_,dom_,dim,nativeidxs_,varid_, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model_) and __arg_match_S__(name_) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(dom_) and __arg_match_I__(dim) and __arg_match__3I__(nativeidxs_) and __arg_match_J__(varid_))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4RangeDomain_2I_3IJ(*args):
    if len(args) != 6: return False
    model_,name_,dom_,dim,nativeidxs_,varid_, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model_) and __arg_alt_match_S__(name_) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(dom_) and __arg_alt_match_I__(dim) and __arg_alt_match__3I__(nativeidxs_) and __arg_alt_match_J__(varid_))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4RangeDomain_2I_3IJ(self,model_,name_,dom_,dim,nativeidxs_,varid_):
    self._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4RangeDomain_2I_3IJ(model_,name_,dom_,numpy.int32(dim),numpy.array(nativeidxs_,dtype=numpy.dtype(numpy.int32)),numpy.int64(varid_))
  def _ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4RangeDomain_2I_3IJ(self,model_,name_,dom_,dim,nativeidxs_,varid_):
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2J(self,model_,name_,mosek.fusion.Set._make_II(dim,dim),varid_)
   (self._dim) = dim
   self.__nativeidxs = nativeidxs_
   if (nativeidxs_ is None):
    self.__idxmap = mosek.fusion.Utils.IntMap()
   else:
    self.__idxmap = None
   self.__dom = dom_
   self.__names_flushed = False
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("RangedVariable(")
   if (int(len(self._name)) > 0):
    _0._a_S("'")._a_S(self._name)._a_S("',")
   _0._a_I(self._shape_p._dim_I(0))
   for _1 in range(1,(self._shape_p.nd)):
    _0._a_S(",")._a_I(self._shape_p._dim_I(_1))
   _0._a_S(") )")
   return (_0._toString_())
  def _flushNames_alt_(self,):
    return self._flushNames_()
  def _flushNames_(self,):
   if ((not self.__names_flushed) and (int(len(self._name)) > 0)):
    if (self.__nativeidxs is not None):
     for _0 in range(0,int((self.__nativeidxs).shape[0])):
      self._model._varname_IS(self.__nativeidxs[_0],mosek.fusion.Utils.StringBuffer()._a_S(self._name)._a_S("[")._a_S(self._shape_p._getname_J(_0))._a_S("]")._toString_())
    else:
     _1=self.__idxmap._keys_()
     _2=self.__idxmap._values_()
     for _3 in range(0,int((_1).shape[0])):
      self._model._varname_IS(_2[_3],mosek.fusion.Utils.StringBuffer()._a_S(self._name)._a_S("[")._a_S(self._shape_p._getname_J(_3))._a_S("]")._toString_())
    self.__names_flushed = True
  @staticmethod
  def _match_inst__3JIIJJ_3I_3I_3I(*args):
    if len(args) != 8: return False
    _0,_1,_2,_3,_4,_5,_6,_7, = args
    return (__arg_match__3J__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4) and __arg_match__3I__(_5) and __arg_match__3I__(_6) and __arg_match__3I__(_7))
  @staticmethod
  def _match_alt_inst__3JIIJJ_3I_3I_3I(*args):
    if len(args) != 8: return False
    _0,_1,_2,_3,_4,_5,_6,_7, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4) and __arg_alt_match__3I__(_5) and __arg_alt_match__3I__(_6) and __arg_alt_match__3I__(_7))
  def _inst_alt__3JIIJJ_3I_3I_3I(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.int32(_t__2)
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.int32))
   _6=numpy.array(_t__6,dtype=numpy.dtype(numpy.int32))
   _7=numpy.array(_t__7,dtype=numpy.dtype(numpy.int32))
   _1 = self._inst__3JIIJJ_3I_3I_3I(_0,_1,_2,_3,_4,_5,_6,_7)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__6[:] = _6
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__7[:] = _7
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst__3JIIJJ_3I_3I_3I(self,_0,_1,_2,_3,_4,_5,_6,_7):
   if (self.__nativeidxs is not None):
    for _8 in range(_1,_2):
     _5[((_4 + _8) - _1)] = self.__nativeidxs[self.__tril_1lin_1idx_J((_0[_8] - _3))]
   else:
    for _9 in range(_1,_2):
     _10=self.__tril_1lin_1idx_J((_0[_9] - _3))
     _11=self.__tril_1idx_J((_0[_9] - _3))
     if (not self.__idxmap._hasItem_J(_10)):
      _12=self._model._append_1rangedvar_Lmosek_4fusion_4ModelVariable_2JDD(self,_11,self.__dom._get_1lb_1item_J(_11),self.__dom._get_1ub_1item_J(_11))
      self.__idxmap._setItem_JI(_11,_12)
      _5[((_4 + _9) - _1)] = _12
      self.__names_flushed = False
     else:
      _5[((_4 + _9) - _1)] = self.__idxmap._getItem_J(_11)
  @staticmethod
  def _match_inst_JJ_3I_3I_3I(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match_J__(_0) and __arg_match_J__(_1) and __arg_match__3I__(_2) and __arg_match__3I__(_3) and __arg_match__3I__(_4))
  @staticmethod
  def _match_alt_inst_JJ_3I_3I_3I(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_J__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match__3I__(_3) and __arg_alt_match__3I__(_4))
  def _inst_alt_JJ_3I_3I_3I(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.int64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int32))
   _1 = self._inst_JJ_3I_3I_3I(_0,_1,_2,_3,_4)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst_JJ_3I_3I_3I(self,_0,_1,_2,_3,_4):
   if ((_0 < 0) or (_0 >= (self._shape_p._size))):
    raise mosek_fusion_IndexError._ctor_S("Index out of bounds")
   _5=self.__tril_1lin_1idx_J(_0)
   _6=self.__tril_1idx_J(_0)
   if (self.__nativeidxs is not None):
    _2[_1] = self.__nativeidxs[_5]
   else:
    if (not self.__idxmap._hasItem_J(_6)):
     _7=self
     _8=self._model._append_1rangedvar_Lmosek_4fusion_4ModelVariable_2JDD(_7,_5,self.__dom._get_1lb_1item_J(_6),self.__dom._get_1ub_1item_J(_6))
     self.__idxmap._setItem_JI(_6,_8)
     _2[_1] = _8
     self.__names_flushed = False
    else:
     _2[_1] = self.__idxmap._getItem_J(_6)
  def _dual_1u_alt_J_3I_3JI_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1u_J_3I_3JI_3D(_0,_1,_2,_3,_4)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1u_J_3I_3JI_3D(self,_0,_1,_2,_3,_4):
   _5=1
   _6=int((_2).shape[0])
   _7=mosek_fusion_IndexCounter._ctor_J_3I_3J(_0,_1,_2)
   _8=self._model._getSolution_1sux_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _5 = fragments._c_closure_114(_6,_1,_5) # src/fusion/SymRangedVariable.mbi:516:9-51
   _5 = numpy.int64(_5) # postprocess
   if (self.__nativeidxs is not None):
    for _9 in range(0,_5):
     _10=self.__nativeidxs[self.__tril_1lin_1idx_J(_7._get_())]
     _4[(_9 + _3)] = _8[_10]
     _7._inc_()
   else:
    _11=self._model._getPrimalSolutionStatus_()
    for _12 in range(0,numpy.int32(_5)):
     _13=self.__tril_1idx_J(_7._get_())
     if self.__idxmap._hasItem_J(_13):
      _14=self.__idxmap._getItem_J(_13)
      _4[_12] = _8[_14]
     else:
      if ((_11==mosek.fusion.SolutionStatus.Optimal) or ((_11==mosek.fusion.SolutionStatus.NearOptimal) or ((_11==mosek.fusion.SolutionStatus.Feasible) or (_11==mosek.fusion.SolutionStatus.NearFeasible)))):
       _4[(_3 + _12)] = self.__dom._get_1ub_1item_J(_13)
      else:
       _4[(_3 + _12)] = 0.0
     _7._inc_()
  def _dual_1u_alt__3JI_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1u__3JI_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1u__3JI_3D(self,_0,_1,_2):
   _3=self._model._getSolution_1sux_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   if (self.__nativeidxs is not None):
    for _4 in range(0,int((_0).shape[0])):
     _5=self.__nativeidxs[self.__tril_1lin_1idx_J(_0[_4])]
     _2[(_1 + _4)] = _3[_5]
   else:
    _6=self._model._getPrimalSolutionStatus_()
    for _7 in range(0,int((_0).shape[0])):
     _8=self.__tril_1idx_J(_0[_7])
     if self.__idxmap._hasItem_J(_8):
      _9=self.__idxmap._getItem_J(_8)
      _2[(_1 + _7)] = _3[_9]
     else:
      if ((_6==mosek.fusion.SolutionStatus.Optimal) or ((_6==mosek.fusion.SolutionStatus.NearOptimal) or ((_6==mosek.fusion.SolutionStatus.Feasible) or (_6==mosek.fusion.SolutionStatus.NearFeasible)))):
       _2[(_1 + _7)] = self.__dom._get_1ub_1item_J(_8)
      else:
       _2[(_1 + _7)] = 0.0
  def _dual_1l_alt_J_3I_3JI_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1l_J_3I_3JI_3D(_0,_1,_2,_3,_4)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1l_J_3I_3JI_3D(self,_0,_1,_2,_3,_4):
   _5=1
   _6=int((_2).shape[0])
   _7=mosek_fusion_IndexCounter._ctor_J_3I_3J(_0,_1,_2)
   _8=self._model._getSolution_1slx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _5 = fragments._c_closure_115(_6,_1,_5) # src/fusion/SymRangedVariable.mbi:426:9-51
   _5 = numpy.int64(_5) # postprocess
   if (self.__nativeidxs is not None):
    for _9 in range(0,_5):
     _10=self.__nativeidxs[self.__tril_1lin_1idx_J(_7._get_())]
     _4[(_9 + _3)] = _8[_10]
     _7._inc_()
   else:
    _11=self._model._getPrimalSolutionStatus_()
    for _12 in range(0,numpy.int32(_5)):
     _13=self.__tril_1idx_J(_7._get_())
     if self.__idxmap._hasItem_J(_13):
      _14=self.__idxmap._getItem_J(_13)
      _4[_12] = _8[_14]
     else:
      if ((_11==mosek.fusion.SolutionStatus.Optimal) or ((_11==mosek.fusion.SolutionStatus.NearOptimal) or ((_11==mosek.fusion.SolutionStatus.Feasible) or (_11==mosek.fusion.SolutionStatus.NearFeasible)))):
       _4[(_3 + _12)] = self.__dom._get_1ub_1item_J(_13)
      else:
       _4[(_3 + _12)] = 0.0
     _7._inc_()
  def _dual_1l_alt__3JI_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1l__3JI_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1l__3JI_3D(self,_0,_1,_2):
   _3=self._model._getSolution_1slx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   if (self.__nativeidxs is not None):
    for _4 in range(0,int((_0).shape[0])):
     _5=self.__nativeidxs[self.__tril_1lin_1idx_J(_0[_4])]
     _2[(_1 + _4)] = _3[_5]
   else:
    _6=self._model._getPrimalSolutionStatus_()
    for _7 in range(0,int((_0).shape[0])):
     if self.__idxmap._hasItem_J(_0[_7]):
      _8=self.__nativeidxs[self.__tril_1lin_1idx_J(_0[_7])]
      _2[(_1 + _7)] = _3[_8]
     else:
      if ((_6==mosek.fusion.SolutionStatus.Optimal) or ((_6==mosek.fusion.SolutionStatus.NearOptimal) or ((_6==mosek.fusion.SolutionStatus.Feasible) or (_6==mosek.fusion.SolutionStatus.NearFeasible)))):
       _2[(_1 + _7)] = self.__dom._get_1ub_1item_J(self.__tril_1idx_J(_0[_7]))
      else:
       _2[(_1 + _7)] = 0.0
  def __dual_1values_alt_J_3I_3JI_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = self.__dual_1values_J_3I_3JI_3D(_0,_1,_2,_3,_4)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __dual_1values_J_3I_3JI_3D(self,_0,_1,_2,_3,_4):
   _5=1
   _6=int((_2).shape[0])
   _7=mosek_fusion_IndexCounter._ctor_J_3I_3J(_0,_1,_2)
   _8=self._model._getSolution_1slx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _9=self._model._getSolution_1sux_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _5 = fragments._c_closure_116(_6,_1,_5) # src/fusion/SymRangedVariable.mbi:340:9-51
   _5 = numpy.int64(_5) # postprocess
   if (self.__nativeidxs is not None):
    for _10 in range(0,_5):
     _11=self.__nativeidxs[self.__tril_1lin_1idx_J(_7._get_())]
     _4[(_10 + _3)] = (_8[_11] - _9[_11])
     _7._inc_()
   else:
    _12=self._model._getPrimalSolutionStatus_()
    for _13 in range(0,numpy.int32(_5)):
     if self.__idxmap._hasItem_J(_7._get_()):
      _14=self.__idxmap._getItem_J(self.__tril_1idx_J(_7._get_()))
      _4[_13] = (_8[_14] - _9[_14])
     else:
      if ((_12==mosek.fusion.SolutionStatus.Optimal) or ((_12==mosek.fusion.SolutionStatus.NearOptimal) or ((_12==mosek.fusion.SolutionStatus.Feasible) or (_12==mosek.fusion.SolutionStatus.NearFeasible)))):
       _4[(_3 + _13)] = self.__dom._get_1ub_1item_J(self.__tril_1idx_J(_7._get_()))
      else:
       _4[(_3 + _13)] = 0.0
     _7._inc_()
  def __dual_1values_alt__3JI_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self.__dual_1values__3JI_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __dual_1values__3JI_3D(self,_0,_1,_2):
   _3=self._model._getSolution_1slx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _4=self._model._getSolution_1sux_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   if (self.__nativeidxs is not None):
    for _5 in range(0,int((_0).shape[0])):
     _6=self.__nativeidxs[self.__tril_1lin_1idx_J(_0[_5])]
     _2[(_1 + _5)] = (_3[_6] - _4[_6])
   else:
    _7=self._model._getPrimalSolutionStatus_()
    for _8 in range(0,int((_0).shape[0])):
     if self.__idxmap._hasItem_J(self.__tril_1idx_J(_0[_8])):
      _9=self.__idxmap._getItem_J(self.__tril_1idx_J(_0[_8]))
      _2[(_1 + _8)] = (_3[_9] - _4[_9])
     else:
      if ((_7==mosek.fusion.SolutionStatus.Optimal) or ((_7==mosek.fusion.SolutionStatus.NearOptimal) or ((_7==mosek.fusion.SolutionStatus.Feasible) or (_7==mosek.fusion.SolutionStatus.NearFeasible)))):
       _2[(_1 + _8)] = self.__dom._get_1ub_1item_J(self.__tril_1idx_J(_0[_8]))
      else:
       _2[(_1 + _8)] = 0.0
  @staticmethod
  def _match_set_1values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match_J__(_0) and __arg_match__3I__(_1) and __arg_match__3J__(_2) and __arg_match_I__(_3) and __arg_match__3D__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_set_1values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match__3D__(_4) and __arg_alt_match_Z__(_5))
  def _set_1values_alt_J_3I_3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = self._set_1values_J_3I_3JI_3DZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values_J_3I_3JI_3DZ(self,_0,_1,_2,_3,_4,_5):
   if _5:
    _6=1
    _7=int((_2).shape[0])
    _8=mosek_fusion_IndexCounter._ctor_J_3I_3J(_0,_1,_2)
    _6 = fragments._c_closure_117(_7,_1,_6) # src/fusion/SymRangedVariable.mbi:264:11-53
    _6 = numpy.int64(_6) # postprocess
    if (self.__nativeidxs is not None):
     _9=int((self.__nativeidxs).shape[0])
     _10=numpy.array([self.__nativeidxs[self.__tril_1lin_1idx_J(_8._next_())] for _11 in range(0,_6)], dtype=numpy.dtype(numpy.int32))
     _12=(numpy.array([_4[(_3 + _13)] for _13 in range(0,_9)], dtype=numpy.dtype(numpy.float64)) if ((_3 > 0) ) else _4)
     self._model._setSolution_1xx__3I_3D(_10,_12)
    else:
     _14=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int32))
     for _15 in range(0,_6):
      self._inst_JJ_3I_3I_3I(_8._next_(),_15,_14,None,None)
     _16=numpy.array([_4[(_3 + _17)] for _17 in range(0,_6)], dtype=numpy.dtype(numpy.float64))
     self._model._setSolution_1xx__3I_3D(_14,_16)
   else:
    pass
  @staticmethod
  def _match_set_1values__3J_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3J__(_0) and __arg_match__3D__(_1) and __arg_match_Z__(_2))
  @staticmethod
  def _match_alt_set_1values__3J_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3D__(_1) and __arg_alt_match_Z__(_2))
  def _set_1values_alt__3J_3DZ(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=_t__2
   _1 = self._set_1values__3J_3DZ(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values__3J_3DZ(self,_0,_1,_2):
   if _2:
    if (self.__nativeidxs is not None):
     _3=int((self.__nativeidxs).shape[0])
     _4=numpy.array([self.__nativeidxs[self.__tril_1lin_1idx_J(_0[_5])] for _5 in range(0,_3)], dtype=numpy.dtype(numpy.int32))
     _6=numpy.array([_1[_7] for _7 in range(0,_3)], dtype=numpy.dtype(numpy.float64))
     self._model._setSolution_1xx__3I_3D(_4,_6)
    else:
     _8=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int32))
     for _9 in range(0,int((_0).shape[0])):
      self._inst_JJ_3I_3I_3I(_0[_9],_9,_8,None,None)
     _10=numpy.array([_1[_11] for _11 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.float64))
     self._model._setSolution_1xx__3I_3D(_8,_10)
   else:
    pass
  @staticmethod
  def _match_values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match_J__(_0) and __arg_match__3I__(_1) and __arg_match__3J__(_2) and __arg_match_I__(_3) and __arg_match__3D__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match__3D__(_4) and __arg_alt_match_Z__(_5))
  def _values_alt_J_3I_3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = self._values_J_3I_3JI_3DZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values_J_3I_3JI_3DZ(self,_0,_1,_2,_3,_4,_5):
   if _5:
    _6=1
    _7=int((_2).shape[0])
    _8=mosek_fusion_IndexCounter._ctor_J_3I_3J(_0,_1,_2)
    _9=self._model._getSolution_1xx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
    _6 = fragments._c_closure_118(_7,_1,_6) # src/fusion/SymRangedVariable.mbi:183:11-53
    _6 = numpy.int64(_6) # postprocess
    if (self.__nativeidxs is not None):
     for _10 in range(0,_6):
      _4[(_10 + _3)] = _9[self.__nativeidxs[self.__tril_1lin_1idx_J(_8._get_())]]
      _8._inc_()
    else:
     _11=self._model._getPrimalSolutionStatus_()
     for _12 in range(0,numpy.int32(_6)):
      if self.__idxmap._hasItem_J(_8._get_()):
       _4[_12] = _9[self.__idxmap._getItem_J(self.__tril_1idx_J(_8._get_()))]
      else:
       if ((_11==mosek.fusion.SolutionStatus.Optimal) or ((_11==mosek.fusion.SolutionStatus.NearOptimal) or ((_11==mosek.fusion.SolutionStatus.Feasible) or (_11==mosek.fusion.SolutionStatus.NearFeasible)))):
        _4[(_3 + _12)] = self.__dom._get_1lb_1item_J(self.__tril_1idx_J(_8._get_()))
       else:
        _4[(_3 + _12)] = 0.0
      _8._inc_()
   else:
    self.__dual_1values_J_3I_3JI_3D(_0,_1,_2,_3,_4)
  @staticmethod
  def _match_values__3JI_3DZ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match__3J__(_0) and __arg_match_I__(_1) and __arg_match__3D__(_2) and __arg_match_Z__(_3))
  @staticmethod
  def _match_alt_values__3JI_3DZ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match_Z__(_3))
  def _values_alt__3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=_t__3
   _1 = self._values__3JI_3DZ(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values__3JI_3DZ(self,_0,_1,_2,_3):
   if _3:
    _4=self._model._getSolution_1xx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
    if (self.__nativeidxs is not None):
     for _5 in range(0,int((_0).shape[0])):
      _2[(_1 + _5)] = _4[self.__nativeidxs[self.__tril_1lin_1idx_J(_0[_5])]]
    else:
     _6=self._model._getPrimalSolutionStatus_()
     if ((_6==mosek.fusion.SolutionStatus.Optimal) or ((_6==mosek.fusion.SolutionStatus.NearOptimal) or ((_6==mosek.fusion.SolutionStatus.Feasible) or (_6==mosek.fusion.SolutionStatus.NearFeasible)))):
      for _7 in range(0,int((_0).shape[0])):
       _8=_0[_7]
       if self.__idxmap._hasItem_J(_8):
        _2[(_1 + _7)] = _4[self.__idxmap._getItem_J(_8)]
       else:
        _2[(_1 + _7)] = self.__dom._get_1lb_1item_J(_8)
     else:
      for _9 in range(0,int((_0).shape[0])):
       if self.__idxmap._hasItem_J(_0[_9]):
        _2[(_1 + _9)] = _4[self.__idxmap._getItem_J(_0[_9])]
       else:
        _2[(_1 + _9)] = 0.0
   else:
    self.__dual_1values__3JI_3D(_0,_1,_2)
  def __tril_1idx_alt_J(self,_t__0):
    return self.__tril_1idx_J(numpy.int64(__0))
  def __tril_1idx_J(self,_0):
   _1=(_0 // self._dim)
   _2=(_0 % self._dim)
   if (_2 > _1):
    return numpy.int64(((_2 * self._dim) + _1))
   else:
    return numpy.int64(_0)
  def __tril_1lin_1idx_alt_J(self,_t__0):
    return self.__tril_1lin_1idx_J(numpy.int64(__0))
  def __tril_1lin_1idx_J(self,_0):
   _1=(_0 // self._dim)
   _2=(_0 % self._dim)
   if (_2 > _1):
    return numpy.int64((((_2 * (_2 + 1)) // 2) + _1))
   else:
    return numpy.int64((((_1 * (_1 + 1)) // 2) + _2))
  @staticmethod
  def _match_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3J__(_0))
  @staticmethod
  def _match_alt_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3J__(_0))
  def _make_1continuous_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1continuous__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1continuous__3J(self,_0):
   if (self.__nativeidxs is not None):
    self._getModel_()._task_1var_1putcontlist__3I(numpy.array([self.__nativeidxs[_0[_1]] for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32)))
   else:
    _2=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int32))
    self._inst__3JIIJJ_3I_3I_3I(_0,0,int((_0).shape[0]),0,0,_2,None,None)
    self._getModel_()._task_1var_1putcontlist__3I(_2)
  @staticmethod
  def _match_make_1integer__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3J__(_0))
  @staticmethod
  def _match_alt_make_1integer__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3J__(_0))
  def _make_1integer_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1integer__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1integer__3J(self,_0):
   if (self.__nativeidxs is not None):
    self._getModel_()._task_1var_1putintlist__3I(numpy.array([self.__nativeidxs[_0[_1]] for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32)))
   else:
    _2=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int32))
    self._inst__3JIIJJ_3I_3I_3I(_0,0,int((_0).shape[0]),0,0,_2,None,None)
    self._getModel_()._task_1var_1putintlist__3I(_2)
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   return (mosek_fusion_SymRangedVariable._ctor_Lmosek_4fusion_4SymRangedVariable_2Lmosek_4fusion_4Model_2(self,_0))
 return SymRangedVariable
mosek_fusion_SymRangedVariable=__mk_mosek_fusion_SymRangedVariable()
del __mk_mosek_fusion_SymRangedVariable
#BEFORE CLASS
def __mk_mosek_fusion_RangedVariable():
 class RangedVariable(mosek_fusion_ModelVariable):
  __slots__ = ['_RangedVariable__names_flushed','_RangedVariable__nativeidxs','_RangedVariable__dom','_RangedVariable__idxmap']
  def values(self,*args):
    if False: pass
    elif mosek_fusion_RangedVariable._match_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_I_3DZ(*args)
    elif mosek_fusion_RangedVariable._match_alt_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_alt_I_3DZ(*args)
    elif mosek_fusion_RangedVariable._match_values__3JI_3DZ(*args): # []int64,int32,[]double,bool
      return self._values__3JI_3DZ(*args)
    elif mosek_fusion_RangedVariable._match_alt_values__3JI_3DZ(*args): # []int64,int32,[]double,bool
      return self._values_alt__3JI_3DZ(*args)
    elif mosek_fusion_RangedVariable._match_values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._values_J_3I_3JI_3DZ(*args)
    elif mosek_fusion_RangedVariable._match_alt_values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._values_alt_J_3I_3JI_3DZ(*args)
    else:
      raise ValueError('Invalid argument list values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RangedVariable.values(int32,array(double,ndim=1),bool)\n\tmosek.fusion.RangedVariable.values(array(int64,ndim=1),int32,array(double,ndim=1),bool)\n\tmosek.fusion.RangedVariable.values(int64,array(int32,ndim=1),array(int64,ndim=1),int32,array(double,ndim=1),bool)')
  def lowerBoundVar(self,*args):
    if False: pass
    elif mosek_fusion_RangedVariable._match_lowerBoundVar_(*args): # 
      return self._lowerBoundVar_(*args)
    elif mosek_fusion_RangedVariable._match_alt_lowerBoundVar_(*args): # 
      return self._lowerBoundVar_alt_(*args)
    else:
      raise ValueError('Invalid argument list lowerBoundVar('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RangedVariable.lowerBoundVar()')
  def make_integer(self,*args):
    if False: pass
    elif mosek_fusion_RangedVariable._match_make_1integer__3J(*args): # []int64
      return self._make_1integer__3J(*args)
    elif mosek_fusion_RangedVariable._match_alt_make_1integer__3J(*args): # []int64
      return self._make_1integer_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_integer('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RangedVariable.make_integer(array(int64,ndim=1))')
  def set_values(self,*args):
    if False: pass
    elif mosek_fusion_RangedVariable._match_set_1values__3J_3DZ(*args): # []int64,[]double,bool
      return self._set_1values__3J_3DZ(*args)
    elif mosek_fusion_RangedVariable._match_alt_set_1values__3J_3DZ(*args): # []int64,[]double,bool
      return self._set_1values_alt__3J_3DZ(*args)
    elif mosek_fusion_RangedVariable._match_set_1values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._set_1values_J_3I_3JI_3DZ(*args)
    elif mosek_fusion_RangedVariable._match_alt_set_1values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._set_1values_alt_J_3I_3JI_3DZ(*args)
    else:
      raise ValueError('Invalid argument list set_values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RangedVariable.set_values(array(int64,ndim=1),array(double,ndim=1),bool)\n\tmosek.fusion.RangedVariable.set_values(int64,array(int32,ndim=1),array(int64,ndim=1),int32,array(double,ndim=1),bool)')
  def inst(self,*args):
    if False: pass
    elif mosek_fusion_RangedVariable._match_inst_JJ_3I_3I_3I(*args): # int64,int64,[]int32,[]int32,[]int32
      return self._inst_JJ_3I_3I_3I(*args)
    elif mosek_fusion_RangedVariable._match_alt_inst_JJ_3I_3I_3I(*args): # int64,int64,[]int32,[]int32,[]int32
      return self._inst_alt_JJ_3I_3I_3I(*args)
    elif mosek_fusion_RangedVariable._match_inst__3JIIJJ_3I_3I_3I(*args): # []int64,int32,int32,int64,int64,[]int32,[]int32,[]int32
      return self._inst__3JIIJJ_3I_3I_3I(*args)
    elif mosek_fusion_RangedVariable._match_alt_inst__3JIIJJ_3I_3I_3I(*args): # []int64,int32,int32,int64,int64,[]int32,[]int32,[]int32
      return self._inst_alt__3JIIJJ_3I_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list inst('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RangedVariable.inst(int64,int64,array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.RangedVariable.inst(array(int64,ndim=1),int32,int32,int64,int64,array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))')
  def make_continuous(self,*args):
    if False: pass
    elif mosek_fusion_RangedVariable._match_make_1continuous__3J(*args): # []int64
      return self._make_1continuous__3J(*args)
    elif mosek_fusion_RangedVariable._match_alt_make_1continuous__3J(*args): # []int64
      return self._make_1continuous_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_continuous('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RangedVariable.make_continuous(array(int64,ndim=1))')
  def upperBoundVar(self,*args):
    if False: pass
    elif mosek_fusion_RangedVariable._match_upperBoundVar_(*args): # 
      return self._upperBoundVar_(*args)
    elif mosek_fusion_RangedVariable._match_alt_upperBoundVar_(*args): # 
      return self._upperBoundVar_alt_(*args)
    else:
      raise ValueError('Invalid argument list upperBoundVar('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RangedVariable.upperBoundVar()')
  def elementDesc(self,*args):
    if False: pass
    elif mosek_fusion_RangedVariable._match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_RangedVariable._match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementDesc('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RangedVariable.elementDesc(int64,mosek.fusion.Utils.StringBuffer)')
  def __repr__(self): return 'mosek.fusion.RangedVariable'
  @staticmethod
  def _ctor_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Model_2(v,m):
    o = RangedVariable.__new__(RangedVariable)
    o._ctor_init_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Model_2(v,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_match_Lmosek_4fusion_4RangedVariable_2__(v) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4RangedVariable_2__(v) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Model_2(self,v,m):
    self._ctor_init_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Model_2(v,m)
  def _ctor_init_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Model_2(self,v,m):
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(self,v,m)
   self.__dom = (v.__dom)
   self.__idxmap = ((v.__idxmap)._clone_() if (((v.__idxmap) is not None) ) else None)
   self.__nativeidxs = (numpy.array([(v.__nativeidxs)[_0] for _0 in range(0,int(((v.__nativeidxs)).shape[0]))], dtype=numpy.dtype(numpy.int32)) if (((v.__nativeidxs) is not None) ) else None)
   self.__names_flushed = (v.__names_flushed)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2_3IJ(model_,name_,shape_p,dom_,nativeidxs_,varid_):
    o = RangedVariable.__new__(RangedVariable)
    o._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2_3IJ(model_,name_,shape_p,dom_,nativeidxs_,varid_)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2_3IJ(*args):
    if len(args) != 6: return False
    model_,name_,shape_p,dom_,nativeidxs_,varid_, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model_) and __arg_match_S__(name_) and __arg_match_Lmosek_4fusion_4Set_2__(shape_p) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(dom_) and __arg_match__3I__(nativeidxs_) and __arg_match_J__(varid_))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2_3IJ(*args):
    if len(args) != 6: return False
    model_,name_,shape_p,dom_,nativeidxs_,varid_, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model_) and __arg_alt_match_S__(name_) and __arg_alt_match_Lmosek_4fusion_4Set_2__(shape_p) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(dom_) and __arg_alt_match__3I__(nativeidxs_) and __arg_alt_match_J__(varid_))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2_3IJ(self,model_,name_,shape_p,dom_,nativeidxs_,varid_):
    self._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2_3IJ(model_,name_,shape_p,dom_,numpy.array(nativeidxs_,dtype=numpy.dtype(numpy.int32)),numpy.int64(varid_))
  def _ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2_3IJ(self,model_,name_,shape_p,dom_,nativeidxs_,varid_):
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2J(self,model_,name_,shape_p,varid_)
   self.__nativeidxs = nativeidxs_
   if (nativeidxs_ is None):
    self.__idxmap = mosek.fusion.Utils.IntMap()
   else:
    self.__idxmap = None
   self.__dom = dom_
   self.__names_flushed = False
  @staticmethod
  def _match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_J__(_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  @staticmethod
  def _match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  def _elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(_0,_1)
   self.__dom._domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(_0,_1)
   return (_1)
  def _flushNames_alt_(self,):
    return self._flushNames_()
  def _flushNames_(self,):
   if ((not self.__names_flushed) and (int(len(self._name)) > 0)):
    if (self.__nativeidxs is not None):
     for _0 in range(0,int((self.__nativeidxs).shape[0])):
      self._model._varname_IS(self.__nativeidxs[_0],mosek.fusion.Utils.StringBuffer()._a_S(self._name)._a_S("[")._a_S(self._shape_p._getname_J(_0))._a_S("]")._toString_())
    else:
     _1=self.__idxmap._keys_()
     _2=self.__idxmap._values_()
     for _3 in range(0,int((_1).shape[0])):
      self._model._varname_IS(_2[_3],mosek.fusion.Utils.StringBuffer()._a_S(self._name)._a_S("[")._a_S(self._shape_p._getname_J(_3))._a_S("]")._toString_())
    self.__names_flushed = True
  @staticmethod
  def _match_inst__3JIIJJ_3I_3I_3I(*args):
    if len(args) != 8: return False
    _0,_1,_2,_3,_4,_5,_6,_7, = args
    return (__arg_match__3J__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4) and __arg_match__3I__(_5) and __arg_match__3I__(_6) and __arg_match__3I__(_7))
  @staticmethod
  def _match_alt_inst__3JIIJJ_3I_3I_3I(*args):
    if len(args) != 8: return False
    _0,_1,_2,_3,_4,_5,_6,_7, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4) and __arg_alt_match__3I__(_5) and __arg_alt_match__3I__(_6) and __arg_alt_match__3I__(_7))
  def _inst_alt__3JIIJJ_3I_3I_3I(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.int32(_t__2)
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.int32))
   _6=numpy.array(_t__6,dtype=numpy.dtype(numpy.int32))
   _7=numpy.array(_t__7,dtype=numpy.dtype(numpy.int32))
   _1 = self._inst__3JIIJJ_3I_3I_3I(_0,_1,_2,_3,_4,_5,_6,_7)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__6[:] = _6
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__7[:] = _7
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst__3JIIJJ_3I_3I_3I(self,_0,_1,_2,_3,_4,_5,_6,_7):
   if (self.__nativeidxs is not None):
    fragments._c_closure_119(_5,_4,_1,_0,_3,_2,self.__nativeidxs) # src/fusion/RangedVariable.mbi:592:9-595:10
   else:
    for _8 in range(_1,_2):
     if (not self.__idxmap._hasItem_J(_0[(numpy.int64(_8) - _3)])):
      _9=self._model._append_1rangedvar_Lmosek_4fusion_4ModelVariable_2JDD(self,_0[(_8 - _3)],self.__dom._get_1lb_1item_J(_0[(_8 - _3)]),self.__dom._get_1ub_1item_J(_0[(_8 - _3)]))
      self.__idxmap._setItem_JI(_0[(_8 - _3)],_9)
      _5[((_4 + _8) - _1)] = _9
      self.__names_flushed = False
     else:
      _5[((_4 + _8) - _1)] = self.__idxmap._getItem_J(_0[(numpy.int64(_8) - _3)])
  @staticmethod
  def _match_inst_JJ_3I_3I_3I(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match_J__(_0) and __arg_match_J__(_1) and __arg_match__3I__(_2) and __arg_match__3I__(_3) and __arg_match__3I__(_4))
  @staticmethod
  def _match_alt_inst_JJ_3I_3I_3I(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_J__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match__3I__(_3) and __arg_alt_match__3I__(_4))
  def _inst_alt_JJ_3I_3I_3I(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.int64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int32))
   _1 = self._inst_JJ_3I_3I_3I(_0,_1,_2,_3,_4)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst_JJ_3I_3I_3I(self,_0,_1,_2,_3,_4):
   if ((_0 < 0) or (_0 >= (self._shape_p._size))):
    raise mosek_fusion_IndexError._ctor_S("Index out of bounds")
   if (self.__nativeidxs is not None):
    _2[_1] = self.__nativeidxs[_0]
   else:
    if (not self.__idxmap._hasItem_J(_0)):
     _5=self
     _6=self._model._append_1rangedvar_Lmosek_4fusion_4ModelVariable_2JDD(_5,_0,self.__dom._get_1lb_1item_J(_0),self.__dom._get_1ub_1item_J(_0))
     self.__idxmap._setItem_JI(_0,_6)
     _2[_1] = _6
     self.__names_flushed = False
    else:
     _2[_1] = self.__idxmap._getItem_J(_0)
  @staticmethod
  def _match_upperBoundVar_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_upperBoundVar_(*args):
    if len(args) != 0: return False
    return True
  def _upperBoundVar_alt_(self,):
    return self._upperBoundVar_()
  def _upperBoundVar_(self,):
   _0=numpy.zeros(((self._shape_p.nd),), dtype=numpy.dtype(numpy.int64))
   _0[((self._shape_p.nd) - 1)] = 1
   _1=((self._shape_p.nd) - 1)
   while (_1 > 0):
    _0[(_1 - 1)] = (_0[_1] * numpy.int64(self._shape_p._dim_I(_1)))
    _1 -= 1
   return (mosek_fusion_BoundInterfaceVariable._ctor_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Set_2J_3JZ(self,self._shape_p,0,_0,False))
  @staticmethod
  def _match_lowerBoundVar_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_lowerBoundVar_(*args):
    if len(args) != 0: return False
    return True
  def _lowerBoundVar_alt_(self,):
    return self._lowerBoundVar_()
  def _lowerBoundVar_(self,):
   _0=numpy.zeros(((self._shape_p.nd),), dtype=numpy.dtype(numpy.int64))
   _0[((self._shape_p.nd) - 1)] = 1
   _1=((self._shape_p.nd) - 1)
   while (_1 > 0):
    _0[(_1 - 1)] = (_0[_1] * self._shape_p._dim_I(_1))
    _1 -= 1
   return (mosek_fusion_BoundInterfaceVariable._ctor_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Set_2J_3JZ(self,self._shape_p,0,_0,True))
  def _dual_1u_alt_J_3I_3JI_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1u_J_3I_3JI_3D(_0,_1,_2,_3,_4)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1u_J_3I_3JI_3D(self,_0,_1,_2,_3,_4):
   _5=1
   _6=int((_2).shape[0])
   _7=mosek_fusion_IndexCounter._ctor_J_3I_3J(_0,_1,_2)
   _8=self._model._getSolution_1sux_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _5 = fragments._c_closure_120(_6,_1,_5) # src/fusion/RangedVariable.mbi:482:9-51
   _5 = numpy.int64(_5) # postprocess
   if (self.__nativeidxs is not None):
    for _9 in range(0,_5):
     _10=self.__nativeidxs[_7._get_()]
     _4[(_9 + _3)] = _8[_10]
     _7._inc_()
   else:
    _11=self._model._getPrimalSolutionStatus_()
    for _12 in range(0,numpy.int32(_5)):
     if self.__idxmap._hasItem_J(_7._get_()):
      _13=self.__idxmap._getItem_J(_7._get_())
      _4[_12] = _8[_13]
     else:
      if ((_11==mosek.fusion.SolutionStatus.Optimal) or ((_11==mosek.fusion.SolutionStatus.NearOptimal) or ((_11==mosek.fusion.SolutionStatus.Feasible) or (_11==mosek.fusion.SolutionStatus.NearFeasible)))):
       _4[(_3 + _12)] = self.__dom._get_1ub_1item_J(_7._get_())
      else:
       _4[(_3 + _12)] = 0.0
     _7._inc_()
  def _dual_1u_alt__3JI_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1u__3JI_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1u__3JI_3D(self,_0,_1,_2):
   _3=self._model._getSolution_1sux_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   if (self.__nativeidxs is not None):
    fragments._c_closure_121(_0,self.__nativeidxs,_1,_3,_2) # src/fusion/RangedVariable.mbi:442:11-446:12
   else:
    _4=self._model._getPrimalSolutionStatus_()
    for _5 in range(0,int((_0).shape[0])):
     if self.__idxmap._hasItem_J(_0[_5]):
      _6=self.__idxmap._getItem_J(_0[_5])
      _2[(_1 + _5)] = _3[_6]
     else:
      if ((_4==mosek.fusion.SolutionStatus.Optimal) or ((_4==mosek.fusion.SolutionStatus.NearOptimal) or ((_4==mosek.fusion.SolutionStatus.Feasible) or (_4==mosek.fusion.SolutionStatus.NearFeasible)))):
       _2[(_1 + _5)] = self.__dom._get_1ub_1item_J(_0[_5])
      else:
       _2[(_1 + _5)] = 0.0
  def _dual_1l_alt_J_3I_3JI_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1l_J_3I_3JI_3D(_0,_1,_2,_3,_4)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1l_J_3I_3JI_3D(self,_0,_1,_2,_3,_4):
   _5=1
   _6=int((_2).shape[0])
   _7=mosek_fusion_IndexCounter._ctor_J_3I_3J(_0,_1,_2)
   _8=self._model._getSolution_1slx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _5 = fragments._c_closure_122(_6,_1,_5) # src/fusion/RangedVariable.mbi:396:9-51
   _5 = numpy.int64(_5) # postprocess
   if (self.__nativeidxs is not None):
    for _9 in range(0,_5):
     _10=self.__nativeidxs[_7._get_()]
     _4[(_9 + _3)] = _8[_10]
     _7._inc_()
   else:
    _11=self._model._getPrimalSolutionStatus_()
    for _12 in range(0,numpy.int32(_5)):
     if self.__idxmap._hasItem_J(_7._get_()):
      _13=self.__idxmap._getItem_J(_7._get_())
      _4[_12] = _8[_13]
     else:
      if ((_11==mosek.fusion.SolutionStatus.Optimal) or ((_11==mosek.fusion.SolutionStatus.NearOptimal) or ((_11==mosek.fusion.SolutionStatus.Feasible) or (_11==mosek.fusion.SolutionStatus.NearFeasible)))):
       _4[(_3 + _12)] = self.__dom._get_1ub_1item_J(_7._get_())
      else:
       _4[(_3 + _12)] = 0.0
     _7._inc_()
  def _dual_1l_alt__3JI_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1l__3JI_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1l__3JI_3D(self,_0,_1,_2):
   _3=self._model._getSolution_1slx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   if (self.__nativeidxs is not None):
    fragments._c_closure_123(_0,self.__nativeidxs,_1,_3,_2) # src/fusion/RangedVariable.mbi:357:11-361:12
   else:
    _4=self._model._getPrimalSolutionStatus_()
    for _5 in range(0,int((_0).shape[0])):
     if self.__idxmap._hasItem_J(_0[_5]):
      _6=self.__idxmap._getItem_J(_0[_5])
      _2[(_1 + _5)] = _3[_6]
     else:
      if ((_4==mosek.fusion.SolutionStatus.Optimal) or ((_4==mosek.fusion.SolutionStatus.NearOptimal) or ((_4==mosek.fusion.SolutionStatus.Feasible) or (_4==mosek.fusion.SolutionStatus.NearFeasible)))):
       _2[(_1 + _5)] = self.__dom._get_1ub_1item_J(_0[_5])
      else:
       _2[(_1 + _5)] = 0.0
  def __dual_1values_alt_J_3I_3JI_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = self.__dual_1values_J_3I_3JI_3D(_0,_1,_2,_3,_4)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __dual_1values_J_3I_3JI_3D(self,_0,_1,_2,_3,_4):
   _5=1
   _6=int((_2).shape[0])
   _7=mosek_fusion_IndexCounter._ctor_J_3I_3J(_0,_1,_2)
   _8=self._model._getSolution_1slx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _9=self._model._getSolution_1sux_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _5 = fragments._c_closure_124(_6,_1,_5) # src/fusion/RangedVariable.mbi:310:9-51
   _5 = numpy.int64(_5) # postprocess
   if (self.__nativeidxs is not None):
    for _10 in range(0,_5):
     _11=self.__nativeidxs[_7._get_()]
     _4[(_10 + _3)] = (_8[_11] - _9[_11])
     _7._inc_()
   else:
    _12=self._model._getPrimalSolutionStatus_()
    for _13 in range(0,numpy.int32(_5)):
     if self.__idxmap._hasItem_J(_7._get_()):
      _14=self.__idxmap._getItem_J(_7._get_())
      _4[_13] = (_8[_14] - _9[_14])
     else:
      if ((_12==mosek.fusion.SolutionStatus.Optimal) or ((_12==mosek.fusion.SolutionStatus.NearOptimal) or ((_12==mosek.fusion.SolutionStatus.Feasible) or (_12==mosek.fusion.SolutionStatus.NearFeasible)))):
       _4[(_3 + _13)] = self.__dom._get_1ub_1item_J(_7._get_())
      else:
       _4[(_3 + _13)] = 0.0
     _7._inc_()
  def __dual_1values_alt__3JI_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self.__dual_1values__3JI_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __dual_1values__3JI_3D(self,_0,_1,_2):
   _3=self._model._getSolution_1slx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _4=self._model._getSolution_1sux_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   if (self.__nativeidxs is not None):
    fragments._c_closure_125(_0,self.__nativeidxs,_1,_3,_4,_2) # src/fusion/RangedVariable.mbi:270:11-274:12
   else:
    _5=self._model._getPrimalSolutionStatus_()
    for _6 in range(0,int((_0).shape[0])):
     if self.__idxmap._hasItem_J(_0[_6]):
      _7=self.__idxmap._getItem_J(_0[_6])
      _2[(_1 + _6)] = (_3[_7] - _4[_7])
     else:
      if ((_5==mosek.fusion.SolutionStatus.Optimal) or ((_5==mosek.fusion.SolutionStatus.NearOptimal) or ((_5==mosek.fusion.SolutionStatus.Feasible) or (_5==mosek.fusion.SolutionStatus.NearFeasible)))):
       _2[(_1 + _6)] = self.__dom._get_1ub_1item_J(_0[_6])
      else:
       _2[(_1 + _6)] = 0.0
  @staticmethod
  def _match_set_1values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match_J__(_0) and __arg_match__3I__(_1) and __arg_match__3J__(_2) and __arg_match_I__(_3) and __arg_match__3D__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_set_1values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match__3D__(_4) and __arg_alt_match_Z__(_5))
  def _set_1values_alt_J_3I_3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = self._set_1values_J_3I_3JI_3DZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values_J_3I_3JI_3DZ(self,_0,_1,_2,_3,_4,_5):
   if _5:
    _6=1
    _7=int((_2).shape[0])
    _8=mosek_fusion_IndexCounter._ctor_J_3I_3J(_0,_1,_2)
    _6 = fragments._c_closure_126(_7,_1,_6) # src/fusion/RangedVariable.mbi:233:11-53
    _6 = numpy.int64(_6) # postprocess
    if (self.__nativeidxs is not None):
     _9=int((self.__nativeidxs).shape[0])
     _10=numpy.array([self.__nativeidxs[_8._next_()] for _11 in range(0,_6)], dtype=numpy.dtype(numpy.int32))
     _12=(numpy.array([_4[(_3 + _13)] for _13 in range(0,_9)], dtype=numpy.dtype(numpy.float64)) if ((_3 > 0) ) else _4)
     self._model._setSolution_1xx__3I_3D(_10,_12)
    else:
     _14=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int32))
     for _15 in range(0,_6):
      self._inst_JJ_3I_3I_3I(_8._next_(),_15,_14,None,None)
     _16=numpy.array([_4[(_3 + _17)] for _17 in range(0,_6)], dtype=numpy.dtype(numpy.float64))
     self._model._setSolution_1xx__3I_3D(_14,_16)
   else:
    pass
  @staticmethod
  def _match_set_1values__3J_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3J__(_0) and __arg_match__3D__(_1) and __arg_match_Z__(_2))
  @staticmethod
  def _match_alt_set_1values__3J_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3D__(_1) and __arg_alt_match_Z__(_2))
  def _set_1values_alt__3J_3DZ(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=_t__2
   _1 = self._set_1values__3J_3DZ(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values__3J_3DZ(self,_0,_1,_2):
   if _2:
    if (self.__nativeidxs is not None):
     _3=int((self.__nativeidxs).shape[0])
     _4=numpy.array([self.__nativeidxs[_0[_5]] for _5 in range(0,_3)], dtype=numpy.dtype(numpy.int32))
     _6=numpy.array([_1[_7] for _7 in range(0,_3)], dtype=numpy.dtype(numpy.float64))
     self._model._setSolution_1xx__3I_3D(_4,_6)
    else:
     _8=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int32))
     for _9 in range(0,int((_0).shape[0])):
      self._inst_JJ_3I_3I_3I(_0[_9],_9,_8,None,None)
     _10=numpy.array([_1[_11] for _11 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.float64))
     self._model._setSolution_1xx__3I_3D(_8,_10)
   else:
    pass
  @staticmethod
  def _match_values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match_J__(_0) and __arg_match__3I__(_1) and __arg_match__3J__(_2) and __arg_match_I__(_3) and __arg_match__3D__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match__3D__(_4) and __arg_alt_match_Z__(_5))
  def _values_alt_J_3I_3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = self._values_J_3I_3JI_3DZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values_J_3I_3JI_3DZ(self,_0,_1,_2,_3,_4,_5):
   if _5:
    _6=1
    _7=int((_2).shape[0])
    _8=mosek_fusion_IndexCounter._ctor_J_3I_3J(_0,_1,_2)
    _9=self._model._getSolution_1xx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
    _6 = fragments._c_closure_127(_7,_1,_6) # src/fusion/RangedVariable.mbi:153:11-53
    _6 = numpy.int64(_6) # postprocess
    if (self.__nativeidxs is not None):
     for _10 in range(0,_6):
      _4[(_10 + _3)] = _9[self.__nativeidxs[_8._get_()]]
      _8._inc_()
    else:
     _11=self._model._getPrimalSolutionStatus_()
     for _12 in range(0,numpy.int32(_6)):
      if self.__idxmap._hasItem_J(_8._get_()):
       _4[_12] = _9[self.__idxmap._getItem_J(_8._get_())]
      else:
       if ((_11==mosek.fusion.SolutionStatus.Optimal) or ((_11==mosek.fusion.SolutionStatus.NearOptimal) or ((_11==mosek.fusion.SolutionStatus.Feasible) or (_11==mosek.fusion.SolutionStatus.NearFeasible)))):
        _4[(_3 + _12)] = self.__dom._get_1ub_1item_J(_8._get_())
       else:
        _4[(_3 + _12)] = 0.0
      _8._inc_()
   else:
    self.__dual_1values_J_3I_3JI_3D(_0,_1,_2,_3,_4)
  @staticmethod
  def _match_values__3JI_3DZ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match__3J__(_0) and __arg_match_I__(_1) and __arg_match__3D__(_2) and __arg_match_Z__(_3))
  @staticmethod
  def _match_alt_values__3JI_3DZ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match_Z__(_3))
  def _values_alt__3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=_t__3
   _1 = self._values__3JI_3DZ(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values__3JI_3DZ(self,_0,_1,_2,_3):
   if _3:
    _4=self._model._getSolution_1xx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
    if (self.__nativeidxs is not None):
     fragments._c_closure_128(_0,self.__nativeidxs,_1,_2,_4) # src/fusion/RangedVariable.mbi:113:13-114:58
    else:
     _5=self._model._getPrimalSolutionStatus_()
     for _6 in range(0,int((_0).shape[0])):
      if self.__idxmap._hasItem_J(_0[_6]):
       _2[(_1 + _6)] = _4[self.__idxmap._getItem_J(_0[_6])]
      else:
       if ((_5==mosek.fusion.SolutionStatus.Optimal) or ((_5==mosek.fusion.SolutionStatus.NearOptimal) or ((_5==mosek.fusion.SolutionStatus.Feasible) or (_5==mosek.fusion.SolutionStatus.NearFeasible)))):
        _2[(_1 + _6)] = self.__dom._get_1ub_1item_J(_0[_6])
       else:
        _2[(_1 + _6)] = 0.0
   else:
    self.__dual_1values__3JI_3D(_0,_1,_2)
  @staticmethod
  def _match_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3J__(_0))
  @staticmethod
  def _match_alt_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3J__(_0))
  def _make_1continuous_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1continuous__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1continuous__3J(self,_0):
   if (self.__nativeidxs is not None):
    self._getModel_()._task_1var_1putcontlist__3I(numpy.array([self.__nativeidxs[_0[_1]] for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32)))
   else:
    _2=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int32))
    self._inst__3JIIJJ_3I_3I_3I(_0,0,int((_0).shape[0]),0,0,_2,None,None)
    self._getModel_()._task_1var_1putcontlist__3I(_2)
  @staticmethod
  def _match_make_1integer__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3J__(_0))
  @staticmethod
  def _match_alt_make_1integer__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3J__(_0))
  def _make_1integer_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1integer__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1integer__3J(self,_0):
   if (self.__nativeidxs is not None):
    self._getModel_()._task_1var_1putintlist__3I(numpy.array([self.__nativeidxs[_0[_1]] for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32)))
   else:
    _2=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int32))
    self._inst__3JIIJJ_3I_3I_3I(_0,0,int((_0).shape[0]),0,0,_2,None,None)
    self._getModel_()._task_1var_1putintlist__3I(_2)
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   return (mosek_fusion_RangedVariable._ctor_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Model_2(self,_0))
 return RangedVariable
mosek_fusion_RangedVariable=__mk_mosek_fusion_RangedVariable()
del __mk_mosek_fusion_RangedVariable
#BEFORE CLASS
def __mk_mosek_fusion_LinearPSDVariable():
 class LinearPSDVariable(mosek_fusion_ModelVariable):
  __slots__ = ['_LinearPSDVariable__numcones','_LinearPSDVariable__coneidx','_LinearPSDVariable__conesize','_LinearPSDVariable__sdpvardim','_LinearPSDVariable__blocksize']
  def make_integer(self,*args):
    if False: pass
    elif mosek_fusion_LinearPSDVariable._match_make_1integer__3J(*args): # []int64
      return self._make_1integer__3J(*args)
    elif mosek_fusion_LinearPSDVariable._match_alt_make_1integer__3J(*args): # []int64
      return self._make_1integer_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_integer('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearPSDVariable.make_integer(array(int64,ndim=1))')
  def set_values(self,*args):
    if False: pass
    elif mosek_fusion_LinearPSDVariable._match_set_1values__3J_3DZ(*args): # []int64,[]double,bool
      return self._set_1values__3J_3DZ(*args)
    elif mosek_fusion_LinearPSDVariable._match_alt_set_1values__3J_3DZ(*args): # []int64,[]double,bool
      return self._set_1values_alt__3J_3DZ(*args)
    elif mosek_fusion_LinearPSDVariable._match_set_1values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._set_1values_J_3I_3JI_3DZ(*args)
    elif mosek_fusion_LinearPSDVariable._match_alt_set_1values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._set_1values_alt_J_3I_3JI_3DZ(*args)
    else:
      raise ValueError('Invalid argument list set_values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearPSDVariable.set_values(array(int64,ndim=1),array(double,ndim=1),bool)\n\tmosek.fusion.LinearPSDVariable.set_values(int64,array(int32,ndim=1),array(int64,ndim=1),int32,array(double,ndim=1),bool)')
  def make_continuous(self,*args):
    if False: pass
    elif mosek_fusion_LinearPSDVariable._match_make_1continuous__3J(*args): # []int64
      return self._make_1continuous__3J(*args)
    elif mosek_fusion_LinearPSDVariable._match_alt_make_1continuous__3J(*args): # []int64
      return self._make_1continuous_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_continuous('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearPSDVariable.make_continuous(array(int64,ndim=1))')
  def inst(self,*args):
    if False: pass
    elif mosek_fusion_LinearPSDVariable._match_inst_JJ_3I_3I_3I(*args): # int64,int64,[]int32,[]int32,[]int32
      return self._inst_JJ_3I_3I_3I(*args)
    elif mosek_fusion_LinearPSDVariable._match_alt_inst_JJ_3I_3I_3I(*args): # int64,int64,[]int32,[]int32,[]int32
      return self._inst_alt_JJ_3I_3I_3I(*args)
    elif mosek_fusion_LinearPSDVariable._match_inst__3JIIJJ_3I_3I_3I(*args): # []int64,int32,int32,int64,int64,[]int32,[]int32,[]int32
      return self._inst__3JIIJJ_3I_3I_3I(*args)
    elif mosek_fusion_LinearPSDVariable._match_alt_inst__3JIIJJ_3I_3I_3I(*args): # []int64,int32,int32,int64,int64,[]int32,[]int32,[]int32
      return self._inst_alt__3JIIJJ_3I_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list inst('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearPSDVariable.inst(int64,int64,array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.LinearPSDVariable.inst(array(int64,ndim=1),int32,int32,int64,int64,array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))')
  def values(self,*args):
    if False: pass
    elif mosek_fusion_LinearPSDVariable._match_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_I_3DZ(*args)
    elif mosek_fusion_LinearPSDVariable._match_alt_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_alt_I_3DZ(*args)
    elif mosek_fusion_LinearPSDVariable._match_values__3JI_3DZ(*args): # []int64,int32,[]double,bool
      return self._values__3JI_3DZ(*args)
    elif mosek_fusion_LinearPSDVariable._match_alt_values__3JI_3DZ(*args): # []int64,int32,[]double,bool
      return self._values_alt__3JI_3DZ(*args)
    elif mosek_fusion_LinearPSDVariable._match_values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._values_J_3I_3JI_3DZ(*args)
    elif mosek_fusion_LinearPSDVariable._match_alt_values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._values_alt_J_3I_3JI_3DZ(*args)
    else:
      raise ValueError('Invalid argument list values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearPSDVariable.values(int32,array(double,ndim=1),bool)\n\tmosek.fusion.LinearPSDVariable.values(array(int64,ndim=1),int32,array(double,ndim=1),bool)\n\tmosek.fusion.LinearPSDVariable.values(int64,array(int32,ndim=1),array(int64,ndim=1),int32,array(double,ndim=1),bool)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_LinearPSDVariable._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_LinearPSDVariable._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearPSDVariable.toString()')
  def __repr__(self): return 'mosek.fusion.LinearPSDVariable'
  @staticmethod
  def _ctor_Lmosek_4fusion_4LinearPSDVariable_2Lmosek_4fusion_4Model_2(v,m):
    o = LinearPSDVariable.__new__(LinearPSDVariable)
    o._ctor_init_Lmosek_4fusion_4LinearPSDVariable_2Lmosek_4fusion_4Model_2(v,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4LinearPSDVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_match_Lmosek_4fusion_4LinearPSDVariable_2__(v) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4LinearPSDVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinearPSDVariable_2__(v) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4LinearPSDVariable_2Lmosek_4fusion_4Model_2(self,v,m):
    self._ctor_init_Lmosek_4fusion_4LinearPSDVariable_2Lmosek_4fusion_4Model_2(v,m)
  def _ctor_init_Lmosek_4fusion_4LinearPSDVariable_2Lmosek_4fusion_4Model_2(self,v,m):
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(self,v,m)
   self.__blocksize = (v.__blocksize)
   self.__conesize = (v.__conesize)
   self.__coneidx = (v.__coneidx)
   self.__sdpvardim = (v.__sdpvardim)
   self.__numcones = (v.__numcones)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SILmosek_4fusion_4Set_2IJ(model_,name_,n,shp_,coneidx_,varid_):
    o = LinearPSDVariable.__new__(LinearPSDVariable)
    o._ctor_init_Lmosek_4fusion_4Model_2SILmosek_4fusion_4Set_2IJ(model_,name_,n,shp_,coneidx_,varid_)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SILmosek_4fusion_4Set_2IJ(*args):
    if len(args) != 6: return False
    model_,name_,n,shp_,coneidx_,varid_, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model_) and __arg_match_S__(name_) and __arg_match_I__(n) and __arg_match_Lmosek_4fusion_4Set_2__(shp_) and __arg_match_I__(coneidx_) and __arg_match_J__(varid_))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SILmosek_4fusion_4Set_2IJ(*args):
    if len(args) != 6: return False
    model_,name_,n,shp_,coneidx_,varid_, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model_) and __arg_alt_match_S__(name_) and __arg_alt_match_I__(n) and __arg_alt_match_Lmosek_4fusion_4Set_2__(shp_) and __arg_alt_match_I__(coneidx_) and __arg_alt_match_J__(varid_))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SILmosek_4fusion_4Set_2IJ(self,model_,name_,n,shp_,coneidx_,varid_):
    self._ctor_init_Lmosek_4fusion_4Model_2SILmosek_4fusion_4Set_2IJ(model_,name_,numpy.int32(n),shp_,numpy.int32(coneidx_),numpy.int64(varid_))
  def _ctor_init_Lmosek_4fusion_4Model_2SILmosek_4fusion_4Set_2IJ(self,model_,name_,n,shp_,coneidx_,varid_):
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2J(self,model_,name_,shp_,varid_)
   self.__blocksize = shp_._dim_I(0)
   self.__conesize = shp_._dim_I(0)
   self.__coneidx = coneidx_
   self.__sdpvardim = n
   self.__numcones = 1
   for _0 in range(1,(shp_.nd)):
    self.__numcones *= shp_._dim_I(_0)
  def _flushNames_alt_(self,):
    return self._flushNames_()
  def _flushNames_(self,):
   pass
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("PSDVariable(")
   if (int(len(self._name)) > 0):
    _0._a_S("'")._a_S(self._name)._a_S("',")
   _0._a_I(self._shape_p._dim_I(0))
   for _1 in range(1,(self._shape_p.nd)):
    _0._a_S(",")._a_I(self._shape_p._dim_I(_1))
   _0._a_S(")")
   return (_0._toString_())
  @staticmethod
  def _match_inst__3JIIJJ_3I_3I_3I(*args):
    if len(args) != 8: return False
    _0,_1,_2,_3,_4,_5,_6,_7, = args
    return (__arg_match__3J__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4) and __arg_match__3I__(_5) and __arg_match__3I__(_6) and __arg_match__3I__(_7))
  @staticmethod
  def _match_alt_inst__3JIIJJ_3I_3I_3I(*args):
    if len(args) != 8: return False
    _0,_1,_2,_3,_4,_5,_6,_7, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4) and __arg_alt_match__3I__(_5) and __arg_alt_match__3I__(_6) and __arg_alt_match__3I__(_7))
  def _inst_alt__3JIIJJ_3I_3I_3I(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.int32(_t__2)
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.int32))
   _6=numpy.array(_t__6,dtype=numpy.dtype(numpy.int32))
   _7=numpy.array(_t__7,dtype=numpy.dtype(numpy.int32))
   _1 = self._inst__3JIIJJ_3I_3I_3I(_0,_1,_2,_3,_4,_5,_6,_7)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__6[:] = _6
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__7[:] = _7
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst__3JIIJJ_3I_3I_3I(self,_0,_1,_2,_3,_4,_5,_6,_7):
   for _8 in range(_1,_2):
    if ((_0[_8] < _3) or (_0[_8] >= ((self._shape_p._size) + _3))):
     raise mosek_fusion_IndexError._ctor_S("Index out of bounds")
   _9=_4
   _10=self.__sdpvardim
   _9 = fragments._c_closure_129(self.__blocksize,self.__coneidx,_5,_6,_7,_1,_0,_3,_2,_10,_9) # src/fusion/LinearPSDVariable.monty:183:9-198:10
   _9 = numpy.int64(_9) # postprocess
  @staticmethod
  def _match_inst_JJ_3I_3I_3I(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match_J__(_0) and __arg_match_J__(_1) and __arg_match__3I__(_2) and __arg_match__3I__(_3) and __arg_match__3I__(_4))
  @staticmethod
  def _match_alt_inst_JJ_3I_3I_3I(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_J__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match__3I__(_3) and __arg_alt_match__3I__(_4))
  def _inst_alt_JJ_3I_3I_3I(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.int64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int32))
   _1 = self._inst_JJ_3I_3I_3I(_0,_1,_2,_3,_4)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst_JJ_3I_3I_3I(self,_0,_1,_2,_3,_4):
   if ((_0 < 0) or (_0 >= (self._shape_p._size))):
    raise mosek_fusion_IndexError._ctor_S("Index out of bounds")
   _5=self.__sdpvardim
   _6=numpy.int32((_0 // self.__blocksize))
   _7=(_0 % self.__blocksize)
   _2[_1] = (- ((1 + self.__coneidx) + _6))
   _8=numpy.int32(((_5 + 0.5) - mosek.fusion.Utils.Tools._sqrt_D((((_5 + 0.5) * (_5 + 0.5)) - (_7 * 2)))))
   _9=numpy.int32((_7 - ((_8 * (((2 * _5) + 1) + _8)) // 2)))
   if (_9 >= _8):
    _3[_1] = _9
    _4[_1] = _8
   else:
    _3[_1] = _8
    _4[_1] = _9
  @staticmethod
  def _match_set_1values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match_J__(_0) and __arg_match__3I__(_1) and __arg_match__3J__(_2) and __arg_match_I__(_3) and __arg_match__3D__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_set_1values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match__3D__(_4) and __arg_alt_match_Z__(_5))
  def _set_1values_alt_J_3I_3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = self._set_1values_J_3I_3JI_3DZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values_J_3I_3JI_3DZ(self,_0,_1,_2,_3,_4,_5):
   raise mosek_fusion_UnimplementedError._ctor_S("Cannot make PSDVariable elements integer")
  @staticmethod
  def _match_set_1values__3J_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3J__(_0) and __arg_match__3D__(_1) and __arg_match_Z__(_2))
  @staticmethod
  def _match_alt_set_1values__3J_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3D__(_1) and __arg_alt_match_Z__(_2))
  def _set_1values_alt__3J_3DZ(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=_t__2
   _1 = self._set_1values__3J_3DZ(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values__3J_3DZ(self,_0,_1,_2):
   raise mosek_fusion_UnimplementedError._ctor_S("Cannot make PSDVariable elements integer")
  @staticmethod
  def _match_values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match_J__(_0) and __arg_match__3I__(_1) and __arg_match__3J__(_2) and __arg_match_I__(_3) and __arg_match__3D__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match__3D__(_4) and __arg_alt_match_Z__(_5))
  def _values_alt_J_3I_3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = self._values_J_3I_3JI_3DZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values_J_3I_3JI_3DZ(self,_0,_1,_2,_3,_4,_5):
   _6=1
   _7=int((_2).shape[0])
   _8=mosek_fusion_IndexCounter._ctor_J_3I_3J(_0,_1,_2)
   _9=(self._model._getSolution_1barx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default) if (_5 ) else self._model._getSolution_1bars_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default))
   _6 = fragments._c_closure_130(_7,_1,_6) # src/fusion/LinearPSDVariable.monty:105:9-51
   _6 = numpy.int64(_6) # postprocess
   for _10 in range(0,_6):
    _11=(_8._get_() // self.__blocksize)
    _12=(_8._get_() % self.__blocksize)
    _4[_10] = _9[(numpy.int64(self.__coneidx) + _11)][_12]
    _8._inc_()
  @staticmethod
  def _match_values__3JI_3DZ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match__3J__(_0) and __arg_match_I__(_1) and __arg_match__3D__(_2) and __arg_match_Z__(_3))
  @staticmethod
  def _match_alt_values__3JI_3DZ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match_Z__(_3))
  def _values_alt__3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=_t__3
   _1 = self._values__3JI_3DZ(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values__3JI_3DZ(self,_0,_1,_2,_3):
   _4=(self._model._getSolution_1barx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default) if (_3 ) else self._model._getSolution_1bars_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default))
   for _5 in range(0,int((_0).shape[0])):
    if ((_0[_5] < 0) or (_0[_5] >= (self._shape_p._size))):
     raise mosek_fusion_IndexError._ctor_S("Index out of bounds")
   fragments._c_closure_131(_4,self.__blocksize,self.__coneidx,_0,_2) # src/fusion/LinearPSDVariable.monty:79:9-85:10
  @staticmethod
  def _match_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3J__(_0))
  @staticmethod
  def _match_alt_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3J__(_0))
  def _make_1continuous_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1continuous__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1continuous__3J(self,_0):
   pass
  @staticmethod
  def _match_make_1integer__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3J__(_0))
  @staticmethod
  def _match_alt_make_1integer__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3J__(_0))
  def _make_1integer_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1integer__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1integer__3J(self,_0):
   raise mosek_fusion_UnimplementedError._ctor_S("Cannot make PSDVariable elements integer")
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   return (mosek_fusion_LinearPSDVariable._ctor_Lmosek_4fusion_4LinearPSDVariable_2Lmosek_4fusion_4Model_2(self,_0))
 return LinearPSDVariable
mosek_fusion_LinearPSDVariable=__mk_mosek_fusion_LinearPSDVariable()
del __mk_mosek_fusion_LinearPSDVariable
#BEFORE CLASS
def __mk_mosek_fusion_PSDVariable():
 class PSDVariable(mosek_fusion_SymmetricVariable,mosek_fusion_ModelVariable):
  __slots__ = ['_PSDVariable__numcones','_PSDVariable__coneidx','_PSDVariable__conesize']
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_PSDVariable._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_PSDVariable._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.PSDVariable.toString()')
  def make_integer(self,*args):
    if False: pass
    elif mosek_fusion_PSDVariable._match_make_1integer__3J(*args): # []int64
      return self._make_1integer__3J(*args)
    elif mosek_fusion_PSDVariable._match_alt_make_1integer__3J(*args): # []int64
      return self._make_1integer_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_integer('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.PSDVariable.make_integer(array(int64,ndim=1))')
  def elementDesc(self,*args):
    if False: pass
    elif mosek_fusion_PSDVariable._match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_PSDVariable._match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementDesc('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.PSDVariable.elementDesc(int64,mosek.fusion.Utils.StringBuffer)')
  def make_continuous(self,*args):
    if False: pass
    elif mosek_fusion_PSDVariable._match_make_1continuous__3J(*args): # []int64
      return self._make_1continuous__3J(*args)
    elif mosek_fusion_PSDVariable._match_alt_make_1continuous__3J(*args): # []int64
      return self._make_1continuous_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_continuous('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.PSDVariable.make_continuous(array(int64,ndim=1))')
  def inst(self,*args):
    if False: pass
    elif mosek_fusion_PSDVariable._match_inst_JJ_3I_3I_3I(*args): # int64,int64,[]int32,[]int32,[]int32
      return self._inst_JJ_3I_3I_3I(*args)
    elif mosek_fusion_PSDVariable._match_alt_inst_JJ_3I_3I_3I(*args): # int64,int64,[]int32,[]int32,[]int32
      return self._inst_alt_JJ_3I_3I_3I(*args)
    elif mosek_fusion_PSDVariable._match_inst__3JIIJJ_3I_3I_3I(*args): # []int64,int32,int32,int64,int64,[]int32,[]int32,[]int32
      return self._inst__3JIIJJ_3I_3I_3I(*args)
    elif mosek_fusion_PSDVariable._match_alt_inst__3JIIJJ_3I_3I_3I(*args): # []int64,int32,int32,int64,int64,[]int32,[]int32,[]int32
      return self._inst_alt__3JIIJJ_3I_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list inst('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.PSDVariable.inst(int64,int64,array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.PSDVariable.inst(array(int64,ndim=1),int32,int32,int64,int64,array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))')
  def values(self,*args):
    if False: pass
    elif mosek_fusion_PSDVariable._match_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_I_3DZ(*args)
    elif mosek_fusion_PSDVariable._match_alt_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_alt_I_3DZ(*args)
    elif mosek_fusion_PSDVariable._match_values__3JI_3DZ(*args): # []int64,int32,[]double,bool
      return self._values__3JI_3DZ(*args)
    elif mosek_fusion_PSDVariable._match_alt_values__3JI_3DZ(*args): # []int64,int32,[]double,bool
      return self._values_alt__3JI_3DZ(*args)
    elif mosek_fusion_PSDVariable._match_values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._values_J_3I_3JI_3DZ(*args)
    elif mosek_fusion_PSDVariable._match_alt_values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._values_alt_J_3I_3JI_3DZ(*args)
    else:
      raise ValueError('Invalid argument list values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.PSDVariable.values(int32,array(double,ndim=1),bool)\n\tmosek.fusion.PSDVariable.values(array(int64,ndim=1),int32,array(double,ndim=1),bool)\n\tmosek.fusion.PSDVariable.values(int64,array(int32,ndim=1),array(int64,ndim=1),int32,array(double,ndim=1),bool)')
  def elementName(self,*args):
    if False: pass
    elif mosek_fusion_PSDVariable._match_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_PSDVariable._match_alt_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementName_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementName('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.PSDVariable.elementName(int64,mosek.fusion.Utils.StringBuffer)')
  def set_values(self,*args):
    if False: pass
    elif mosek_fusion_PSDVariable._match_set_1values__3J_3DZ(*args): # []int64,[]double,bool
      return self._set_1values__3J_3DZ(*args)
    elif mosek_fusion_PSDVariable._match_alt_set_1values__3J_3DZ(*args): # []int64,[]double,bool
      return self._set_1values_alt__3J_3DZ(*args)
    elif mosek_fusion_PSDVariable._match_set_1values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._set_1values_J_3I_3JI_3DZ(*args)
    elif mosek_fusion_PSDVariable._match_alt_set_1values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._set_1values_alt_J_3I_3JI_3DZ(*args)
    else:
      raise ValueError('Invalid argument list set_values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.PSDVariable.set_values(array(int64,ndim=1),array(double,ndim=1),bool)\n\tmosek.fusion.PSDVariable.set_values(int64,array(int32,ndim=1),array(int64,ndim=1),int32,array(double,ndim=1),bool)')
  def __repr__(self): return 'mosek.fusion.PSDVariable'
  @staticmethod
  def _ctor_Lmosek_4fusion_4PSDVariable_2Lmosek_4fusion_4Model_2(v,m):
    o = PSDVariable.__new__(PSDVariable)
    o._ctor_init_Lmosek_4fusion_4PSDVariable_2Lmosek_4fusion_4Model_2(v,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4PSDVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_match_Lmosek_4fusion_4PSDVariable_2__(v) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4PSDVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4PSDVariable_2__(v) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4PSDVariable_2Lmosek_4fusion_4Model_2(self,v,m):
    self._ctor_init_Lmosek_4fusion_4PSDVariable_2Lmosek_4fusion_4Model_2(v,m)
  def _ctor_init_Lmosek_4fusion_4PSDVariable_2Lmosek_4fusion_4Model_2(self,v,m):
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(self,v,m)
   self.__conesize = (v.__conesize)
   self.__coneidx = (v.__coneidx)
   self.__numcones = (v.__numcones)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SIIIJ(model_,name_,conesize_,coneidx_,num_,varid_):
    o = PSDVariable.__new__(PSDVariable)
    o._ctor_init_Lmosek_4fusion_4Model_2SIIIJ(model_,name_,conesize_,coneidx_,num_,varid_)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SIIIJ(*args):
    if len(args) != 6: return False
    model_,name_,conesize_,coneidx_,num_,varid_, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model_) and __arg_match_S__(name_) and __arg_match_I__(conesize_) and __arg_match_I__(coneidx_) and __arg_match_I__(num_) and __arg_match_J__(varid_))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SIIIJ(*args):
    if len(args) != 6: return False
    model_,name_,conesize_,coneidx_,num_,varid_, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model_) and __arg_alt_match_S__(name_) and __arg_alt_match_I__(conesize_) and __arg_alt_match_I__(coneidx_) and __arg_alt_match_I__(num_) and __arg_alt_match_J__(varid_))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SIIIJ(self,model_,name_,conesize_,coneidx_,num_,varid_):
    self._ctor_init_Lmosek_4fusion_4Model_2SIIIJ(model_,name_,numpy.int32(conesize_),numpy.int32(coneidx_),numpy.int32(num_),numpy.int64(varid_))
  def _ctor_init_Lmosek_4fusion_4Model_2SIIIJ(self,model_,name_,conesize_,coneidx_,num_,varid_):
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2J(self,model_,name_,(mosek_fusion_NDSet._ctor_II(conesize_,conesize_) if ((num_==1) ) else mosek_fusion_NDSet._ctor_III(num_,conesize_,conesize_)),varid_)
   self.__conesize = conesize_
   self.__coneidx = coneidx_
   self.__numcones = num_
  def _flushNames_alt_(self,):
    return self._flushNames_()
  def _flushNames_(self,):
   pass
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("PSDVariable(")
   if (int(len(self._name)) > 0):
    _0._a_S("'")._a_S(self._name)._a_S("',")
   _0._a_I(self._shape_p._dim_I(0))
   for _1 in range(1,(self._shape_p.nd)):
    _0._a_S(",")._a_I(self._shape_p._dim_I(_1))
   _0._a_S(")")
   return (_0._toString_())
  @staticmethod
  def _match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_J__(_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  @staticmethod
  def _match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  def _elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   _2=(numpy.int64(self.__conesize) * numpy.int64(self.__conesize))
   _3=(_0 // _2)
   _4=(_0 % _2)
   _5=(_4 // self.__conesize)
   _6=(_4 % self.__conesize)
   _1._a_S(("_" if ((int(len(self._name))==0) ) else self._name))._a_S("[")._a_J(_3)._a_S(",")._a_J(_5)._a_S(",")._a_J(_6)._a_S("] ")
   if (self.__numcones > 1):
    _1._a_S(" : element (")._a_J(_3)._a_S(",")._a_J(_5)._a_S(",")._a_J(_6)
   else:
    _1._a_S(" : element (")._a_J(_5)._a_S(",")._a_J(_6)
   _1._a_S(") in a semidefinite cone of size (")._a_I(self.__numcones)._a_S(",")._a_I(self.__conesize)._a_S(",")._a_I(self.__conesize)._a_S(")")
   return (_1)
  @staticmethod
  def _match_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_J__(_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  @staticmethod
  def _match_alt_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  def _elementName_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   _2=(numpy.int64(self.__conesize) * numpy.int64(self.__conesize))
   _3=(_0 // _2)
   _4=(_0 % _2)
   _5=(_4 // self.__conesize)
   _6=(_4 % self.__conesize)
   _1._a_S(("_" if ((int(len(self._name))==0) ) else self._name))._a_S("[")._a_J(_3)._a_S(",")._a_J(_5)._a_S(",")._a_J(_6)._a_S("] ")
  @staticmethod
  def _match_inst__3JIIJJ_3I_3I_3I(*args):
    if len(args) != 8: return False
    _0,_1,_2,_3,_4,_5,_6,_7, = args
    return (__arg_match__3J__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4) and __arg_match__3I__(_5) and __arg_match__3I__(_6) and __arg_match__3I__(_7))
  @staticmethod
  def _match_alt_inst__3JIIJJ_3I_3I_3I(*args):
    if len(args) != 8: return False
    _0,_1,_2,_3,_4,_5,_6,_7, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4) and __arg_alt_match__3I__(_5) and __arg_alt_match__3I__(_6) and __arg_alt_match__3I__(_7))
  def _inst_alt__3JIIJJ_3I_3I_3I(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.int32(_t__2)
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.int32))
   _6=numpy.array(_t__6,dtype=numpy.dtype(numpy.int32))
   _7=numpy.array(_t__7,dtype=numpy.dtype(numpy.int32))
   _1 = self._inst__3JIIJJ_3I_3I_3I(_0,_1,_2,_3,_4,_5,_6,_7)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__6[:] = _6
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__7[:] = _7
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst__3JIIJJ_3I_3I_3I(self,_0,_1,_2,_3,_4,_5,_6,_7):
   for _8 in range(_1,_2):
    if ((_0[_8] < _3) or (_0[_8] >= ((self._shape_p._size) + _3))):
     raise mosek_fusion_IndexError._ctor_S("Index out of bounds")
   _9=_4
   for _10 in range(_1,_2):
    _11=(_0[_10] - _3)
    _12=numpy.int32((_11 // (self.__conesize * self.__conesize)))
    _13=(_11 - ((self.__conesize * self.__conesize) * _12))
    _5[_9] = (- ((1 + self.__coneidx) + _12))
    _14=(numpy.int32(_13) // self._shape_p._dim_I(1))
    _15=(numpy.int32(_13) - numpy.int32((_14 * self._shape_p._dim_I(1))))
    if (_14 >= _15):
     _6[_9] = _14
     _7[_9] = _15
    else:
     _6[_9] = _15
     _7[_9] = _14
    _9 += 1
  @staticmethod
  def _match_inst_JJ_3I_3I_3I(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match_J__(_0) and __arg_match_J__(_1) and __arg_match__3I__(_2) and __arg_match__3I__(_3) and __arg_match__3I__(_4))
  @staticmethod
  def _match_alt_inst_JJ_3I_3I_3I(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_J__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match__3I__(_3) and __arg_alt_match__3I__(_4))
  def _inst_alt_JJ_3I_3I_3I(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.int64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int32))
   _1 = self._inst_JJ_3I_3I_3I(_0,_1,_2,_3,_4)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst_JJ_3I_3I_3I(self,_0,_1,_2,_3,_4):
   if ((_0 < 0) or (_0 >= (self._shape_p._size))):
    raise mosek_fusion_IndexError._ctor_S("Index out of bounds")
   _5=numpy.int32((_0 // (self.__conesize * self.__conesize)))
   _6=(_0 - ((self.__conesize * self.__conesize) * _5))
   _2[_1] = (- ((1 + self.__coneidx) + _5))
   _7=(numpy.int32(_6) // self._shape_p._dim_I(1))
   _8=(numpy.int32(_6) - numpy.int32((_7 * self._shape_p._dim_I(1))))
   if (_7 >= _8):
    _3[_1] = _7
    _4[_1] = _8
   else:
    _3[_1] = _8
    _4[_1] = _7
  @staticmethod
  def _match_set_1values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match_J__(_0) and __arg_match__3I__(_1) and __arg_match__3J__(_2) and __arg_match_I__(_3) and __arg_match__3D__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_set_1values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match__3D__(_4) and __arg_alt_match_Z__(_5))
  def _set_1values_alt_J_3I_3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = self._set_1values_J_3I_3JI_3DZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values_J_3I_3JI_3DZ(self,_0,_1,_2,_3,_4,_5):
   pass
  @staticmethod
  def _match_set_1values__3J_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3J__(_0) and __arg_match__3D__(_1) and __arg_match_Z__(_2))
  @staticmethod
  def _match_alt_set_1values__3J_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3D__(_1) and __arg_alt_match_Z__(_2))
  def _set_1values_alt__3J_3DZ(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=_t__2
   _1 = self._set_1values__3J_3DZ(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values__3J_3DZ(self,_0,_1,_2):
   pass
  @staticmethod
  def _match_values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match_J__(_0) and __arg_match__3I__(_1) and __arg_match__3J__(_2) and __arg_match_I__(_3) and __arg_match__3D__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match__3D__(_4) and __arg_alt_match_Z__(_5))
  def _values_alt_J_3I_3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = self._values_J_3I_3JI_3DZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values_J_3I_3JI_3DZ(self,_0,_1,_2,_3,_4,_5):
   _6=1
   _7=int((_2).shape[0])
   _8=mosek_fusion_IndexCounter._ctor_J_3I_3J(_0,_1,_2)
   _9=(self._model._getSolution_1barx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default) if (_5 ) else self._model._getSolution_1bars_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default))
   _10=(self.__conesize * self.__conesize)
   _6 = fragments._c_closure_132(_7,_1,_6) # src/fusion/SemidefiniteVariable.mbi:106:9-51
   _6 = numpy.int64(_6) # postprocess
   for _11 in range(0,_6):
    _12=(_8._get_() // _10)
    _13=(_8._get_() - (_12 * _10))
    _14=(_13 // self.__conesize)
    _15=(_13 - (_14 * self.__conesize))
    if (_15 > _14):
     _4[_11] = _9[(numpy.int64(self.__coneidx) + _12)][(((_14 * self.__conesize) + _15) - ((_14 * (_14 + 1)) // 2))]
    else:
     _4[_11] = _9[(numpy.int64(self.__coneidx) + _12)][(((_15 * self.__conesize) + _14) - ((_15 * (_15 + 1)) // 2))]
    _8._inc_()
  @staticmethod
  def _match_values__3JI_3DZ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match__3J__(_0) and __arg_match_I__(_1) and __arg_match__3D__(_2) and __arg_match_Z__(_3))
  @staticmethod
  def _match_alt_values__3JI_3DZ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match_Z__(_3))
  def _values_alt__3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=_t__3
   _1 = self._values__3JI_3DZ(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values__3JI_3DZ(self,_0,_1,_2,_3):
   _4=(self._model._getSolution_1barx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default) if (_3 ) else self._model._getSolution_1bars_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default))
   _5=(self.__conesize * self.__conesize)
   fragments._c_closure_133(_4,_5,self.__coneidx,self.__conesize,_0,_2) # src/fusion/SemidefiniteVariable.mbi:74:9-85:10
  @staticmethod
  def _match_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3J__(_0))
  @staticmethod
  def _match_alt_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3J__(_0))
  def _make_1continuous_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1continuous__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1continuous__3J(self,_0):
   pass
  @staticmethod
  def _match_make_1integer__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3J__(_0))
  @staticmethod
  def _match_alt_make_1integer__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3J__(_0))
  def _make_1integer_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1integer__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1integer__3J(self,_0):
   raise mosek_fusion_UnimplementedError._ctor_S("Cannot make PSDVariable elements integer")
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   return (mosek_fusion_PSDVariable._ctor_Lmosek_4fusion_4PSDVariable_2Lmosek_4fusion_4Model_2(self,_0))
 return PSDVariable
mosek_fusion_PSDVariable=__mk_mosek_fusion_PSDVariable()
del __mk_mosek_fusion_PSDVariable
#BEFORE CLASS
def __mk_mosek_fusion_SymLinearVariable():
 class SymLinearVariable(mosek_fusion_SymmetricVariable,mosek_fusion_ModelVariable):
  __slots__ = ['_SymLinearVariable__dim','_SymLinearVariable__names_flushed','_SymLinearVariable__dom','_SymLinearVariable__nativeidxs','_SymLinearVariable__idxmap']
  def make_continuous(self,*args):
    if False: pass
    elif mosek_fusion_SymLinearVariable._match_make_1continuous__3J(*args): # []int64
      return self._make_1continuous__3J(*args)
    elif mosek_fusion_SymLinearVariable._match_alt_make_1continuous__3J(*args): # []int64
      return self._make_1continuous_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_continuous('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymLinearVariable.make_continuous(array(int64,ndim=1))')
  def inst(self,*args):
    if False: pass
    elif mosek_fusion_SymLinearVariable._match_inst_JJ_3I_3I_3I(*args): # int64,int64,[]int32,[]int32,[]int32
      return self._inst_JJ_3I_3I_3I(*args)
    elif mosek_fusion_SymLinearVariable._match_alt_inst_JJ_3I_3I_3I(*args): # int64,int64,[]int32,[]int32,[]int32
      return self._inst_alt_JJ_3I_3I_3I(*args)
    elif mosek_fusion_SymLinearVariable._match_inst__3JIIJJ_3I_3I_3I(*args): # []int64,int32,int32,int64,int64,[]int32,[]int32,[]int32
      return self._inst__3JIIJJ_3I_3I_3I(*args)
    elif mosek_fusion_SymLinearVariable._match_alt_inst__3JIIJJ_3I_3I_3I(*args): # []int64,int32,int32,int64,int64,[]int32,[]int32,[]int32
      return self._inst_alt__3JIIJJ_3I_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list inst('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymLinearVariable.inst(int64,int64,array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.SymLinearVariable.inst(array(int64,ndim=1),int32,int32,int64,int64,array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))')
  def make_integer(self,*args):
    if False: pass
    elif mosek_fusion_SymLinearVariable._match_make_1integer__3J(*args): # []int64
      return self._make_1integer__3J(*args)
    elif mosek_fusion_SymLinearVariable._match_alt_make_1integer__3J(*args): # []int64
      return self._make_1integer_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_integer('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymLinearVariable.make_integer(array(int64,ndim=1))')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_SymLinearVariable._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_SymLinearVariable._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymLinearVariable.toString()')
  def set_values(self,*args):
    if False: pass
    elif mosek_fusion_SymLinearVariable._match_set_1values__3J_3DZ(*args): # []int64,[]double,bool
      return self._set_1values__3J_3DZ(*args)
    elif mosek_fusion_SymLinearVariable._match_alt_set_1values__3J_3DZ(*args): # []int64,[]double,bool
      return self._set_1values_alt__3J_3DZ(*args)
    elif mosek_fusion_SymLinearVariable._match_set_1values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._set_1values_J_3I_3JI_3DZ(*args)
    elif mosek_fusion_SymLinearVariable._match_alt_set_1values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._set_1values_alt_J_3I_3JI_3DZ(*args)
    else:
      raise ValueError('Invalid argument list set_values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymLinearVariable.set_values(array(int64,ndim=1),array(double,ndim=1),bool)\n\tmosek.fusion.SymLinearVariable.set_values(int64,array(int32,ndim=1),array(int64,ndim=1),int32,array(double,ndim=1),bool)')
  def values(self,*args):
    if False: pass
    elif mosek_fusion_SymLinearVariable._match_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_I_3DZ(*args)
    elif mosek_fusion_SymLinearVariable._match_alt_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_alt_I_3DZ(*args)
    elif mosek_fusion_SymLinearVariable._match_values__3JI_3DZ(*args): # []int64,int32,[]double,bool
      return self._values__3JI_3DZ(*args)
    elif mosek_fusion_SymLinearVariable._match_alt_values__3JI_3DZ(*args): # []int64,int32,[]double,bool
      return self._values_alt__3JI_3DZ(*args)
    elif mosek_fusion_SymLinearVariable._match_values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._values_J_3I_3JI_3DZ(*args)
    elif mosek_fusion_SymLinearVariable._match_alt_values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._values_alt_J_3I_3JI_3DZ(*args)
    else:
      raise ValueError('Invalid argument list values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymLinearVariable.values(int32,array(double,ndim=1),bool)\n\tmosek.fusion.SymLinearVariable.values(array(int64,ndim=1),int32,array(double,ndim=1),bool)\n\tmosek.fusion.SymLinearVariable.values(int64,array(int32,ndim=1),array(int64,ndim=1),int32,array(double,ndim=1),bool)')
  def __repr__(self): return 'mosek.fusion.SymLinearVariable'
  @staticmethod
  def _ctor_Lmosek_4fusion_4SymLinearVariable_2Lmosek_4fusion_4Model_2(v,m):
    o = SymLinearVariable.__new__(SymLinearVariable)
    o._ctor_init_Lmosek_4fusion_4SymLinearVariable_2Lmosek_4fusion_4Model_2(v,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4SymLinearVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_match_Lmosek_4fusion_4SymLinearVariable_2__(v) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4SymLinearVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4SymLinearVariable_2__(v) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4SymLinearVariable_2Lmosek_4fusion_4Model_2(self,v,m):
    self._ctor_init_Lmosek_4fusion_4SymLinearVariable_2Lmosek_4fusion_4Model_2(v,m)
  def _ctor_init_Lmosek_4fusion_4SymLinearVariable_2Lmosek_4fusion_4Model_2(self,v,m):
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(self,v,m)
   self.__nativeidxs = (numpy.array([(v.__nativeidxs)[_0] for _0 in range(0,int(((v.__nativeidxs)).shape[0]))], dtype=numpy.dtype(numpy.int32)) if (((v.__nativeidxs) is not None) ) else None)
   self.__idxmap = ((v.__idxmap)._clone_() if (((v.__idxmap) is not None) ) else None)
   self.__dom = (v.__dom)
   (self.__dim) = (v.__dim)
   self.__names_flushed = (v.__names_flushed)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4SymmetricLinearDomain_2I_3IJ(model,name,dom,dim,nativeidxs,varid):
    o = SymLinearVariable.__new__(SymLinearVariable)
    o._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4SymmetricLinearDomain_2I_3IJ(model,name,dom,dim,nativeidxs,varid)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4SymmetricLinearDomain_2I_3IJ(*args):
    if len(args) != 6: return False
    model,name,dom,dim,nativeidxs,varid, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match_S__(name) and __arg_match_Lmosek_4fusion_4SymmetricLinearDomain_2__(dom) and __arg_match_I__(dim) and __arg_match__3I__(nativeidxs) and __arg_match_J__(varid))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4SymmetricLinearDomain_2I_3IJ(*args):
    if len(args) != 6: return False
    model,name,dom,dim,nativeidxs,varid, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match_S__(name) and __arg_alt_match_Lmosek_4fusion_4SymmetricLinearDomain_2__(dom) and __arg_alt_match_I__(dim) and __arg_alt_match__3I__(nativeidxs) and __arg_alt_match_J__(varid))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4SymmetricLinearDomain_2I_3IJ(self,model,name,dom,dim,nativeidxs,varid):
    self._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4SymmetricLinearDomain_2I_3IJ(model,name,dom,numpy.int32(dim),numpy.array(nativeidxs,dtype=numpy.dtype(numpy.int32)),numpy.int64(varid))
  def _ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4SymmetricLinearDomain_2I_3IJ(self,model,name,dom,dim,nativeidxs,varid):
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2J(self,model,name,mosek.fusion.Set._make_II(dim,dim),varid)
   (self.__nativeidxs) = nativeidxs
   self.__idxmap = (mosek.fusion.Utils.IntMap() if (((self.__nativeidxs) is None) ) else None)
   (self.__dom) = dom
   (self.__dim) = dim
   self.__names_flushed = False
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("SymLinearVariable( (")
   if (int(len(self._name)) > 0):
    _0._a_S("'")._a_S(self._name)._a_S("',")
   _0._a_I(self._shape_p._dim_I(0))
   for _1 in range(1,(self._shape_p.nd)):
    _0._a_S(",")._a_I(self._shape_p._dim_I(_1))
   _0._a_S(") )")
   return (_0._toString_())
  def _flushNames_alt_(self,):
    return self._flushNames_()
  def _flushNames_(self,):
   if ((not self.__names_flushed) and (int(len(self._name)) > 0)):
    if (self.__nativeidxs is not None):
     for _0 in range(0,self.__dim):
      for _1 in range(0,(_0 + 1)):
       _2=(((_0 * self.__dim) - ((_0 * (_0 + 1)) // 2)) + _1)
       _3=((_0 * self.__dim) + _1)
       self._model._varname_IS(self.__nativeidxs[_2],("" if ((int(len(self._name))==0) ) else mosek.fusion.Utils.StringBuffer()._a_S(self._name)._a_S("[")._a_S(self._shape_p._getname_J(_3))._a_S("]")._toString_()))
    else:
     for _4 in range(0,self.__dim):
      for _5 in range(0,(_4 + 1)):
       _6=((_4 * self.__dim) + _5)
       if self.__idxmap._hasItem_J(_6):
        self._model._varname_IS(self.__nativeidxs[self.__idxmap._getItem_J(_6)],("" if ((int(len(self._name))==0) ) else mosek.fusion.Utils.StringBuffer()._a_S(self._name)._a_S("[")._a_S(self._shape_p._getname_J(_6))._a_S("]")._toString_()))
    self.__names_flushed = True
  @staticmethod
  def _match_inst__3JIIJJ_3I_3I_3I(*args):
    if len(args) != 8: return False
    _0,_1,_2,_3,_4,_5,_6,_7, = args
    return (__arg_match__3J__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4) and __arg_match__3I__(_5) and __arg_match__3I__(_6) and __arg_match__3I__(_7))
  @staticmethod
  def _match_alt_inst__3JIIJJ_3I_3I_3I(*args):
    if len(args) != 8: return False
    _0,_1,_2,_3,_4,_5,_6,_7, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4) and __arg_alt_match__3I__(_5) and __arg_alt_match__3I__(_6) and __arg_alt_match__3I__(_7))
  def _inst_alt__3JIIJJ_3I_3I_3I(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.int32(_t__2)
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.int32))
   _6=numpy.array(_t__6,dtype=numpy.dtype(numpy.int32))
   _7=numpy.array(_t__7,dtype=numpy.dtype(numpy.int32))
   _1 = self._inst__3JIIJJ_3I_3I_3I(_0,_1,_2,_3,_4,_5,_6,_7)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__6[:] = _6
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__7[:] = _7
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst__3JIIJJ_3I_3I_3I(self,_0,_1,_2,_3,_4,_5,_6,_7):
   if (self.__nativeidxs is not None):
    for _8 in range(_1,_2):
     _5[((_4 + _8) - _1)] = self.__nativeidxs[self.__tril_1lin_1idx_J((_0[_8] - _3))]
   else:
    for _9 in range(_1,_2):
     _10=self.__tril_1lin_1idx_J((_0[_9] - _3))
     _11=self.__tril_1idx_J((_0[_9] - _3))
     if (not self.__idxmap._hasItem_J(_11)):
      _12=self._model._append_1linearvar_Lmosek_4fusion_4ModelVariable_2JEmosek_4fusion_4RelationKey_2D(self,_11,(self.__dom._key),self.__dom._get_1rhs_1item_J(_10))
      self.__idxmap._setItem_JI(_11,_12)
      _5[((_4 + _9) - _1)] = _12
      self.__names_flushed = False
     else:
      _5[((_4 + _9) - _1)] = self.__idxmap._getItem_J(_11)
  @staticmethod
  def _match_inst_JJ_3I_3I_3I(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match_J__(_0) and __arg_match_J__(_1) and __arg_match__3I__(_2) and __arg_match__3I__(_3) and __arg_match__3I__(_4))
  @staticmethod
  def _match_alt_inst_JJ_3I_3I_3I(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_J__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match__3I__(_3) and __arg_alt_match__3I__(_4))
  def _inst_alt_JJ_3I_3I_3I(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.int64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int32))
   _1 = self._inst_JJ_3I_3I_3I(_0,_1,_2,_3,_4)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst_JJ_3I_3I_3I(self,_0,_1,_2,_3,_4):
   _5=self.__tril_1lin_1idx_J(_0)
   _6=self.__tril_1idx_J(_0)
   if (self.__nativeidxs is not None):
    _2[_1] = self.__nativeidxs[_5]
   else:
    if (not self.__idxmap._hasItem_J(_6)):
     _7=self._model._append_1linearvar_Lmosek_4fusion_4ModelVariable_2JEmosek_4fusion_4RelationKey_2D(self,_6,(self.__dom._key),self.__dom._get_1rhs_1item_J(_6))
     self.__idxmap._setItem_JI(_5,_7)
     _2[_1] = _7
    else:
     _2[_1] = self.__idxmap._getItem_J(_5)
  def __dual_1values_alt_J_3I_3JI_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = self.__dual_1values_J_3I_3JI_3D(_0,_1,_2,_3,_4)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __dual_1values_J_3I_3JI_3D(self,_0,_1,_2,_3,_4):
   _5=1
   _6=int((_2).shape[0])
   _7=mosek_fusion_IndexCounter._ctor_J_3I_3J(_0,_1,_2)
   _8=self._model._getSolution_1slx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _9=self._model._getSolution_1sux_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _5 = fragments._c_closure_134(_6,_1,_5) # src/fusion/SymLinearVariable.monty:350:9-51
   _5 = numpy.int64(_5) # postprocess
   if (self.__nativeidxs is not None):
    for _10 in range(0,_5):
     _11=self.__nativeidxs[self.__tril_1lin_1idx_J(_7._get_())]
     _4[(_10 + _3)] = (_8[_11] - _9[_11])
     _7._inc_()
   else:
    _12=self._model._getPrimalSolutionStatus_()
    for _13 in range(0,numpy.int32(_5)):
     if self.__idxmap._hasItem_J(self.__tril_1lin_1idx_J(_7._get_())):
      _14=self.__idxmap._getItem_J(_7._get_())
      _4[(_3 + _13)] = (_8[_14] - _9[_14])
     else:
      _4[(_3 + _13)] = 0.0
     _7._inc_()
  def __dual_1values_alt__3JI_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self.__dual_1values__3JI_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __dual_1values__3JI_3D(self,_0,_1,_2):
   _3=self._model._getSolution_1slx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _4=self._model._getSolution_1sux_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   if (self.__nativeidxs is not None):
    for _5 in range(0,int((_0).shape[0])):
     _6=self.__nativeidxs[self.__tril_1lin_1idx_J(_0[_5])]
     _2[(_1 + _5)] = (_3[_6] - _4[_6])
   else:
    _7=self._model._getPrimalSolutionStatus_()
    for _8 in range(0,int((_0).shape[0])):
     if self.__idxmap._hasItem_J(_0[_8]):
      _9=self.__idxmap._getItem_J(_0[_8])
      _2[(_1 + _8)] = (_3[_9] - _4[_9])
     else:
      _2[(_1 + _8)] = 0.0
  @staticmethod
  def _match_set_1values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match_J__(_0) and __arg_match__3I__(_1) and __arg_match__3J__(_2) and __arg_match_I__(_3) and __arg_match__3D__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_set_1values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match__3D__(_4) and __arg_alt_match_Z__(_5))
  def _set_1values_alt_J_3I_3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = self._set_1values_J_3I_3JI_3DZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values_J_3I_3JI_3DZ(self,_0,_1,_2,_3,_4,_5):
   if _5:
    _6=1
    _7=int((_2).shape[0])
    _8=mosek_fusion_IndexCounter._ctor_J_3I_3J(_0,_1,_2)
    _6 = fragments._c_closure_135(_7,_1,_6) # src/fusion/SymLinearVariable.monty:271:11-53
    _6 = numpy.int64(_6) # postprocess
    if (self.__nativeidxs is not None):
     _9=int((self.__nativeidxs).shape[0])
     _10=numpy.array([self.__nativeidxs[self.__tril_1lin_1idx_J(_8._next_())] for _11 in range(0,_6)], dtype=numpy.dtype(numpy.int32))
     _12=(numpy.array([_4[(_3 + _13)] for _13 in range(0,_9)], dtype=numpy.dtype(numpy.float64)) if ((_3 > 0) ) else _4)
     self._model._setSolution_1xx__3I_3D(_10,_12)
    else:
     _14=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int32))
     for _15 in range(0,_6):
      self._inst_JJ_3I_3I_3I(_8._next_(),_15,_14,None,None)
     _16=numpy.array([_4[(_3 + _17)] for _17 in range(0,_6)], dtype=numpy.dtype(numpy.float64))
     self._model._setSolution_1xx__3I_3D(_14,_16)
   else:
    pass
  @staticmethod
  def _match_set_1values__3J_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3J__(_0) and __arg_match__3D__(_1) and __arg_match_Z__(_2))
  @staticmethod
  def _match_alt_set_1values__3J_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3D__(_1) and __arg_alt_match_Z__(_2))
  def _set_1values_alt__3J_3DZ(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=_t__2
   _1 = self._set_1values__3J_3DZ(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values__3J_3DZ(self,_0,_1,_2):
   if _2:
    if (self.__nativeidxs is not None):
     _3=int((self.__nativeidxs).shape[0])
     _4=numpy.array([self.__nativeidxs[self.__tril_1lin_1idx_J(_0[_5])] for _5 in range(0,_3)], dtype=numpy.dtype(numpy.int32))
     _6=numpy.array([_1[_7] for _7 in range(0,_3)], dtype=numpy.dtype(numpy.float64))
     self._model._setSolution_1xx__3I_3D(_4,_6)
    else:
     _8=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int32))
     for _9 in range(0,int((_0).shape[0])):
      self._inst_JJ_3I_3I_3I(_0[_9],_9,_8,None,None)
     self._model._setSolution_1xx__3I_3D(_8,_1)
   else:
    pass
  @staticmethod
  def _match_values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match_J__(_0) and __arg_match__3I__(_1) and __arg_match__3J__(_2) and __arg_match_I__(_3) and __arg_match__3D__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match__3D__(_4) and __arg_alt_match_Z__(_5))
  def _values_alt_J_3I_3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = self._values_J_3I_3JI_3DZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values_J_3I_3JI_3DZ(self,_0,_1,_2,_3,_4,_5):
   if _5:
    _6=1
    _7=int((_2).shape[0])
    _8=mosek_fusion_IndexCounter._ctor_J_3I_3J(_0,_1,_2)
    _9=self._model._getSolution_1xx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
    _6 = fragments._c_closure_136(_7,_1,_6) # src/fusion/SymLinearVariable.monty:182:11-47
    _6 = numpy.int64(_6) # postprocess
    if (self.__nativeidxs is not None):
     for _10 in range(0,_6):
      _4[(_10 + _3)] = _9[self.__nativeidxs[self.__tril_1lin_1idx_J(_8._get_())]]
      _8._inc_()
    else:
     _11=self._model._getPrimalSolutionStatus_()
     if ((_11==mosek.fusion.SolutionStatus.Optimal) or ((_11==mosek.fusion.SolutionStatus.NearOptimal) or ((_11==mosek.fusion.SolutionStatus.Feasible) or (_11==mosek.fusion.SolutionStatus.NearFeasible)))):
      for _12 in range(0,numpy.int32(_6)):
       if self.__idxmap._hasItem_J(_8._get_()):
        _4[(_3 + _12)] = _9[self.__idxmap._getItem_J(_8._get_())]
       else:
        _4[(_3 + _12)] = self.__dom._get_1rhs_1item_J(self.__tril_1idx_J(_8._get_()))
       _8._inc_()
     else:
      for _13 in range(0,numpy.int32(_6)):
       if self.__idxmap._hasItem_J(_8._get_()):
        _4[(_3 + _13)] = _9[self.__idxmap._getItem_J(_8._get_())]
       else:
        _4[(_3 + _13)] = 0.0
       _8._inc_()
   else:
    self.__dual_1values_J_3I_3JI_3D(_0,_1,_2,_3,_4)
  @staticmethod
  def _match_values__3JI_3DZ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match__3J__(_0) and __arg_match_I__(_1) and __arg_match__3D__(_2) and __arg_match_Z__(_3))
  @staticmethod
  def _match_alt_values__3JI_3DZ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match_Z__(_3))
  def _values_alt__3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=_t__3
   _1 = self._values__3JI_3DZ(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values__3JI_3DZ(self,_0,_1,_2,_3):
   if _3:
    _4=self._model._getSolution_1xx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
    if (self.__nativeidxs is not None):
     for _5 in range(0,int((_0).shape[0])):
      _2[(_1 + _5)] = _4[self.__nativeidxs[self.__tril_1lin_1idx_J(_0[_5])]]
    else:
     _6=self._model._getPrimalSolutionStatus_()
     if ((_6==mosek.fusion.SolutionStatus.Optimal) or ((_6==mosek.fusion.SolutionStatus.NearOptimal) or ((_6==mosek.fusion.SolutionStatus.Feasible) or (_6==mosek.fusion.SolutionStatus.NearFeasible)))):
      for _7 in range(0,int((_0).shape[0])):
       _8=_0[_7]
       if self.__idxmap._hasItem_J(_8):
        _2[(_1 + _7)] = _4[self.__idxmap._getItem_J(_8)]
       else:
        _2[(_1 + _7)] = self.__dom._get_1rhs_1item_J(self.__tril_1idx_J(_8))
     else:
      for _9 in range(0,int((_0).shape[0])):
       _10=_0[_9]
       if self.__idxmap._hasItem_J(_10):
        _2[(_1 + _9)] = _4[self.__idxmap._getItem_J(self.__tril_1idx_J(_10))]
       else:
        _2[(_1 + _9)] = 0.0
   else:
    self.__dual_1values__3JI_3D(_0,_1,_2)
  @staticmethod
  def _match_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3J__(_0))
  @staticmethod
  def _match_alt_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3J__(_0))
  def _make_1continuous_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1continuous__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1continuous__3J(self,_0):
   if (self.__nativeidxs is not None):
    self._getModel_()._task_1var_1putcontlist__3I(numpy.array([self.__nativeidxs[_0[_1]] for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32)))
   else:
    _2=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int32))
    self._inst__3JIIJJ_3I_3I_3I(_0,0,int((_0).shape[0]),0,0,_2,None,None)
    self._getModel_()._task_1var_1putcontlist__3I(_2)
  @staticmethod
  def _match_make_1integer__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3J__(_0))
  @staticmethod
  def _match_alt_make_1integer__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3J__(_0))
  def _make_1integer_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1integer__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1integer__3J(self,_0):
   if (self.__nativeidxs is not None):
    self._getModel_()._task_1var_1putintlist__3I(numpy.array([self.__nativeidxs[_0[_1]] for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32)))
   else:
    _2=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int32))
    self._inst__3JIIJJ_3I_3I_3I(_0,0,int((_0).shape[0]),0,0,_2,None,None)
    self._getModel_()._task_1var_1putintlist__3I(_2)
  def __tril_1idx_alt_J(self,_t__0):
    return self.__tril_1idx_J(numpy.int64(__0))
  def __tril_1idx_J(self,_0):
   _1=(_0 // self.__dim)
   _2=(_0 % self.__dim)
   if (_2 > _1):
    return numpy.int64(((_2 * self.__dim) + _1))
   else:
    return numpy.int64(_0)
  def __tril_1lin_1idx_alt_J(self,_t__0):
    return self.__tril_1lin_1idx_J(numpy.int64(__0))
  def __tril_1lin_1idx_J(self,_0):
   _1=(_0 // self.__dim)
   _2=(_0 % self.__dim)
   if (_2 > _1):
    return numpy.int64((((_2 * (_2 + 1)) // 2) + _1))
   else:
    return numpy.int64((((_1 * (_1 + 1)) // 2) + _2))
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   return (mosek_fusion_SymLinearVariable._ctor_Lmosek_4fusion_4SymLinearVariable_2Lmosek_4fusion_4Model_2(self,_0))
 return SymLinearVariable
mosek_fusion_SymLinearVariable=__mk_mosek_fusion_SymLinearVariable()
del __mk_mosek_fusion_SymLinearVariable
#BEFORE CLASS
def __mk_mosek_fusion_LinearVariable():
 class LinearVariable(mosek_fusion_ModelVariable):
  __slots__ = ['_LinearVariable__names_flushed','_LinearVariable__dom','_LinearVariable__nativeidxs','_LinearVariable__idxmap']
  def inst(self,*args):
    if False: pass
    elif mosek_fusion_LinearVariable._match_inst_JJ_3I_3I_3I(*args): # int64,int64,[]int32,[]int32,[]int32
      return self._inst_JJ_3I_3I_3I(*args)
    elif mosek_fusion_LinearVariable._match_alt_inst_JJ_3I_3I_3I(*args): # int64,int64,[]int32,[]int32,[]int32
      return self._inst_alt_JJ_3I_3I_3I(*args)
    elif mosek_fusion_LinearVariable._match_inst__3JIIJJ_3I_3I_3I(*args): # []int64,int32,int32,int64,int64,[]int32,[]int32,[]int32
      return self._inst__3JIIJJ_3I_3I_3I(*args)
    elif mosek_fusion_LinearVariable._match_alt_inst__3JIIJJ_3I_3I_3I(*args): # []int64,int32,int32,int64,int64,[]int32,[]int32,[]int32
      return self._inst_alt__3JIIJJ_3I_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list inst('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearVariable.inst(int64,int64,array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.LinearVariable.inst(array(int64,ndim=1),int32,int32,int64,int64,array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))')
  def elementDesc(self,*args):
    if False: pass
    elif mosek_fusion_LinearVariable._match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_LinearVariable._match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementDesc('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearVariable.elementDesc(int64,mosek.fusion.Utils.StringBuffer)')
  def make_integer(self,*args):
    if False: pass
    elif mosek_fusion_LinearVariable._match_make_1integer__3J(*args): # []int64
      return self._make_1integer__3J(*args)
    elif mosek_fusion_LinearVariable._match_alt_make_1integer__3J(*args): # []int64
      return self._make_1integer_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_integer('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearVariable.make_integer(array(int64,ndim=1))')
  def values(self,*args):
    if False: pass
    elif mosek_fusion_LinearVariable._match_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_I_3DZ(*args)
    elif mosek_fusion_LinearVariable._match_alt_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_alt_I_3DZ(*args)
    elif mosek_fusion_LinearVariable._match_values__3JI_3DZ(*args): # []int64,int32,[]double,bool
      return self._values__3JI_3DZ(*args)
    elif mosek_fusion_LinearVariable._match_alt_values__3JI_3DZ(*args): # []int64,int32,[]double,bool
      return self._values_alt__3JI_3DZ(*args)
    elif mosek_fusion_LinearVariable._match_values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._values_J_3I_3JI_3DZ(*args)
    elif mosek_fusion_LinearVariable._match_alt_values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._values_alt_J_3I_3JI_3DZ(*args)
    else:
      raise ValueError('Invalid argument list values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearVariable.values(int32,array(double,ndim=1),bool)\n\tmosek.fusion.LinearVariable.values(array(int64,ndim=1),int32,array(double,ndim=1),bool)\n\tmosek.fusion.LinearVariable.values(int64,array(int32,ndim=1),array(int64,ndim=1),int32,array(double,ndim=1),bool)')
  def elementName(self,*args):
    if False: pass
    elif mosek_fusion_LinearVariable._match_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_LinearVariable._match_alt_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementName_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementName('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearVariable.elementName(int64,mosek.fusion.Utils.StringBuffer)')
  def make_continuous(self,*args):
    if False: pass
    elif mosek_fusion_LinearVariable._match_make_1continuous__3J(*args): # []int64
      return self._make_1continuous__3J(*args)
    elif mosek_fusion_LinearVariable._match_alt_make_1continuous__3J(*args): # []int64
      return self._make_1continuous_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_continuous('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearVariable.make_continuous(array(int64,ndim=1))')
  def set_values(self,*args):
    if False: pass
    elif mosek_fusion_LinearVariable._match_set_1values__3J_3DZ(*args): # []int64,[]double,bool
      return self._set_1values__3J_3DZ(*args)
    elif mosek_fusion_LinearVariable._match_alt_set_1values__3J_3DZ(*args): # []int64,[]double,bool
      return self._set_1values_alt__3J_3DZ(*args)
    elif mosek_fusion_LinearVariable._match_set_1values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._set_1values_J_3I_3JI_3DZ(*args)
    elif mosek_fusion_LinearVariable._match_alt_set_1values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._set_1values_alt_J_3I_3JI_3DZ(*args)
    else:
      raise ValueError('Invalid argument list set_values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearVariable.set_values(array(int64,ndim=1),array(double,ndim=1),bool)\n\tmosek.fusion.LinearVariable.set_values(int64,array(int32,ndim=1),array(int64,ndim=1),int32,array(double,ndim=1),bool)')
  def __repr__(self): return 'mosek.fusion.LinearVariable'
  @staticmethod
  def _ctor_Lmosek_4fusion_4LinearVariable_2Lmosek_4fusion_4Model_2(v,m):
    o = LinearVariable.__new__(LinearVariable)
    o._ctor_init_Lmosek_4fusion_4LinearVariable_2Lmosek_4fusion_4Model_2(v,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4LinearVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_match_Lmosek_4fusion_4LinearVariable_2__(v) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4LinearVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinearVariable_2__(v) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4LinearVariable_2Lmosek_4fusion_4Model_2(self,v,m):
    self._ctor_init_Lmosek_4fusion_4LinearVariable_2Lmosek_4fusion_4Model_2(v,m)
  def _ctor_init_Lmosek_4fusion_4LinearVariable_2Lmosek_4fusion_4Model_2(self,v,m):
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(self,v,m)
   self.__nativeidxs = (numpy.array([(v.__nativeidxs)[_0] for _0 in range(0,int(((v.__nativeidxs)).shape[0]))], dtype=numpy.dtype(numpy.int32)) if (((v.__nativeidxs) is not None) ) else None)
   self.__idxmap = ((v.__idxmap)._clone_() if (((v.__idxmap) is not None) ) else None)
   self.__dom = (v.__dom)
   self.__names_flushed = (v.__names_flushed)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4LinearDomain_2Lmosek_4fusion_4Set_2_3IJ(model_,name_,dom_,shape_p,nativeidxs_,varid_):
    o = LinearVariable.__new__(LinearVariable)
    o._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4LinearDomain_2Lmosek_4fusion_4Set_2_3IJ(model_,name_,dom_,shape_p,nativeidxs_,varid_)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4LinearDomain_2Lmosek_4fusion_4Set_2_3IJ(*args):
    if len(args) != 6: return False
    model_,name_,dom_,shape_p,nativeidxs_,varid_, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model_) and __arg_match_S__(name_) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(dom_) and __arg_match_Lmosek_4fusion_4Set_2__(shape_p) and __arg_match__3I__(nativeidxs_) and __arg_match_J__(varid_))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4LinearDomain_2Lmosek_4fusion_4Set_2_3IJ(*args):
    if len(args) != 6: return False
    model_,name_,dom_,shape_p,nativeidxs_,varid_, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model_) and __arg_alt_match_S__(name_) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(dom_) and __arg_alt_match_Lmosek_4fusion_4Set_2__(shape_p) and __arg_alt_match__3I__(nativeidxs_) and __arg_alt_match_J__(varid_))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4LinearDomain_2Lmosek_4fusion_4Set_2_3IJ(self,model_,name_,dom_,shape_p,nativeidxs_,varid_):
    self._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4LinearDomain_2Lmosek_4fusion_4Set_2_3IJ(model_,name_,dom_,shape_p,numpy.array(nativeidxs_,dtype=numpy.dtype(numpy.int32)),numpy.int64(varid_))
  def _ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4LinearDomain_2Lmosek_4fusion_4Set_2_3IJ(self,model_,name_,dom_,shape_p,nativeidxs_,varid_):
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2J(self,model_,name_,shape_p,varid_)
   self.__nativeidxs = nativeidxs_
   if (nativeidxs_ is None):
    self.__idxmap = mosek.fusion.Utils.IntMap()
   else:
    self.__idxmap = None
   self.__dom = dom_
   self.__names_flushed = False
  @staticmethod
  def _match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_J__(_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  @staticmethod
  def _match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  def _elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(_0,_1)
   self.__dom._domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(_0,_1)
   return (_1)
  @staticmethod
  def _match_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_J__(_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  @staticmethod
  def _match_alt_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  def _elementName_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   _1._a_S(("_" if ((int(len(self._name))==0) ) else self._name))._a_S("[")._a_S(self._shape_p._indexToString_J(_0))._a_S("] ")
  def _flushNames_alt_(self,):
    return self._flushNames_()
  def _flushNames_(self,):
   if ((not self.__names_flushed) and (int(len(self._name)) > 0)):
    if (self.__nativeidxs is not None):
     for _0 in range(0,int((self.__nativeidxs).shape[0])):
      self._model._varname_IS(self.__nativeidxs[_0],("" if ((int(len(self._name))==0) ) else mosek.fusion.Utils.StringBuffer()._a_S(self._name)._a_S("[")._a_S(self._shape_p._getname_J(_0))._a_S("]")._toString_()))
    else:
     _1=self.__idxmap._keys_()
     _2=self.__idxmap._values_()
     for _3 in range(0,int((_1).shape[0])):
      self._model._varname_IS(_2[_3],mosek.fusion.Utils.StringBuffer()._a_S(self._name)._a_S("[")._a_S(self._shape_p._getname_J(_1[_3]))._a_S("]")._toString_())
    self.__names_flushed = True
  @staticmethod
  def _match_inst__3JIIJJ_3I_3I_3I(*args):
    if len(args) != 8: return False
    _0,_1,_2,_3,_4,_5,_6,_7, = args
    return (__arg_match__3J__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4) and __arg_match__3I__(_5) and __arg_match__3I__(_6) and __arg_match__3I__(_7))
  @staticmethod
  def _match_alt_inst__3JIIJJ_3I_3I_3I(*args):
    if len(args) != 8: return False
    _0,_1,_2,_3,_4,_5,_6,_7, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4) and __arg_alt_match__3I__(_5) and __arg_alt_match__3I__(_6) and __arg_alt_match__3I__(_7))
  def _inst_alt__3JIIJJ_3I_3I_3I(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.int32(_t__2)
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.int32))
   _6=numpy.array(_t__6,dtype=numpy.dtype(numpy.int32))
   _7=numpy.array(_t__7,dtype=numpy.dtype(numpy.int32))
   _1 = self._inst__3JIIJJ_3I_3I_3I(_0,_1,_2,_3,_4,_5,_6,_7)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__6[:] = _6
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__7[:] = _7
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst__3JIIJJ_3I_3I_3I(self,_0,_1,_2,_3,_4,_5,_6,_7):
   if (self.__nativeidxs is not None):
    fragments._c_closure_137(_5,_4,_1,_0,_3,_2,self.__nativeidxs) # src/fusion/LinearVariable.mbi:387:9-390:10
   else:
    for _8 in range(_1,_2):
     if (not self.__idxmap._hasItem_J(_0[(numpy.int64(_8) - _3)])):
      _9=self._model._append_1linearvar_Lmosek_4fusion_4ModelVariable_2JEmosek_4fusion_4RelationKey_2D(self,_0[(numpy.int64(_8) - _3)],(self.__dom._key),self.__dom._get_1rhs_1item_J(_0[(numpy.int64(_8) - _3)]))
      self.__idxmap._setItem_JI(_0[(_8 - _3)],_9)
      _5[((_4 + _8) - _1)] = _9
      self.__names_flushed = False
     else:
      _5[((_4 + _8) - _1)] = self.__idxmap._getItem_J(_0[(numpy.int64(_8) - _3)])
  @staticmethod
  def _match_inst_JJ_3I_3I_3I(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match_J__(_0) and __arg_match_J__(_1) and __arg_match__3I__(_2) and __arg_match__3I__(_3) and __arg_match__3I__(_4))
  @staticmethod
  def _match_alt_inst_JJ_3I_3I_3I(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_J__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match__3I__(_3) and __arg_alt_match__3I__(_4))
  def _inst_alt_JJ_3I_3I_3I(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.int64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int32))
   _1 = self._inst_JJ_3I_3I_3I(_0,_1,_2,_3,_4)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst_JJ_3I_3I_3I(self,_0,_1,_2,_3,_4):
   if (self.__nativeidxs is not None):
    _2[_1] = self.__nativeidxs[_0]
   else:
    if (not self.__idxmap._hasItem_J(_0)):
     _5=self._model._append_1linearvar_Lmosek_4fusion_4ModelVariable_2JEmosek_4fusion_4RelationKey_2D(self,_0,(self.__dom._key),self.__dom._get_1rhs_1item_J(_0))
     self.__idxmap._setItem_JI(_0,_5)
     _2[_1] = _5
    else:
     _2[_1] = self.__idxmap._getItem_J(_0)
  def __dual_1values_alt_J_3I_3JI_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = self.__dual_1values_J_3I_3JI_3D(_0,_1,_2,_3,_4)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __dual_1values_J_3I_3JI_3D(self,_0,_1,_2,_3,_4):
   _5=1
   _6=int((_2).shape[0])
   _7=mosek_fusion_IndexCounter._ctor_J_3I_3J(_0,_1,_2)
   _8=self._model._getSolution_1slx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _9=self._model._getSolution_1sux_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _5 = fragments._c_closure_138(_6,_1,_5) # src/fusion/LinearVariable.mbi:312:9-51
   _5 = numpy.int64(_5) # postprocess
   if (self.__nativeidxs is not None):
    for _10 in range(0,_5):
     _11=self.__nativeidxs[_7._get_()]
     _4[(_10 + _3)] = (_8[_11] - _9[_11])
     _7._inc_()
   else:
    _12=self._model._getPrimalSolutionStatus_()
    for _13 in range(0,numpy.int32(_5)):
     if self.__idxmap._hasItem_J(_7._get_()):
      _14=self.__idxmap._getItem_J(_7._get_())
      _4[(_3 + _13)] = (_8[_14] - _9[_14])
     else:
      if ((_12==mosek.fusion.SolutionStatus.Optimal) or ((_12==mosek.fusion.SolutionStatus.NearOptimal) or ((_12==mosek.fusion.SolutionStatus.Feasible) or (_12==mosek.fusion.SolutionStatus.NearFeasible)))):
       _4[(_3 + _13)] = self.__dom._get_1rhs_1item_J(_7._get_())
      else:
       _4[(_3 + _13)] = 0.0
     _7._inc_()
  def __dual_1values_alt__3JI_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self.__dual_1values__3JI_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __dual_1values__3JI_3D(self,_0,_1,_2):
   _3=self._model._getSolution_1slx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _4=self._model._getSolution_1sux_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   if (self.__nativeidxs is not None):
    fragments._c_closure_139(_0,self.__nativeidxs,_1,_3,_4,_2) # src/fusion/LinearVariable.mbi:270:11-274:12
   else:
    _5=self._model._getPrimalSolutionStatus_()
    for _6 in range(0,int((_0).shape[0])):
     if self.__idxmap._hasItem_J(_0[_6]):
      _7=self.__idxmap._getItem_J(_0[_6])
      _2[(_1 + _6)] = (_3[_7] - _4[_7])
     else:
      if ((_5==mosek.fusion.SolutionStatus.Optimal) or ((_5==mosek.fusion.SolutionStatus.NearOptimal) or ((_5==mosek.fusion.SolutionStatus.Feasible) or (_5==mosek.fusion.SolutionStatus.NearFeasible)))):
       _2[(_1 + _6)] = self.__dom._get_1rhs_1item_J(_0[_6])
      else:
       _2[(_1 + _6)] = 0.0
  @staticmethod
  def _match_set_1values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match_J__(_0) and __arg_match__3I__(_1) and __arg_match__3J__(_2) and __arg_match_I__(_3) and __arg_match__3D__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_set_1values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match__3D__(_4) and __arg_alt_match_Z__(_5))
  def _set_1values_alt_J_3I_3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = self._set_1values_J_3I_3JI_3DZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values_J_3I_3JI_3DZ(self,_0,_1,_2,_3,_4,_5):
   if _5:
    _6=1
    _7=int((_2).shape[0])
    _8=mosek_fusion_IndexCounter._ctor_J_3I_3J(_0,_1,_2)
    _6 = fragments._c_closure_140(_7,_1,_6) # src/fusion/LinearVariable.mbi:229:11-53
    _6 = numpy.int64(_6) # postprocess
    if (self.__nativeidxs is not None):
     _9=int((self.__nativeidxs).shape[0])
     _10=numpy.array([self.__nativeidxs[_8._next_()] for _11 in range(0,_6)], dtype=numpy.dtype(numpy.int32))
     _12=(numpy.array([_4[_13] for _13 in range(0,_9)], dtype=numpy.dtype(numpy.float64)) if ((_3 > 0) ) else _4)
     self._model._setSolution_1xx__3I_3D(_10,_12)
    else:
     _14=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int32))
     for _15 in range(0,_6):
      self._inst_JJ_3I_3I_3I(_8._next_(),_15,_14,None,None)
     _16=numpy.array([_4[(_3 + _17)] for _17 in range(0,_6)], dtype=numpy.dtype(numpy.float64))
     self._model._setSolution_1xx__3I_3D(_14,_16)
   else:
    pass
  @staticmethod
  def _match_set_1values__3J_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3J__(_0) and __arg_match__3D__(_1) and __arg_match_Z__(_2))
  @staticmethod
  def _match_alt_set_1values__3J_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3D__(_1) and __arg_alt_match_Z__(_2))
  def _set_1values_alt__3J_3DZ(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=_t__2
   _1 = self._set_1values__3J_3DZ(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values__3J_3DZ(self,_0,_1,_2):
   if _2:
    if (self.__nativeidxs is not None):
     _3=int((self.__nativeidxs).shape[0])
     _4=numpy.array([self.__nativeidxs[_0[_5]] for _5 in range(0,_3)], dtype=numpy.dtype(numpy.int32))
     _6=numpy.array([_1[_7] for _7 in range(0,_3)], dtype=numpy.dtype(numpy.float64))
     self._model._setSolution_1xx__3I_3D(_4,_6)
    else:
     _8=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int32))
     for _9 in range(0,int((_0).shape[0])):
      self._inst_JJ_3I_3I_3I(_0[_9],_9,_8,None,None)
     _10=numpy.array([_1[_11] for _11 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.float64))
     self._model._setSolution_1xx__3I_3D(_8,_10)
   else:
    pass
  @staticmethod
  def _match_values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match_J__(_0) and __arg_match__3I__(_1) and __arg_match__3J__(_2) and __arg_match_I__(_3) and __arg_match__3D__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match__3D__(_4) and __arg_alt_match_Z__(_5))
  def _values_alt_J_3I_3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = self._values_J_3I_3JI_3DZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values_J_3I_3JI_3DZ(self,_0,_1,_2,_3,_4,_5):
   if (not _5):
    self.__dual_1values_J_3I_3JI_3D(_0,_1,_2,_3,_4)
   else:
    _6=1
    _7=int((_2).shape[0])
    _8=mosek_fusion_IndexCounter._ctor_J_3I_3J(_0,_1,_2)
    _9=self._model._getSolution_1xx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
    _6 = fragments._c_closure_141(_7,_1,_6) # src/fusion/LinearVariable.mbi:149:11-53
    _6 = numpy.int64(_6) # postprocess
    if (self.__nativeidxs is not None):
     for _10 in range(0,_6):
      _4[(_10 + _3)] = _9[self.__nativeidxs[_8._get_()]]
      _8._inc_()
    else:
     _11=self._model._getPrimalSolutionStatus_()
     for _12 in range(0,numpy.int32(_6)):
      if self.__idxmap._hasItem_J(_8._get_()):
       _4[(_3 + _12)] = _9[self.__idxmap._getItem_J(_8._get_())]
      else:
       if ((_11==mosek.fusion.SolutionStatus.Optimal) or ((_11==mosek.fusion.SolutionStatus.NearOptimal) or ((_11==mosek.fusion.SolutionStatus.Feasible) or (_11==mosek.fusion.SolutionStatus.NearFeasible)))):
        _4[(_3 + _12)] = self.__dom._get_1rhs_1item_J(_8._get_())
       else:
        _4[(_3 + _12)] = 0.0
      _8._inc_()
  @staticmethod
  def _match_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3J__(_0))
  @staticmethod
  def _match_alt_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3J__(_0))
  def _make_1continuous_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1continuous__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1continuous__3J(self,_0):
   if (self.__nativeidxs is not None):
    self._getModel_()._task_1var_1putcontlist__3I(numpy.array([self.__nativeidxs[_0[_1]] for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32)))
   else:
    _2=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int32))
    self._inst__3JIIJJ_3I_3I_3I(_0,0,int((_0).shape[0]),0,0,_2,None,None)
    self._getModel_()._task_1var_1putcontlist__3I(_2)
  @staticmethod
  def _match_make_1integer__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3J__(_0))
  @staticmethod
  def _match_alt_make_1integer__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3J__(_0))
  def _make_1integer_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1integer__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1integer__3J(self,_0):
   if (self.__nativeidxs is not None):
    self._getModel_()._task_1var_1putintlist__3I(numpy.array([self.__nativeidxs[_0[_1]] for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32)))
   else:
    _2=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int32))
    self._inst__3JIIJJ_3I_3I_3I(_0,0,int((_0).shape[0]),0,0,_2,None,None)
    self._getModel_()._task_1var_1putintlist__3I(_2)
  @staticmethod
  def _match_values__3JI_3DZ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match__3J__(_0) and __arg_match_I__(_1) and __arg_match__3D__(_2) and __arg_match_Z__(_3))
  @staticmethod
  def _match_alt_values__3JI_3DZ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match_Z__(_3))
  def _values_alt__3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=_t__3
   _1 = self._values__3JI_3DZ(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values__3JI_3DZ(self,_0,_1,_2,_3):
   if (not _3):
    self.__dual_1values__3JI_3D(_0,_1,_2)
   else:
    _4=self._model._getSolution_1xx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
    if (self.__nativeidxs is not None):
     fragments._c_closure_142(_0,self.__nativeidxs,_1,_2,_4) # src/fusion/LinearVariable.mbi:85:13-86:58
    else:
     _5=self._model._getPrimalSolutionStatus_()
     for _6 in range(0,int((_0).shape[0])):
      if self.__idxmap._hasItem_J(_0[_6]):
       _2[(_1 + _6)] = _4[self.__idxmap._getItem_J(_0[_6])]
      else:
       if ((_5==mosek.fusion.SolutionStatus.Optimal) or ((_5==mosek.fusion.SolutionStatus.NearOptimal) or ((_5==mosek.fusion.SolutionStatus.Feasible) or (_5==mosek.fusion.SolutionStatus.NearFeasible)))):
        _2[(_1 + _6)] = self.__dom._get_1rhs_1item_J(_0[_6])
       else:
        _2[(_1 + _6)] = 0.0
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   return (mosek_fusion_LinearVariable._ctor_Lmosek_4fusion_4LinearVariable_2Lmosek_4fusion_4Model_2(self,_0))
 return LinearVariable
mosek_fusion_LinearVariable=__mk_mosek_fusion_LinearVariable()
del __mk_mosek_fusion_LinearVariable
#BEFORE CLASS
def __mk_mosek_fusion_ConicVariable():
 class ConicVariable(mosek_fusion_ModelVariable):
  __slots__ = ['_ConicVariable__names_flushed','_ConicVariable__nativeidxs','_ConicVariable__dom','_ConicVariable__numcone','_ConicVariable__conesize','_ConicVariable__coneidx']
  def make_continuous(self,*args):
    if False: pass
    elif mosek_fusion_ConicVariable._match_make_1continuous__3J(*args): # []int64
      return self._make_1continuous__3J(*args)
    elif mosek_fusion_ConicVariable._match_alt_make_1continuous__3J(*args): # []int64
      return self._make_1continuous_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_continuous('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ConicVariable.make_continuous(array(int64,ndim=1))')
  def values(self,*args):
    if False: pass
    elif mosek_fusion_ConicVariable._match_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_I_3DZ(*args)
    elif mosek_fusion_ConicVariable._match_alt_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_alt_I_3DZ(*args)
    elif mosek_fusion_ConicVariable._match_values__3JI_3DZ(*args): # []int64,int32,[]double,bool
      return self._values__3JI_3DZ(*args)
    elif mosek_fusion_ConicVariable._match_alt_values__3JI_3DZ(*args): # []int64,int32,[]double,bool
      return self._values_alt__3JI_3DZ(*args)
    elif mosek_fusion_ConicVariable._match_values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._values_J_3I_3JI_3DZ(*args)
    elif mosek_fusion_ConicVariable._match_alt_values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._values_alt_J_3I_3JI_3DZ(*args)
    else:
      raise ValueError('Invalid argument list values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ConicVariable.values(int32,array(double,ndim=1),bool)\n\tmosek.fusion.ConicVariable.values(array(int64,ndim=1),int32,array(double,ndim=1),bool)\n\tmosek.fusion.ConicVariable.values(int64,array(int32,ndim=1),array(int64,ndim=1),int32,array(double,ndim=1),bool)')
  def set_values(self,*args):
    if False: pass
    elif mosek_fusion_ConicVariable._match_set_1values__3J_3DZ(*args): # []int64,[]double,bool
      return self._set_1values__3J_3DZ(*args)
    elif mosek_fusion_ConicVariable._match_alt_set_1values__3J_3DZ(*args): # []int64,[]double,bool
      return self._set_1values_alt__3J_3DZ(*args)
    elif mosek_fusion_ConicVariable._match_set_1values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._set_1values_J_3I_3JI_3DZ(*args)
    elif mosek_fusion_ConicVariable._match_alt_set_1values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._set_1values_alt_J_3I_3JI_3DZ(*args)
    else:
      raise ValueError('Invalid argument list set_values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ConicVariable.set_values(array(int64,ndim=1),array(double,ndim=1),bool)\n\tmosek.fusion.ConicVariable.set_values(int64,array(int32,ndim=1),array(int64,ndim=1),int32,array(double,ndim=1),bool)')
  def elementName(self,*args):
    if False: pass
    elif mosek_fusion_ConicVariable._match_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_ConicVariable._match_alt_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementName_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementName('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ConicVariable.elementName(int64,mosek.fusion.Utils.StringBuffer)')
  def inst(self,*args):
    if False: pass
    elif mosek_fusion_ConicVariable._match_inst_JJ_3I_3I_3I(*args): # int64,int64,[]int32,[]int32,[]int32
      return self._inst_JJ_3I_3I_3I(*args)
    elif mosek_fusion_ConicVariable._match_alt_inst_JJ_3I_3I_3I(*args): # int64,int64,[]int32,[]int32,[]int32
      return self._inst_alt_JJ_3I_3I_3I(*args)
    elif mosek_fusion_ConicVariable._match_inst__3JIIJJ_3I_3I_3I(*args): # []int64,int32,int32,int64,int64,[]int32,[]int32,[]int32
      return self._inst__3JIIJJ_3I_3I_3I(*args)
    elif mosek_fusion_ConicVariable._match_alt_inst__3JIIJJ_3I_3I_3I(*args): # []int64,int32,int32,int64,int64,[]int32,[]int32,[]int32
      return self._inst_alt__3JIIJJ_3I_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list inst('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ConicVariable.inst(int64,int64,array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.ConicVariable.inst(array(int64,ndim=1),int32,int32,int64,int64,array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ConicVariable._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ConicVariable._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ConicVariable.toString()')
  def make_integer(self,*args):
    if False: pass
    elif mosek_fusion_ConicVariable._match_make_1integer__3J(*args): # []int64
      return self._make_1integer__3J(*args)
    elif mosek_fusion_ConicVariable._match_alt_make_1integer__3J(*args): # []int64
      return self._make_1integer_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_integer('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ConicVariable.make_integer(array(int64,ndim=1))')
  def elementDesc(self,*args):
    if False: pass
    elif mosek_fusion_ConicVariable._match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_ConicVariable._match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementDesc('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ConicVariable.elementDesc(int64,mosek.fusion.Utils.StringBuffer)')
  def __repr__(self): return 'mosek.fusion.ConicVariable'
  @staticmethod
  def _ctor_Lmosek_4fusion_4ConicVariable_2Lmosek_4fusion_4Model_2(v,m):
    o = ConicVariable.__new__(ConicVariable)
    o._ctor_init_Lmosek_4fusion_4ConicVariable_2Lmosek_4fusion_4Model_2(v,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4ConicVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_match_Lmosek_4fusion_4ConicVariable_2__(v) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4ConicVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4ConicVariable_2__(v) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4ConicVariable_2Lmosek_4fusion_4Model_2(self,v,m):
    self._ctor_init_Lmosek_4fusion_4ConicVariable_2Lmosek_4fusion_4Model_2(v,m)
  def _ctor_init_Lmosek_4fusion_4ConicVariable_2Lmosek_4fusion_4Model_2(self,v,m):
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(self,v,m)
   self.__dom = (v.__dom)
   self.__coneidx = (v.__coneidx)
   self.__conesize = (v.__conesize)
   self.__numcone = (v.__numcone)
   self.__nativeidxs = (numpy.array([(v.__nativeidxs)[_0] for _0 in range(0,int(((v.__nativeidxs)).shape[0]))], dtype=numpy.dtype(numpy.int32)) if (((v.__nativeidxs) is not None) ) else None)
   self.__names_flushed = (v.__names_flushed)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4QConeDomain_2Lmosek_4fusion_4Set_2_3IIIIJ(model_,name_,dom_,shape_p,nativeidxs_,conesize_,firstcone_,numcone_,varid_):
    o = ConicVariable.__new__(ConicVariable)
    o._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4QConeDomain_2Lmosek_4fusion_4Set_2_3IIIIJ(model_,name_,dom_,shape_p,nativeidxs_,conesize_,firstcone_,numcone_,varid_)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4QConeDomain_2Lmosek_4fusion_4Set_2_3IIIIJ(*args):
    if len(args) != 9: return False
    model_,name_,dom_,shape_p,nativeidxs_,conesize_,firstcone_,numcone_,varid_, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model_) and __arg_match_S__(name_) and __arg_match_Lmosek_4fusion_4QConeDomain_2__(dom_) and __arg_match_Lmosek_4fusion_4Set_2__(shape_p) and __arg_match__3I__(nativeidxs_) and __arg_match_I__(conesize_) and __arg_match_I__(firstcone_) and __arg_match_I__(numcone_) and __arg_match_J__(varid_))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4QConeDomain_2Lmosek_4fusion_4Set_2_3IIIIJ(*args):
    if len(args) != 9: return False
    model_,name_,dom_,shape_p,nativeidxs_,conesize_,firstcone_,numcone_,varid_, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model_) and __arg_alt_match_S__(name_) and __arg_alt_match_Lmosek_4fusion_4QConeDomain_2__(dom_) and __arg_alt_match_Lmosek_4fusion_4Set_2__(shape_p) and __arg_alt_match__3I__(nativeidxs_) and __arg_alt_match_I__(conesize_) and __arg_alt_match_I__(firstcone_) and __arg_alt_match_I__(numcone_) and __arg_alt_match_J__(varid_))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4QConeDomain_2Lmosek_4fusion_4Set_2_3IIIIJ(self,model_,name_,dom_,shape_p,nativeidxs_,conesize_,firstcone_,numcone_,varid_):
    self._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4QConeDomain_2Lmosek_4fusion_4Set_2_3IIIIJ(model_,name_,dom_,shape_p,numpy.array(nativeidxs_,dtype=numpy.dtype(numpy.int32)),numpy.int32(conesize_),numpy.int32(firstcone_),numpy.int32(numcone_),numpy.int64(varid_))
  def _ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4QConeDomain_2Lmosek_4fusion_4Set_2_3IIIIJ(self,model_,name_,dom_,shape_p,nativeidxs_,conesize_,firstcone_,numcone_,varid_):
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2J(self,model_,name_,shape_p,varid_)
   self.__dom = dom_
   self.__conesize = conesize_
   self.__coneidx = firstcone_
   self.__numcone = numcone_
   self.__nativeidxs = nativeidxs_
   self.__names_flushed = False
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("ConicVariable( ")
   if (int(len(self._name)) > 0):
    _0._a_S("'")._a_S(self._name)._a_S("',")
   _0._a_S("(")
   _0._a_I(self._shape_p._dim_I(0))
   for _1 in range(1,(self._shape_p.nd)):
    _0._a_S(",")._a_I(self._shape_p._dim_I(_1))
   _0._a_S(") )")
   return (_0._toString_())
  @staticmethod
  def _match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_J__(_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  @staticmethod
  def _match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  def _elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(_0,_1)
   self.__dom._domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(_0,_1)
   return (_1)
  @staticmethod
  def _match_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_J__(_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  @staticmethod
  def _match_alt_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  def _elementName_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   _1._a_S(("_" if ((int(len(self._name))==0) ) else self._name))._a_S("[")._a_S(self._shape_p._indexToString_J(_0))._a_S("] ")
  def _flushNames_alt_(self,):
    return self._flushNames_()
  def _flushNames_(self,):
   if ((not self.__names_flushed) and (int(len(self._name)) > 0)):
    for _0 in range(0,int((self.__nativeidxs).shape[0])):
     self._model._varname_IS(self.__nativeidxs[_0],mosek.fusion.Utils.StringBuffer()._a_S(self._name)._a_S("[")._a_S(self._shape_p._getname_J(_0))._a_S("]")._toString_())
    self.__names_flushed = True
  @staticmethod
  def _match_inst__3JIIJJ_3I_3I_3I(*args):
    if len(args) != 8: return False
    _0,_1,_2,_3,_4,_5,_6,_7, = args
    return (__arg_match__3J__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4) and __arg_match__3I__(_5) and __arg_match__3I__(_6) and __arg_match__3I__(_7))
  @staticmethod
  def _match_alt_inst__3JIIJJ_3I_3I_3I(*args):
    if len(args) != 8: return False
    _0,_1,_2,_3,_4,_5,_6,_7, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4) and __arg_alt_match__3I__(_5) and __arg_alt_match__3I__(_6) and __arg_alt_match__3I__(_7))
  def _inst_alt__3JIIJJ_3I_3I_3I(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.int32(_t__2)
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.int32))
   _6=numpy.array(_t__6,dtype=numpy.dtype(numpy.int32))
   _7=numpy.array(_t__7,dtype=numpy.dtype(numpy.int32))
   _1 = self._inst__3JIIJJ_3I_3I_3I(_0,_1,_2,_3,_4,_5,_6,_7)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__6[:] = _6
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__7[:] = _7
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst__3JIIJJ_3I_3I_3I(self,_0,_1,_2,_3,_4,_5,_6,_7):
   fragments._c_closure_143(_5,_4,_1,_0,_3,_2,self.__nativeidxs) # src/fusion/ConicVariable.mbi:209:7-215:8
  @staticmethod
  def _match_inst_JJ_3I_3I_3I(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match_J__(_0) and __arg_match_J__(_1) and __arg_match__3I__(_2) and __arg_match__3I__(_3) and __arg_match__3I__(_4))
  @staticmethod
  def _match_alt_inst_JJ_3I_3I_3I(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_J__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match__3I__(_3) and __arg_alt_match__3I__(_4))
  def _inst_alt_JJ_3I_3I_3I(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.int64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int32))
   _1 = self._inst_JJ_3I_3I_3I(_0,_1,_2,_3,_4)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst_JJ_3I_3I_3I(self,_0,_1,_2,_3,_4):
   if ((_0 < 0) or (_0 >= long((self.__nativeidxs).shape[0]))):
    raise mosek_fusion_IndexError._ctor_S("Index out of bounds")
   _2[_1] = self.__nativeidxs[_0]
  @staticmethod
  def _match_set_1values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match_J__(_0) and __arg_match__3I__(_1) and __arg_match__3J__(_2) and __arg_match_I__(_3) and __arg_match__3D__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_set_1values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match__3D__(_4) and __arg_alt_match_Z__(_5))
  def _set_1values_alt_J_3I_3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = self._set_1values_J_3I_3JI_3DZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values_J_3I_3JI_3DZ(self,_0,_1,_2,_3,_4,_5):
   if _5:
    _6=1
    _7=int((_2).shape[0])
    _8=mosek_fusion_IndexCounter._ctor_J_3I_3J(_0,_1,_2)
    _6 = fragments._c_closure_144(_7,_1,_6) # src/fusion/ConicVariable.mbi:169:11-53
    _6 = numpy.int64(_6) # postprocess
    _9=int((self.__nativeidxs).shape[0])
    _10=numpy.array([self.__nativeidxs[_8._next_()] for _11 in range(0,_6)], dtype=numpy.dtype(numpy.int32))
    _12=(numpy.array([_4[(_3 + _13)] for _13 in range(0,_9)], dtype=numpy.dtype(numpy.float64)) if ((_3 > 0) ) else _4)
    self._model._setSolution_1xx__3I_3D(_10,_12)
   else:
    pass
  @staticmethod
  def _match_set_1values__3J_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3J__(_0) and __arg_match__3D__(_1) and __arg_match_Z__(_2))
  @staticmethod
  def _match_alt_set_1values__3J_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3D__(_1) and __arg_alt_match_Z__(_2))
  def _set_1values_alt__3J_3DZ(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=_t__2
   _1 = self._set_1values__3J_3DZ(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values__3J_3DZ(self,_0,_1,_2):
   if _2:
    _3=int((self.__nativeidxs).shape[0])
    _4=numpy.array([self.__nativeidxs[_0[_5]] for _5 in range(0,_3)], dtype=numpy.dtype(numpy.int32))
    _6=numpy.array([_1[_7] for _7 in range(0,_3)], dtype=numpy.dtype(numpy.float64))
    self._model._setSolution_1xx__3I_3D(_4,_6)
   else:
    pass
  @staticmethod
  def _match_values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match_J__(_0) and __arg_match__3I__(_1) and __arg_match__3J__(_2) and __arg_match_I__(_3) and __arg_match__3D__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match__3D__(_4) and __arg_alt_match_Z__(_5))
  def _values_alt_J_3I_3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = self._values_J_3I_3JI_3DZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values_J_3I_3JI_3DZ(self,_0,_1,_2,_3,_4,_5):
   _6=1
   _7=int((_2).shape[0])
   _8=mosek_fusion_IndexCounter._ctor_J_3I_3J(_0,_1,_2)
   _9=(self._model._getSolution_1xx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default) if (_5 ) else self._model._getSolution_1snx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default))
   _6 = fragments._c_closure_145(_7,_1,_6) # src/fusion/ConicVariable.mbi:126:9-51
   _6 = numpy.int64(_6) # postprocess
   for _10 in range(0,_6):
    _4[(_10 + _3)] = _9[self.__nativeidxs[_8._get_()]]
    _8._inc_()
  @staticmethod
  def _match_values__3JI_3DZ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match__3J__(_0) and __arg_match_I__(_1) and __arg_match__3D__(_2) and __arg_match_Z__(_3))
  @staticmethod
  def _match_alt_values__3JI_3DZ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match_Z__(_3))
  def _values_alt__3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=_t__3
   _1 = self._values__3JI_3DZ(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values__3JI_3DZ(self,_0,_1,_2,_3):
   _4=(self._model._getSolution_1xx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default) if (_3 ) else self._model._getSolution_1snx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default))
   fragments._c_closure_146(_0,self.__nativeidxs,_1,_2,_4) # src/fusion/ConicVariable.mbi:106:9-107:54
  @staticmethod
  def _match_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3J__(_0))
  @staticmethod
  def _match_alt_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3J__(_0))
  def _make_1continuous_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1continuous__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1continuous__3J(self,_0):
   self._getModel_()._task_1var_1putcontlist__3I(numpy.array([self.__nativeidxs[_0[_1]] for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32)))
  @staticmethod
  def _match_make_1integer__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3J__(_0))
  @staticmethod
  def _match_alt_make_1integer__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3J__(_0))
  def _make_1integer_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1integer__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1integer__3J(self,_0):
   self._getModel_()._task_1var_1putintlist__3I(numpy.array([self.__nativeidxs[_0[_1]] for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32)))
  def _get_1variable_1index_alt_I(self,_t__0):
    return self._get_1variable_1index_I(numpy.int32(__0))
  def _get_1variable_1index_I(self,_0):
   if (_0 >= int((self.__nativeidxs).shape[0])):
    raise mosek_fusion_IndexError._ctor_S("Variable index out of range")
   else:
    return numpy.int32(self.__nativeidxs[_0])
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   return (mosek_fusion_ConicVariable._ctor_Lmosek_4fusion_4ConicVariable_2Lmosek_4fusion_4Model_2(self,_0))
 return ConicVariable
mosek_fusion_ConicVariable=__mk_mosek_fusion_ConicVariable()
del __mk_mosek_fusion_ConicVariable
#BEFORE CLASS
def __mk_mosek_fusion_NilVariable():
 class NilVariable(mosek_fusion_SymmetricVariable,mosek_fusion_BaseVariable):
  def index(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_index_I(*args): # int32
      return self._index_I(*args)
    elif mosek_fusion_NilVariable._match_alt_index_I(*args): # int32
      return self._index_alt_I(*args)
    elif mosek_fusion_NilVariable._match_index__3I(*args): # []int32
      return self._index__3I(*args)
    elif mosek_fusion_NilVariable._match_alt_index__3I(*args): # []int32
      return self._index_alt__3I(*args)
    elif mosek_fusion_NilVariable._match_index_II(*args): # int32,int32
      return self._index_II(*args)
    elif mosek_fusion_NilVariable._match_alt_index_II(*args): # int32,int32
      return self._index_alt_II(*args)
    elif mosek_fusion_NilVariable._match_index_III(*args): # int32,int32,int32
      return self._index_III(*args)
    elif mosek_fusion_NilVariable._match_alt_index_III(*args): # int32,int32,int32
      return self._index_alt_III(*args)
    else:
      raise ValueError('Invalid argument list index('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.index(int32)\n\tmosek.fusion.NilVariable.index(array(int32,ndim=1))\n\tmosek.fusion.NilVariable.index(int32,int32)\n\tmosek.fusion.NilVariable.index(int32,int32,int32)')
  def slice(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_slice_II(*args): # int32,int32
      return self._slice_II(*args)
    elif mosek_fusion_NilVariable._match_alt_slice_II(*args): # int32,int32
      return self._slice_alt_II(*args)
    elif mosek_fusion_NilVariable._match_slice__3I_3I(*args): # []int32,[]int32
      return self._slice__3I_3I(*args)
    elif mosek_fusion_NilVariable._match_alt_slice__3I_3I(*args): # []int32,[]int32
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.slice(int32,int32)\n\tmosek.fusion.NilVariable.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def set_values(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_set_1values__3J_3DZ(*args): # []int64,[]double,bool
      return self._set_1values__3J_3DZ(*args)
    elif mosek_fusion_NilVariable._match_alt_set_1values__3J_3DZ(*args): # []int64,[]double,bool
      return self._set_1values_alt__3J_3DZ(*args)
    elif mosek_fusion_NilVariable._match_set_1values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._set_1values_J_3I_3JI_3DZ(*args)
    elif mosek_fusion_NilVariable._match_alt_set_1values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._set_1values_alt_J_3I_3JI_3DZ(*args)
    else:
      raise ValueError('Invalid argument list set_values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.set_values(array(int64,ndim=1),array(double,ndim=1),bool)\n\tmosek.fusion.NilVariable.set_values(int64,array(int32,ndim=1),array(int64,ndim=1),int32,array(double,ndim=1),bool)')
  def inst(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_inst_JJ_3I_3I_3I(*args): # int64,int64,[]int32,[]int32,[]int32
      return self._inst_JJ_3I_3I_3I(*args)
    elif mosek_fusion_NilVariable._match_alt_inst_JJ_3I_3I_3I(*args): # int64,int64,[]int32,[]int32,[]int32
      return self._inst_alt_JJ_3I_3I_3I(*args)
    elif mosek_fusion_NilVariable._match_inst__3JIIJJ_3I_3I_3I(*args): # []int64,int32,int32,int64,int64,[]int32,[]int32,[]int32
      return self._inst__3JIIJJ_3I_3I_3I(*args)
    elif mosek_fusion_NilVariable._match_alt_inst__3JIIJJ_3I_3I_3I(*args): # []int64,int32,int32,int64,int64,[]int32,[]int32,[]int32
      return self._inst_alt__3JIIJJ_3I_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list inst('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.inst(int64,int64,array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.NilVariable.inst(array(int64,ndim=1),int32,int32,int64,int64,array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))')
  def size(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_size_(*args): # 
      return self._size_(*args)
    elif mosek_fusion_NilVariable._match_alt_size_(*args): # 
      return self._size_alt_(*args)
    else:
      raise ValueError('Invalid argument list size('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.size()')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_NilVariable._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.toString()')
  def elementDesc(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_NilVariable._match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementDesc('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.elementDesc(int64,mosek.fusion.Utils.StringBuffer)')
  def values(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_I_3DZ(*args)
    elif mosek_fusion_NilVariable._match_alt_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_alt_I_3DZ(*args)
    elif mosek_fusion_NilVariable._match_values__3JI_3DZ(*args): # []int64,int32,[]double,bool
      return self._values__3JI_3DZ(*args)
    elif mosek_fusion_NilVariable._match_alt_values__3JI_3DZ(*args): # []int64,int32,[]double,bool
      return self._values_alt__3JI_3DZ(*args)
    elif mosek_fusion_NilVariable._match_values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._values_J_3I_3JI_3DZ(*args)
    elif mosek_fusion_NilVariable._match_alt_values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._values_alt_J_3I_3JI_3DZ(*args)
    else:
      raise ValueError('Invalid argument list values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.values(int32,array(double,ndim=1),bool)\n\tmosek.fusion.NilVariable.values(array(int64,ndim=1),int32,array(double,ndim=1),bool)\n\tmosek.fusion.NilVariable.values(int64,array(int32,ndim=1),array(int64,ndim=1),int32,array(double,ndim=1),bool)')
  def elementName(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_NilVariable._match_alt_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementName_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementName('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.elementName(int64,mosek.fusion.Utils.StringBuffer)')
  def makeInteger(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_makeInteger_(*args): # 
      return self._makeInteger_(*args)
    elif mosek_fusion_NilVariable._match_alt_makeInteger_(*args): # 
      return self._makeInteger_alt_(*args)
    else:
      raise ValueError('Invalid argument list makeInteger('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.makeInteger()')
  def make_integer(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_make_1integer__3J(*args): # []int64
      return self._make_1integer__3J(*args)
    elif mosek_fusion_NilVariable._match_alt_make_1integer__3J(*args): # []int64
      return self._make_1integer_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_integer('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.make_integer(array(int64,ndim=1))')
  def makeContinuous(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_makeContinuous_(*args): # 
      return self._makeContinuous_(*args)
    elif mosek_fusion_NilVariable._match_alt_makeContinuous_(*args): # 
      return self._makeContinuous_alt_(*args)
    else:
      raise ValueError('Invalid argument list makeContinuous('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.makeContinuous()')
  def dual(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_dual_(*args): # 
      return self._dual_(*args)
    elif mosek_fusion_NilVariable._match_alt_dual_(*args): # 
      return self._dual_alt_(*args)
    else:
      raise ValueError('Invalid argument list dual('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.dual()')
  def level(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_level_(*args): # 
      return self._level_(*args)
    elif mosek_fusion_NilVariable._match_alt_level_(*args): # 
      return self._level_alt_(*args)
    else:
      raise ValueError('Invalid argument list level('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.level()')
  def make_continuous(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_make_1continuous__3J(*args): # []int64
      return self._make_1continuous__3J(*args)
    elif mosek_fusion_NilVariable._match_alt_make_1continuous__3J(*args): # []int64
      return self._make_1continuous_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_continuous('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.make_continuous(array(int64,ndim=1))')
  def __repr__(self): return 'mosek.fusion.NilVariable'
  @staticmethod
  def _ctor_():
    o = NilVariable.__new__(NilVariable)
    o._ctor_init_()
    return o
  @staticmethod
  def __match_ctor_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def __match_alt_ctor_(*args):
    if len(args) != 0: return False
    return True
  def _ctor_alt_init_(self,):
    self._ctor_init_()
  def _ctor_init_(self,):
   mosek_fusion_BaseVariable._ctor_init_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Set_2(self,None,mosek.fusion.Set._make_I(0))
  @staticmethod
  def _match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_J__(_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  @staticmethod
  def _match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  def _elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   return (_1)
  @staticmethod
  def _match_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_J__(_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  @staticmethod
  def _match_alt_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  def _elementName_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   pass
  @staticmethod
  def _match_inst__3JIIJJ_3I_3I_3I(*args):
    if len(args) != 8: return False
    _0,_1,_2,_3,_4,_5,_6,_7, = args
    return (__arg_match__3J__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4) and __arg_match__3I__(_5) and __arg_match__3I__(_6) and __arg_match__3I__(_7))
  @staticmethod
  def _match_alt_inst__3JIIJJ_3I_3I_3I(*args):
    if len(args) != 8: return False
    _0,_1,_2,_3,_4,_5,_6,_7, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4) and __arg_alt_match__3I__(_5) and __arg_alt_match__3I__(_6) and __arg_alt_match__3I__(_7))
  def _inst_alt__3JIIJJ_3I_3I_3I(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.int32(_t__2)
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.int32))
   _6=numpy.array(_t__6,dtype=numpy.dtype(numpy.int32))
   _7=numpy.array(_t__7,dtype=numpy.dtype(numpy.int32))
   _1 = self._inst__3JIIJJ_3I_3I_3I(_0,_1,_2,_3,_4,_5,_6,_7)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__6[:] = _6
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__7[:] = _7
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst__3JIIJJ_3I_3I_3I(self,_0,_1,_2,_3,_4,_5,_6,_7):
   pass
  @staticmethod
  def _match_inst_JJ_3I_3I_3I(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match_J__(_0) and __arg_match_J__(_1) and __arg_match__3I__(_2) and __arg_match__3I__(_3) and __arg_match__3I__(_4))
  @staticmethod
  def _match_alt_inst_JJ_3I_3I_3I(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_J__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match__3I__(_3) and __arg_alt_match__3I__(_4))
  def _inst_alt_JJ_3I_3I_3I(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.int64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int32))
   _1 = self._inst_JJ_3I_3I_3I(_0,_1,_2,_3,_4)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst_JJ_3I_3I_3I(self,_0,_1,_2,_3,_4):
   pass
  @staticmethod
  def _match_set_1values__3J_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3J__(_0) and __arg_match__3D__(_1) and __arg_match_Z__(_2))
  @staticmethod
  def _match_alt_set_1values__3J_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3D__(_1) and __arg_alt_match_Z__(_2))
  def _set_1values_alt__3J_3DZ(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=_t__2
   _1 = self._set_1values__3J_3DZ(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values__3J_3DZ(self,_0,_1,_2):
   pass
  @staticmethod
  def _match_set_1values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match_J__(_0) and __arg_match__3I__(_1) and __arg_match__3J__(_2) and __arg_match_I__(_3) and __arg_match__3D__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_set_1values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match__3D__(_4) and __arg_alt_match_Z__(_5))
  def _set_1values_alt_J_3I_3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = self._set_1values_J_3I_3JI_3DZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values_J_3I_3JI_3DZ(self,_0,_1,_2,_3,_4,_5):
   pass
  @staticmethod
  def _match_values__3JI_3DZ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match__3J__(_0) and __arg_match_I__(_1) and __arg_match__3D__(_2) and __arg_match_Z__(_3))
  @staticmethod
  def _match_alt_values__3JI_3DZ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match_Z__(_3))
  def _values_alt__3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=_t__3
   _1 = self._values__3JI_3DZ(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values__3JI_3DZ(self,_0,_1,_2,_3):
   pass
  @staticmethod
  def _match_values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match_J__(_0) and __arg_match__3I__(_1) and __arg_match__3J__(_2) and __arg_match_I__(_3) and __arg_match__3D__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match__3D__(_4) and __arg_alt_match_Z__(_5))
  def _values_alt_J_3I_3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = self._values_J_3I_3JI_3DZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values_J_3I_3JI_3DZ(self,_0,_1,_2,_3,_4,_5):
   pass
  @staticmethod
  def _match_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3J__(_0))
  @staticmethod
  def _match_alt_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3J__(_0))
  def _make_1continuous_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1continuous__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1continuous__3J(self,_0):
   pass
  @staticmethod
  def _match_make_1integer__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3J__(_0))
  @staticmethod
  def _match_alt_make_1integer__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3J__(_0))
  def _make_1integer_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1integer__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1integer__3J(self,_0):
   pass
  @staticmethod
  def _match_makeContinuous_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_makeContinuous_(*args):
    if len(args) != 0: return False
    return True
  def _makeContinuous_alt_(self,):
    return self._makeContinuous_()
  def _makeContinuous_(self,):
   self._make_1continuous__3J(numpy.array([_0 for _0 in range(0,self._size_())], dtype=numpy.dtype(numpy.int64)))
  @staticmethod
  def _match_makeInteger_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_makeInteger_(*args):
    if len(args) != 0: return False
    return True
  def _makeInteger_alt_(self,):
    return self._makeInteger_()
  def _makeInteger_(self,):
   self._make_1integer__3J(numpy.array([_0 for _0 in range(0,self._size_())], dtype=numpy.dtype(numpy.int64)))
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return ("NilVariable")
  @staticmethod
  def _match_size_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_size_(*args):
    if len(args) != 0: return False
    return True
  def _size_alt_(self,):
    return self._size_()
  def _size_(self,):
   return numpy.int32(0)
  @staticmethod
  def _match_dual_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_dual_(*args):
    if len(args) != 0: return False
    return True
  def _dual_alt_(self,):
    return self._dual_()
  def _dual_(self,):
   return (numpy.zeros((0,), dtype=numpy.dtype(numpy.float64)))
  @staticmethod
  def _match_level_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_level_(*args):
    if len(args) != 0: return False
    return True
  def _level_alt_(self,):
    return self._level_()
  def _level_(self,):
   return (numpy.zeros((0,), dtype=numpy.dtype(numpy.float64)))
  @staticmethod
  def _match_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _index_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._index__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _index__3I(self,_0):
   raise mosek_fusion_SliceError._ctor_S("Slice is out of bounds")
  @staticmethod
  def _match_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _index_alt_I(self,_t__0):
    return self._index_I(numpy.int32(__0))
  def _index_I(self,_0):
   raise mosek_fusion_SliceError._ctor_S("Slice is out of bounds")
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _slice_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._slice__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice__3I_3I(self,_0,_1):
   for _2 in range(0,int((_0).shape[0])):
    if (_1[_2] > _0[_2]):
     raise mosek_fusion_SliceError._ctor_S("Slice is out of bounds")
   return (self)
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _slice_alt_II(self,_t__0,_t__1):
    return self._slice_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_II(self,_0,_1):
   if (_1 > _0):
    raise mosek_fusion_SliceError._ctor_S("Slice is out of bounds")
   else:
    return (self)
 return NilVariable
mosek_fusion_NilVariable=__mk_mosek_fusion_NilVariable()
del __mk_mosek_fusion_NilVariable
#BEFORE CLASS
def __mk_mosek_fusion_Var():
 class Var(object):
  @staticmethod
  def flatten(*args):
    if False: pass
    elif mosek_fusion_Var._match_flatten_Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable
      return mosek_fusion_Var._flatten_Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_alt_flatten_Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable
      return mosek_fusion_Var._flatten_alt_Lmosek_4fusion_4Variable_2(*args)
    else:
      raise ValueError('Invalid argument list flatten('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Var.flatten(mosek.fusion.Variable)')
  @staticmethod
  def vrepeat(*args):
    if False: pass
    elif mosek_fusion_Var._match_vrepeat_Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,int32
      return mosek_fusion_Var._vrepeat_Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_alt_vrepeat_Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,int32
      return mosek_fusion_Var._vrepeat_alt_Lmosek_4fusion_4Variable_2I(*args)
    else:
      raise ValueError('Invalid argument list vrepeat('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Var.vrepeat(mosek.fusion.Variable,int32)')
  @staticmethod
  def vstack(*args):
    if False: pass
    elif mosek_fusion_Var._match_vstack__3Lmosek_4fusion_4Variable_2(*args): # []mosek.fusion.Variable
      return mosek_fusion_Var._vstack__3Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_alt_vstack__3Lmosek_4fusion_4Variable_2(*args): # []mosek.fusion.Variable
      return mosek_fusion_Var._vstack_alt__3Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Var._vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_alt_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Var._vstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Var._vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_alt_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Var._vstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    else:
      raise ValueError('Invalid argument list vstack('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Var.vstack(array(mosek.fusion.Variable,ndim=1))\n\tmosek.fusion.Var.vstack(mosek.fusion.Variable,mosek.fusion.Variable)\n\tmosek.fusion.Var.vstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)')
  @staticmethod
  def hrepeat(*args):
    if False: pass
    elif mosek_fusion_Var._match_hrepeat_Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,int32
      return mosek_fusion_Var._hrepeat_Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_alt_hrepeat_Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,int32
      return mosek_fusion_Var._hrepeat_alt_Lmosek_4fusion_4Variable_2I(*args)
    else:
      raise ValueError('Invalid argument list hrepeat('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Var.hrepeat(mosek.fusion.Variable,int32)')
  @staticmethod
  def repeat(*args):
    if False: pass
    elif mosek_fusion_Var._match_repeat_Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,int32
      return mosek_fusion_Var._repeat_Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_alt_repeat_Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,int32
      return mosek_fusion_Var._repeat_alt_Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_repeat_Lmosek_4fusion_4Variable_2II(*args): # mosek.fusion.Variable,int32,int32
      return mosek_fusion_Var._repeat_Lmosek_4fusion_4Variable_2II(*args)
    elif mosek_fusion_Var._match_alt_repeat_Lmosek_4fusion_4Variable_2II(*args): # mosek.fusion.Variable,int32,int32
      return mosek_fusion_Var._repeat_alt_Lmosek_4fusion_4Variable_2II(*args)
    else:
      raise ValueError('Invalid argument list repeat('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Var.repeat(mosek.fusion.Variable,int32)\n\tmosek.fusion.Var.repeat(mosek.fusion.Variable,int32,int32)')
  @staticmethod
  def compress(*args):
    if False: pass
    elif mosek_fusion_Var._match_compress_Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable
      return mosek_fusion_Var._compress_Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_alt_compress_Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable
      return mosek_fusion_Var._compress_alt_Lmosek_4fusion_4Variable_2(*args)
    else:
      raise ValueError('Invalid argument list compress('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Var.compress(mosek.fusion.Variable)')
  @staticmethod
  def stack(*args):
    if False: pass
    elif mosek_fusion_Var._match_stack__3_3Lmosek_4fusion_4Variable_2(*args): # [][]mosek.fusion.Variable
      return mosek_fusion_Var._stack__3_3Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_alt_stack__3_3Lmosek_4fusion_4Variable_2(*args): # [][]mosek.fusion.Variable
      return mosek_fusion_Var._stack_alt__3_3Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_stack__3Lmosek_4fusion_4Variable_2I(*args): # []mosek.fusion.Variable,int32
      return mosek_fusion_Var._stack__3Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_alt_stack__3Lmosek_4fusion_4Variable_2I(*args): # []mosek.fusion.Variable,int32
      return mosek_fusion_Var._stack_alt__3Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,mosek.fusion.Variable,int32
      return mosek_fusion_Var._stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_alt_stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,mosek.fusion.Variable,int32
      return mosek_fusion_Var._stack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable,int32
      return mosek_fusion_Var._stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_alt_stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable,int32
      return mosek_fusion_Var._stack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args)
    else:
      raise ValueError('Invalid argument list stack('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Var.stack(array(array(mosek.fusion.Variable,ndim=1),ndim=1))\n\tmosek.fusion.Var.stack(array(mosek.fusion.Variable,ndim=1),int32)\n\tmosek.fusion.Var.stack(mosek.fusion.Variable,mosek.fusion.Variable,int32)\n\tmosek.fusion.Var.stack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable,int32)')
  @staticmethod
  def hstack(*args):
    if False: pass
    elif mosek_fusion_Var._match_hstack__3Lmosek_4fusion_4Variable_2(*args): # []mosek.fusion.Variable
      return mosek_fusion_Var._hstack__3Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_alt_hstack__3Lmosek_4fusion_4Variable_2(*args): # []mosek.fusion.Variable
      return mosek_fusion_Var._hstack_alt__3Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Var._hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_alt_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Var._hstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Var._hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_alt_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Var._hstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    else:
      raise ValueError('Invalid argument list hstack('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Var.hstack(array(mosek.fusion.Variable,ndim=1))\n\tmosek.fusion.Var.hstack(mosek.fusion.Variable,mosek.fusion.Variable)\n\tmosek.fusion.Var.hstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)')
  @staticmethod
  def reshape(*args):
    if False: pass
    elif mosek_fusion_Var._match_reshape_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2(*args): # mosek.fusion.Variable,mosek.fusion.Set
      return mosek_fusion_Var._reshape_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2(*args)
    elif mosek_fusion_Var._match_alt_reshape_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2(*args): # mosek.fusion.Variable,mosek.fusion.Set
      return mosek_fusion_Var._reshape_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2(*args)
    elif mosek_fusion_Var._match_reshape_Lmosek_4fusion_4Variable_2_3I(*args): # mosek.fusion.Variable,[]int32
      return mosek_fusion_Var._reshape_Lmosek_4fusion_4Variable_2_3I(*args)
    elif mosek_fusion_Var._match_alt_reshape_Lmosek_4fusion_4Variable_2_3I(*args): # mosek.fusion.Variable,[]int32
      return mosek_fusion_Var._reshape_alt_Lmosek_4fusion_4Variable_2_3I(*args)
    elif mosek_fusion_Var._match_reshape_Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,int32
      return mosek_fusion_Var._reshape_Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_alt_reshape_Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,int32
      return mosek_fusion_Var._reshape_alt_Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_reshape_Lmosek_4fusion_4Variable_2II(*args): # mosek.fusion.Variable,int32,int32
      return mosek_fusion_Var._reshape_Lmosek_4fusion_4Variable_2II(*args)
    elif mosek_fusion_Var._match_alt_reshape_Lmosek_4fusion_4Variable_2II(*args): # mosek.fusion.Variable,int32,int32
      return mosek_fusion_Var._reshape_alt_Lmosek_4fusion_4Variable_2II(*args)
    else:
      raise ValueError('Invalid argument list reshape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Var.reshape(mosek.fusion.Variable,mosek.fusion.Set)\n\tmosek.fusion.Var.reshape(mosek.fusion.Variable,array(int32,ndim=1))\n\tmosek.fusion.Var.reshape(mosek.fusion.Variable,int32)\n\tmosek.fusion.Var.reshape(mosek.fusion.Variable,int32,int32)')
  def __repr__(self): return 'mosek.fusion.Var'
  @staticmethod
  def _match_compress_Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _match_alt_compress_Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _compress_alt_Lmosek_4fusion_4Variable_2(_t__0):
    return mosek_fusion_Var._compress_Lmosek_4fusion_4Variable_2(_0)
  @staticmethod
  def _compress_Lmosek_4fusion_4Variable_2(_0):
   _1=_0._getShape_()._realnd_()
   if (_1==(_0._getShape_().nd)):
    return (_0)
   elif (_1==1):
    return (mosek.fusion.Var._reshape_Lmosek_4fusion_4Variable_2I(_0,numpy.int32((_0._getShape_()._size))))
   else:
    _2=numpy.zeros((_1,), dtype=numpy.dtype(numpy.int32))
    _3=0
    for _4 in range(0,(_0._getShape_().nd)):
     if (_0._getShape_()._dim_I(_4) > 1):
      _2[_3] = _0._getShape_()._dim_I(_4)
      _3 += 1
    return (mosek.fusion.Var._reshape_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2(_0,mosek_fusion_NDSet._ctor__3I(_2)))
  @staticmethod
  def _match_reshape_Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_reshape_Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _reshape_alt_Lmosek_4fusion_4Variable_2I(_t__0,_t__1):
    return mosek_fusion_Var._reshape_Lmosek_4fusion_4Variable_2I(_0,numpy.int32(__1))
  @staticmethod
  def _reshape_Lmosek_4fusion_4Variable_2I(_0,_1):
   if (_1!=(_0._getShape_()._size)):
    raise mosek_fusion_DimensionError._ctor_S("New shape has wrong number of elements")
   return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2J_3J(_0,mosek_fusion_IntSet._ctor_I(_1),0,numpy.array([1], dtype=numpy.dtype(numpy.int64))))
  @staticmethod
  def _match_reshape_Lmosek_4fusion_4Variable_2II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_reshape_Lmosek_4fusion_4Variable_2II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _reshape_alt_Lmosek_4fusion_4Variable_2II(_t__0,_t__1,_t__2):
    return mosek_fusion_Var._reshape_Lmosek_4fusion_4Variable_2II(_0,numpy.int32(__1),numpy.int32(__2))
  @staticmethod
  def _reshape_Lmosek_4fusion_4Variable_2II(_0,_1,_2):
   if ((_1 * _2)!=(_0._getShape_()._size)):
    raise mosek_fusion_DimensionError._ctor_S("New shape has wrong number of elements")
   return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2J_3J(_0,mosek_fusion_NDSet._ctor_II(_1,_2),0,numpy.array([numpy.int64(_2),1], dtype=numpy.dtype(numpy.int64))))
  @staticmethod
  def _match_flatten_Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _match_alt_flatten_Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _flatten_alt_Lmosek_4fusion_4Variable_2(_t__0):
    return mosek_fusion_Var._flatten_Lmosek_4fusion_4Variable_2(_0)
  @staticmethod
  def _flatten_Lmosek_4fusion_4Variable_2(_0):
   if ((_0._getShape_().nd)==1):
    return (_0)
   else:
    return (mosek.fusion.Var._reshape_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2(_0,mosek.fusion.Set._make_I(numpy.int32((_0._getShape_()._size)))))
  @staticmethod
  def _match_reshape_Lmosek_4fusion_4Variable_2_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_reshape_Lmosek_4fusion_4Variable_2_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _reshape_alt_Lmosek_4fusion_4Variable_2_3I(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Var._reshape_Lmosek_4fusion_4Variable_2_3I(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _reshape_Lmosek_4fusion_4Variable_2_3I(_0,_1):
   _2=mosek.fusion.Set._make__3I(_1)
   return (mosek.fusion.Var._reshape_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2(_0,_2))
  @staticmethod
  def _match_reshape_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Set_2__(_1))
  @staticmethod
  def _match_alt_reshape_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Set_2__(_1))
  @staticmethod
  def _reshape_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2(_t__0,_t__1):
    return mosek_fusion_Var._reshape_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2(_0,_1)
  @staticmethod
  def _reshape_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2(_0,_1):
   if ((_1._size)!=(_0._getShape_()._size)):
    raise mosek_fusion_DimensionError._ctor_S("New shape has wrong number of elements")
   return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2J_3J(_0,_1,0,numpy.array([_1._stride_I(_2) for _2 in range(0,(_1.nd))], dtype=numpy.dtype(numpy.int64))))
  @staticmethod
  def _reshape_1_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2(_t__0,_t__1):
    return mosek_fusion_Var._reshape_1_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2(_0,_1)
  @staticmethod
  def _reshape_1_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2(_0,_1):
   _2=numpy.array([_1._stride_I(_3) for _3 in range(0,(_1.nd))], dtype=numpy.dtype(numpy.int64))
   return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2J_3J(_0,_1,0,_2))
  @staticmethod
  def _index_1flip_1_alt_Lmosek_4fusion_4Variable_2_3I(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Var._index_1flip_1_Lmosek_4fusion_4Variable_2_3I(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _index_1flip_1_Lmosek_4fusion_4Variable_2_3I(_0,_1):
   _2=numpy.array([_0._getShape_()._stride_I(_3) for _3 in range(0,(_0._getShape_().nd))], dtype=numpy.dtype(numpy.int64))
   _4=numpy.array([_0._getShape_()._dim_I(_5) for _5 in range(0,(_0._getShape_().nd))], dtype=numpy.dtype(numpy.int32))
   _6=0
   _6 = fragments._c_closure_147(_4,_1,_6,_2) # src/fusion/Var.monty:466:9-470:10
   _6 = numpy.int64(_6) # postprocess
   return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2J_3J(_0,_0._getShape_(),0,_2))
  @staticmethod
  def _index_1permute_1_alt_Lmosek_4fusion_4Variable_2_3I(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Var._index_1permute_1_Lmosek_4fusion_4Variable_2_3I(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _index_1permute_1_Lmosek_4fusion_4Variable_2_3I(_0,_1):
   _2=numpy.array([_0._getShape_()._stride_I(_1[_3]) for _3 in range(0,(_0._getShape_().nd))], dtype=numpy.dtype(numpy.int64))
   _4=numpy.array([_0._getShape_()._dim_I(_1[_5]) for _5 in range(0,(_0._getShape_().nd))], dtype=numpy.dtype(numpy.int32))
   return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2J_3J(_0,mosek_fusion_NDSet._ctor__3I(_4),0,_2))
  @staticmethod
  def _match_hrepeat_Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_hrepeat_Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _hrepeat_alt_Lmosek_4fusion_4Variable_2I(_t__0,_t__1):
    return mosek_fusion_Var._hrepeat_Lmosek_4fusion_4Variable_2I(_0,numpy.int32(__1))
  @staticmethod
  def _hrepeat_Lmosek_4fusion_4Variable_2I(_0,_1):
   return (mosek.fusion.Var.__drepeat_Lmosek_4fusion_4Variable_2II(_0,1,_1))
  @staticmethod
  def _match_vrepeat_Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_vrepeat_Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _vrepeat_alt_Lmosek_4fusion_4Variable_2I(_t__0,_t__1):
    return mosek_fusion_Var._vrepeat_Lmosek_4fusion_4Variable_2I(_0,numpy.int32(__1))
  @staticmethod
  def _vrepeat_Lmosek_4fusion_4Variable_2I(_0,_1):
   return (mosek.fusion.Var.__drepeat_Lmosek_4fusion_4Variable_2II(_0,0,_1))
  @staticmethod
  def _match_repeat_Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_repeat_Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _repeat_alt_Lmosek_4fusion_4Variable_2I(_t__0,_t__1):
    return mosek_fusion_Var._repeat_Lmosek_4fusion_4Variable_2I(_0,numpy.int32(__1))
  @staticmethod
  def _repeat_Lmosek_4fusion_4Variable_2I(_0,_1):
   return (mosek.fusion.Var.__drepeat_Lmosek_4fusion_4Variable_2II(_0,0,_1))
  @staticmethod
  def _match_repeat_Lmosek_4fusion_4Variable_2II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_repeat_Lmosek_4fusion_4Variable_2II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _repeat_alt_Lmosek_4fusion_4Variable_2II(_t__0,_t__1,_t__2):
    return mosek_fusion_Var._repeat_Lmosek_4fusion_4Variable_2II(_0,numpy.int32(__1),numpy.int32(__2))
  @staticmethod
  def _repeat_Lmosek_4fusion_4Variable_2II(_0,_1,_2):
   return (mosek.fusion.Var.__drepeat_Lmosek_4fusion_4Variable_2II(_0,_1,_2))
  @staticmethod
  def __drepeat_alt_Lmosek_4fusion_4Variable_2II(_t__0,_t__1,_t__2):
    return mosek_fusion_Var.__drepeat_Lmosek_4fusion_4Variable_2II(_0,numpy.int32(__1),numpy.int32(__2))
  @staticmethod
  def __drepeat_Lmosek_4fusion_4Variable_2II(_0,_1,_2):
   if (_2 < 0):
    raise mosek_fusion_LengthError._ctor_S("Cannot repeat less than 0 times")
   elif (_2==0):
    return (mosek_fusion_NilVariable._ctor_())
   elif (_2==1):
    return (_0)
   else:
    return (mosek_fusion_RepeatVariable._ctor_Lmosek_4fusion_4Variable_2II(_0,_1,_2))
  @staticmethod
  def _match_stack__3_3Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_3Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _match_alt_stack__3_3Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_3Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _stack_alt__3_3Lmosek_4fusion_4Variable_2(_t__0):
   _0=_monty.makeJaggedArray(_t__0,(1,1),numpy.dtype(object))
   _1 = mosek_fusion_Var._stack__3_3Lmosek_4fusion_4Variable_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _stack__3_3Lmosek_4fusion_4Variable_2(_0):
   _1=None
   for _2 in range(0,int((_0).shape[0])):
    for _3 in range(0,int((_0[_2]).shape[0])):
     if (_1 is None):
      _1 = _0[_2][_3]._getModel_()
     elif ((_0[_2][_3]._getModel_() is not None) and (_0[_2][_3]._getModel_() is not _1)):
      raise mosek_fusion_ModelError._ctor_S("Variables belong to different models")
   _4=0
   for _5 in range(0,int((_0).shape[0])):
    if (int((_0[_5]).shape[0]) > 0):
     _4 += 1
   _6=numpy.zeros((_4,), dtype=numpy.dtype(object))
   if (_4==0):
    return (mosek_fusion_NilVariable._ctor_())
   _7=0
   for _8 in range(0,int((_0).shape[0])):
    if (int((_0[_8]).shape[0])==0):
     pass
    elif (int((_0[_8]).shape[0])==1):
     _9=_0[_8][0]
     _6[_7] = (mosek.fusion.Var._reshape_Lmosek_4fusion_4Variable_2II(_9,_9._getShape_()._dim_I(0),1) if (((_9._getShape_().nd)==1) ) else _9)
     _7 += 1
    else:
     _10=0
     for _11 in range(0,int((_0[_8]).shape[0])):
      if ((_0[_8][_11]._getShape_()._size) > 0):
       _10 += 1
     _12=numpy.zeros((_10,), dtype=numpy.dtype(object))
     _13=0
     for _14 in range(0,int((_0[_8]).shape[0])):
      _15=_0[_8][_14]
      if ((_15._getShape_()._size) > 0):
       if ((_15._getShape_().nd)==1):
        _12[_13] = mosek.fusion.Var._reshape_Lmosek_4fusion_4Variable_2II(_15,_15._getShape_()._dim_I(0),1)
       else:
        _12[_13] = _15
       _13 += 1
     _6[_7] = mosek_fusion_CompoundVariable._ctor__3Lmosek_4fusion_4Variable_2I(_12,1)
     _7 += 1
   return ((_6[0] if ((int((_6).shape[0])==1) ) else mosek_fusion_CompoundVariable._ctor__3Lmosek_4fusion_4Variable_2I(_6,0)))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Var._vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1,_2)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1,_2):
   return (mosek.fusion.Var._dstack__3Lmosek_4fusion_4Variable_2I(numpy.array([_0,_1,_2], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Var._vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1):
   return (mosek.fusion.Var._dstack__3Lmosek_4fusion_4Variable_2I(numpy.array([_0,_1], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack__3Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _match_alt_vstack__3Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _vstack_alt__3Lmosek_4fusion_4Variable_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Var._vstack__3Lmosek_4fusion_4Variable_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _vstack__3Lmosek_4fusion_4Variable_2(_0):
   return (mosek.fusion.Var._dstack__3Lmosek_4fusion_4Variable_2I(_0,0))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Var._hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1,_2)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1,_2):
   return (mosek.fusion.Var._dstack__3Lmosek_4fusion_4Variable_2I(numpy.array([_0,_1,_2], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Var._hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1):
   return (mosek.fusion.Var._dstack__3Lmosek_4fusion_4Variable_2I(numpy.array([_0,_1], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack__3Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _match_alt_hstack__3Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _hstack_alt__3Lmosek_4fusion_4Variable_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Var._hstack__3Lmosek_4fusion_4Variable_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _hstack__3Lmosek_4fusion_4Variable_2(_0):
   return (mosek.fusion.Var._dstack__3Lmosek_4fusion_4Variable_2I(_0,1))
  @staticmethod
  def _match_stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2) and __arg_match_I__(_3))
  @staticmethod
  def _match_alt_stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2) and __arg_alt_match_I__(_3))
  @staticmethod
  def _stack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Var._stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(_0,_1,_2,numpy.int32(__3))
  @staticmethod
  def _stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(_0,_1,_2,_3):
   return (mosek.fusion.Var._dstack__3Lmosek_4fusion_4Variable_2I(numpy.array([_0,_1,_2], dtype=numpy.dtype(object)),_3))
  @staticmethod
  def _match_stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _stack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(_t__0,_t__1,_t__2):
    return mosek_fusion_Var._stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(_0,_1,numpy.int32(__2))
  @staticmethod
  def _stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(_0,_1,_2):
   return (mosek.fusion.Var._dstack__3Lmosek_4fusion_4Variable_2I(numpy.array([_0,_1], dtype=numpy.dtype(object)),_2))
  @staticmethod
  def _match_stack__3Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3Lmosek_4fusion_4Variable_2__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_stack__3Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _stack_alt__3Lmosek_4fusion_4Variable_2I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_Var._stack__3Lmosek_4fusion_4Variable_2I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _stack__3Lmosek_4fusion_4Variable_2I(_0,_1):
   return (mosek.fusion.Var._dstack__3Lmosek_4fusion_4Variable_2I(_0,_1))
  @staticmethod
  def _dstack_alt__3Lmosek_4fusion_4Variable_2I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_Var._dstack__3Lmosek_4fusion_4Variable_2I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _dstack__3Lmosek_4fusion_4Variable_2I(_0,_1):
   _2=None
   for _3 in range(0,int((_0).shape[0])):
    if (_2 is None):
     _2 = _0[_3]._getModel_()
    elif ((_0[_3]._getModel_() is not None) and (_0[_3]._getModel_() is not _2)):
     _4=mosek.fusion.Utils.StringBuffer()
     _5=(_2._getName_() if ((int(len(_2._getName_())) > 0) ) else "?")
     _6=(_0[_3]._getModel_()._getName_() if ((int(len(_0[_3]._getModel_()._getName_())) > 0) ) else "?")
     _4._a_S("Variables belong to different models: '")._a_S(_5)._a_S("' and '")._a_S(_6)._a_S("'")
     raise mosek_fusion_ModelError._ctor_S(_4._toString_())
   if (int((_0).shape[0])==0):
    return (mosek_fusion_NilVariable._ctor_())
   elif (int((_0).shape[0])==1):
    return (_0[1])
   else:
    _7=int((_0).shape[0])
    _8=(_1 + 1)
    for _9 in range(0,_7):
     if ((_0[_9]._getShape_().nd) > _8):
      _8 = (_0[_9]._getShape_().nd)
    _10=numpy.array([_0[0]._getShape_()._dim_I(_11) for _11 in range(0,_8)], dtype=numpy.dtype(numpy.int32))
    _12=numpy.zeros((_7,), dtype=numpy.dtype(object))
    _12[0] = mosek.fusion.Var._reshape_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2(_0[0],mosek_fusion_NDSet._ctor__3I(_10))
    for _13 in range(1,_7):
     for _14 in range(0,_8):
      if ((_14!=_1) and (_0[_13]._getShape_()._dim_I(_14)!=_10[_14])):
       raise mosek_fusion_DimensionError._ctor_S("Variable dimensions do not match")
     _10[_1] = _0[_13]._getShape_()._dim_I(_1)
     _12[_13] = mosek.fusion.Var._reshape_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2(_0[_13],mosek_fusion_NDSet._ctor__3I(_10))
    return (mosek_fusion_CompoundVariable._ctor__3Lmosek_4fusion_4Variable_2I(_12,_1))
 return Var
mosek_fusion_Var=__mk_mosek_fusion_Var()
del __mk_mosek_fusion_Var
#BEFORE CLASS
def __mk_mosek_fusion_ConstraintCache():
 class ConstraintCache(object):
  __slots__ = ['barmatidx','barsubj','barsubi','nbarnz','nunordered','buffer_subi','buffer_subj','buffer_cof','bfix','cof','subi','subj','nnz','nrows']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor__3J_3D_3I_3D_3I_3I_3I(*args): # []int64,[]double,[]int32,[]double,[]int32,[]int32,[]int32
      self._ctor_init__3J_3D_3I_3D_3I_3I_3I(*args)
    elif self.__match_alt_ctor__3J_3D_3I_3D_3I_3I_3I(*args):# []int64,[]double,[]int32,[]double,[]int32,[]int32,[]int32
      self._ctor_alt_init__3J_3D_3I_3D_3I_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ConstraintCache.ctor(array(int64,ndim=1),array(double,ndim=1),array(int32,ndim=1),array(double,ndim=1),array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))')
  def add(self,*args):
    if False: pass
    elif mosek_fusion_ConstraintCache._match_add__3J_3I_3D_3D(*args): # []int64,[]int32,[]double,[]double
      return self._add__3J_3I_3D_3D(*args)
    elif mosek_fusion_ConstraintCache._match_alt_add__3J_3I_3D_3D(*args): # []int64,[]int32,[]double,[]double
      return self._add_alt__3J_3I_3D_3D(*args)
    else:
      raise ValueError('Invalid argument list add('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ConstraintCache.add(array(int64,ndim=1),array(int32,ndim=1),array(double,ndim=1),array(double,ndim=1))')
  def flush(self,*args):
    if False: pass
    elif mosek_fusion_ConstraintCache._match_flush__3I_3I_3D_3D(*args): # []int32,[]int32,[]double,[]double
      return self._flush__3I_3I_3D_3D(*args)
    elif mosek_fusion_ConstraintCache._match_alt_flush__3I_3I_3D_3D(*args): # []int32,[]int32,[]double,[]double
      return self._flush_alt__3I_3I_3D_3D(*args)
    else:
      raise ValueError('Invalid argument list flush('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ConstraintCache.flush(array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1),array(double,ndim=1))')
  def numUnsorted(self,*args):
    if False: pass
    elif mosek_fusion_ConstraintCache._match_numUnsorted_(*args): # 
      return self._numUnsorted_(*args)
    elif mosek_fusion_ConstraintCache._match_alt_numUnsorted_(*args): # 
      return self._numUnsorted_alt_(*args)
    else:
      raise ValueError('Invalid argument list numUnsorted('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ConstraintCache.numUnsorted()')
  def __repr__(self): return 'mosek.fusion.ConstraintCache'
  @staticmethod
  def _ctor_Lmosek_4fusion_4ConstraintCache_2(cc):
    o = ConstraintCache.__new__(ConstraintCache)
    o._ctor_init_Lmosek_4fusion_4ConstraintCache_2(cc)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4ConstraintCache_2(*args):
    if len(args) != 1: return False
    cc, = args
    return (__arg_match_Lmosek_4fusion_4ConstraintCache_2__(cc))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4ConstraintCache_2(*args):
    if len(args) != 1: return False
    cc, = args
    return (__arg_alt_match_Lmosek_4fusion_4ConstraintCache_2__(cc))
  def _ctor_alt_init_Lmosek_4fusion_4ConstraintCache_2(self,cc):
    self._ctor_init_Lmosek_4fusion_4ConstraintCache_2(cc)
  def _ctor_init_Lmosek_4fusion_4ConstraintCache_2(self,cc):
   object.__init__(self)
   self.nrows = (cc.nrows)
   self.nnz = (cc.nnz)
   self.subj = (mosek.fusion.Utils.Tools._arraycopy__3I((cc.subj)) if (((cc.subj) is not None) ) else None)
   self.subi = (mosek.fusion.Utils.Tools._arraycopy__3I((cc.subi)) if (((cc.subi) is not None) ) else None)
   self.cof = (mosek.fusion.Utils.Tools._arraycopy__3D((cc.cof)) if (((cc.cof) is not None) ) else None)
   self.bfix = (mosek.fusion.Utils.Tools._arraycopy__3D((cc.bfix)) if (((cc.bfix) is not None) ) else None)
   self.buffer_cof = (mosek.fusion.Utils.Tools._arraycopy__3D((cc.buffer_cof)) if (((cc.buffer_cof) is not None) ) else None)
   self.buffer_subj = (mosek.fusion.Utils.Tools._arraycopy__3I((cc.buffer_subj)) if (((cc.buffer_subj) is not None) ) else None)
   self.buffer_subi = (mosek.fusion.Utils.Tools._arraycopy__3I((cc.buffer_subi)) if (((cc.buffer_subi) is not None) ) else None)
   self.nunordered = (cc.nunordered)
   self.nbarnz = (cc.nbarnz)
   self.barsubi = (mosek.fusion.Utils.Tools._arraycopy__3I((cc.barsubi)) if (((cc.barsubi) is not None) ) else None)
   self.barsubj = (mosek.fusion.Utils.Tools._arraycopy__3I((cc.barsubj)) if (((cc.barsubj) is not None) ) else None)
   self.barmatidx = (mosek.fusion.Utils.Tools._arraycopy__3I((cc.barmatidx)) if (((cc.barmatidx) is not None) ) else None)
  @staticmethod
  def _ctor__3J_3D_3I_3D_3I_3I_3I(ptrb_,cof_,subj_,bfix_,barsubi_,barsubj_,barmatidx_):
    o = ConstraintCache.__new__(ConstraintCache)
    o._ctor_init__3J_3D_3I_3D_3I_3I_3I(ptrb_,cof_,subj_,bfix_,barsubi_,barsubj_,barmatidx_)
    return o
  @staticmethod
  def __match_ctor__3J_3D_3I_3D_3I_3I_3I(*args):
    if len(args) != 7: return False
    ptrb_,cof_,subj_,bfix_,barsubi_,barsubj_,barmatidx_, = args
    return (__arg_match__3J__(ptrb_) and __arg_match__3D__(cof_) and __arg_match__3I__(subj_) and __arg_match__3D__(bfix_) and __arg_match__3I__(barsubi_) and __arg_match__3I__(barsubj_) and __arg_match__3I__(barmatidx_))
  @staticmethod
  def __match_alt_ctor__3J_3D_3I_3D_3I_3I_3I(*args):
    if len(args) != 7: return False
    ptrb_,cof_,subj_,bfix_,barsubi_,barsubj_,barmatidx_, = args
    return (__arg_alt_match__3J__(ptrb_) and __arg_alt_match__3D__(cof_) and __arg_alt_match__3I__(subj_) and __arg_alt_match__3D__(bfix_) and __arg_alt_match__3I__(barsubi_) and __arg_alt_match__3I__(barsubj_) and __arg_alt_match__3I__(barmatidx_))
  def _ctor_alt_init__3J_3D_3I_3D_3I_3I_3I(self,ptrb_,cof_,subj_,bfix_,barsubi_,barsubj_,barmatidx_):
    self._ctor_init__3J_3D_3I_3D_3I_3I_3I(numpy.array(ptrb_,dtype=numpy.dtype(numpy.int64)),numpy.array(cof_,dtype=numpy.dtype(numpy.float64)),numpy.array(subj_,dtype=numpy.dtype(numpy.int32)),numpy.array(bfix_,dtype=numpy.dtype(numpy.float64)),numpy.array(barsubi_,dtype=numpy.dtype(numpy.int32)),numpy.array(barsubj_,dtype=numpy.dtype(numpy.int32)),numpy.array(barmatidx_,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init__3J_3D_3I_3D_3I_3I_3I(self,ptrb_,cof_,subj_,bfix_,barsubi_,barsubj_,barmatidx_):
   object.__init__(self)
   self.nrows = (int((ptrb_).shape[0]) - 1)
   self.nnz = ptrb_[(int((ptrb_).shape[0]) - 1)]
   self.subj = numpy.zeros((self.nnz,), dtype=numpy.dtype(numpy.int32))
   self.subi = numpy.zeros((self.nnz,), dtype=numpy.dtype(numpy.int32))
   self.cof = numpy.zeros((self.nnz,), dtype=numpy.dtype(numpy.float64))
   if (bfix_ is not None):
    self.bfix = bfix_
   else:
    self.bfix = numpy.zeros((self.nrows,), dtype=numpy.dtype(numpy.float64))
   if ((barsubi_ is not None) and ((barsubj_ is not None) and (barmatidx_ is not None))):
    self.nbarnz = int((barsubi_).shape[0])
    if (self.nbarnz > int((barsubj_).shape[0])):
     self.nbarnz = int((barsubj_).shape[0])
    if (self.nbarnz > int((barmatidx_).shape[0])):
     self.nbarnz = int((barmatidx_).shape[0])
    self.barsubi = numpy.zeros((self.nbarnz,), dtype=numpy.dtype(numpy.int32))
    self.barsubj = numpy.zeros((self.nbarnz,), dtype=numpy.dtype(numpy.int32))
    self.barmatidx = numpy.zeros((self.nbarnz,), dtype=numpy.dtype(numpy.int32))
    mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(barsubi_,0,self.barsubi,0,self.nbarnz)
    mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(barsubj_,0,self.barsubj,0,self.nbarnz)
    mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(barmatidx_,0,self.barmatidx,0,self.nbarnz)
   else:
    self.nbarnz = 0
    self.barsubi = None
    self.barsubj = None
    self.barmatidx = None
   mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(subj_,0,self.subj,0,self.nnz)
   mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ(cof_,0,self.cof,0,self.nnz)
   fragments._c_closure_148(self.nrows,ptrb_,self.subi) # src/fusion/ConstraintCache.mbi:103:9-105:25
   self.buffer_cof = None
   self.buffer_subj = None
   self.buffer_subi = None
   self.nunordered = 0
  def _unchecked_1add_1fx_alt__3D(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = self._unchecked_1add_1fx__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _unchecked_1add_1fx__3D(self,_0):
   fragments._c_closure_149(self.bfix,_0,self.nrows) # src/fusion/ConstraintCache.mbi:476:7-479:8
  def _order_1barentries_alt_(self,):
    return self._order_1barentries_()
  def _order_1barentries_(self,):
   _0=numpy.array([_1 for _1 in range(0,self.nbarnz)], dtype=numpy.dtype(numpy.int64))
   if (not mosek.fusion.Sort._issorted__3J_3I_3IJJZ(_0,self.barsubi,self.barsubj,0,self.nbarnz,False)):
    mosek.fusion.Sort._argsort__3J_3I_3IJJZ(_0,self.barsubi,self.barsubj,0,self.nbarnz,False)
    _2=self.barsubi
    _3=self.barsubj
    _4=self.barmatidx
    self.barsubi = numpy.array([_2[_0[_5]] for _5 in range(0,self.nbarnz)], dtype=numpy.dtype(numpy.int32))
    self.barsubj = numpy.array([_3[_0[_6]] for _6 in range(0,self.nbarnz)], dtype=numpy.dtype(numpy.int32))
    self.barmatidx = numpy.array([_4[_0[_7]] for _7 in range(0,self.nbarnz)], dtype=numpy.dtype(numpy.int32))
   return numpy.int64(self.nbarnz)
  def _add_1bar_alt__3I_3I_3I(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = self._add_1bar__3I_3I_3I(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _add_1bar__3I_3I_3I(self,_0,_1,_2):
   if (_0 is not None):
    _3=int((_0).shape[0])
    if (int((_0).shape[0]) <= (self.nbarnz + _3)):
     _4=self.barsubi
     _5=self.barsubj
     _6=self.barmatidx
     _7=((2 * self.nbarnz) if (((2 * self.nbarnz) > (self.nbarnz + _3)) ) else (self.nbarnz + (_3 * 2)))
     self.barsubi = numpy.zeros((_7,), dtype=numpy.dtype(numpy.int32))
     self.barsubj = numpy.zeros((_7,), dtype=numpy.dtype(numpy.int32))
     self.barmatidx = numpy.zeros((_7,), dtype=numpy.dtype(numpy.int32))
     if (self.nbarnz > 0):
      mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(_4,0,self.barsubi,0,self.nbarnz)
      mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(_5,0,self.barsubj,0,self.nbarnz)
      mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(_6,0,self.barmatidx,0,self.nbarnz)
    mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(_0,0,self.barsubi,self.nbarnz,_3)
    mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(_1,0,self.barsubj,self.nbarnz,_3)
    mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(_2,0,self.barmatidx,self.nbarnz,_3)
    self.nbarnz += _3
  def _unchecked_1add_1l_alt__3J_3I_3D_3D(self,_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.float64))
   _1 = self._unchecked_1add_1l__3J_3I_3D_3D(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _unchecked_1add_1l__3J_3I_3D_3D(self,_0,_1,_2,_3):
   _4=(self.nunordered + _0[self.nrows])
   _5=_0[self.nrows]
   if ((self.buffer_cof is None) or (int((self.buffer_cof).shape[0]) < _4)):
    _6 = numpy.zeros((_4,), dtype=numpy.dtype(numpy.int32))
    _7 = numpy.zeros((_4,), dtype=numpy.dtype(numpy.int32))
    _8 = numpy.zeros((_4,), dtype=numpy.dtype(numpy.float64))
    if (self.buffer_cof is not None):
     mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(self.buffer_subi,0,_6,0,self.nunordered)
     mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(self.buffer_subj,0,_7,0,self.nunordered)
     mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ(self.buffer_cof,0,_8,0,self.nunordered)
   else:
    _6 = self.buffer_subi
    _7 = self.buffer_subj
    _8 = self.buffer_cof
   fragments._c_closure_150(self.nrows,self.nunordered,_0,_6) # src/fusion/ConstraintCache.mbi:403:9-405:40
   mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(_1,0,_7,self.nunordered,_5)
   mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ(_2,0,_8,self.nunordered,_5)
   self.buffer_subi = _6
   self.buffer_subj = _7
   self.buffer_cof = _8
   fragments._c_closure_151(self.bfix,_3,self.nrows) # src/fusion/ConstraintCache.mbi:413:9-415:42
   self.nunordered = _4
  @staticmethod
  def _match_add__3J_3I_3D_3D(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match__3J__(_0) and __arg_match__3I__(_1) and __arg_match__3D__(_2) and __arg_match__3D__(_3))
  @staticmethod
  def _match_alt_add__3J_3I_3D_3D(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match__3D__(_3))
  def _add_alt__3J_3I_3D_3D(self,_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.float64))
   _1 = self._add__3J_3I_3D_3D(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _add__3J_3I_3D_3D(self,_0,_1,_2,_3):
   if ((int((_0).shape[0])!=(self.nrows + 1)) or ((_3 is not None) and (int((_3).shape[0])!=self.nrows))):
    raise mosek_fusion_LengthError._ctor_S("Mismatching expression lengths")
   self._unchecked_1add_1l__3J_3I_3D_3D(_0,_1,_2,_3)
  @staticmethod
  def _match_flush__3I_3I_3D_3D(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match__3D__(_2) and __arg_match__3D__(_3))
  @staticmethod
  def _match_alt_flush__3I_3I_3D_3D(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match__3D__(_3))
  def _flush_alt__3I_3I_3D_3D(self,_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.float64))
   _1 = self._flush__3I_3I_3D_3D(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _flush__3I_3I_3D_3D(self,_0,_1,_2,_3):
   _4=None
   fragments._c_closure_152(self.bfix,self.nrows,_3) # src/fusion/ConstraintCache.mbi:170:9-172:34
   if (self.nunordered==0):
    return numpy.int64(0)
   _5=False
   _5 = fragments._c_closure_153(self.buffer_subi,self.buffer_subj,_5,self.nunordered) # src/fusion/ConstraintCache.mbi:180:9-184:10
   if (not _5):
    _4 = numpy.array([_6 for _6 in range(0,self.nunordered)], dtype=numpy.dtype(numpy.int64))
    mosek.fusion.CommonTools._argQsort__3J_3I_3IJJ(_4,self.buffer_subi,self.buffer_subj,0,self.nunordered)
   _7=self.nnz
   _8=numpy.zeros(((self.nunordered + _7),), dtype=numpy.dtype(numpy.int32))
   _9=numpy.zeros(((self.nunordered + _7),), dtype=numpy.dtype(numpy.int32))
   _10=numpy.zeros(((self.nunordered + _7),), dtype=numpy.dtype(numpy.float64))
   _11=0
   self.nnz,_11 = fragments._c_closure_154(self.buffer_cof,self.buffer_subi,self.buffer_subj,self.cof,_5,self.nnz,_7,self.nunordered,_11,_4,_10,_8,_9,_2,_0,_1,self.subi,self.subj) # src/fusion/ConstraintCache.mbi:199:9-328:10
   self.nnz = numpy.int64(self.nnz) # postprocess
   _11 = numpy.int64(_11) # postprocess
   self.subi = _8
   self.subj = _9
   self.cof = _10
   self.nunordered = 0
   return numpy.int64(_11)
  @staticmethod
  def _match_numUnsorted_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_numUnsorted_(*args):
    if len(args) != 0: return False
    return True
  def _numUnsorted_alt_(self,):
    return self._numUnsorted_()
  def _numUnsorted_(self,):
   return numpy.int64(self.nunordered)
  def _clone_alt_(self,):
    return self._clone_()
  def _clone_(self,):
   return (mosek_fusion_ConstraintCache._ctor_Lmosek_4fusion_4ConstraintCache_2(self))
 return ConstraintCache
mosek_fusion_ConstraintCache=__mk_mosek_fusion_ConstraintCache()
del __mk_mosek_fusion_ConstraintCache
#BEFORE CLASS
def __mk_mosek_fusion_Constraint():
 class Constraint(object):
  __slots__ = ['_shape_p','_model']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(*args): # mosek.fusion.Constraint,mosek.fusion.Model
      self._ctor_init_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(*args):# mosek.fusion.Constraint,mosek.fusion.Model
      self._ctor_alt_init_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(*args)
    elif self.__match_ctor_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Set_2(*args): # mosek.fusion.Model,mosek.fusion.Set
      self._ctor_init_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Set_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Set_2(*args):# mosek.fusion.Model,mosek.fusion.Set
      self._ctor_alt_init_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Set_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.Constraint.ctor(mosek.fusion.Constraint,mosek.fusion.Model)\n\tmosek.fusion.Constraint.ctor(mosek.fusion.Model,mosek.fusion.Set)')
  def get_model(self,*args):
    if False: pass
    elif mosek_fusion_Constraint._match_get_1model_(*args): # 
      return self._get_1model_(*args)
    elif mosek_fusion_Constraint._match_alt_get_1model_(*args): # 
      return self._get_1model_alt_(*args)
    else:
      raise ValueError('Invalid argument list get_model('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.get_model()')
  def slice(self,*args):
    if False: pass
    elif mosek_fusion_Constraint._match_slice_II(*args): # int32,int32
      return self._slice_II(*args)
    elif mosek_fusion_Constraint._match_alt_slice_II(*args): # int32,int32
      return self._slice_alt_II(*args)
    elif mosek_fusion_Constraint._match_slice__3I_3I(*args): # []int32,[]int32
      return self._slice__3I_3I(*args)
    elif mosek_fusion_Constraint._match_alt_slice__3I_3I(*args): # []int32,[]int32
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.slice(int32,int32)\n\tmosek.fusion.Constraint.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def size(self,*args):
    if False: pass
    elif mosek_fusion_Constraint._match_size_(*args): # 
      return self._size_(*args)
    elif mosek_fusion_Constraint._match_alt_size_(*args): # 
      return self._size_alt_(*args)
    else:
      raise ValueError('Invalid argument list size('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.size()')
  @staticmethod
  def stack(*args):
    if False: pass
    elif mosek_fusion_Constraint._match_stack__3Lmosek_4fusion_4Constraint_2(*args): # []mosek.fusion.Constraint
      return mosek_fusion_Constraint._stack__3Lmosek_4fusion_4Constraint_2(*args)
    elif mosek_fusion_Constraint._match_alt_stack__3Lmosek_4fusion_4Constraint_2(*args): # []mosek.fusion.Constraint
      return mosek_fusion_Constraint._stack_alt__3Lmosek_4fusion_4Constraint_2(*args)
    elif mosek_fusion_Constraint._match_stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args): # mosek.fusion.Constraint,mosek.fusion.Constraint
      return mosek_fusion_Constraint._stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args)
    elif mosek_fusion_Constraint._match_alt_stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args): # mosek.fusion.Constraint,mosek.fusion.Constraint
      return mosek_fusion_Constraint._stack_alt_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args)
    elif mosek_fusion_Constraint._match_stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args): # mosek.fusion.Constraint,mosek.fusion.Constraint,mosek.fusion.Constraint
      return mosek_fusion_Constraint._stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args)
    elif mosek_fusion_Constraint._match_alt_stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args): # mosek.fusion.Constraint,mosek.fusion.Constraint,mosek.fusion.Constraint
      return mosek_fusion_Constraint._stack_alt_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args)
    else:
      raise ValueError('Invalid argument list stack('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.stack(array(mosek.fusion.Constraint,ndim=1))\n\tmosek.fusion.Constraint.stack(mosek.fusion.Constraint,mosek.fusion.Constraint)\n\tmosek.fusion.Constraint.stack(mosek.fusion.Constraint,mosek.fusion.Constraint,mosek.fusion.Constraint)')
  def index(self,*args):
    if False: pass
    elif mosek_fusion_Constraint._match_index_I(*args): # int32
      return self._index_I(*args)
    elif mosek_fusion_Constraint._match_alt_index_I(*args): # int32
      return self._index_alt_I(*args)
    elif mosek_fusion_Constraint._match_index__3I(*args): # []int32
      return self._index__3I(*args)
    elif mosek_fusion_Constraint._match_alt_index__3I(*args): # []int32
      return self._index_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list index('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.index(int32)\n\tmosek.fusion.Constraint.index(array(int32,ndim=1))')
  def get_nd(self,*args):
    if False: pass
    elif mosek_fusion_Constraint._match_get_1nd_(*args): # 
      return self._get_1nd_(*args)
    elif mosek_fusion_Constraint._match_alt_get_1nd_(*args): # 
      return self._get_1nd_alt_(*args)
    else:
      raise ValueError('Invalid argument list get_nd('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.get_nd()')
  def shape(self,*args):
    if False: pass
    elif mosek_fusion_Constraint._match_shape_(*args): # 
      return self._shape_(*args)
    elif mosek_fusion_Constraint._match_alt_shape_(*args): # 
      return self._shape_alt_(*args)
    else:
      raise ValueError('Invalid argument list shape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.shape()')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_Constraint._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_Constraint._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.toString()')
  def level(self,*args):
    if False: pass
    elif mosek_fusion_Constraint._match_level_(*args): # 
      return self._level_(*args)
    elif mosek_fusion_Constraint._match_alt_level_(*args): # 
      return self._level_alt_(*args)
    else:
      raise ValueError('Invalid argument list level('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.level()')
  def add(self,*args):
    if False: pass
    elif mosek_fusion_Constraint._match_add_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      return self._add_Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Constraint._match_alt_add_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      return self._add_alt_Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Constraint._match_add_Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable
      return self._add_Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Constraint._match_alt_add_Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable
      return self._add_alt_Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Constraint._match_add__3D(*args): # []double
      return self._add__3D(*args)
    elif mosek_fusion_Constraint._match_alt_add__3D(*args): # []double
      return self._add_alt__3D(*args)
    elif mosek_fusion_Constraint._match_add_D(*args): # double
      return self._add_D(*args)
    elif mosek_fusion_Constraint._match_alt_add_D(*args): # double
      return self._add_alt_D(*args)
    else:
      raise ValueError('Invalid argument list add('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.add(mosek.fusion.Expression)\n\tmosek.fusion.Constraint.add(mosek.fusion.Variable)\n\tmosek.fusion.Constraint.add(array(double,ndim=1))\n\tmosek.fusion.Constraint.add(double)')
  def dual(self,*args):
    if False: pass
    elif mosek_fusion_Constraint._match_dual_(*args): # 
      return self._dual_(*args)
    elif mosek_fusion_Constraint._match_alt_dual_(*args): # 
      return self._dual_alt_(*args)
    elif mosek_fusion_Constraint._match_dual_II(*args): # int32,int32
      return self._dual_II(*args)
    elif mosek_fusion_Constraint._match_alt_dual_II(*args): # int32,int32
      return self._dual_alt_II(*args)
    elif mosek_fusion_Constraint._match_dual__3I_3I(*args): # []int32,[]int32
      return self._dual__3I_3I(*args)
    elif mosek_fusion_Constraint._match_alt_dual__3I_3I(*args): # []int32,[]int32
      return self._dual_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list dual('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.dual()\n\tmosek.fusion.Constraint.dual(int32,int32)\n\tmosek.fusion.Constraint.dual(array(int32,ndim=1),array(int32,ndim=1))')
  def __repr__(self): return 'mosek.fusion.Constraint'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(c,m):
    o = Constraint.__new__(Constraint)
    o._ctor_init_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(c,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_match_Lmosek_4fusion_4Constraint_2__(c) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4Constraint_2__(c) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(self,c,m):
    self._ctor_init_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(c,m)
  def _ctor_init_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(self,c,m):
   object.__init__(self)
   self._model = m
   self._shape_p = (c._shape_p)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Set_2(model_,shape_):
    o = Constraint.__new__(Constraint)
    o._ctor_init_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Set_2(model_,shape_)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Set_2(*args):
    if len(args) != 2: return False
    model_,shape_, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model_) and __arg_match_Lmosek_4fusion_4Set_2__(shape_))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Set_2(*args):
    if len(args) != 2: return False
    model_,shape_, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model_) and __arg_alt_match_Lmosek_4fusion_4Set_2__(shape_))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Set_2(self,model_,shape_):
    self._ctor_init_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Set_2(model_,shape_)
  def _ctor_init_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Set_2(self,model_,shape_):
   object.__init__(self)
   self._model = model_
   self._shape_p = shape_
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=(self._shape_p._size)
   _1=numpy.zeros((_0,), dtype=numpy.dtype(object))
   self._toStringArray__3JJ_3S(mosek.fusion.Utils.Tools._range_J(_0),0,_1)
   _2=mosek.fusion.Utils.StringBuffer()
   _2._a_S("Constraint( (")._a_I(self._shape_p._dim_I(0))
   for _3 in range(1,(self._shape_p.nd)):
    _2._a_S(",")._a_I(self._shape_p._dim_I(_3))
   _2._a_S("),")._lf_()
   _2._a_S("  ")._a_S(_1[0])
   for _4 in range(1,int((_1).shape[0])):
    _2._a_S(",")._lf_()._a_S("  ")._a_S(_1[_4])
   _2._a_S(" )")
   return (_2._toString_())
  def _toStringArray_alt__3JJ_3S(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(object))
   _1 = self._toStringArray__3JJ_3S(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _toStringArray__3JJ_3S(self,_0,_1,_2):
   pass
  @staticmethod
  def _match_add_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_D__(_0))
  @staticmethod
  def _match_alt_add_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_D__(_0))
  def _add_alt_D(self,_t__0):
    return self._add_D(numpy.float64(__0))
  def _add_D(self,_0):
   _1=(self._shape_p._size)
   self._add_1l__3J_3J_3I_3I_3I_3D_3DJII(numpy.array([_2 for _2 in range(0,_1)], dtype=numpy.dtype(numpy.int64)),numpy.array([0 for _3 in range(0,(_1 + 1))], dtype=numpy.dtype(numpy.int64)),numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),numpy.zeros((0,), dtype=numpy.dtype(numpy.float64)),numpy.array([_0 for _4 in range(0,_1)], dtype=numpy.dtype(numpy.float64)),0,0,numpy.int32(_1))
   return (self)
  @staticmethod
  def _match_add__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_add__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  def _add_alt__3D(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = self._add__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _add__3D(self,_0):
   _1=(self._shape_p._size)
   if (((self._shape_p.nd)!=1) or (int((_0).shape[0])!=self._shape_p._dim_I(0))):
    raise mosek_fusion_DimensionError._ctor_S("The added constant array does not have the same shape as the constraint")
   self._add_1l__3J_3J_3I_3I_3I_3D_3DJII(numpy.array([_2 for _2 in range(0,_1)], dtype=numpy.dtype(numpy.int64)),numpy.array([0 for _3 in range(0,(_1 + 1))], dtype=numpy.dtype(numpy.int64)),numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),numpy.zeros((0,), dtype=numpy.dtype(numpy.float64)),_0,0,0,numpy.int32(_1))
   return (self)
  @staticmethod
  def _match_add_Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0))
  def _add_alt_Lmosek_4fusion_4Variable_2(self,_t__0):
    return self._add_Lmosek_4fusion_4Variable_2(_0)
  def _add_Lmosek_4fusion_4Variable_2(self,_0):
   if (not _0._shape_()._compare_Lmosek_4fusion_4Set_2(self._shape_p)):
    raise mosek_fusion_DimensionError._ctor_S("The added variable does not have the same shape as the constraint")
   _1=(_0._getShape_()._size)
   _2=numpy.zeros((_1,), dtype=numpy.dtype(numpy.int32))
   _3=numpy.zeros((_1,), dtype=numpy.dtype(numpy.int32))
   _4=numpy.zeros((_1,), dtype=numpy.dtype(numpy.int32))
   _5=mosek.fusion.Utils.Tools._range_JJ(0,(_1 + 1))
   _6=numpy.zeros((_1,), dtype=numpy.dtype(numpy.float64))
   for _7 in range(0,_1):
    _0._inst_JJ_3I_3I_3I(_7,_7,_2,_3,_4)
    _6[_7] = 1.0
   _8=mosek.fusion.Utils.Tools._range_JJ(0,_1)
   self._add_1l__3J_3J_3I_3I_3I_3D_3DJII(_8,_5,_2,_3,_3,_6,None,0,0,numpy.int32(_1))
   return (self)
  @staticmethod
  def _match_add_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0))
  def _add_alt_Lmosek_4fusion_4Expression_2(self,_t__0):
    return self._add_Lmosek_4fusion_4Expression_2(_0)
  def _add_Lmosek_4fusion_4Expression_2(self,_0):
   if (not _0._shape_()._compare_Lmosek_4fusion_4Set_2(self._shape_p)):
    raise mosek_fusion_DimensionError._ctor_S("The added expression does not have the same shape as the constraint")
   _1=_0._eval_()
   _2=(int(((_1.ptrb)).shape[0]) - 1)
   _3=numpy.zeros(((_1.nnz),), dtype=numpy.dtype(numpy.int32))
   _4=numpy.zeros(((_1.nnz),), dtype=numpy.dtype(numpy.int32))
   _5=numpy.zeros(((_1.nnz),), dtype=numpy.dtype(numpy.int32))
   mosek.fusion.Constraint._inst__3Lmosek_4fusion_4Variable_2_3J_3I_3I_3I((_1.x),(_1.subj),_3,_3,_3)
   _6=(_1.inst)
   if (_6 is None):
    _6 = mosek.fusion.Utils.Tools._range_JJ(0,numpy.int64(_2))
   self._add_1l__3J_3J_3I_3I_3I_3D_3DJII(_6,(_1.ptrb),_3,_4,_5,(_1.cof),(_1.bfix),0,0,_2)
   return (self)
  @staticmethod
  def _inst_alt__3Lmosek_4fusion_4Variable_2_3J_3I_3I_3I(_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Constraint._inst__3Lmosek_4fusion_4Variable_2_3J_3I_3I_3I(_0,_1,_2,_3,_4)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _inst__3Lmosek_4fusion_4Variable_2_3J_3I_3I_3I(_0,_1,_2,_3,_4):
   _5=numpy.zeros(((int((_0).shape[0]) + 1),), dtype=numpy.dtype(numpy.int64))
   for _6 in range(0,int((_0).shape[0])):
    _5[(_6 + 1)] = (_5[_6] + _0[_6]._size_())
   for _7 in range(0,int((_1).shape[0])):
    _8=(int((_5).shape[0]) // 2)
    _8 = fragments._c_closure_155(_7,_8,_1,_5) # src/fusion/Constraint.mbi:631:11-644:12
    _8 = numpy.int32(_8) # postprocess
    _0[_8]._inst_JJ_3I_3I_3I((_1[_7] - _5[_8]),numpy.int64(_7),_2,_3,_4)
  def _add_1l_alt__3J_3J_3I_3I_3I_3D_3DJII(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7,_t__8,_t__9):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int32))
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.float64))
   _6=numpy.array(_t__6,dtype=numpy.dtype(numpy.float64))
   _7=numpy.int64(_t__7)
   _8=numpy.int32(_t__8)
   _9=numpy.int32(_t__9)
   _1 = self._add_1l__3J_3J_3I_3I_3I_3D_3DJII(_0,_1,_2,_3,_4,_5,_6,_7,_8,_9)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__6[:] = _6
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _add_1l__3J_3J_3I_3I_3I_3D_3DJII(self,_0,_1,_2,_3,_4,_5,_6,_7,_8,_9):
   pass
  @staticmethod
  def _match_dual__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_dual__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _dual_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._dual__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual__3I_3I(self,_0,_1):
   if (((self._shape_p.nd)!=int((_0).shape[0])) or ((self._shape_p.nd)!=int((_1).shape[0]))):
    raise mosek_fusion_SliceError._ctor_S("Invalid slice specification")
   _2=1
   _3=0
   while (_3 < (self._shape_p.nd)):
    if ((_0[_3] > _1[_3]) or ((_0[_3] < 0) or (_1[_3] >= self._shape_p._dim_I(_3)))):
     raise mosek_fusion_SliceError._ctor_S("Slice index out of bound")
    _2 = (_2 * (_1[_3] * _0[_3]))
    _3 += 1
   _4=numpy.zeros((_2,), dtype=numpy.dtype(numpy.float64))
   _5=numpy.zeros(((self._shape_p.nd),), dtype=numpy.dtype(numpy.int32))
   _6=numpy.zeros(((self._shape_p.nd),), dtype=numpy.dtype(numpy.int64))
   _7=0
   for _8 in range(0,(self._shape_p.nd)):
    _5[_8] = (_1[_8] - _0[_8])
    _6[_8] = self._shape_p._stride_I(_8)
    _7 = (_7 + (_6[_8] * _0[_8]))
   self._dual_1values_J_3I_3JI_3D(_7,_5,_6,0,_4)
   return (_4)
  @staticmethod
  def _match_dual_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_dual_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _dual_alt_II(self,_t__0,_t__1):
    return self._dual_II(numpy.int32(__0),numpy.int32(__1))
  def _dual_II(self,_0,_1):
   if (((self._shape_p.nd)!=1) or ((_0 > _1) or ((_0 < 0) or (_1 >= self._shape_p._dim_I(0))))):
    raise mosek_fusion_SliceError._ctor_S("Invalid slice specification")
   _2=(_1 - _0)
   _3=numpy.zeros((_2,), dtype=numpy.dtype(numpy.float64))
   self._dual_1values_J_3I_3JI_3D(_0,numpy.array([_2], dtype=numpy.dtype(numpy.int32)),numpy.array([1], dtype=numpy.dtype(numpy.int64)),0,_3)
   return (_3)
  @staticmethod
  def _match_dual_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_dual_(*args):
    if len(args) != 0: return False
    return True
  def _dual_alt_(self,):
    return self._dual_()
  def _dual_(self,):
   _0=numpy.zeros(((self._shape_p._size),), dtype=numpy.dtype(numpy.float64))
   self._dual_1values_I_3D(0,_0)
   return (_0)
  def _dual_1values_alt_I_3D(self,_t__0,_t__1):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1values_I_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1values_I_3D(self,_0,_1):
   _2=numpy.array([self._shape_p._dim_I(_3) for _3 in range(0,(self._shape_p.nd))], dtype=numpy.dtype(numpy.int32))
   _4=numpy.array([self._shape_p._stride_I(_5) for _5 in range(0,(self._shape_p.nd))], dtype=numpy.dtype(numpy.int64))
   self._dual_1values_J_3I_3JI_3D(0,_2,_4,_0,_1)
  def _dual_1values_alt__3JI_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1values__3JI_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1values__3JI_3D(self,_0,_1,_2):
   pass
  def _dual_1values_alt_J_3I_3JI_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1values_J_3I_3JI_3D(_0,_1,_2,_3,_4)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1values_J_3I_3JI_3D(self,_0,_1,_2,_3,_4):
   pass
  @staticmethod
  def _match_level_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_level_(*args):
    if len(args) != 0: return False
    return True
  def _level_alt_(self,):
    return self._level_()
  def _level_(self,):
   _0=numpy.zeros(((self._shape_p._size),), dtype=numpy.dtype(numpy.float64))
   self._level_1values_I_3D(0,_0)
   return (_0)
  def _level_alt_I(self,_t__0):
    return self._level_I(numpy.int32(__0))
  def _level_I(self,_0):
   if (((self._shape_p.nd)!=1) or ((_0 < 0) or (_0 >= self._shape_p._dim_I(0)))):
    raise mosek_fusion_SliceError._ctor_S("Invalid index.")
   _1=numpy.array([numpy.int64(_0)], dtype=numpy.dtype(numpy.int64))
   _2=numpy.zeros((1,), dtype=numpy.dtype(numpy.float64))
   self._level_1values__3JI_3D(_1,0,_2)
   return numpy.float64(_2[0])
  def _level_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._level__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _level__3I_3I(self,_0,_1):
   if (((self._shape_p.nd)!=int((_0).shape[0])) or ((self._shape_p.nd)!=int((_1).shape[0]))):
    raise mosek_fusion_SliceError._ctor_S("Invalid slice specification")
   _2=1
   _3=0
   while (_3 < (self._shape_p.nd)):
    if ((_0[_3] > _1[_3]) or ((_0[_3] < 0) or (_1[_3] > self._shape_p._dim_I(_3)))):
     raise mosek_fusion_SliceError._ctor_S("Slice index out of bound")
    _2 = (_2 * (_1[_3] - _0[_3]))
    _3 += 1
   _4=numpy.zeros((_2,), dtype=numpy.dtype(numpy.float64))
   if (_2 > 0):
    _5=numpy.zeros(((self._shape_p.nd),), dtype=numpy.dtype(numpy.int32))
    _6=numpy.zeros(((self._shape_p.nd),), dtype=numpy.dtype(numpy.int64))
    for _7 in range(0,(self._shape_p.nd)):
     _6[_7] = self._shape_p._stride_I(_7)
    for _8 in range(0,(self._shape_p.nd)):
     _5[_8] = (_1[_8] - _0[_8])
    _9=0
    for _10 in range(0,(self._shape_p.nd)):
     _9 = (_9 + (numpy.int64(_0[_10]) * _6[_10]))
    self._level_1values_J_3I_3JI_3D(_9,_5,_6,0,_4)
   return (_4)
  def _level_alt_II(self,_t__0,_t__1):
    return self._level_II(numpy.int32(__0),numpy.int32(__1))
  def _level_II(self,_0,_1):
   if (((self._shape_p.nd)!=1) or ((_0 < 0) or ((_0 > _1) or (_1 > self._shape_p._dim_I(0))))):
    raise mosek_fusion_SliceError._ctor_S("Invalid slice specification")
   _2=(_1 - _0)
   _3=numpy.zeros((_2,), dtype=numpy.dtype(numpy.float64))
   _4=numpy.array([(_1 - _0)], dtype=numpy.dtype(numpy.int32))
   _5=numpy.array([1], dtype=numpy.dtype(numpy.int64))
   self._level_1values_J_3I_3JI_3D(numpy.int64(_0),_4,_5,0,_3)
   return (_3)
  def _level_1values_alt_I_3D(self,_t__0,_t__1):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = self._level_1values_I_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _level_1values_I_3D(self,_0,_1):
   _2=numpy.array([self._shape_p._stride_I(_3) for _3 in range(0,(self._shape_p.nd))], dtype=numpy.dtype(numpy.int64))
   _4=numpy.array([self._shape_p._dim_I(_5) for _5 in range(0,(self._shape_p.nd))], dtype=numpy.dtype(numpy.int32))
   self._level_1values_J_3I_3JI_3D(0,_4,_2,_0,_1)
  def _level_1values_alt__3JI_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._level_1values__3JI_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _level_1values__3JI_3D(self,_0,_1,_2):
   pass
  def _level_1values_alt_J_3I_3JI_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = self._level_1values_J_3I_3JI_3D(_0,_1,_2,_3,_4)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _level_1values_J_3I_3JI_3D(self,_0,_1,_2,_3,_4):
   pass
  @staticmethod
  def _match_get_1model_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_get_1model_(*args):
    if len(args) != 0: return False
    return True
  def _get_1model_alt_(self,):
    return self._get_1model_()
  def _get_1model_(self,):
   return (self._model)
  @staticmethod
  def _match_get_1nd_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_get_1nd_(*args):
    if len(args) != 0: return False
    return True
  def _get_1nd_alt_(self,):
    return self._get_1nd_()
  def _get_1nd_(self,):
   return numpy.int32((self._shape_p._nd_p))
  @staticmethod
  def _match_size_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_size_(*args):
    if len(args) != 0: return False
    return True
  def _size_alt_(self,):
    return self._size_()
  def _size_(self,):
   return numpy.int64((self._shape_p._size))
  @staticmethod
  def _match_stack__3Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3Lmosek_4fusion_4Constraint_2__(_0))
  @staticmethod
  def _match_alt_stack__3Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Constraint_2__(_0))
  @staticmethod
  def _stack_alt__3Lmosek_4fusion_4Constraint_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Constraint._stack__3Lmosek_4fusion_4Constraint_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _stack__3Lmosek_4fusion_4Constraint_2(_0):
   return (mosek_fusion_CompoundConstraint._ctor__3Lmosek_4fusion_4Constraint_2(_0))
  @staticmethod
  def _match_stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Constraint_2__(_0) and __arg_match_Lmosek_4fusion_4Constraint_2__(_1) and __arg_match_Lmosek_4fusion_4Constraint_2__(_2))
  @staticmethod
  def _match_alt_stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Constraint_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Constraint_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Constraint_2__(_2))
  @staticmethod
  def _stack_alt_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Constraint._stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(_0,_1,_2)
  @staticmethod
  def _stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(_0,_1,_2):
   _3=numpy.array([_0,_1], dtype=numpy.dtype(object))
   return (mosek_fusion_CompoundConstraint._ctor__3Lmosek_4fusion_4Constraint_2(_3))
  @staticmethod
  def _match_stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Constraint_2__(_0) and __arg_match_Lmosek_4fusion_4Constraint_2__(_1))
  @staticmethod
  def _match_alt_stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Constraint_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Constraint_2__(_1))
  @staticmethod
  def _stack_alt_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(_t__0,_t__1):
    return mosek_fusion_Constraint._stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(_0,_1)
  @staticmethod
  def _stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(_0,_1):
   _2=numpy.array([_0,_1], dtype=numpy.dtype(object))
   return (mosek_fusion_CompoundConstraint._ctor__3Lmosek_4fusion_4Constraint_2(_2))
  @staticmethod
  def _match_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _index_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._index__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _index__3I(self,_0):
   return (self._slice__3I_3I(_0,numpy.array([(_0[_1] + 1) for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32))).__reduceDims_())
  @staticmethod
  def _match_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _index_alt_I(self,_t__0):
    return self._index_I(numpy.int32(__0))
  def _index_I(self,_0):
   return (self._slice_II(_0,(_0 + 1)))
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _slice_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._slice__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice__3I_3I(self,_0,_1):
   pass
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _slice_alt_II(self,_t__0,_t__1):
    return self._slice_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_II(self,_0,_1):
   pass
  def __reduceDims_alt_(self,):
    return self.__reduceDims_()
  def __reduceDims_(self,):
   if ((self._shape_p.nd) > 1):
    _0=self._shape_p._realnd_()
    _1=numpy.zeros((_0,), dtype=numpy.dtype(numpy.int32))
    _2=0
    _3=0
    while (_3 < _0):
     if (self._shape_p._dim_I(_3) > 1):
      _1[_2] = self._shape_p._dim_I(_3)
      _2 += 1
     _3 += 1
    self._shape_p = mosek_fusion_NDSet._ctor__3I(_1)
   return (self)
  @staticmethod
  def _match_shape_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_shape_(*args):
    if len(args) != 0: return False
    return True
  def _shape_alt_(self,):
    return self._shape_()
  def _shape_(self,):
   return (self._shape_p)
 return Constraint
mosek_fusion_Constraint=__mk_mosek_fusion_Constraint()
del __mk_mosek_fusion_Constraint
#BEFORE CLASS
def __mk_mosek_fusion_CompoundConstraint():
 class CompoundConstraint(mosek_fusion_Constraint):
  __slots__ = ['_CompoundConstraint__stackdim','_CompoundConstraint__consb','_CompoundConstraint__cons']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor__3Lmosek_4fusion_4Constraint_2(*args): # []mosek.fusion.Constraint
      self._ctor_init__3Lmosek_4fusion_4Constraint_2(*args)
    elif self.__match_alt_ctor__3Lmosek_4fusion_4Constraint_2(*args):# []mosek.fusion.Constraint
      self._ctor_alt_init__3Lmosek_4fusion_4Constraint_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.CompoundConstraint.ctor(array(mosek.fusion.Constraint,ndim=1))')
  def slice(self,*args):
    if False: pass
    elif mosek_fusion_CompoundConstraint._match_slice_II(*args): # int32,int32
      return self._slice_II(*args)
    elif mosek_fusion_CompoundConstraint._match_alt_slice_II(*args): # int32,int32
      return self._slice_alt_II(*args)
    elif mosek_fusion_CompoundConstraint._match_slice__3I_3I(*args): # []int32,[]int32
      return self._slice__3I_3I(*args)
    elif mosek_fusion_CompoundConstraint._match_alt_slice__3I_3I(*args): # []int32,[]int32
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CompoundConstraint.slice(int32,int32)\n\tmosek.fusion.CompoundConstraint.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def add(self,*args):
    if False: pass
    elif mosek_fusion_CompoundConstraint._match_add_Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable
      return self._add_Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_CompoundConstraint._match_alt_add_Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable
      return self._add_alt_Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_CompoundConstraint._match_add_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      return self._add_Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_CompoundConstraint._match_alt_add_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      return self._add_alt_Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_CompoundConstraint._match_add__3D(*args): # []double
      return self._add__3D(*args)
    elif mosek_fusion_CompoundConstraint._match_alt_add__3D(*args): # []double
      return self._add_alt__3D(*args)
    elif mosek_fusion_CompoundConstraint._match_add_D(*args): # double
      return self._add_D(*args)
    elif mosek_fusion_CompoundConstraint._match_alt_add_D(*args): # double
      return self._add_alt_D(*args)
    else:
      raise ValueError('Invalid argument list add('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CompoundConstraint.add(mosek.fusion.Variable)\n\tmosek.fusion.CompoundConstraint.add(mosek.fusion.Expression)\n\tmosek.fusion.CompoundConstraint.add(array(double,ndim=1))\n\tmosek.fusion.CompoundConstraint.add(double)')
  def __repr__(self): return 'mosek.fusion.CompoundConstraint'
  @staticmethod
  def _ctor__3Lmosek_4fusion_4Constraint_2(c):
    o = CompoundConstraint.__new__(CompoundConstraint)
    o._ctor_init__3Lmosek_4fusion_4Constraint_2(c)
    return o
  @staticmethod
  def __match_ctor__3Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 1: return False
    c, = args
    return (__arg_match__3Lmosek_4fusion_4Constraint_2__(c))
  @staticmethod
  def __match_alt_ctor__3Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 1: return False
    c, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Constraint_2__(c))
  def _ctor_alt_init__3Lmosek_4fusion_4Constraint_2(self,c):
    self._ctor_init__3Lmosek_4fusion_4Constraint_2(numpy.array(c,dtype=numpy.dtype(object)))
  def _ctor_init__3Lmosek_4fusion_4Constraint_2(self,c):
   mosek_fusion_Constraint._ctor_init_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Set_2(self,mosek.fusion.CompoundConstraint.__model_1from_1con__3Lmosek_4fusion_4Constraint_2(c),mosek.fusion.CompoundConstraint.__compute_1shape__3Lmosek_4fusion_4Constraint_2I(c,0))
   _0=0
   _1=0
   _2=0
   _3=0
   while (_3 < int((c).shape[0])):
    if (((c[_3]._shape_p)._size)==1):
     _1 += 1
     _2 += 1
    elif (((c[_3]._shape_p)._size) > 1):
     _1 += 1
     _2 = (_2 + (c[_3]._shape_p)._dim_I(_0))
    _3 += 1
   self.__cons = numpy.zeros((_1,), dtype=numpy.dtype(object))
   self.__consb = numpy.zeros(((_1 + 1),), dtype=numpy.dtype(numpy.int32))
   self.__consb[0] = 0
   self.__stackdim = _0
   _4=0
   _5=0
   while (_5 < int((c).shape[0])):
    if (((c[_5]._shape_p)._size) > 0):
     self.__cons[_4] = c[_5]
     _4 += 1
     if (((c[_5]._shape_p)._size)==1):
      self.__consb[(_5 + 1)] = (self.__consb[_5] + 1)
     else:
      self.__consb[(_5 + 1)] = (self.__consb[_5] + (c[_5]._shape_p)._dim_I(_0))
    _5 += 1
  def _toStringArray_alt__3JJ_3S(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(object))
   _1 = self._toStringArray__3JJ_3S(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _toStringArray__3JJ_3S(self,_0,_1,_2):
   raise mosek_fusion_UnimplementedError._ctor_S("SliceConstraint.toStringArray() not implemented")
  def _add_1l_alt__3J_3J_3I_3I_3I_3D_3DJII(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7,_t__8,_t__9):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int32))
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.float64))
   _6=numpy.array(_t__6,dtype=numpy.dtype(numpy.float64))
   _7=numpy.int64(_t__7)
   _8=numpy.int32(_t__8)
   _9=numpy.int32(_t__9)
   _1 = self._add_1l__3J_3J_3I_3I_3I_3D_3DJII(_0,_1,_2,_3,_4,_5,_6,_7,_8,_9)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__6[:] = _6
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _add_1l__3J_3J_3I_3I_3I_3D_3DJII(self,_0,_1,_2,_3,_4,_5,_6,_7,_8,_9):
   _10=numpy.array([(_0[(_8 + _11)] - _7) for _11 in range(0,_9)], dtype=numpy.dtype(numpy.int64))
   _12=numpy.array([_13 for _13 in range(0,_9)], dtype=numpy.dtype(numpy.int64))
   _14=numpy.array([self._shape_p._idxtokey_J((_0[(_8 + _15)] - _7))[self.__stackdim] for _15 in range(0,_9)], dtype=numpy.dtype(numpy.int64))
   mosek.fusion.CommonTools._argQsort__3J_3J_3JJJ(_12,_14,_10,0,numpy.int64(_9))
   _16=numpy.zeros((_9,), dtype=numpy.dtype(numpy.int32))
   fragments._c_closure_156(_14,self.__consb,_16,_9,_12) # src/fusion/CompoundConstraint.mbi:385:9-393:10
   _17=numpy.zeros((_9,), dtype=numpy.dtype(numpy.int64))
   _18=numpy.zeros(((_9 + 1),), dtype=numpy.dtype(numpy.int64))
   _19=(_1[(_8 + _9)] - _1[_8])
   _20=numpy.zeros((_19,), dtype=numpy.dtype(numpy.int32))
   _21=numpy.zeros((_19,), dtype=numpy.dtype(numpy.int32))
   _22=numpy.zeros((_19,), dtype=numpy.dtype(numpy.int32))
   _23=numpy.zeros((_19,), dtype=numpy.dtype(numpy.float64))
   _24=(None if ((_6 is None) ) else numpy.zeros((_9,), dtype=numpy.dtype(numpy.float64)))
   _18[0] = 0
   for _25 in range(0,_9):
    _26=_16[_25]
    if (((self.__cons[_26]._shape_p)._size)==1):
     _17[_25] = 0
    else:
     _27=self._shape_p._idxtokey_J(_10[_12[_25]])
     _27[self.__stackdim] = (_27[self.__stackdim] - self.__consb[_26])
     _17[_25] = (self.__cons[_26]._shape_p)._linearidx__3I(_27)
    _28=(_1[(_12[_25] + 1)] - _1[_12[_25]])
    _18[(_25 + 1)] = (_18[_25] + _28)
    mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(_2,_1[_12[_25]],_20,_18[_25],_28)
    mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(_3,_1[_12[_25]],_21,_18[_25],_28)
    mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(_4,_1[_12[_25]],_22,_18[_25],_28)
    mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ(_5,_1[_12[_25]],_23,_18[_25],_28)
   fragments._c_closure_157(_6,_9,_12,_24) # src/fusion/CompoundConstraint.mbi:426:11-428:42
   _29=0
   while (_29 < _9):
    _30=_29
    _29 += 1
    _29 = fragments._c_closure_158(_16,_29,_30,_9) # src/fusion/CompoundConstraint.mbi:435:36-86
    _29 = numpy.int32(_29) # postprocess
    self.__cons[_16[_30]]._add_1l__3J_3J_3I_3I_3I_3D_3DJII(_17,_18,_20,_21,_22,_23,_24,0,_30,(_29 - _30))
  def _dual_1values_alt_J_3I_3JI_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1values_J_3I_3JI_3D(_0,_1,_2,_3,_4)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1values_J_3I_3JI_3D(self,_0,_1,_2,_3,_4):
   _5=int((_2).shape[0])
   _6=_1[0]
   _6 = fragments._c_closure_159(_1,_6) # src/fusion/CompoundConstraint.mbi:312:9-70
   _6 = numpy.int32(_6) # postprocess
   _7=numpy.array([_0 for _8 in range(0,int((_1).shape[0]))], dtype=numpy.dtype(numpy.int64))
   _9=numpy.zeros((int((_1).shape[0]),), dtype=numpy.dtype(numpy.int32))
   _10=numpy.zeros(((self._shape_p.nd),), dtype=numpy.dtype(numpy.int32))
   _11=numpy.zeros(((self._shape_p.nd),), dtype=numpy.dtype(numpy.int64))
   _11[((self._shape_p.nd) - 1)] = 1
   for _12 in range(1,(self._shape_p.nd)):
    _11[(((self._shape_p.nd) - _12) - 1)] = (_11[((self._shape_p.nd) - _12)] * self._shape_p._dim_I(((self._shape_p.nd) - _12)))
   _13=numpy.zeros((1,), dtype=numpy.dtype(numpy.int64))
   for _14 in range(0,_6):
    _15=_7[0]
    for _16 in range(0,(self._shape_p.nd)):
     _10[_16] = numpy.int32((_15 // _11[_16]))
     _15 = (_15 - (numpy.int64(_10[_16]) * _11[_16]))
    _17=0
    _17 = fragments._c_closure_160(self.__consb,_10,self.__stackdim,_17) # src/fusion/CompoundConstraint.mbi:343:13-61
    _17 = numpy.int32(_17) # postprocess
    _10[self.__stackdim] = (_10[self.__stackdim] - self.__consb[_17])
    _13[0] = (self.__cons[_17]._shape_p)._linearidx__3I(_10)
    self.__cons[_17]._dual_1values__3JI_3D(_13,(_3 + _14),_4)
    _9[0] += 1
    _7[0] = (_7[0] + _2[(_5 - 1)])
    _18=0
    _18 = 0
    while ((_18 < (_5 - 1)) and (_9[_18]==_1[_18])):
     _9[_18] = 0
     _9[(_18 + 1)] += 1
     _18 += 1
    fragments._c_closure_161(_18,_7) # src/fusion/CompoundConstraint.mbi:359:13-360:28
  def _dual_1values_alt__3JI_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1values__3JI_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1values__3JI_3D(self,_0,_1,_2):
   _3=numpy.zeros((1,), dtype=numpy.dtype(numpy.int64))
   _4=numpy.zeros(((self._shape_p.nd),), dtype=numpy.dtype(numpy.int32))
   for _5 in range(0,int((_0).shape[0])):
    _6=numpy.int64(_0[_5])
    for _7 in range(0,(self._shape_p.nd)):
     _4[_7] = numpy.int32((_6 // self._shape_p._stride_I(_7)))
     _6 = (_6 - (numpy.int64(_4[_7]) * self._shape_p._stride_I(_7)))
    _8=0
    _8 = fragments._c_closure_162(self.__consb,_4,self.__stackdim,_8) # src/fusion/CompoundConstraint.mbi:295:13-61
    _8 = numpy.int32(_8) # postprocess
    _4[self.__stackdim] = (_4[self.__stackdim] - self.__consb[_8])
    _3[0] = (self.__cons[_8]._shape_p)._linearidx__3I(_4)
    self.__cons[_8]._dual_1values__3JI_3D(_3,(_1 + _5),_2)
  def _level_1values_alt_J_3I_3JI_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = self._level_1values_J_3I_3JI_3D(_0,_1,_2,_3,_4)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _level_1values_J_3I_3JI_3D(self,_0,_1,_2,_3,_4):
   _5=int((_2).shape[0])
   _6=_1[0]
   _6 = fragments._c_closure_163(_1,_6) # src/fusion/CompoundConstraint.mbi:218:9-70
   _6 = numpy.int32(_6) # postprocess
   _7=numpy.array([_0 for _8 in range(0,int((_1).shape[0]))], dtype=numpy.dtype(numpy.int64))
   _9=numpy.zeros((int((_1).shape[0]),), dtype=numpy.dtype(numpy.int32))
   _10=numpy.zeros(((self._shape_p.nd),), dtype=numpy.dtype(numpy.int32))
   _11=numpy.zeros(((self._shape_p.nd),), dtype=numpy.dtype(numpy.int64))
   _11[((self._shape_p.nd) - 1)] = 1
   for _12 in range(1,(self._shape_p.nd)):
    _11[(((self._shape_p.nd) - _12) - 1)] = (_11[((self._shape_p.nd) - _12)] * self._shape_p._dim_I(((self._shape_p.nd) - _12)))
   _13=numpy.zeros((1,), dtype=numpy.dtype(numpy.int64))
   for _14 in range(0,_6):
    _15=_7[0]
    for _16 in range(0,(self._shape_p.nd)):
     _10[_16] = numpy.int32((_15 // _11[_16]))
     _15 = (_15 - (numpy.int64(_10[_16]) * _11[_16]))
    _17=0
    _17 = fragments._c_closure_164(self.__consb,_10,self.__stackdim,_17) # src/fusion/CompoundConstraint.mbi:249:13-61
    _17 = numpy.int32(_17) # postprocess
    _10[self.__stackdim] = (_10[self.__stackdim] - self.__consb[_17])
    _13[0] = (self.__cons[_17]._shape_p)._linearidx__3I(_10)
    self.__cons[_17]._level_1values__3JI_3D(_13,(_3 + _14),_4)
    _9[0] += 1
    _7[0] = (_7[0] + _2[(_5 - 1)])
    _18=0
    _18 = 0
    while ((_18 < (_5 - 1)) and (_9[_18]==_1[_18])):
     _9[_18] = 0
     _9[(_18 + 1)] += 1
     _18 += 1
    fragments._c_closure_165(_18,_7) # src/fusion/CompoundConstraint.mbi:265:13-266:28
  def _level_1values_alt__3JI_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._level_1values__3JI_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _level_1values__3JI_3D(self,_0,_1,_2):
   _3=numpy.zeros((1,), dtype=numpy.dtype(numpy.int64))
   _4=numpy.zeros(((self._shape_p.nd),), dtype=numpy.dtype(numpy.int32))
   for _5 in range(0,int((_0).shape[0])):
    _6=numpy.int64(_0[_5])
    for _7 in range(0,(self._shape_p.nd)):
     _4[_7] = numpy.int32((_6 // self._shape_p._stride_I(_7)))
     _6 = (_6 - (numpy.int64(_4[_7]) * self._shape_p._stride_I(_7)))
    _8=0
    _8 = fragments._c_closure_166(self.__consb,_4,self.__stackdim,_8) # src/fusion/CompoundConstraint.mbi:201:13-61
    _8 = numpy.int32(_8) # postprocess
    _4[self.__stackdim] = (_4[self.__stackdim] - self.__consb[_8])
    _3[0] = (self.__cons[_8]._shape_p)._linearidx__3I(_4)
    self.__cons[_8]._level_1values__3JI_3D(_3,(_1 + _5),_2)
  def _add_alt__3J_3I_3D_3DI_3II(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.float64))
   _4=numpy.int32(_t__4)
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.int32))
   _6=numpy.int32(_t__6)
   _1 = self._add__3J_3I_3D_3DI_3II(_0,_1,_2,_3,_4,_5,_6)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _add__3J_3I_3D_3DI_3II(self,_0,_1,_2,_3,_4,_5,_6):
   raise mosek_fusion_UnimplementedError._ctor_S("Functionality not implemented yet.")
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _slice_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._slice__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice__3I_3I(self,_0,_1):
   raise mosek_fusion_UnimplementedError._ctor_S("Compound constraints cannot be sliced")
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _slice_alt_II(self,_t__0,_t__1):
    return self._slice_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_II(self,_0,_1):
   raise mosek_fusion_UnimplementedError._ctor_S("Compound constraints cannot be sliced")
  @staticmethod
  def __compute_1shape_alt__3Lmosek_4fusion_4Constraint_2I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_CompoundConstraint.__compute_1shape__3Lmosek_4fusion_4Constraint_2I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __compute_1shape__3Lmosek_4fusion_4Constraint_2I(_0,_1):
   _2=_0[0]._shape_()
   _3=0
   for _4 in range(0,int((_0).shape[0])):
    if (((_0[_4]._shape_p)._size) > 0):
     if (((_0[_4]._shape_p).nd)!=(_2.nd)):
      raise mosek_fusion_DimensionError._ctor_S("Mismatching variable shape")
     _5=0
     while (_5 < (_2.nd)):
      if ((_5!=_1) and (_2._dim_I(_5)!=(_0[_4]._shape_p)._dim_I(_5))):
       raise mosek_fusion_DimensionError._ctor_S("Mismatching variable shape")
      _5 += 1
     _3 = (_3 + (_0[_4]._shape_p)._dim_I(_1))
    else:
     raise mosek_fusion_DimensionError._ctor_S("Empty element in compound variable")
   if ((_2.nd)==1):
    return (mosek_fusion_IntSet._ctor_I(_3))
   else:
    _6=numpy.array([_2._dim_I(_7) for _7 in range(0,(_2.nd))], dtype=numpy.dtype(numpy.int32))
    _6[_1] = _3
    return (mosek_fusion_NDSet._ctor__3I(_6))
  @staticmethod
  def __count_1numcon_alt__3Lmosek_4fusion_4Constraint_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_CompoundConstraint.__count_1numcon__3Lmosek_4fusion_4Constraint_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __count_1numcon__3Lmosek_4fusion_4Constraint_2(_0):
   _1=0
   _2=0
   while (_2 < int((_0).shape[0])):
    _3=_0[_2]
    _5=_3
    if   isinstance(_5,mosek_fusion_CompoundConstraint):
     cc=_5
     _1 = (_1 + int(((cc.__cons)).shape[0]))
    else:
     cc=_5
     _1 += 1
    _2 += 1
   return numpy.int32(_1)
  @staticmethod
  def __model_1from_1con_alt__3Lmosek_4fusion_4Constraint_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_CompoundConstraint.__model_1from_1con__3Lmosek_4fusion_4Constraint_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __model_1from_1con__3Lmosek_4fusion_4Constraint_2(_0):
   return ((_0[0]._model))
 return CompoundConstraint
mosek_fusion_CompoundConstraint=__mk_mosek_fusion_CompoundConstraint()
del __mk_mosek_fusion_CompoundConstraint
#BEFORE CLASS
def __mk_mosek_fusion_SliceConstraint():
 class SliceConstraint(mosek_fusion_Constraint):
  __slots__ = ['_strides','_first','_origin']
  def size(self,*args):
    if False: pass
    elif mosek_fusion_SliceConstraint._match_size_(*args): # 
      return self._size_(*args)
    elif mosek_fusion_SliceConstraint._match_alt_size_(*args): # 
      return self._size_alt_(*args)
    else:
      raise ValueError('Invalid argument list size('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SliceConstraint.size()')
  def slice(self,*args):
    if False: pass
    elif mosek_fusion_SliceConstraint._match_slice_II(*args): # int32,int32
      return self._slice_II(*args)
    elif mosek_fusion_SliceConstraint._match_alt_slice_II(*args): # int32,int32
      return self._slice_alt_II(*args)
    elif mosek_fusion_SliceConstraint._match_slice__3I_3I(*args): # []int32,[]int32
      return self._slice__3I_3I(*args)
    elif mosek_fusion_SliceConstraint._match_alt_slice__3I_3I(*args): # []int32,[]int32
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SliceConstraint.slice(int32,int32)\n\tmosek.fusion.SliceConstraint.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def __repr__(self): return 'mosek.fusion.SliceConstraint'
  @staticmethod
  def _ctor_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Set_2J_3J(origin_,shape_,first_,strides_):
    o = SliceConstraint.__new__(SliceConstraint)
    o._ctor_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Set_2J_3J(origin_,shape_,first_,strides_)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Set_2J_3J(*args):
    if len(args) != 4: return False
    origin_,shape_,first_,strides_, = args
    return (__arg_match_Lmosek_4fusion_4ModelConstraint_2__(origin_) and __arg_match_Lmosek_4fusion_4Set_2__(shape_) and __arg_match_J__(first_) and __arg_match__3J__(strides_))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Set_2J_3J(*args):
    if len(args) != 4: return False
    origin_,shape_,first_,strides_, = args
    return (__arg_alt_match_Lmosek_4fusion_4ModelConstraint_2__(origin_) and __arg_alt_match_Lmosek_4fusion_4Set_2__(shape_) and __arg_alt_match_J__(first_) and __arg_alt_match__3J__(strides_))
  def _ctor_alt_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Set_2J_3J(self,origin_,shape_,first_,strides_):
    self._ctor_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Set_2J_3J(origin_,shape_,numpy.int64(first_),numpy.array(strides_,dtype=numpy.dtype(numpy.int64)))
  def _ctor_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Set_2J_3J(self,origin_,shape_,first_,strides_):
   mosek_fusion_Constraint._ctor_init_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Set_2(self,(origin_._model),shape_)
   self._origin = origin_
   self._first = first_
   self._strides = strides_
  def _add_1l_alt__3J_3J_3I_3I_3I_3D_3DJII(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7,_t__8,_t__9):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int32))
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.float64))
   _6=numpy.array(_t__6,dtype=numpy.dtype(numpy.float64))
   _7=numpy.int64(_t__7)
   _8=numpy.int32(_t__8)
   _9=numpy.int32(_t__9)
   _1 = self._add_1l__3J_3J_3I_3I_3I_3D_3DJII(_0,_1,_2,_3,_4,_5,_6,_7,_8,_9)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__6[:] = _6
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _add_1l__3J_3J_3I_3I_3I_3D_3DJII(self,_0,_1,_2,_3,_4,_5,_6,_7,_8,_9):
   _10=(_1[(_8 + _9)] - _1[_8])
   _11=numpy.zeros((_9,), dtype=numpy.dtype(numpy.int64))
   _12=numpy.zeros(((_9 + 1),), dtype=numpy.dtype(numpy.int64))
   _13=(None if ((_6 is None) ) else numpy.zeros((_9,), dtype=numpy.dtype(numpy.float64)))
   fragments._c_closure_167(_9,_1,_12,_8) # src/fusion/SliceConstraint.mbi:346:9-63
   if ((self._shape_p.nd)==1):
    fragments._c_closure_168(self._first,_9,_11,_8,_0,_7) # src/fusion/SliceConstraint.mbi:349:9-352:10
   else:
    for _14 in range(0,_9):
     _15=self._shape_p._idxtokey_J((_0[(_8 + _14)] - _7))
     _16=0
     _16 = fragments._c_closure_169(_15,_16,self._strides) # src/fusion/SliceConstraint.mbi:359:13-92
     _16 = numpy.int64(_16) # postprocess
     _11[_14] = _16
   if (_6 is not None):
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(_6,_8,_13,0,_9)
   self._origin._add_1l__3J_3J_3I_3I_3I_3D_3DJII(_11,_12,_2,_3,_4,_5,_13,0,0,_9)
  def _add_1fx_alt__3J_3DJII(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=numpy.int64(_t__2)
   _3=numpy.int32(_t__3)
   _4=numpy.int32(_t__4)
   _1 = self._add_1fx__3J_3DJII(_0,_1,_2,_3,_4)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _add_1fx__3J_3DJII(self,_0,_1,_2,_3,_4):
   _5=numpy.zeros((_4,), dtype=numpy.dtype(numpy.int64))
   _6=numpy.zeros((_4,), dtype=numpy.dtype(numpy.float64))
   mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(_1,_3,_6,0,_4)
   for _7 in range(0,_4):
    _8=self._shape_p._idxtokey_J(_0[(_3 + _7)])
    _9=0
    _9 = fragments._c_closure_170(_8,_9,self._strides) # src/fusion/SliceConstraint.mbi:319:11-90
    _9 = numpy.int64(_9) # postprocess
    _5[_7] = _9
   self._origin._add_1fx__3J_3DJII(_5,_6,0,0,_4)
  def _dual_1values_alt_J_3I_3JI_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1values_J_3I_3JI_3D(_0,_1,_2,_3,_4)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1values_J_3I_3JI_3D(self,_0,_1,_2,_3,_4):
   if ((_0==0) and ((int((_1).shape[0])==1) and ((_1[0]==(self._shape_p._size)) and (_2[0]==1)))):
    _5=numpy.array([self._shape_p._dim_I(_6) for _6 in range(0,(self._shape_p.nd))], dtype=numpy.dtype(numpy.int32))
    self._origin._dual_1values_J_3I_3JI_3D(self._first,_5,self._strides,_3,_4)
   else:
    _7=int((_1).shape[0])
    _8=(_7==(self._shape_p.nd))
    _9=0
    while ((_9 < _7) and _8):
     _8 = (_2[_9]==self._shape_p._stride_I(_9))
     _9 += 1
    if _8:
     _10=self._first
     _11=_0
     for _12 in range(0,((self._shape_p.nd) - 1)):
      _13=(_11 // _2[_12])
      _11 = (_11 - (_2[_12] * _13))
      _10 = (_10 + (self._shape_p._stride_I(_12) * _13))
     self._origin._dual_1values_J_3I_3JI_3D(_10,_1,self._strides,_3,_4)
    else:
     _14=1
     _14 = fragments._c_closure_171(_1,_14) # src/fusion/SliceConstraint.mbi:263:33-96
     _14 = numpy.int64(_14) # postprocess
     _15=numpy.zeros((_14,), dtype=numpy.dtype(numpy.int64))
     _16=numpy.zeros((int((_1).shape[0]),), dtype=numpy.dtype(numpy.int32))
     _17=numpy.zeros((int((_1).shape[0]),), dtype=numpy.dtype(numpy.int64))
     fragments._c_closure_172(_1,_17) # src/fusion/SliceConstraint.mbi:268:49-88
     for _18 in range(0,_14):
      _19=(_0 + _17[0])
      _20=0
      for _21 in range(0,(self._shape_p.nd)):
       _22=(_19 // self._shape_p._stride_I(_21))
       _20 = (_20 + (self._strides[_21] * _22))
       _19 = (_19 - (_22 * self._shape_p._stride_I(_21)))
      _15[_18] = _20
      _23=0
      _16[0] += 1
      _17[0] = (_17[0] + _2[(_7 - 1)])
      while ((_23 < (_7 - 1)) and (_16[_23] >= _1[((_7 - _23) - 1)])):
       _17[_23] = 0
       _17[_23] = (_17[_23] + _2[((_7 - _23) - 1)])
       _16[_23] = 0
       _16[(_23 + 1)] += 1
       _23 += 1
      fragments._c_closure_173(_23,_17) # src/fusion/SliceConstraint.mbi:292:20-55
     self._origin._dual_1values__3JI_3D(_15,_3,_4)
  def _dual_1values_alt__3JI_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1values__3JI_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1values__3JI_3D(self,_0,_1,_2):
   _3=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int64))
   for _4 in range(0,int((_0).shape[0])):
    _5=self._shape_p._idxtokey_J(_0[_4])
    _6=0
    for _7 in range(0,(self._shape_p.nd)):
     _6 = (_6 + (numpy.int64(_5[_7]) * self._strides[_7]))
    _3[_4] = _6
   self._origin._dual_1values__3JI_3D(_3,_1,_2)
  def _level_1values_alt_J_3I_3JI_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = self._level_1values_J_3I_3JI_3D(_0,_1,_2,_3,_4)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _level_1values_J_3I_3JI_3D(self,_0,_1,_2,_3,_4):
   if ((_0==0) and ((int((_1).shape[0])==1) and ((_1[0]==(self._shape_p._size)) and (_2[0]==1)))):
    _5=numpy.array([self._shape_p._dim_I(_6) for _6 in range(0,(self._shape_p.nd))], dtype=numpy.dtype(numpy.int32))
    self._origin._level_1values_J_3I_3JI_3D(self._first,_5,self._strides,_3,_4)
   else:
    _7=int((_1).shape[0])
    _8=(_7==(self._shape_p.nd))
    _9=0
    while ((_9 < _7) and _8):
     _8 = (_2[_9]==self._shape_p._stride_I(_9))
     _9 += 1
    if _8:
     _10=self._first
     _11=_0
     for _12 in range(0,((self._shape_p.nd) - 1)):
      _13=(_11 // _2[_12])
      _11 = (_11 - (_2[_12] * _13))
      _10 = (_10 + (self._shape_p._stride_I(_12) * _13))
     self._origin._level_1values_J_3I_3JI_3D(_10,_1,self._strides,_3,_4)
    else:
     _14=1
     _14 = fragments._c_closure_174(_1,_14) # src/fusion/SliceConstraint.mbi:161:33-96
     _14 = numpy.int64(_14) # postprocess
     _15=numpy.zeros((_14,), dtype=numpy.dtype(numpy.int64))
     _16=numpy.zeros((int((_1).shape[0]),), dtype=numpy.dtype(numpy.int32))
     _17=numpy.zeros((int((_1).shape[0]),), dtype=numpy.dtype(numpy.int64))
     for _18 in range(0,_14):
      _19=(_0 + _17[0])
      _20=0
      for _21 in range(0,(self._shape_p.nd)):
       _22=(_19 // self._shape_p._stride_I(_21))
       _20 = (_20 + (self._strides[_21] * _22))
       _19 = (_19 - (_22 * self._shape_p._stride_I(_21)))
      _15[_18] = _20
      _23=0
      _16[0] += 1
      _17[0] = (_17[0] + _2[(_7 - 1)])
      while ((_23 < (_7 - 1)) and (_16[_23] >= _1[((_7 - _23) - 1)])):
       _17[_23] = 0
       _17[_23] = (_17[_23] + _2[((_7 - _23) - 1)])
       _16[_23] = 0
       _16[(_23 + 1)] += 1
       _23 += 1
      fragments._c_closure_175(_23,_17) # src/fusion/SliceConstraint.mbi:190:20-55
     self._origin._level_1values__3JI_3D(_15,_3,_4)
  def _level_1values_alt__3JI_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._level_1values__3JI_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _level_1values__3JI_3D(self,_0,_1,_2):
   _3=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int64))
   for _4 in range(0,int((_0).shape[0])):
    _5=self._shape_p._idxtokey_J(_0[_4])
    _6=0
    for _7 in range(0,(self._shape_p.nd)):
     _6 = (_6 + (numpy.int64(_5[_7]) * self._strides[_7]))
    _3[_4] = _6
   self._origin._level_1values__3JI_3D(_3,_1,_2)
  def _toStringArray_alt__3JJ_3S(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(object))
   _1 = self._toStringArray__3JJ_3S(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _toStringArray__3JJ_3S(self,_0,_1,_2):
   _3=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int64))
   for _4 in range(0,int((_0).shape[0])):
    _5=self._shape_p._idxtokey_J(_0[_4])
    _6=0
    for _7 in range(0,(self._shape_p.nd)):
     _6 = (_6 + (numpy.int64(_5[_7]) * self._strides[_7]))
    _3[_4] = _6
   self._origin._toStringArray__3JJ_3S(_3,_1,_2)
  @staticmethod
  def _match_size_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_size_(*args):
    if len(args) != 0: return False
    return True
  def _size_alt_(self,):
    return self._size_()
  def _size_(self,):
   return numpy.int64((self._shape_p._size))
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _slice_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._slice__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice__3I_3I(self,_0,_1):
   _2=self._shape_p._slice__3I_3I(_0,_1)
   _3=self._first
   _3 = fragments._c_closure_176(_0,_3,self._strides) # src/fusion/SliceConstraint.mbi:65:9-66:61
   _3 = numpy.int64(_3) # postprocess
   return (self._slice_1_Lmosek_4fusion_4Set_2J_3J(_2,_3,self._strides))
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _slice_alt_II(self,_t__0,_t__1):
    return self._slice_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_II(self,_0,_1):
   _2=self._shape_p._slice_II(_0,_1)
   return (self._slice_1_Lmosek_4fusion_4Set_2J_3J(_2,(_0 + _0),self._strides))
  def _slice_1_alt_Lmosek_4fusion_4Set_2J_3J(self,_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.int64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _1 = self._slice_1_Lmosek_4fusion_4Set_2J_3J(_0,_1,_2)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice_1_Lmosek_4fusion_4Set_2J_3J(self,_0,_1,_2):
   return (mosek_fusion_SliceConstraint._ctor_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Set_2J_3J(self._origin,_0,_1,_2))
 return SliceConstraint
mosek_fusion_SliceConstraint=__mk_mosek_fusion_SliceConstraint()
del __mk_mosek_fusion_SliceConstraint
#BEFORE CLASS
def __mk_mosek_fusion_BoundInterfaceConstraint():
 class BoundInterfaceConstraint(mosek_fusion_SliceConstraint):
  __slots__ = ['_BoundInterfaceConstraint__origincon','_BoundInterfaceConstraint__islower']
  def __repr__(self): return 'mosek.fusion.BoundInterfaceConstraint'
  @staticmethod
  def _ctor_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Set_2J_3JZ(origin_,shape_,first_,strides_,islower_):
    o = BoundInterfaceConstraint.__new__(BoundInterfaceConstraint)
    o._ctor_init_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Set_2J_3JZ(origin_,shape_,first_,strides_,islower_)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Set_2J_3JZ(*args):
    if len(args) != 5: return False
    origin_,shape_,first_,strides_,islower_, = args
    return (__arg_match_Lmosek_4fusion_4RangedConstraint_2__(origin_) and __arg_match_Lmosek_4fusion_4Set_2__(shape_) and __arg_match_J__(first_) and __arg_match__3J__(strides_) and __arg_match_Z__(islower_))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Set_2J_3JZ(*args):
    if len(args) != 5: return False
    origin_,shape_,first_,strides_,islower_, = args
    return (__arg_alt_match_Lmosek_4fusion_4RangedConstraint_2__(origin_) and __arg_alt_match_Lmosek_4fusion_4Set_2__(shape_) and __arg_alt_match_J__(first_) and __arg_alt_match__3J__(strides_) and __arg_alt_match_Z__(islower_))
  def _ctor_alt_init_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Set_2J_3JZ(self,origin_,shape_,first_,strides_,islower_):
    self._ctor_init_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Set_2J_3JZ(origin_,shape_,numpy.int64(first_),numpy.array(strides_,dtype=numpy.dtype(numpy.int64)),islower_)
  def _ctor_init_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Set_2J_3JZ(self,origin_,shape_,first_,strides_,islower_):
   mosek_fusion_SliceConstraint._ctor_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Set_2J_3J(self,origin_,shape_,first_,strides_)
   self.__origincon = origin_
   self.__islower = islower_
  def _slice_1_alt_Lmosek_4fusion_4Set_2J_3J(self,_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.int64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _1 = self._slice_1_Lmosek_4fusion_4Set_2J_3J(_0,_1,_2)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice_1_Lmosek_4fusion_4Set_2J_3J(self,_0,_1,_2):
   return (mosek_fusion_BoundInterfaceConstraint._ctor_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Set_2J_3JZ(self.__origincon,_0,_1,_2,self.__islower))
  def _dual_1values_alt_J_3I_3JI_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1values_J_3I_3JI_3D(_0,_1,_2,_3,_4)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1values_J_3I_3JI_3D(self,_0,_1,_2,_3,_4):
   if self.__islower:
    self.__origincon._dual_1l_J_3I_3JI_3D(_0,_1,_2,_3,_4)
   else:
    self.__origincon._dual_1u_J_3I_3JI_3D(_0,_1,_2,_3,_4)
  def _dual_1values_alt__3JI_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1values__3JI_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1values__3JI_3D(self,_0,_1,_2):
   if self.__islower:
    self.__origincon._dual_1l__3JI_3D(_0,_1,_2)
   else:
    self.__origincon._dual_1u__3JI_3D(_0,_1,_2)
 return BoundInterfaceConstraint
mosek_fusion_BoundInterfaceConstraint=__mk_mosek_fusion_BoundInterfaceConstraint()
del __mk_mosek_fusion_BoundInterfaceConstraint
#BEFORE CLASS
def __mk_mosek_fusion_ModelConstraint():
 class ModelConstraint(mosek_fusion_Constraint):
  __slots__ = ['_ModelConstraint__names_flushed','_nativeindexes','_name','_cache_bfix','_cache']
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ModelConstraint._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ModelConstraint._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ModelConstraint.toString()')
  def slice(self,*args):
    if False: pass
    elif mosek_fusion_ModelConstraint._match_slice_II(*args): # int32,int32
      return self._slice_II(*args)
    elif mosek_fusion_ModelConstraint._match_alt_slice_II(*args): # int32,int32
      return self._slice_alt_II(*args)
    elif mosek_fusion_ModelConstraint._match_slice__3I_3I(*args): # []int32,[]int32
      return self._slice__3I_3I(*args)
    elif mosek_fusion_ModelConstraint._match_alt_slice__3I_3I(*args): # []int32,[]int32
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ModelConstraint.slice(int32,int32)\n\tmosek.fusion.ModelConstraint.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def __repr__(self): return 'mosek.fusion.ModelConstraint'
  @staticmethod
  def _ctor_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(c,m):
    o = ModelConstraint.__new__(ModelConstraint)
    o._ctor_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(c,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_match_Lmosek_4fusion_4ModelConstraint_2__(c) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4ModelConstraint_2__(c) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
    self._ctor_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(c,m)
  def _ctor_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
   mosek_fusion_Constraint._ctor_init_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(self,c,m)
   self._cache = (c._cache)._clone_()
   self._nativeindexes = numpy.array([(c._nativeindexes)[_0] for _0 in range(0,int(((c._nativeindexes)).shape[0]))], dtype=numpy.dtype(numpy.int32))
   self._name = (c._name)
   self._cache_bfix = numpy.array([(c._cache_bfix)[_1] for _1 in range(0,int(((c._cache_bfix)).shape[0]))], dtype=numpy.dtype(numpy.float64))
   self.__names_flushed = (c.__names_flushed)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2_3I_3J_3I_3D_3D_3I_3I_3I(model_,name_,shape_,nidxs_,ptrb,subj,cof,bfix,barsubi_,barsubj_,barsymmatidx_):
    o = ModelConstraint.__new__(ModelConstraint)
    o._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2_3I_3J_3I_3D_3D_3I_3I_3I(model_,name_,shape_,nidxs_,ptrb,subj,cof,bfix,barsubi_,barsubj_,barsymmatidx_)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2_3I_3J_3I_3D_3D_3I_3I_3I(*args):
    if len(args) != 11: return False
    model_,name_,shape_,nidxs_,ptrb,subj,cof,bfix,barsubi_,barsubj_,barsymmatidx_, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model_) and __arg_match_S__(name_) and __arg_match_Lmosek_4fusion_4Set_2__(shape_) and __arg_match__3I__(nidxs_) and __arg_match__3J__(ptrb) and __arg_match__3I__(subj) and __arg_match__3D__(cof) and __arg_match__3D__(bfix) and __arg_match__3I__(barsubi_) and __arg_match__3I__(barsubj_) and __arg_match__3I__(barsymmatidx_))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2_3I_3J_3I_3D_3D_3I_3I_3I(*args):
    if len(args) != 11: return False
    model_,name_,shape_,nidxs_,ptrb,subj,cof,bfix,barsubi_,barsubj_,barsymmatidx_, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model_) and __arg_alt_match_S__(name_) and __arg_alt_match_Lmosek_4fusion_4Set_2__(shape_) and __arg_alt_match__3I__(nidxs_) and __arg_alt_match__3J__(ptrb) and __arg_alt_match__3I__(subj) and __arg_alt_match__3D__(cof) and __arg_alt_match__3D__(bfix) and __arg_alt_match__3I__(barsubi_) and __arg_alt_match__3I__(barsubj_) and __arg_alt_match__3I__(barsymmatidx_))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2_3I_3J_3I_3D_3D_3I_3I_3I(self,model_,name_,shape_,nidxs_,ptrb,subj,cof,bfix,barsubi_,barsubj_,barsymmatidx_):
    self._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2_3I_3J_3I_3D_3D_3I_3I_3I(model_,name_,shape_,numpy.array(nidxs_,dtype=numpy.dtype(numpy.int32)),numpy.array(ptrb,dtype=numpy.dtype(numpy.int64)),numpy.array(subj,dtype=numpy.dtype(numpy.int32)),numpy.array(cof,dtype=numpy.dtype(numpy.float64)),numpy.array(bfix,dtype=numpy.dtype(numpy.float64)),numpy.array(barsubi_,dtype=numpy.dtype(numpy.int32)),numpy.array(barsubj_,dtype=numpy.dtype(numpy.int32)),numpy.array(barsymmatidx_,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2_3I_3J_3I_3D_3D_3I_3I_3I(self,model_,name_,shape_,nidxs_,ptrb,subj,cof,bfix,barsubi_,barsubj_,barsymmatidx_):
   mosek_fusion_Constraint._ctor_init_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Set_2(self,model_,shape_)
   self._cache = mosek_fusion_ConstraintCache._ctor__3J_3D_3I_3D_3I_3I_3I(ptrb,cof,subj,bfix,barsubi_,barsubj_,barsymmatidx_)
   self._nativeindexes = nidxs_
   self._name = name_
   if (bfix is not None):
    self._cache_bfix = mosek.fusion.Utils.Tools._arraycopy__3D(bfix)
   else:
    self._cache_bfix = numpy.zeros((int((nidxs_).shape[0]),), dtype=numpy.dtype(numpy.float64))
   self.__names_flushed = False
  def _flushNames_alt_(self,):
    return self._flushNames_()
  def _flushNames_(self,):
   if ((not self.__names_flushed) and (int(len(self._name)) > 0)):
    for _0 in range(0,int((self._nativeindexes).shape[0])):
     self._model._task_1con_1name_IS(self._nativeindexes[_0],("" if ((int(len(self._name))==0) ) else mosek.fusion.Utils.StringBuffer()._a_S(self._name)._a_S("[")._a_S(self._shape_p._getname_J(_0))._a_S("]")._toString_()))
    self.__names_flushed = True
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=(self._shape_p._size)
   _1=numpy.zeros((_0,), dtype=numpy.dtype(object))
   self._toStringArray__3JJ_3S(mosek.fusion.Utils.Tools._range_J(_0),0,_1)
   _2=mosek.fusion.Utils.StringBuffer()
   _2._a_S("Constraint( ")
   if (int(len(self._name)) > 0):
    _2._a_S("'")._a_S(self._name)._a_S("', ")
   _2._a_S("(")._a_I(self._shape_p._dim_I(0))
   for _3 in range(1,(self._shape_p.nd)):
    _2._a_S(",")._a_I(self._shape_p._dim_I(_3))
   _2._a_S("),")._lf_()
   if (int((_1).shape[0]) > 0):
    _2._a_S("  ")._a_S(_1[0])
    for _4 in range(1,int((_1).shape[0])):
     _2._a_S(",")._lf_()._a_S("  ")._a_S(_1[_4])
   _2._a_S(" )")
   return (_2._toString_())
  def _toStringArray_alt__3JJ_3S(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(object))
   _1 = self._toStringArray__3JJ_3S(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _toStringArray__3JJ_3S(self,_0,_1,_2):
   for _3 in range(0,int((_0).shape[0])):
    if ((_0[_3] < 0) or (_0[_3] >= (self._shape_p._size))):
     raise mosek_fusion_IndexError._ctor_S("Constraint index out of bounds")
   if ((long((_0).shape[0]) + _1) > long((_2).shape[0])):
    raise mosek_fusion_LengthError._ctor_S("Result array is too small to hold the result")
   _4=mosek.fusion.Utils.StringBuffer()
   _5=0
   _6=self._cache._order_1barentries_()
   _7=0
   for _8 in range(0,int((_0).shape[0])):
    _9=_0[_8]
    _10=self._nativeindexes[_9]
    _11=_5
    while ((_5 < (self._cache.nnz)) and ((self._cache.subi)[_5]==_9)):
     _5 += 1
    _4._clear_()._a_S(self._name)._a_S("[")._a_S(self._shape_p._indexToString_J(_9))._a_S("] : ")
    for _12 in range(_11,_5):
     _13=(self._cache.cof)[_12]
     if (_13 > 0):
      _4._a_S(" + ")._a_D(_13)._a_S(" ")
      self._model._nativeVarToStr_ILmosek_4fusion_4Utils_4StringBuffer_2((self._cache.subj)[_12],_4)
     elif (_13 < 0):
      _4._a_S(" - ")._a_D((- _13))._a_S(" ")
      self._model._nativeVarToStr_ILmosek_4fusion_4Utils_4StringBuffer_2((self._cache.subj)[_12],_4)
    while ((_7 < _6) and ((self._cache.barsubi)[_7] < _9)):
     _7 += 1
    _14=_7
    while ((_14 < _6) and ((self._cache.barsubi)[_14]==_9)):
     _14 += 1
    while ((_7 < _14) and ((self._cache.barsubi)[_7]==_9)):
     _15=_7
     _16=(self._cache.barsubj)[_7]
     _7 += 1
     while ((_7 < _14) and ((self._cache.barsubj)[_7]==_16)):
      _7 += 1
     _4._a_S(" + < M")._a_I((self._cache.barmatidx)[_15])
     for _17 in range((_15 + 1),_7):
      _4._a_S(" + M")._a_I((self._cache.barmatidx)[_17])
     _4._a_S(" ; ")._a_S((((self._model._vars)[(self._model._natbarvarmap_Var)[(self._cache.barsubj)[_15]]]._name) if ((int(len(((self._model._vars)[(self._model._natbarvarmap_Var)[(self._cache.barsubj)[_15]]]._name))) > 0) ) else "_"))._a_S(" >")
    if (self._cache_bfix is not None):
     if (self._cache_bfix[_9] > 0):
      _4._a_S(" + ")._a_D(self._cache_bfix[_9])
     elif (self._cache_bfix[_9] < 0):
      _4._a_S(" + ")._a_D(self._cache_bfix[_9])
    _4._a_S(" ")
    self._domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(_9,_4)
    _2[(numpy.int64(_8) + _1)] = _4._toString_()
  def _domainToString_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   pass
  def _add_1l_alt__3J_3J_3I_3I_3I_3D_3DJII(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7,_t__8,_t__9):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int32))
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.float64))
   _6=numpy.array(_t__6,dtype=numpy.dtype(numpy.float64))
   _7=numpy.int64(_t__7)
   _8=numpy.int32(_t__8)
   _9=numpy.int32(_t__9)
   _1 = self._add_1l__3J_3J_3I_3I_3I_3D_3DJII(_0,_1,_2,_3,_4,_5,_6,_7,_8,_9)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__6[:] = _6
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _add_1l__3J_3J_3I_3I_3I_3D_3DJII(self,_0,_1,_2,_3,_4,_5,_6,_7,_8,_9):
   for _10 in range(1,int((_0).shape[0])):
    if (_0[(_10 - 1)] >= _0[_10]):
     raise mosek_fusion_UnimplementedError._ctor_S("Not supported: Non-contiguous index ranges in ModelConstraint.add_l")
   if ((_1[(_8 + _9)] <= _1[_8]) and (_6 is None)):
    return 
   _11=numpy.zeros(((_1[(_8 + _9)] - _1[_8]),), dtype=numpy.dtype(numpy.int64))
   fragments._c_closure_177(_9,_11,_1,_8) # src/fusion/ModelConstraint.mbi:171:9-91
   for _12 in range(0,_9):
    mosek.fusion.CommonTools._argQsort__3J_3I_3IJJ(_11,_2,None,_1[(_8 + _12)],_1[((_8 + _12) + 1)])
   _13=0
   _14=0
   _14,_13 = fragments._c_closure_178(_9,_14,_13,_1,_8,_2) # src/fusion/ModelConstraint.mbi:178:9-183:24
   _14 = numpy.int32(_14) # postprocess
   _13 = numpy.int32(_13) # postprocess
   if ((_13 > 0) or (_6 is not None)):
    _15=numpy.zeros((((self._cache.nrows) + 1),), dtype=numpy.dtype(numpy.int64))
    _16=numpy.zeros((_13,), dtype=numpy.dtype(numpy.int32))
    _17=numpy.zeros((_13,), dtype=numpy.dtype(numpy.float64))
    _18=None
    if (_6 is not None):
     _18 = numpy.zeros(((self._cache.nrows),), dtype=numpy.dtype(numpy.float64))
     fragments._c_closure_179(_6,_18,_9,_8,_0,_7) # src/fusion/ModelConstraint.mbi:196:13-197:69
    _15[0] = 0
    _19=_8
    for _20 in range(0,(self._cache.nrows)):
     _19 = fragments._c_closure_180(_5,_20,_19,_17,_15,_16,_9,_1,_0,_7,_2) # src/fusion/ModelConstraint.mbi:203:11-221:12
     _19 = numpy.int32(_19) # postprocess
    self._cache._add__3J_3I_3D_3D(_15,_16,_17,_18)
    _21=(self._cache.nrows)
    _22=numpy.int32(self._cache._numUnsorted_())
    _23=numpy.zeros((_22,), dtype=numpy.dtype(numpy.int32))
    _24=numpy.zeros((_22,), dtype=numpy.dtype(numpy.int32))
    _25=numpy.zeros((_22,), dtype=numpy.dtype(numpy.float64))
    _26=self._cache._flush__3I_3I_3D_3D(_23,_24,_25,None)
    fragments._c_closure_181(self._nativeindexes,_23,_26) # src/fusion/ModelConstraint.mbi:235:13-236:50
    self._model._task_1putaijlist__3I_3I_3DJ(_23,_24,_25,_26)
    if (_6 is not None):
     self._add_1fx__3J_3DJII(_0,(self._cache.bfix),_7,_8,_9)
   if (_14 > 0):
    _27=0
    _27 = fragments._c_closure_182(_9,_27,_11,_1,_8,_2) # src/fusion/ModelConstraint.mbi:251:11-265:12
    _27 = numpy.int32(_27) # postprocess
    _28=numpy.zeros((_27,), dtype=numpy.dtype(numpy.int32))
    _29=numpy.zeros((_27,), dtype=numpy.dtype(numpy.int32))
    _30=numpy.zeros((_27,), dtype=numpy.dtype(numpy.int32))
    _31=numpy.zeros((_27,), dtype=numpy.dtype(numpy.int32))
    _32=_1[_8]
    _33=0
    for _34 in range(0,_9):
     _35=(_1[(_8 + _34)] - _32)
     _36=(_1[((_8 + _34) + 1)] - _32)
     if (_2[_11[_35]] < 0):
      while ((_35 < _36) and (_2[_11[_35]] < 0)):
       _29[_33] = numpy.int32(_0[(_8 + _34)])
       _28[_33] = self._nativeindexes[numpy.int32(_0[(_8 + _34)])]
       _30[_33] = ((- _2[_11[_35]]) - 1)
       _37=_35
       _35 = fragments._c_closure_183(_35,_37,_36,_11,_2) # src/fusion/ModelConstraint.mbi:289:19-292:25
       _35 = numpy.int64(_35) # postprocess
       _41=1
       if ((_35 - _37) > 1):
        mosek.fusion.CommonTools._argQsort__3J_3I_3IJJ(_11,_3,_4,numpy.int64(_37),numpy.int64((_35 - _37)))
        _42=1
        _42 = fragments._c_closure_184(_35,_37,_42,_11,_3,_4) # src/fusion/ModelConstraint.mbi:306:21-309:42
        _42 = numpy.int32(_42) # postprocess
        _38 = numpy.zeros((_42,), dtype=numpy.dtype(numpy.int32))
        _39 = numpy.zeros((_42,), dtype=numpy.dtype(numpy.int32))
        _40 = numpy.zeros((_42,), dtype=numpy.dtype(numpy.float64))
        _38[0] = _3[_11[0]]
        _39[0] = _4[_11[0]]
        _40[0] = _5[_11[0]]
        _43=0
        _43 = fragments._c_closure_185(_40,_38,_39,_5,_35,_37,_43,_11,_3,_4) # src/fusion/ModelConstraint.mbi:319:21-330:22
        _43 = numpy.int32(_43) # postprocess
       else:
        _38 = numpy.array([_3[_11[_37]]], dtype=numpy.dtype(numpy.int32))
        _39 = numpy.array([_4[_11[_37]]], dtype=numpy.dtype(numpy.int32))
        _40 = numpy.array([_5[_11[_37]]], dtype=numpy.dtype(numpy.float64))
       _44=self._model._task_1append_1barmatrix_I_3I_3I_3D(self._model._task_1barvardim_I(_30[_33]),_38,_39,_40)
       _31[_33] = _44
       _33 += 1
    self._cache._add_1bar__3I_3I_3I(_29,_30,_31)
  def _add_1fx_alt__3J_3DJII(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=numpy.int64(_t__2)
   _3=numpy.int32(_t__3)
   _4=numpy.int32(_t__4)
   _1 = self._add_1fx__3J_3DJII(_0,_1,_2,_3,_4)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _add_1fx__3J_3DJII(self,_0,_1,_2,_3,_4):
   pass
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _slice_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._slice__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice__3I_3I(self,_0,_1):
   if (int((_0).shape[0])!=int((_1).shape[0])):
    raise mosek_fusion_LengthError._ctor_S("Mismatching array lengths")
   _2=self._shape_p._slice__3I_3I(_0,_1)
   _3=numpy.zeros(((self._shape_p.nd),), dtype=numpy.dtype(numpy.int64))
   _3[((self._shape_p.nd) - 1)] = 1
   _4=((self._shape_p.nd) - 1)
   while (_4 > 0):
    _3[(_4 - 1)] = (_3[_4] * self._shape_p._dim_I(_4))
    _4 = (_4 - 1)
   _5=0
   _5 = fragments._c_closure_186(_0,_5,_3) # src/fusion/ModelConstraint.mbi:113:9-114:56
   _5 = numpy.int64(_5) # postprocess
   return (mosek_fusion_SliceConstraint._ctor_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Set_2J_3J(self,_2,_5,_3))
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _slice_alt_II(self,_t__0,_t__1):
    return self._slice_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_II(self,_0,_1):
   _2=numpy.array([1], dtype=numpy.dtype(numpy.int64))
   return (mosek_fusion_SliceConstraint._ctor_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Set_2J_3J(self,self._shape_p._slice_II(_0,_1),numpy.int64(_0),_2))
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   pass
 return ModelConstraint
mosek_fusion_ModelConstraint=__mk_mosek_fusion_ModelConstraint()
del __mk_mosek_fusion_ModelConstraint
#BEFORE CLASS
def __mk_mosek_fusion_LinearPSDConstraint():
 class LinearPSDConstraint(mosek_fusion_ModelConstraint):
  __slots__ = ['_LinearPSDConstraint__psdvardim','_LinearPSDConstraint__names_flushed','_LinearPSDConstraint__numcones','_LinearPSDConstraint__conesize','_LinearPSDConstraint__coneidx']
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_LinearPSDConstraint._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_LinearPSDConstraint._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearPSDConstraint.toString()')
  def __repr__(self): return 'mosek.fusion.LinearPSDConstraint'
  @staticmethod
  def _ctor_Lmosek_4fusion_4LinearPSDConstraint_2Lmosek_4fusion_4Model_2(c,m):
    o = LinearPSDConstraint.__new__(LinearPSDConstraint)
    o._ctor_init_Lmosek_4fusion_4LinearPSDConstraint_2Lmosek_4fusion_4Model_2(c,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4LinearPSDConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_match_Lmosek_4fusion_4LinearPSDConstraint_2__(c) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4LinearPSDConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinearPSDConstraint_2__(c) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4LinearPSDConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
    self._ctor_init_Lmosek_4fusion_4LinearPSDConstraint_2Lmosek_4fusion_4Model_2(c,m)
  def _ctor_init_Lmosek_4fusion_4LinearPSDConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
   mosek_fusion_ModelConstraint._ctor_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(self,c,m)
   self.__coneidx = (c.__coneidx)
   self.__conesize = (c.__conesize)
   self.__psdvardim = (c.__psdvardim)
   self.__numcones = (c.__numcones)
   self.__names_flushed = (c.__names_flushed)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2_3IIII_3J_3I_3D_3D_3I_3I_3I(model_,name_,shape_,nativeidxs_,conesize_,firstcone_,numcone_,ptrb,subj,cof,bfix,barsubi_,barsubj_,barsymmatidx_):
    o = LinearPSDConstraint.__new__(LinearPSDConstraint)
    o._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2_3IIII_3J_3I_3D_3D_3I_3I_3I(model_,name_,shape_,nativeidxs_,conesize_,firstcone_,numcone_,ptrb,subj,cof,bfix,barsubi_,barsubj_,barsymmatidx_)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2_3IIII_3J_3I_3D_3D_3I_3I_3I(*args):
    if len(args) != 14: return False
    model_,name_,shape_,nativeidxs_,conesize_,firstcone_,numcone_,ptrb,subj,cof,bfix,barsubi_,barsubj_,barsymmatidx_, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model_) and __arg_match_S__(name_) and __arg_match_Lmosek_4fusion_4Set_2__(shape_) and __arg_match__3I__(nativeidxs_) and __arg_match_I__(conesize_) and __arg_match_I__(firstcone_) and __arg_match_I__(numcone_) and __arg_match__3J__(ptrb) and __arg_match__3I__(subj) and __arg_match__3D__(cof) and __arg_match__3D__(bfix) and __arg_match__3I__(barsubi_) and __arg_match__3I__(barsubj_) and __arg_match__3I__(barsymmatidx_))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2_3IIII_3J_3I_3D_3D_3I_3I_3I(*args):
    if len(args) != 14: return False
    model_,name_,shape_,nativeidxs_,conesize_,firstcone_,numcone_,ptrb,subj,cof,bfix,barsubi_,barsubj_,barsymmatidx_, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model_) and __arg_alt_match_S__(name_) and __arg_alt_match_Lmosek_4fusion_4Set_2__(shape_) and __arg_alt_match__3I__(nativeidxs_) and __arg_alt_match_I__(conesize_) and __arg_alt_match_I__(firstcone_) and __arg_alt_match_I__(numcone_) and __arg_alt_match__3J__(ptrb) and __arg_alt_match__3I__(subj) and __arg_alt_match__3D__(cof) and __arg_alt_match__3D__(bfix) and __arg_alt_match__3I__(barsubi_) and __arg_alt_match__3I__(barsubj_) and __arg_alt_match__3I__(barsymmatidx_))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2_3IIII_3J_3I_3D_3D_3I_3I_3I(self,model_,name_,shape_,nativeidxs_,conesize_,firstcone_,numcone_,ptrb,subj,cof,bfix,barsubi_,barsubj_,barsymmatidx_):
    self._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2_3IIII_3J_3I_3D_3D_3I_3I_3I(model_,name_,shape_,numpy.array(nativeidxs_,dtype=numpy.dtype(numpy.int32)),numpy.int32(conesize_),numpy.int32(firstcone_),numpy.int32(numcone_),numpy.array(ptrb,dtype=numpy.dtype(numpy.int64)),numpy.array(subj,dtype=numpy.dtype(numpy.int32)),numpy.array(cof,dtype=numpy.dtype(numpy.float64)),numpy.array(bfix,dtype=numpy.dtype(numpy.float64)),numpy.array(barsubi_,dtype=numpy.dtype(numpy.int32)),numpy.array(barsubj_,dtype=numpy.dtype(numpy.int32)),numpy.array(barsymmatidx_,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2_3IIII_3J_3I_3D_3D_3I_3I_3I(self,model_,name_,shape_,nativeidxs_,conesize_,firstcone_,numcone_,ptrb,subj,cof,bfix,barsubi_,barsubj_,barsymmatidx_):
   mosek_fusion_ModelConstraint._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2_3I_3J_3I_3D_3D_3I_3I_3I(self,model_,name_,shape_,nativeidxs_,ptrb,subj,cof,bfix,barsubi_,barsubj_,barsymmatidx_)
   self.__coneidx = firstcone_
   self.__conesize = conesize_
   self.__numcones = numcone_
   _0=self._shape_p._dim_I(0)
   _1=numpy.int32(((mosek.fusion.Utils.Tools._sqrt_D((1 + (8 * _0))) - 1) / 2))
   if (((_1 * (_1 + 1)) // 2)!=_0):
    raise mosek_fusion_DimensionError._ctor_S("Invalid size for semidefinite constraint")
   self.__psdvardim = _1
   self.__names_flushed = False
  def _domainToString_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   _2=self._shape_p._idxtokey_J(_0)
   _1._a_S(" : element (")._a_I(_2[0])
   for _3 in range(1,int((_2).shape[0])):
    _1._a_S(",")._a_I(_2[_3])
   _1._a_S(") in a positive semi-definite cone of size (")._a_I(self._shape_p._dim_I(0))
   for _4 in range(1,int((_2).shape[0])):
    _1._a_S(",")._a_I(self._shape_p._dim_I(_4))
   _1._a_S(")")
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=(self._shape_p._size)
   _1=numpy.zeros((_0,), dtype=numpy.dtype(object))
   self._toStringArray__3JJ_3SZ(numpy.array([_2 for _2 in range(0,_0)], dtype=numpy.dtype(numpy.int64)),0,_1,False)
   _3=mosek.fusion.Utils.StringBuffer()
   _3._a_S("LinearPSDConstraint( (")._a_I(self._shape_p._dim_I(0))
   for _4 in range(1,(self._shape_p.nd)):
    _3._a_S(",")._a_I(self._shape_p._dim_I(_4))
   _3._a_S("),")._lf_()
   _3._a_S("  ")._a_S(_1[0])
   for _5 in range(1,int((_1).shape[0])):
    _3._a_S(",")._lf_()._a_S("  ")._a_S(_1[_5])
   _3._a_S(" )")
   return (_3._toString_())
  def _toStringArray_alt__3JJ_3S(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(object))
   _1 = self._toStringArray__3JJ_3S(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _toStringArray__3JJ_3S(self,_0,_1,_2):
   self._toStringArray__3JJ_3SZ(_0,_1,_2,True)
  def _toStringArray_alt__3JJ_3SZ(self,_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(object))
   _3=_t__3
   _1 = self._toStringArray__3JJ_3SZ(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _toStringArray__3JJ_3SZ(self,_0,_1,_2,_3):
   for _4 in range(0,int((_0).shape[0])):
    if ((_0[_4] < 0) or (_0[_4] >= (self._shape_p._size))):
     raise mosek_fusion_IndexError._ctor_S("Constraint index out of bounds")
   if ((long((_0).shape[0]) + _1) > long((_2).shape[0])):
    raise mosek_fusion_LengthError._ctor_S("Result array is too small to hold the result")
   _5=mosek.fusion.Utils.StringBuffer()
   _6=self._cache._order_1barentries_()
   _7=0
   for _8 in range(0,int((_0).shape[0])):
    _9=_0[_8]
    _10=(_9 // self.__conesize)
    _11=(_9 % self.__conesize)
    _12=(_9 + self.__coneidx)
    _5._clear_()._a_S(self._name)._a_S("[")._a_J(_10)._a_S(",")._a_J(_11)._a_S("] : ")
    _13=self._nativeindexes[_9]
    _14=0
    while ((_14 < int(((self._cache.subi)).shape[0])) and ((self._cache.subi)[_14] < _12)):
     _14 += 1
    _15=_14
    while ((_14 < int(((self._cache.subi)).shape[0])) and ((self._cache.subi)[_14]==_12)):
     _14 += 1
    _16=0
    while ((_16 < _6) and ((self._cache.barsubi)[_16] < _12)):
     _16 += 1
    _17=_16
    while ((_16 < _6) and ((self._cache.barsubi)[_16]==_12)):
     _16 += 1
    for _18 in range(_15,_14):
     _19=(self._cache.cof)[_18]
     if (_19 > 0):
      _5._a_S(" + ")._a_D(_19)._a_S(" ")
     elif (_19 < 0):
      _5._a_S(" - ")._a_D((- _19))._a_S(" ")
     else:
      _5._a_S(" + 0.0 ")
     self._model._nativeVarToStr_ILmosek_4fusion_4Utils_4StringBuffer_2((self._cache.subj)[_18],_5)
    _20=_16
    _16 = _17
    while ((_16 < _20) and ((self._cache.barsubi)[_16]==_12)):
     _21=_16
     _22=(self._cache.barsubj)[_16]
     _16 += 1
     while ((_16 < _20) and ((self._cache.barsubj)[_16]==_22)):
      _16 += 1
     _5._a_S(" + < M")._a_I((self._cache.barmatidx)[_21])
     for _23 in range((_21 + 1),_16):
      _5._a_S(" + M")._a_I((self._cache.barmatidx)[_23])
     _5._a_S(" ; ")._a_S((((self._model._vars)[(self._model._natbarvarmap_Var)[(self._cache.barsubj)[_21]]]._name) if ((int(len(((self._model._vars)[(self._model._natbarvarmap_Var)[(self._cache.barsubj)[_21]]]._name))) > 0) ) else "_"))._a_S(" >")
    if (self._cache_bfix is not None):
     if (self._cache_bfix[_12] > 0):
      _5._a_S(" + ")._a_D(self._cache_bfix[_12])
     elif (self._cache_bfix[_12] < 0):
      _5._a_S(" + ")._a_D(self._cache_bfix[_12])
    if _3:
     _5._a_S(" ")
     self._domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(_9,_5)
    _2[(numpy.int64(_8) + _1)] = _5._toString_()
  def _flushNames_alt_(self,):
    return self._flushNames_()
  def _flushNames_(self,):
   if ((not self.__names_flushed) and (int(len(self._name)) > 0)):
    _0=mosek.fusion.Utils.StringBuffer()
    if (self.__numcones > 1):
     _1=0
     for _2 in range(0,self.__numcones):
      for _3 in range(0,self.__conesize):
       self._model._task_1con_1name_IS(self._nativeindexes[_1],_0._clear_()._a_S(self._name)._a_S("[")._a_I(_2)._a_S(",")._a_I(_3)._a_S("]")._toString_())
       _1 += 1
    else:
     _4=0
     for _5 in range(0,self.__conesize):
      self._model._task_1con_1name_IS(self._nativeindexes[_4],_0._clear_()._a_S(self._name)._a_S("[")._a_I(_5)._a_S("]")._toString_())
      _4 += 1
    for _6 in range(0,self.__numcones):
     self._model._task_1barvar_1name_IS((self.__coneidx + _6),_0._clear_()._a_S(self._name)._a_S("[")._a_I(_6)._a_S("].coneslack")._toString_())
    self.__names_flushed = True
  def _add_1fx_alt__3J_3DJII(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=numpy.int64(_t__2)
   _3=numpy.int32(_t__3)
   _4=numpy.int32(_t__4)
   _1 = self._add_1fx__3J_3DJII(_0,_1,_2,_3,_4)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _add_1fx__3J_3DJII(self,_0,_1,_2,_3,_4):
   _5=numpy.zeros((_4,), dtype=numpy.dtype(numpy.float64))
   _6=numpy.zeros((_4,), dtype=numpy.dtype(numpy.int32))
   fragments._c_closure_187(_6,self._nativeindexes,_4,_3,_0,_2) # src/fusion/LinearPSDConstraint.monty:187:9-188:63
   fragments._c_closure_188(_1,_5,_3,_0,_2) # src/fusion/LinearPSDConstraint.monty:190:9-191:60
   self._model._task_1con_1putboundlist_1fx__3I_3D(_6,_5)
  def _dual_1values_alt_J_3I_3JI_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1values_J_3I_3JI_3D(_0,_1,_2,_3,_4)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1values_J_3I_3JI_3D(self,_0,_1,_2,_3,_4):
   _5=mosek_fusion_IndexCounter._ctor_J_3I_3J(_0,_1,_2)
   _6=1
   _6 = fragments._c_closure_189(_1,_6) # src/fusion/LinearPSDConstraint.monty:161:22-66
   _6 = numpy.int32(_6) # postprocess
   _7=self._model._getSolution_1bars_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _8=self.__conesize
   for _9 in range(0,_6):
    _10=((_5._get_() // _8) + self.__coneidx)
    _11=(_5._get_() % _8)
    _4[_9] = _7[self.__coneidx][_11]
    _5._inc_()
  def _dual_1values_alt__3JI_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1values__3JI_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1values__3JI_3D(self,_0,_1,_2):
   _3=self._model._getSolution_1bars_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _4=self.__conesize
   fragments._c_closure_190(_3,_4,self.__coneidx,_0,_2) # src/fusion/LinearPSDConstraint.monty:144:9-150:10
  def _level_1values_alt_J_3I_3JI_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = self._level_1values_J_3I_3JI_3D(_0,_1,_2,_3,_4)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _level_1values_J_3I_3JI_3D(self,_0,_1,_2,_3,_4):
   _5=mosek_fusion_IndexCounter._ctor_J_3I_3J(_0,_1,_2)
   _6=1
   _6 = fragments._c_closure_191(_1,_6) # src/fusion/LinearPSDConstraint.monty:119:22-66
   _6 = numpy.int32(_6) # postprocess
   _7=self._model._getSolution_1barx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _8=self.__conesize
   for _9 in range(0,_6):
    _10=((_5._get_() // _8) + self.__coneidx)
    _11=(_5._get_() % _8)
    _4[_9] = _7[self.__coneidx][_11]
    _5._inc_()
  def _level_1values_alt__3JI_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._level_1values__3JI_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _level_1values__3JI_3D(self,_0,_1,_2):
   _3=self._model._getSolution_1barx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _4=self.__psdvardim
   fragments._c_closure_192(_3,_4,self.__coneidx,_0,_2) # src/fusion/LinearPSDConstraint.monty:101:9-107:10
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   return (mosek_fusion_LinearPSDConstraint._ctor_Lmosek_4fusion_4LinearPSDConstraint_2Lmosek_4fusion_4Model_2(self,_0))
 return LinearPSDConstraint
mosek_fusion_LinearPSDConstraint=__mk_mosek_fusion_LinearPSDConstraint()
del __mk_mosek_fusion_LinearPSDConstraint
#BEFORE CLASS
def __mk_mosek_fusion_PSDConstraint():
 class PSDConstraint(mosek_fusion_ModelConstraint):
  __slots__ = ['_PSDConstraint__names_flushed','_PSDConstraint__numcones','_PSDConstraint__conesize','_PSDConstraint__coneidx']
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_PSDConstraint._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_PSDConstraint._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.PSDConstraint.toString()')
  def __repr__(self): return 'mosek.fusion.PSDConstraint'
  @staticmethod
  def _ctor_Lmosek_4fusion_4PSDConstraint_2Lmosek_4fusion_4Model_2(c,m):
    o = PSDConstraint.__new__(PSDConstraint)
    o._ctor_init_Lmosek_4fusion_4PSDConstraint_2Lmosek_4fusion_4Model_2(c,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4PSDConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_match_Lmosek_4fusion_4PSDConstraint_2__(c) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4PSDConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4PSDConstraint_2__(c) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4PSDConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
    self._ctor_init_Lmosek_4fusion_4PSDConstraint_2Lmosek_4fusion_4Model_2(c,m)
  def _ctor_init_Lmosek_4fusion_4PSDConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
   mosek_fusion_ModelConstraint._ctor_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(self,c,m)
   self.__coneidx = (c.__coneidx)
   self.__conesize = (c.__conesize)
   self.__numcones = (c.__numcones)
   self.__names_flushed = (c.__names_flushed)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2_3IIII_3J_3I_3D_3D_3I_3I_3I(model_,name_,shape_,nativeidxs_,conesize_,firstcone_,numcone_,ptrb,subj,cof,bfix,barsubi_,barsubj_,barsymmatidx_):
    o = PSDConstraint.__new__(PSDConstraint)
    o._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2_3IIII_3J_3I_3D_3D_3I_3I_3I(model_,name_,shape_,nativeidxs_,conesize_,firstcone_,numcone_,ptrb,subj,cof,bfix,barsubi_,barsubj_,barsymmatidx_)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2_3IIII_3J_3I_3D_3D_3I_3I_3I(*args):
    if len(args) != 14: return False
    model_,name_,shape_,nativeidxs_,conesize_,firstcone_,numcone_,ptrb,subj,cof,bfix,barsubi_,barsubj_,barsymmatidx_, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model_) and __arg_match_S__(name_) and __arg_match_Lmosek_4fusion_4Set_2__(shape_) and __arg_match__3I__(nativeidxs_) and __arg_match_I__(conesize_) and __arg_match_I__(firstcone_) and __arg_match_I__(numcone_) and __arg_match__3J__(ptrb) and __arg_match__3I__(subj) and __arg_match__3D__(cof) and __arg_match__3D__(bfix) and __arg_match__3I__(barsubi_) and __arg_match__3I__(barsubj_) and __arg_match__3I__(barsymmatidx_))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2_3IIII_3J_3I_3D_3D_3I_3I_3I(*args):
    if len(args) != 14: return False
    model_,name_,shape_,nativeidxs_,conesize_,firstcone_,numcone_,ptrb,subj,cof,bfix,barsubi_,barsubj_,barsymmatidx_, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model_) and __arg_alt_match_S__(name_) and __arg_alt_match_Lmosek_4fusion_4Set_2__(shape_) and __arg_alt_match__3I__(nativeidxs_) and __arg_alt_match_I__(conesize_) and __arg_alt_match_I__(firstcone_) and __arg_alt_match_I__(numcone_) and __arg_alt_match__3J__(ptrb) and __arg_alt_match__3I__(subj) and __arg_alt_match__3D__(cof) and __arg_alt_match__3D__(bfix) and __arg_alt_match__3I__(barsubi_) and __arg_alt_match__3I__(barsubj_) and __arg_alt_match__3I__(barsymmatidx_))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2_3IIII_3J_3I_3D_3D_3I_3I_3I(self,model_,name_,shape_,nativeidxs_,conesize_,firstcone_,numcone_,ptrb,subj,cof,bfix,barsubi_,barsubj_,barsymmatidx_):
    self._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2_3IIII_3J_3I_3D_3D_3I_3I_3I(model_,name_,shape_,numpy.array(nativeidxs_,dtype=numpy.dtype(numpy.int32)),numpy.int32(conesize_),numpy.int32(firstcone_),numpy.int32(numcone_),numpy.array(ptrb,dtype=numpy.dtype(numpy.int64)),numpy.array(subj,dtype=numpy.dtype(numpy.int32)),numpy.array(cof,dtype=numpy.dtype(numpy.float64)),numpy.array(bfix,dtype=numpy.dtype(numpy.float64)),numpy.array(barsubi_,dtype=numpy.dtype(numpy.int32)),numpy.array(barsubj_,dtype=numpy.dtype(numpy.int32)),numpy.array(barsymmatidx_,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2_3IIII_3J_3I_3D_3D_3I_3I_3I(self,model_,name_,shape_,nativeidxs_,conesize_,firstcone_,numcone_,ptrb,subj,cof,bfix,barsubi_,barsubj_,barsymmatidx_):
   mosek_fusion_ModelConstraint._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2_3I_3J_3I_3D_3D_3I_3I_3I(self,model_,name_,shape_,nativeidxs_,ptrb,subj,cof,bfix,barsubi_,barsubj_,barsymmatidx_)
   self.__coneidx = firstcone_
   self.__conesize = conesize_
   self.__numcones = numcone_
   self.__names_flushed = False
  def _domainToString_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   _2=self._shape_p._idxtokey_J(_0)
   _1._a_S(" : element (")._a_I(_2[0])
   for _3 in range(1,int((_2).shape[0])):
    _1._a_S(",")._a_I(_2[_3])
   _1._a_S(") in a positive semi-definite cone of size (")._a_I(self._shape_p._dim_I(0))
   for _4 in range(1,int((_2).shape[0])):
    _1._a_S(",")._a_I(self._shape_p._dim_I(_4))
   _1._a_S(")")
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=(self._shape_p._size)
   _1=numpy.zeros((_0,), dtype=numpy.dtype(object))
   self._toStringArray__3JJ_3SZ(numpy.array([_2 for _2 in range(0,_0)], dtype=numpy.dtype(numpy.int64)),0,_1,False)
   _3=mosek.fusion.Utils.StringBuffer()
   _3._a_S("PSDConstraint( (")._a_I(self._shape_p._dim_I(0))
   for _4 in range(1,(self._shape_p.nd)):
    _3._a_S(",")._a_I(self._shape_p._dim_I(_4))
   _3._a_S("),")._lf_()
   _3._a_S("  ")._a_S(_1[0])
   for _5 in range(1,int((_1).shape[0])):
    _3._a_S(",")._lf_()._a_S("  ")._a_S(_1[_5])
   _3._a_S(" )")
   return (_3._toString_())
  def _toStringArray_alt__3JJ_3S(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(object))
   _1 = self._toStringArray__3JJ_3S(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _toStringArray__3JJ_3S(self,_0,_1,_2):
   self._toStringArray__3JJ_3SZ(_0,_1,_2,True)
  def _toStringArray_alt__3JJ_3SZ(self,_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(object))
   _3=_t__3
   _1 = self._toStringArray__3JJ_3SZ(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _toStringArray__3JJ_3SZ(self,_0,_1,_2,_3):
   for _4 in range(0,int((_0).shape[0])):
    if ((_0[_4] < 0) or (_0[_4] >= (self._shape_p._size))):
     raise mosek_fusion_IndexError._ctor_S("Constraint index out of bounds")
   if ((long((_0).shape[0]) + _1) > long((_2).shape[0])):
    raise mosek_fusion_LengthError._ctor_S("Result array is too small to hold the result")
   _5=mosek.fusion.Utils.StringBuffer()
   _6=self._cache._order_1barentries_()
   _7=0
   for _8 in range(0,int((_0).shape[0])):
    _9=_0[_8]
    _10=(_9 // (self.__conesize * self.__conesize))
    _11=(_9 % (self.__conesize * self.__conesize))
    _12=(_11 // self.__conesize)
    _13=(_11 % self.__conesize)
    _14=((((_12 * (_12 + 1)) // 2) + _13) if ((_12 >= _13) ) else (((_13 * (_13 + 1)) // 2) + _12))
    _15=(_14 + (((_10 * self.__conesize) * (self.__conesize + 1)) // 2))
    _5._clear_()._a_S(self._name)._a_S("[")._a_J(_10)._a_S(",")._a_J(_12)._a_S(",")._a_J(_13)._a_S("] : ")
    _16=self._nativeindexes[_15]
    _17=0
    while ((_17 < int(((self._cache.subi)).shape[0])) and ((self._cache.subi)[_17] < _15)):
     _17 += 1
    _18=_17
    while ((_17 < int(((self._cache.subi)).shape[0])) and ((self._cache.subi)[_17]==_15)):
     _17 += 1
    _19=0
    while ((_19 < _6) and ((self._cache.barsubi)[_19] < _15)):
     _19 += 1
    _20=_19
    while ((_19 < _6) and ((self._cache.barsubi)[_19]==_15)):
     _19 += 1
    for _21 in range(_18,_17):
     _22=(self._cache.cof)[_21]
     if (_22 > 0):
      _5._a_S(" + ")._a_D(_22)._a_S(" ")
     elif (_22 < 0):
      _5._a_S(" - ")._a_D((- _22))._a_S(" ")
     else:
      _5._a_S(" + 0.0 ")
     self._model._nativeVarToStr_ILmosek_4fusion_4Utils_4StringBuffer_2((self._cache.subj)[_21],_5)
    _23=_19
    _19 = _20
    while ((_19 < _23) and ((self._cache.barsubi)[_19]==_15)):
     _24=_19
     _25=(self._cache.barsubj)[_19]
     _19 += 1
     while ((_19 < _23) and ((self._cache.barsubj)[_19]==_25)):
      _19 += 1
     _5._a_S(" + < M")._a_I((self._cache.barmatidx)[_24])
     for _26 in range((_24 + 1),_19):
      _5._a_S(" + M")._a_I((self._cache.barmatidx)[_26])
     _5._a_S(" ; ")._a_S((((self._model._vars)[(self._model._natbarvarmap_Var)[(self._cache.barsubj)[_24]]]._name) if ((int(len(((self._model._vars)[(self._model._natbarvarmap_Var)[(self._cache.barsubj)[_24]]]._name))) > 0) ) else "_"))._a_S(" >")
    if (self._cache_bfix is not None):
     if (self._cache_bfix[_15] > 0):
      _5._a_S(" + ")._a_D(self._cache_bfix[_15])
     elif (self._cache_bfix[_15] < 0):
      _5._a_S(" + ")._a_D(self._cache_bfix[_15])
    if _3:
     _5._a_S(" ")
     self._domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(_9,_5)
    _2[(numpy.int64(_8) + _1)] = _5._toString_()
  def _flushNames_alt_(self,):
    return self._flushNames_()
  def _flushNames_(self,):
   if ((not self.__names_flushed) and (int(len(self._name)) > 0)):
    _0=mosek.fusion.Utils.StringBuffer()
    if (self.__numcones > 1):
     _1=0
     for _2 in range(0,self.__numcones):
      for _3 in range(0,self.__conesize):
       for _4 in range(0,(_3 + 1)):
        self._model._task_1con_1name_IS(self._nativeindexes[_1],_0._clear_()._a_S(self._name)._a_S("[")._a_I(_2)._a_S(",")._a_I(_3)._a_S(",")._a_I(_4)._a_S("]")._toString_())
        _1 += 1
    else:
     _5=0
     for _6 in range(0,self.__conesize):
      for _7 in range(0,(_6 + 1)):
       self._model._task_1con_1name_IS(self._nativeindexes[_5],_0._clear_()._a_S(self._name)._a_S("[")._a_I(_6)._a_S(",")._a_I(_7)._a_S("]")._toString_())
       _5 += 1
    for _8 in range(0,self.__numcones):
     self._model._task_1barvar_1name_IS((self.__coneidx + _8),_0._clear_()._a_S(self._name)._a_S("[")._a_I(_8)._a_S("].coneslack")._toString_())
    self.__names_flushed = True
  def _add_1fx_alt__3J_3DJII(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=numpy.int64(_t__2)
   _3=numpy.int32(_t__3)
   _4=numpy.int32(_t__4)
   _1 = self._add_1fx__3J_3DJII(_0,_1,_2,_3,_4)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _add_1fx__3J_3DJII(self,_0,_1,_2,_3,_4):
   _5=numpy.zeros((_4,), dtype=numpy.dtype(numpy.float64))
   _6=numpy.zeros((_4,), dtype=numpy.dtype(numpy.int32))
   fragments._c_closure_193(_6,self._nativeindexes,_4,_3,_0,_2) # src/fusion/SemidefiniteConstraint.mbi:233:9-234:63
   fragments._c_closure_194(_1,_5,_3,_0,_2) # src/fusion/SemidefiniteConstraint.mbi:236:9-237:60
   self._model._task_1con_1putboundlist_1fx__3I_3D(_6,_5)
  def _dual_1values_alt_J_3I_3JI_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1values_J_3I_3JI_3D(_0,_1,_2,_3,_4)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1values_J_3I_3JI_3D(self,_0,_1,_2,_3,_4):
   _5=1
   _6=int((_2).shape[0])
   _7=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int32))
   _8=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int64))
   _9=self._model._getSolution_1bars_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _10=(self.__conesize * self.__conesize)
   fragments._c_closure_195(_6,_8,_0) # src/fusion/SemidefiniteConstraint.mbi:191:9-42
   _5 = fragments._c_closure_196(_6,_1,_5) # src/fusion/SemidefiniteConstraint.mbi:192:9-51
   _5 = numpy.int64(_5) # postprocess
   for _11 in range(0,_5):
    _12=(_8[0] // _10)
    _13=(_8[0] - (_12 * _10))
    _14=(_13 // self.__conesize)
    _15=(_13 - (_14 * self.__conesize))
    if (_15 > _14):
     _4[_11] = _9[(numpy.int64(self.__coneidx) + _12)][(((_14 * self.__conesize) + _15) - ((_14 * (_14 + 1)) // 2))]
    else:
     _4[_11] = _9[(numpy.int64(self.__coneidx) + _12)][(((_15 * self.__conesize) + _14) - ((_15 * (_15 + 1)) // 2))]
    _7[0] += 1
    _8[0] = (_8[0] + _2[(_6 - 1)])
    _16=0
    _16 = 0
    while ((_16 < (_6 - 1)) and (_7[_16]==_1[_16])):
     _7[_16] = 0
     _7[(_16 + 1)] += 1
     _8[(_16 + 1)] = (_8[(_16 + 1)] + _2[((_6 - 2) - _16)])
     _16 += 1
    fragments._c_closure_197(_16,_8) # src/fusion/SemidefiniteConstraint.mbi:217:13-218:29
  def _dual_1values_alt__3JI_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1values__3JI_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1values__3JI_3D(self,_0,_1,_2):
   _3=self._model._getSolution_1bars_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _4=(self.__conesize * self.__conesize)
   fragments._c_closure_198(_3,_4,self.__coneidx,self.__conesize,_0,_2) # src/fusion/SemidefiniteConstraint.mbi:162:9-173:10
  def _level_1values_alt_J_3I_3JI_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = self._level_1values_J_3I_3JI_3D(_0,_1,_2,_3,_4)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _level_1values_J_3I_3JI_3D(self,_0,_1,_2,_3,_4):
   _5=1
   _6=int((_2).shape[0])
   _7=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int32))
   _8=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int64))
   _9=self._model._getSolution_1barx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _10=(self.__conesize * self.__conesize)
   fragments._c_closure_199(_6,_8,_0) # src/fusion/SemidefiniteConstraint.mbi:120:9-42
   _5 = fragments._c_closure_200(_6,_1,_5) # src/fusion/SemidefiniteConstraint.mbi:121:9-51
   _5 = numpy.int64(_5) # postprocess
   for _11 in range(0,_5):
    _12=(_8[0] // _10)
    _13=(_8[0] - (_12 * _10))
    _14=(_13 // self.__conesize)
    _15=(_13 - (_14 * self.__conesize))
    if (_15 > _14):
     _4[_11] = _9[(numpy.int64(self.__coneidx) + _12)][(((_14 * self.__conesize) + _15) - ((_14 * (_14 + 1)) // 2))]
    else:
     _4[_11] = _9[(numpy.int64(self.__coneidx) + _12)][(((_15 * self.__conesize) + _14) - ((_15 * (_15 + 1)) // 2))]
    _7[0] += 1
    _8[0] = (_8[0] + _2[(_6 - 1)])
    _16=0
    _16 = 0
    while ((_16 < (_6 - 1)) and (_7[_16]==_1[_16])):
     _7[_16] = 0
     _7[(_16 + 1)] += 1
     _8[(_16 + 1)] = (_8[(_16 + 1)] + _2[((_6 - 2) - _16)])
     _16 += 1
    fragments._c_closure_201(_16,_8) # src/fusion/SemidefiniteConstraint.mbi:146:13-147:29
  def _level_1values_alt__3JI_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._level_1values__3JI_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _level_1values__3JI_3D(self,_0,_1,_2):
   _3=self._model._getSolution_1barx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _4=(self.__conesize * self.__conesize)
   fragments._c_closure_202(_3,_4,self.__coneidx,self.__conesize,_0,_2) # src/fusion/SemidefiniteConstraint.mbi:90:9-101:10
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   return (mosek_fusion_PSDConstraint._ctor_Lmosek_4fusion_4PSDConstraint_2Lmosek_4fusion_4Model_2(self,_0))
 return PSDConstraint
mosek_fusion_PSDConstraint=__mk_mosek_fusion_PSDConstraint()
del __mk_mosek_fusion_PSDConstraint
#BEFORE CLASS
def __mk_mosek_fusion_RangedConstraint():
 class RangedConstraint(mosek_fusion_ModelConstraint):
  __slots__ = ['_RangedConstraint__idxmap','_RangedConstraint__dom']
  def upperBoundCon(self,*args):
    if False: pass
    elif mosek_fusion_RangedConstraint._match_upperBoundCon_(*args): # 
      return self._upperBoundCon_(*args)
    elif mosek_fusion_RangedConstraint._match_alt_upperBoundCon_(*args): # 
      return self._upperBoundCon_alt_(*args)
    else:
      raise ValueError('Invalid argument list upperBoundCon('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RangedConstraint.upperBoundCon()')
  def lowerBoundCon(self,*args):
    if False: pass
    elif mosek_fusion_RangedConstraint._match_lowerBoundCon_(*args): # 
      return self._lowerBoundCon_(*args)
    elif mosek_fusion_RangedConstraint._match_alt_lowerBoundCon_(*args): # 
      return self._lowerBoundCon_alt_(*args)
    else:
      raise ValueError('Invalid argument list lowerBoundCon('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RangedConstraint.lowerBoundCon()')
  def __repr__(self): return 'mosek.fusion.RangedConstraint'
  @staticmethod
  def _ctor_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Model_2(c,m):
    o = RangedConstraint.__new__(RangedConstraint)
    o._ctor_init_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Model_2(c,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_match_Lmosek_4fusion_4RangedConstraint_2__(c) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4RangedConstraint_2__(c) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
    self._ctor_init_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Model_2(c,m)
  def _ctor_init_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
   mosek_fusion_ModelConstraint._ctor_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(self,c,m)
   self.__dom = (c.__dom)
   self.__idxmap = None
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2_3I_3J_3I_3D_3D_3I_3I_3I(model_,name_,shape_,dom_,nidxs_,ptrb,subj,cof,bfix,barsubi,barsubj,barmatidx):
    o = RangedConstraint.__new__(RangedConstraint)
    o._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2_3I_3J_3I_3D_3D_3I_3I_3I(model_,name_,shape_,dom_,nidxs_,ptrb,subj,cof,bfix,barsubi,barsubj,barmatidx)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2_3I_3J_3I_3D_3D_3I_3I_3I(*args):
    if len(args) != 12: return False
    model_,name_,shape_,dom_,nidxs_,ptrb,subj,cof,bfix,barsubi,barsubj,barmatidx, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model_) and __arg_match_S__(name_) and __arg_match_Lmosek_4fusion_4Set_2__(shape_) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(dom_) and __arg_match__3I__(nidxs_) and __arg_match__3J__(ptrb) and __arg_match__3I__(subj) and __arg_match__3D__(cof) and __arg_match__3D__(bfix) and __arg_match__3I__(barsubi) and __arg_match__3I__(barsubj) and __arg_match__3I__(barmatidx))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2_3I_3J_3I_3D_3D_3I_3I_3I(*args):
    if len(args) != 12: return False
    model_,name_,shape_,dom_,nidxs_,ptrb,subj,cof,bfix,barsubi,barsubj,barmatidx, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model_) and __arg_alt_match_S__(name_) and __arg_alt_match_Lmosek_4fusion_4Set_2__(shape_) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(dom_) and __arg_alt_match__3I__(nidxs_) and __arg_alt_match__3J__(ptrb) and __arg_alt_match__3I__(subj) and __arg_alt_match__3D__(cof) and __arg_alt_match__3D__(bfix) and __arg_alt_match__3I__(barsubi) and __arg_alt_match__3I__(barsubj) and __arg_alt_match__3I__(barmatidx))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2_3I_3J_3I_3D_3D_3I_3I_3I(self,model_,name_,shape_,dom_,nidxs_,ptrb,subj,cof,bfix,barsubi,barsubj,barmatidx):
    self._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2_3I_3J_3I_3D_3D_3I_3I_3I(model_,name_,shape_,dom_,numpy.array(nidxs_,dtype=numpy.dtype(numpy.int32)),numpy.array(ptrb,dtype=numpy.dtype(numpy.int64)),numpy.array(subj,dtype=numpy.dtype(numpy.int32)),numpy.array(cof,dtype=numpy.dtype(numpy.float64)),numpy.array(bfix,dtype=numpy.dtype(numpy.float64)),numpy.array(barsubi,dtype=numpy.dtype(numpy.int32)),numpy.array(barsubj,dtype=numpy.dtype(numpy.int32)),numpy.array(barmatidx,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2_3I_3J_3I_3D_3D_3I_3I_3I(self,model_,name_,shape_,dom_,nidxs_,ptrb,subj,cof,bfix,barsubi,barsubj,barmatidx):
   mosek_fusion_ModelConstraint._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2_3I_3J_3I_3D_3D_3I_3I_3I(self,model_,name_,shape_,nidxs_,ptrb,subj,cof,bfix,barsubi,barsubj,barmatidx)
   self.__dom = dom_
   self.__idxmap = None
  def _add_1fx_alt__3J_3DJII(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=numpy.int64(_t__2)
   _3=numpy.int32(_t__3)
   _4=numpy.int32(_t__4)
   _1 = self._add_1fx__3J_3DJII(_0,_1,_2,_3,_4)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _add_1fx__3J_3DJII(self,_0,_1,_2,_3,_4):
   _5=numpy.zeros((_4,), dtype=numpy.dtype(numpy.float64))
   _6=numpy.zeros((_4,), dtype=numpy.dtype(numpy.float64))
   _7=numpy.zeros((_4,), dtype=numpy.dtype(numpy.int32))
   fragments._c_closure_203(_7,self._nativeindexes,_4,_3,_0,_2) # src/fusion/RangedConstraint.mbi:375:9-376:63
   for _8 in range(0,int((_5).shape[0])):
    _5[_8] = (self.__dom._get_1lb_1item_J((_0[(_3 + _8)] - _2)) - _1[(_0[(_3 + _8)] - _2)])
    _6[_8] = (self.__dom._get_1ub_1item_J((_0[(_3 + _8)] - _2)) - _1[(_0[(_3 + _8)] - _2)])
   self._model._task_1con_1putboundlist_1ra__3I_3D_3D(_7,_5,_6)
  def _dual_1u_alt_J_3I_3JI_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1u_J_3I_3JI_3D(_0,_1,_2,_3,_4)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1u_J_3I_3JI_3D(self,_0,_1,_2,_3,_4):
   _5=1
   _6=int((_2).shape[0])
   _7=mosek_fusion_IndexCounter._ctor_J_3I_3J(_0,_1,_2)
   _8=self._model._getSolution_1suc_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _5 = fragments._c_closure_204(_6,_1,_5) # src/fusion/RangedConstraint.mbi:341:9-51
   _5 = numpy.int64(_5) # postprocess
   if (self._nativeindexes is not None):
    for _9 in range(0,_5):
     _4[(_9 + _3)] = (_8[self._nativeindexes[_7._get_()]] + (self._cache.bfix)[_7._get_()])
     _7._inc_()
   else:
    for _10 in range(0,_5):
     if self.__idxmap._hasItem_J(_7._get_()):
      _4[_10] = (_8[self.__idxmap._getItem_J(_7._get_())] + (self._cache.bfix)[_7._get_()])
     else:
      _4[_10] = self.__dom._get_1ub_1item_J(_7._get_())
     _7._inc_()
  def _dual_1u_alt__3JI_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1u__3JI_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1u__3JI_3D(self,_0,_1,_2):
   _3=self._model._getSolution_1suc_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   if (self._nativeindexes is not None):
    for _4 in range(0,int((_0).shape[0])):
     _2[(_1 + _4)] = (_3[self._nativeindexes[_0[_4]]] + (self._cache.bfix)[_0[_4]])
   else:
    for _5 in range(0,int((_0).shape[0])):
     if self.__idxmap._hasItem_J(_0[_5]):
      _2[(_1 + _5)] = (_3[self.__idxmap._getItem_J(_0[_5])] + (self._cache.bfix)[_0[_5]])
     else:
      _2[(_1 + _5)] = self.__dom._get_1ub_1item_J(_0[_5])
  def _dual_1l_alt_J_3I_3JI_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1l_J_3I_3JI_3D(_0,_1,_2,_3,_4)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1l_J_3I_3JI_3D(self,_0,_1,_2,_3,_4):
   _5=1
   _6=int((_2).shape[0])
   _7=mosek_fusion_IndexCounter._ctor_J_3I_3J(_0,_1,_2)
   _8=self._model._getSolution_1slc_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _5 = fragments._c_closure_205(_6,_1,_5) # src/fusion/RangedConstraint.mbi:285:9-51
   _5 = numpy.int64(_5) # postprocess
   if (self._nativeindexes is not None):
    for _9 in range(0,_5):
     _4[(_9 + _3)] = (_8[self._nativeindexes[_7._get_()]] + (self._cache.bfix)[_7._get_()])
     _7._inc_()
   else:
    for _10 in range(0,_5):
     if self.__idxmap._hasItem_J(_7._get_()):
      _4[_10] = (_8[self.__idxmap._getItem_J(_7._get_())] + (self._cache.bfix)[_7._get_()])
     else:
      _4[_10] = self.__dom._get_1ub_1item_J(_7._get_())
     _7._inc_()
  def _dual_1l_alt__3JI_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1l__3JI_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1l__3JI_3D(self,_0,_1,_2):
   _3=self._model._getSolution_1slc_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   if (self._nativeindexes is not None):
    for _4 in range(0,int((_0).shape[0])):
     _2[(_1 + _4)] = (_3[self._nativeindexes[_0[_4]]] + (self._cache.bfix)[_0[_4]])
   else:
    for _5 in range(0,int((_0).shape[0])):
     if self.__idxmap._hasItem_J(_0[_5]):
      _2[(_1 + _5)] = (_3[self.__idxmap._getItem_J(_0[_5])] + (self._cache.bfix)[_0[_5]])
     else:
      _2[(_1 + _5)] = self.__dom._get_1ub_1item_J(_0[_5])
  def _dual_1values_alt_J_3I_3JI_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1values_J_3I_3JI_3D(_0,_1,_2,_3,_4)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1values_J_3I_3JI_3D(self,_0,_1,_2,_3,_4):
   _5=1
   _6=int((_2).shape[0])
   _7=mosek_fusion_IndexCounter._ctor_J_3I_3J(_0,_1,_2)
   _8=self._model._getSolution_1y_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _5 = fragments._c_closure_206(_6,_1,_5) # src/fusion/RangedConstraint.mbi:228:9-51
   _5 = numpy.int64(_5) # postprocess
   if (self._nativeindexes is not None):
    for _9 in range(0,_5):
     _4[(_9 + _3)] = (_8[self._nativeindexes[_7._get_()]] + (self._cache.bfix)[_7._get_()])
     _7._inc_()
   else:
    for _10 in range(0,_5):
     if self.__idxmap._hasItem_J(_7._get_()):
      _4[_10] = (_8[self.__idxmap._getItem_J(_7._get_())] + (self._cache.bfix)[_7._get_()])
     else:
      _4[_10] = self.__dom._get_1ub_1item_J(_7._get_())
     _7._inc_()
  def _dual_1values_alt__3JI_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1values__3JI_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1values__3JI_3D(self,_0,_1,_2):
   _3=self._model._getSolution_1y_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   if (self._nativeindexes is not None):
    for _4 in range(0,int((_0).shape[0])):
     _2[(_1 + _4)] = (_3[self._nativeindexes[_0[_4]]] + (self._cache.bfix)[_0[_4]])
   else:
    for _5 in range(0,int((_0).shape[0])):
     if self.__idxmap._hasItem_J(_0[_5]):
      _2[(_1 + _5)] = (_3[self.__idxmap._getItem_J(_0[_5])] + (self._cache.bfix)[_0[_5]])
     else:
      _2[(_1 + _5)] = self.__dom._get_1ub_1item_J(_0[_5])
  def _level_1values_alt_J_3I_3JI_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = self._level_1values_J_3I_3JI_3D(_0,_1,_2,_3,_4)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _level_1values_J_3I_3JI_3D(self,_0,_1,_2,_3,_4):
   _5=1
   _6=int((_2).shape[0])
   _7=mosek_fusion_IndexCounter._ctor_J_3I_3J(_0,_1,_2)
   _8=self._model._getSolution_1xc_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _5 = fragments._c_closure_207(_6,_1,_5) # src/fusion/RangedConstraint.mbi:173:9-51
   _5 = numpy.int64(_5) # postprocess
   if (self._nativeindexes is not None):
    for _9 in range(0,_5):
     _4[(_9 + _3)] = (_8[self._nativeindexes[_7._get_()]] + (self._cache.bfix)[_7._get_()])
     _7._inc_()
   else:
    for _10 in range(0,_5):
     if self.__idxmap._hasItem_J(_7._get_()):
      _4[_10] = (_8[self.__idxmap._getItem_J(_7._get_())] + (self._cache.bfix)[_7._get_()])
     else:
      _4[_10] = self.__dom._get_1ub_1item_J(_7._get_())
     _7._inc_()
  def _level_1values_alt__3JI_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._level_1values__3JI_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _level_1values__3JI_3D(self,_0,_1,_2):
   _3=self._model._getSolution_1xc_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   if (self._nativeindexes is not None):
    for _4 in range(0,int((_0).shape[0])):
     _2[(_1 + _4)] = (_3[self._nativeindexes[_0[_4]]] + (self._cache.bfix)[_0[_4]])
   else:
    for _5 in range(0,int((_0).shape[0])):
     if self.__idxmap._hasItem_J(_0[_5]):
      _2[(_1 + _5)] = (_3[self.__idxmap._getItem_J(_0[_5])] + (self._cache.bfix)[_0[_5]])
     else:
      _2[(_1 + _5)] = self.__dom._get_1ub_1item_J(_0[_5])
  def _add_1l_alt__3J_3J_3I_3I_3I_3D_3DIII(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7,_t__8,_t__9):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int32))
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.float64))
   _6=numpy.array(_t__6,dtype=numpy.dtype(numpy.float64))
   _7=numpy.int32(_t__7)
   _8=numpy.int32(_t__8)
   _9=numpy.int32(_t__9)
   _1 = self._add_1l__3J_3J_3I_3I_3I_3D_3DIII(_0,_1,_2,_3,_4,_5,_6,_7,_8,_9)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__6[:] = _6
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _add_1l__3J_3J_3I_3I_3I_3D_3DIII(self,_0,_1,_2,_3,_4,_5,_6,_7,_8,_9):
   self._add_1l__3J_3J_3I_3I_3I_3D_3DIII(_0,_1,_2,_3,_4,_5,_6,_7,_8,_9)
   if (_6 is not None):
    _10=((self.__dom._shape)._size)
    _11=numpy.zeros((_10,), dtype=numpy.dtype(numpy.float64))
    _12=numpy.zeros((_10,), dtype=numpy.dtype(numpy.float64))
    _13=numpy.zeros((_9,), dtype=numpy.dtype(numpy.int32))
    for _14 in range(0,_9):
     _11[_14] = (self.__dom._get_1lb_1item_J(_0[_14]) - (self._cache.bfix)[_14])
     _12[_14] = (self.__dom._get_1ub_1item_J(_0[_14]) - (self._cache.bfix)[_14])
     _13[_14] = self._nativeindexes[_0[_14]]
    self._model._task_1con_1putboundlist_1ra__3I_3D_3D(_13,_11,_12)
  def _domainToString_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   self.__dom._domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(_0,_1)
  @staticmethod
  def _match_upperBoundCon_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_upperBoundCon_(*args):
    if len(args) != 0: return False
    return True
  def _upperBoundCon_alt_(self,):
    return self._upperBoundCon_()
  def _upperBoundCon_(self,):
   _0=numpy.zeros(((self._shape_p.nd),), dtype=numpy.dtype(numpy.int64))
   _0[((self._shape_p.nd) - 1)] = 1
   _1=((self._shape_p.nd) - 1)
   while (_1 > 0):
    _0[(_1 - 1)] = (_0[_1] * self._shape_p._dim_I(_1))
    _1 -= 1
   return (mosek_fusion_BoundInterfaceConstraint._ctor_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Set_2J_3JZ(self,self._shape_p,0,_0,False))
  @staticmethod
  def _match_lowerBoundCon_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_lowerBoundCon_(*args):
    if len(args) != 0: return False
    return True
  def _lowerBoundCon_alt_(self,):
    return self._lowerBoundCon_()
  def _lowerBoundCon_(self,):
   _0=numpy.zeros(((self._shape_p.nd),), dtype=numpy.dtype(numpy.int64))
   _0[((self._shape_p.nd) - 1)] = 1
   _1=((self._shape_p.nd) - 1)
   while (_1 > 0):
    _0[(_1 - 1)] = (_0[_1] * self._shape_p._dim_I(_1))
    _1 -= 1
   return (mosek_fusion_BoundInterfaceConstraint._ctor_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Set_2J_3JZ(self,self._shape_p,0,_0,True))
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   return (mosek_fusion_RangedConstraint._ctor_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Model_2(self,_0))
 return RangedConstraint
mosek_fusion_RangedConstraint=__mk_mosek_fusion_RangedConstraint()
del __mk_mosek_fusion_RangedConstraint
#BEFORE CLASS
def __mk_mosek_fusion_ConicConstraint():
 class ConicConstraint(mosek_fusion_ModelConstraint):
  __slots__ = ['_ConicConstraint__names_flushed','_ConicConstraint__dom','_ConicConstraint__conesize','_ConicConstraint__last','_ConicConstraint__first','_ConicConstraint__last_slack','_ConicConstraint__first_slack','_ConicConstraint__coneidx']
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ConicConstraint._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ConicConstraint._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ConicConstraint.toString()')
  def dual(self,*args):
    if False: pass
    elif mosek_fusion_ConicConstraint._match_dual_(*args): # 
      return self._dual_(*args)
    elif mosek_fusion_ConicConstraint._match_alt_dual_(*args): # 
      return self._dual_alt_(*args)
    elif mosek_fusion_ConicConstraint._match_dual_II(*args): # int32,int32
      return self._dual_II(*args)
    elif mosek_fusion_ConicConstraint._match_alt_dual_II(*args): # int32,int32
      return self._dual_alt_II(*args)
    elif mosek_fusion_ConicConstraint._match_dual__3I_3I(*args): # []int32,[]int32
      return self._dual__3I_3I(*args)
    elif mosek_fusion_ConicConstraint._match_alt_dual__3I_3I(*args): # []int32,[]int32
      return self._dual_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list dual('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ConicConstraint.dual()\n\tmosek.fusion.ConicConstraint.dual(int32,int32)\n\tmosek.fusion.ConicConstraint.dual(array(int32,ndim=1),array(int32,ndim=1))')
  def __repr__(self): return 'mosek.fusion.ConicConstraint'
  @staticmethod
  def _ctor_Lmosek_4fusion_4ConicConstraint_2Lmosek_4fusion_4Model_2(c,m):
    o = ConicConstraint.__new__(ConicConstraint)
    o._ctor_init_Lmosek_4fusion_4ConicConstraint_2Lmosek_4fusion_4Model_2(c,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4ConicConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_match_Lmosek_4fusion_4ConicConstraint_2__(c) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4ConicConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4ConicConstraint_2__(c) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4ConicConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
    self._ctor_init_Lmosek_4fusion_4ConicConstraint_2Lmosek_4fusion_4Model_2(c,m)
  def _ctor_init_Lmosek_4fusion_4ConicConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
   mosek_fusion_ModelConstraint._ctor_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(self,c,m)
   self.__first_slack = (c.__first_slack)
   self.__last_slack = (c.__last_slack)
   self.__first = (c.__first)
   self.__last = (c.__last)
   self.__dom = (c.__dom)
   self.__conesize = (c.__conesize)
   self.__coneidx = (c.__coneidx)
   self.__names_flushed = (c.__names_flushed)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4QConeDomain_2Lmosek_4fusion_4Set_2_3IIIIII_3J_3I_3D_3D_3I_3I_3I(model_,name_,dom_,shape_,nativeidxs_,first_slack_,last_slack_,conesize_,firstcone_,numcone_,ptrb,subj,cof,bfix,barsubi,barsubj,barmatidx):
    o = ConicConstraint.__new__(ConicConstraint)
    o._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4QConeDomain_2Lmosek_4fusion_4Set_2_3IIIIII_3J_3I_3D_3D_3I_3I_3I(model_,name_,dom_,shape_,nativeidxs_,first_slack_,last_slack_,conesize_,firstcone_,numcone_,ptrb,subj,cof,bfix,barsubi,barsubj,barmatidx)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4QConeDomain_2Lmosek_4fusion_4Set_2_3IIIIII_3J_3I_3D_3D_3I_3I_3I(*args):
    if len(args) != 17: return False
    model_,name_,dom_,shape_,nativeidxs_,first_slack_,last_slack_,conesize_,firstcone_,numcone_,ptrb,subj,cof,bfix,barsubi,barsubj,barmatidx, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model_) and __arg_match_S__(name_) and __arg_match_Lmosek_4fusion_4QConeDomain_2__(dom_) and __arg_match_Lmosek_4fusion_4Set_2__(shape_) and __arg_match__3I__(nativeidxs_) and __arg_match_I__(first_slack_) and __arg_match_I__(last_slack_) and __arg_match_I__(conesize_) and __arg_match_I__(firstcone_) and __arg_match_I__(numcone_) and __arg_match__3J__(ptrb) and __arg_match__3I__(subj) and __arg_match__3D__(cof) and __arg_match__3D__(bfix) and __arg_match__3I__(barsubi) and __arg_match__3I__(barsubj) and __arg_match__3I__(barmatidx))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4QConeDomain_2Lmosek_4fusion_4Set_2_3IIIIII_3J_3I_3D_3D_3I_3I_3I(*args):
    if len(args) != 17: return False
    model_,name_,dom_,shape_,nativeidxs_,first_slack_,last_slack_,conesize_,firstcone_,numcone_,ptrb,subj,cof,bfix,barsubi,barsubj,barmatidx, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model_) and __arg_alt_match_S__(name_) and __arg_alt_match_Lmosek_4fusion_4QConeDomain_2__(dom_) and __arg_alt_match_Lmosek_4fusion_4Set_2__(shape_) and __arg_alt_match__3I__(nativeidxs_) and __arg_alt_match_I__(first_slack_) and __arg_alt_match_I__(last_slack_) and __arg_alt_match_I__(conesize_) and __arg_alt_match_I__(firstcone_) and __arg_alt_match_I__(numcone_) and __arg_alt_match__3J__(ptrb) and __arg_alt_match__3I__(subj) and __arg_alt_match__3D__(cof) and __arg_alt_match__3D__(bfix) and __arg_alt_match__3I__(barsubi) and __arg_alt_match__3I__(barsubj) and __arg_alt_match__3I__(barmatidx))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4QConeDomain_2Lmosek_4fusion_4Set_2_3IIIIII_3J_3I_3D_3D_3I_3I_3I(self,model_,name_,dom_,shape_,nativeidxs_,first_slack_,last_slack_,conesize_,firstcone_,numcone_,ptrb,subj,cof,bfix,barsubi,barsubj,barmatidx):
    self._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4QConeDomain_2Lmosek_4fusion_4Set_2_3IIIIII_3J_3I_3D_3D_3I_3I_3I(model_,name_,dom_,shape_,numpy.array(nativeidxs_,dtype=numpy.dtype(numpy.int32)),numpy.int32(first_slack_),numpy.int32(last_slack_),numpy.int32(conesize_),numpy.int32(firstcone_),numpy.int32(numcone_),numpy.array(ptrb,dtype=numpy.dtype(numpy.int64)),numpy.array(subj,dtype=numpy.dtype(numpy.int32)),numpy.array(cof,dtype=numpy.dtype(numpy.float64)),numpy.array(bfix,dtype=numpy.dtype(numpy.float64)),numpy.array(barsubi,dtype=numpy.dtype(numpy.int32)),numpy.array(barsubj,dtype=numpy.dtype(numpy.int32)),numpy.array(barmatidx,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4QConeDomain_2Lmosek_4fusion_4Set_2_3IIIIII_3J_3I_3D_3D_3I_3I_3I(self,model_,name_,dom_,shape_,nativeidxs_,first_slack_,last_slack_,conesize_,firstcone_,numcone_,ptrb,subj,cof,bfix,barsubi,barsubj,barmatidx):
   mosek_fusion_ModelConstraint._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2_3I_3J_3I_3D_3D_3I_3I_3I(self,model_,name_,shape_,nativeidxs_,ptrb,subj,cof,bfix,barsubi,barsubj,barmatidx)
   self.__first_slack = first_slack_
   self.__last_slack = last_slack_
   self.__first = firstcone_
   self.__last = (firstcone_ + numcone_)
   self.__dom = dom_
   self.__conesize = conesize_
   self.__coneidx = firstcone_
   self.__names_flushed = False
  def _flushNames_alt_(self,):
    return self._flushNames_()
  def _flushNames_(self,):
   mosek_fusion_ModelConstraint._flushNames_(self)
   if ((not self.__names_flushed) and (int(len(self._name)) > 0)):
    for _0 in range(self.__first_slack,self.__last_slack):
     self._model._task_1var_1name_IS(_0,("" if ((int(len(self._name))==0) ) else mosek.fusion.Utils.StringBuffer()._a_S(self._name)._a_S("[")._a_S(self._shape_p._getname_J((_0 - self.__first_slack)))._a_S("].coneslack")._toString_()))
    for _1 in range(self.__first,self.__last):
     self._model._task_1cone_1name_IS(_1,("" if ((int(len(self._name))==0) ) else mosek.fusion.Utils.StringBuffer()._a_S(self._name)._a_S("[")._a_I((_1 - self.__first))._a_S("]")._toString_()))
    self.__names_flushed = True
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=(self._shape_p._size)
   _1=numpy.zeros((_0,), dtype=numpy.dtype(object))
   self._toStringArray__3JJ_3S(mosek.fusion.Utils.Tools._range_J(_0),0,_1)
   _2=mosek.fusion.Utils.StringBuffer()
   _2._a_S("ConicConstraint( (")._a_I(self._shape_p._dim_I(0))
   for _3 in range(1,(self._shape_p.nd)):
    _2._a_S(",")._a_I(self._shape_p._dim_I(_3))
   _2._a_S("),")
   if ((self.__dom._key)==mosek.fusion.QConeKey.InQCone):
    _2._a_S(" QuadCone,")._lf_()
   else:
    _2._a_S(" RotatedQuadCone,")._lf_()
   _2._a_S("  ")._a_S(_1[0])
   for _4 in range(1,int((_1).shape[0])):
    _2._a_S(",")._lf_()._a_S("  ")._a_S(_1[_4])
   _2._a_S(" )")
   return (_2._toString_())
  def _dual_1values_alt_J_3I_3JI_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1values_J_3I_3JI_3D(_0,_1,_2,_3,_4)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1values_J_3I_3JI_3D(self,_0,_1,_2,_3,_4):
   _5=1
   _6=int((_2).shape[0])
   _7=mosek_fusion_IndexCounter._ctor_J_3I_3J(_0,_1,_2)
   _8=self._model._getSolution_1snx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _5 = fragments._c_closure_208(_6,_1,_5) # src/fusion/ConicConstraint.mbi:261:9-51
   _5 = numpy.int64(_5) # postprocess
   for _9 in range(0,_5):
    _4[(_9 + _3)] = _8[(numpy.int64(self.__first_slack) + _7._get_())]
    _7._inc_()
  def _dual_1values_alt__3JI_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1values__3JI_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1values__3JI_3D(self,_0,_1,_2):
   _3=self._model._getSolution_1snx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   fragments._c_closure_209(self.__first_slack,_0,_1,_2,_3) # src/fusion/ConicConstraint.mbi:244:9-245:63
  def _level_1values_alt_J_3I_3JI_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = self._level_1values_J_3I_3JI_3D(_0,_1,_2,_3,_4)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _level_1values_J_3I_3JI_3D(self,_0,_1,_2,_3,_4):
   _5=1
   _6=int((_2).shape[0])
   _7=mosek_fusion_IndexCounter._ctor_J_3I_3J(_0,_1,_2)
   _8=self._model._getSolution_1xx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _9=self._model._getSolution_1xc_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _5 = fragments._c_closure_210(_6,_1,_5) # src/fusion/ConicConstraint.mbi:226:9-51
   _5 = numpy.int64(_5) # postprocess
   for _10 in range(0,_5):
    _4[(_10 + _3)] = (_8[(self.__first_slack + _7._get_())] + _9[self._nativeindexes[_7._get_()]])
    _7._inc_()
  def _level_1values_alt__3JI_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._level_1values__3JI_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _level_1values__3JI_3D(self,_0,_1,_2):
   _3=self._model._getSolution_1xx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _4=self._model._getSolution_1xc_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   fragments._c_closure_211(self.__first_slack,_0,self._nativeindexes,_1,_2,_4,_3) # src/fusion/ConicConstraint.mbi:207:9-208:85
  def _add_1fx_alt__3J_3DJII(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=numpy.int64(_t__2)
   _3=numpy.int32(_t__3)
   _4=numpy.int32(_t__4)
   _1 = self._add_1fx__3J_3DJII(_0,_1,_2,_3,_4)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _add_1fx__3J_3DJII(self,_0,_1,_2,_3,_4):
   _5=numpy.array([(- _1[(_0[(_3 + _6)] - _2)]) for _6 in range(0,_4)], dtype=numpy.dtype(numpy.float64))
   _7=numpy.array([self._nativeindexes[(_0[(_3 + _8)] - _2)] for _8 in range(0,_4)], dtype=numpy.dtype(numpy.int32))
   self._model._task_1con_1putboundlist_1fx__3I_3D(_7,_5)
  def _dual_alt__3IIII_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.int32(_t__1)
   _2=numpy.int32(_t__2)
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual__3IIII_3D(_0,_1,_2,_3,_4)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual__3IIII_3D(self,_0,_1,_2,_3,_4):
   if ((_2 - _1) > (int((_4).shape[0]) - _3)):
    raise mosek_fusion_SliceError._ctor_S("Wrong target array length")
   elif ((_2 < _1) or (_2 >= int((_0).shape[0]))):
    raise mosek_fusion_SliceError._ctor_S("Slice indexes out of bounds")
   _5=self._model._getSolution_1snx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   fragments._c_closure_212(_1,self.__first_slack,_0,_2,_3,_5,_4) # src/fusion/ConicConstraint.mbi:171:11-174:12
  def _dual_1values_alt__3I_3II_3D(self,_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.int32(_t__2)
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1values__3I_3II_3D(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1values__3I_3II_3D(self,_0,_1,_2,_3):
   if ((int((_0).shape[0])!=1) or (int((_1).shape[0])!=1)):
    raise mosek_fusion_SliceError._ctor_S("Invalid slice dimensions")
   _4=_0[0]
   _5=_1[0]
   if ((_5 - _4) > (int((_3).shape[0]) - _2)):
    raise mosek_fusion_SliceError._ctor_S("Wrong target array length")
   elif ((_5 < _4) or (_5 > (self.__last_slack - self.__first_slack))):
    raise mosek_fusion_SliceError._ctor_S("Slice indexes out of bounds")
   _6 = self._model._getSolution_1snx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   fragments._c_closure_213(_4,self.__first_slack,_5,_2,_6,_3) # src/fusion/ConicConstraint.mbi:147:11-150:12
  def _domainToString_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   self.__dom._domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(_0,_1)
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   return (mosek_fusion_ConicConstraint._ctor_Lmosek_4fusion_4ConicConstraint_2Lmosek_4fusion_4Model_2(self,_0))
 return ConicConstraint
mosek_fusion_ConicConstraint=__mk_mosek_fusion_ConicConstraint()
del __mk_mosek_fusion_ConicConstraint
#BEFORE CLASS
def __mk_mosek_fusion_LinearConstraint():
 class LinearConstraint(mosek_fusion_ModelConstraint):
  __slots__ = ['_LinearConstraint__dom','_LinearConstraint__idxmap']
  def __repr__(self): return 'mosek.fusion.LinearConstraint'
  @staticmethod
  def _ctor_Lmosek_4fusion_4LinearConstraint_2Lmosek_4fusion_4Model_2(c,m):
    o = LinearConstraint.__new__(LinearConstraint)
    o._ctor_init_Lmosek_4fusion_4LinearConstraint_2Lmosek_4fusion_4Model_2(c,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4LinearConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_match_Lmosek_4fusion_4LinearConstraint_2__(c) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4LinearConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinearConstraint_2__(c) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4LinearConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
    self._ctor_init_Lmosek_4fusion_4LinearConstraint_2Lmosek_4fusion_4Model_2(c,m)
  def _ctor_init_Lmosek_4fusion_4LinearConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
   mosek_fusion_ModelConstraint._ctor_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(self,c,m)
   self.__dom = (c.__dom)
   self.__idxmap = None
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4LinearDomain_2Lmosek_4fusion_4Set_2_3I_3J_3I_3D_3D_3I_3I_3I(model_,name_,dom_,shape_,nidxs_,ptrb,subj,cof,bfix,barsubi,barsubj,barmatidx):
    o = LinearConstraint.__new__(LinearConstraint)
    o._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4LinearDomain_2Lmosek_4fusion_4Set_2_3I_3J_3I_3D_3D_3I_3I_3I(model_,name_,dom_,shape_,nidxs_,ptrb,subj,cof,bfix,barsubi,barsubj,barmatidx)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4LinearDomain_2Lmosek_4fusion_4Set_2_3I_3J_3I_3D_3D_3I_3I_3I(*args):
    if len(args) != 12: return False
    model_,name_,dom_,shape_,nidxs_,ptrb,subj,cof,bfix,barsubi,barsubj,barmatidx, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model_) and __arg_match_S__(name_) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(dom_) and __arg_match_Lmosek_4fusion_4Set_2__(shape_) and __arg_match__3I__(nidxs_) and __arg_match__3J__(ptrb) and __arg_match__3I__(subj) and __arg_match__3D__(cof) and __arg_match__3D__(bfix) and __arg_match__3I__(barsubi) and __arg_match__3I__(barsubj) and __arg_match__3I__(barmatidx))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4LinearDomain_2Lmosek_4fusion_4Set_2_3I_3J_3I_3D_3D_3I_3I_3I(*args):
    if len(args) != 12: return False
    model_,name_,dom_,shape_,nidxs_,ptrb,subj,cof,bfix,barsubi,barsubj,barmatidx, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model_) and __arg_alt_match_S__(name_) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(dom_) and __arg_alt_match_Lmosek_4fusion_4Set_2__(shape_) and __arg_alt_match__3I__(nidxs_) and __arg_alt_match__3J__(ptrb) and __arg_alt_match__3I__(subj) and __arg_alt_match__3D__(cof) and __arg_alt_match__3D__(bfix) and __arg_alt_match__3I__(barsubi) and __arg_alt_match__3I__(barsubj) and __arg_alt_match__3I__(barmatidx))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4LinearDomain_2Lmosek_4fusion_4Set_2_3I_3J_3I_3D_3D_3I_3I_3I(self,model_,name_,dom_,shape_,nidxs_,ptrb,subj,cof,bfix,barsubi,barsubj,barmatidx):
    self._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4LinearDomain_2Lmosek_4fusion_4Set_2_3I_3J_3I_3D_3D_3I_3I_3I(model_,name_,dom_,shape_,numpy.array(nidxs_,dtype=numpy.dtype(numpy.int32)),numpy.array(ptrb,dtype=numpy.dtype(numpy.int64)),numpy.array(subj,dtype=numpy.dtype(numpy.int32)),numpy.array(cof,dtype=numpy.dtype(numpy.float64)),numpy.array(bfix,dtype=numpy.dtype(numpy.float64)),numpy.array(barsubi,dtype=numpy.dtype(numpy.int32)),numpy.array(barsubj,dtype=numpy.dtype(numpy.int32)),numpy.array(barmatidx,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4LinearDomain_2Lmosek_4fusion_4Set_2_3I_3J_3I_3D_3D_3I_3I_3I(self,model_,name_,dom_,shape_,nidxs_,ptrb,subj,cof,bfix,barsubi,barsubj,barmatidx):
   mosek_fusion_ModelConstraint._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2_3I_3J_3I_3D_3D_3I_3I_3I(self,model_,name_,shape_,nidxs_,ptrb,subj,cof,bfix,barsubi,barsubj,barmatidx)
   self.__dom = dom_
   self.__idxmap = None
  def _add_1fx_alt__3J_3DJII(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=numpy.int64(_t__2)
   _3=numpy.int32(_t__3)
   _4=numpy.int32(_t__4)
   _1 = self._add_1fx__3J_3DJII(_0,_1,_2,_3,_4)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _add_1fx__3J_3DJII(self,_0,_1,_2,_3,_4):
   if ((self.__dom._key)==mosek.fusion.RelationKey.IsFree):
    pass
   else:
    _5 = numpy.zeros((_4,), dtype=numpy.dtype(numpy.float64))
    _6=numpy.array([self._nativeindexes[(_0[(_3 + _7)] - _2)] for _7 in range(0,_4)], dtype=numpy.dtype(numpy.int32))
    _5 = numpy.array([(self.__dom._get_1rhs_1item_J((_0[(_3 + _8)] - _2)) - _1[(_0[(_3 + _8)] - _2)]) for _8 in range(0,_4)], dtype=numpy.dtype(numpy.float64))
    if ((self.__dom._key)==mosek.fusion.RelationKey.EqualsTo):
     self._model._task_1con_1putboundlist_1fx__3I_3D(_6,_5)
    elif ((self.__dom._key)==mosek.fusion.RelationKey.LessThan):
     self._model._task_1con_1putboundlist_1up__3I_3D(_6,_5)
    elif ((self.__dom._key)==mosek.fusion.RelationKey.GreaterThan):
     self._model._task_1con_1putboundlist_1lo__3I_3D(_6,_5)
  def _dual_1values_alt_J_3I_3JI_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1values_J_3I_3JI_3D(_0,_1,_2,_3,_4)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1values_J_3I_3JI_3D(self,_0,_1,_2,_3,_4):
   _5=1
   _6=int((_2).shape[0])
   _7=mosek_fusion_IndexCounter._ctor_J_3I_3J(_0,_1,_2)
   _8=self._model._getSolution_1y_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _5 = fragments._c_closure_214(_6,_1,_5) # src/fusion/LinearConstraint.mbi:182:9-51
   _5 = numpy.int64(_5) # postprocess
   if (self._nativeindexes is not None):
    for _9 in range(0,_5):
     _4[(_9 + _3)] = _8[self._nativeindexes[_7._get_()]]
     _7._inc_()
   else:
    for _10 in range(0,_5):
     if self.__idxmap._hasItem_J(_7._get_()):
      _4[_10] = _8[self.__idxmap._getItem_J(_7._get_())]
     else:
      _4[_10] = 0.0
     _7._inc_()
  def _dual_1values_alt__3JI_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1values__3JI_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1values__3JI_3D(self,_0,_1,_2):
   _3=self._model._getSolution_1y_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   if (self._nativeindexes is not None):
    fragments._c_closure_215(_0,self._nativeindexes,_1,_2,_3) # src/fusion/LinearConstraint.mbi:159:11-160:58
   else:
    for _4 in range(0,int((_0).shape[0])):
     if self.__idxmap._hasItem_J(_0[_4]):
      _2[(_1 + _4)] = _3[self.__idxmap._getItem_J(_0[_4])]
     else:
      _2[(_1 + _4)] = 0.0
  def _level_1values_alt_J_3I_3JI_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = self._level_1values_J_3I_3JI_3D(_0,_1,_2,_3,_4)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _level_1values_J_3I_3JI_3D(self,_0,_1,_2,_3,_4):
   _5=1
   _6=int((_2).shape[0])
   _7=mosek_fusion_IndexCounter._ctor_J_3I_3J(_0,_1,_2)
   _8=self._model._getSolution_1xc_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _5 = fragments._c_closure_216(_6,_1,_5) # src/fusion/LinearConstraint.mbi:117:9-51
   _5 = numpy.int64(_5) # postprocess
   if (self._nativeindexes is not None):
    for _9 in range(0,_5):
     _4[(_9 + _3)] = _8[self._nativeindexes[_7._get_()]]
     _7._inc_()
   else:
    for _10 in range(0,_5):
     if self.__idxmap._hasItem_J(_7._get_()):
      _4[_10] = _8[self.__idxmap._getItem_J(_7._get_())]
     else:
      _4[_10] = 0.0
     _7._inc_()
  def _level_1values_alt__3JI_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._level_1values__3JI_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _level_1values__3JI_3D(self,_0,_1,_2):
   _3=self._model._getSolution_1xc_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   if (self._nativeindexes is not None):
    fragments._c_closure_217(_0,self._nativeindexes,_1,_2,_3) # src/fusion/LinearConstraint.mbi:87:11-89:59
   else:
    for _4 in range(0,int((_0).shape[0])):
     if self.__idxmap._hasItem_J(_0[_4]):
      _2[(_1 + _4)] = _3[self.__idxmap._getItem_J(_0[_4])]
     else:
      _2[(_1 + _4)] = 0.0
  def _domainToString_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   self.__dom._domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(_0,_1)
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   return (mosek_fusion_LinearConstraint._ctor_Lmosek_4fusion_4LinearConstraint_2Lmosek_4fusion_4Model_2(self,_0))
 return LinearConstraint
mosek_fusion_LinearConstraint=__mk_mosek_fusion_LinearConstraint()
del __mk_mosek_fusion_LinearConstraint
#BEFORE CLASS
def __mk_mosek_fusion_Set():
 class Set(object):
  __slots__ = ['_size','_nd_p','nd']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_IJ(*args): # int32,int64
      self._ctor_init_IJ(*args)
    elif self.__match_alt_ctor_IJ(*args):# int32,int64
      self._ctor_alt_init_IJ(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.Set.ctor(int32,int64)')
  def idxtokey(self,*args):
    if False: pass
    elif mosek_fusion_Set._match_idxtokey_J(*args): # int64
      return self._idxtokey_J(*args)
    elif mosek_fusion_Set._match_alt_idxtokey_J(*args): # int64
      return self._idxtokey_alt_J(*args)
    else:
      raise ValueError('Invalid argument list idxtokey('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.idxtokey(int64)')
  def dim(self,*args):
    if False: pass
    elif mosek_fusion_Set._match_dim_I(*args): # int32
      return self._dim_I(*args)
    elif mosek_fusion_Set._match_alt_dim_I(*args): # int32
      return self._dim_alt_I(*args)
    else:
      raise ValueError('Invalid argument list dim('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.dim(int32)')
  def compare(self,*args):
    if False: pass
    elif mosek_fusion_Set._match_compare_Lmosek_4fusion_4Set_2(*args): # mosek.fusion.Set
      return self._compare_Lmosek_4fusion_4Set_2(*args)
    elif mosek_fusion_Set._match_alt_compare_Lmosek_4fusion_4Set_2(*args): # mosek.fusion.Set
      return self._compare_alt_Lmosek_4fusion_4Set_2(*args)
    else:
      raise ValueError('Invalid argument list compare('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.compare(mosek.fusion.Set)')
  def getname(self,*args):
    if False: pass
    elif mosek_fusion_Set._match_getname_J(*args): # int64
      return self._getname_J(*args)
    elif mosek_fusion_Set._match_alt_getname_J(*args): # int64
      return self._getname_alt_J(*args)
    elif mosek_fusion_Set._match_getname__3I(*args): # []int32
      return self._getname__3I(*args)
    elif mosek_fusion_Set._match_alt_getname__3I(*args): # []int32
      return self._getname_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list getname('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.getname(int64)\n\tmosek.fusion.Set.getname(array(int32,ndim=1))')
  def slice(self,*args):
    if False: pass
    elif mosek_fusion_Set._match_slice_II(*args): # int32,int32
      return self._slice_II(*args)
    elif mosek_fusion_Set._match_alt_slice_II(*args): # int32,int32
      return self._slice_alt_II(*args)
    elif mosek_fusion_Set._match_slice__3I_3I(*args): # []int32,[]int32
      return self._slice__3I_3I(*args)
    elif mosek_fusion_Set._match_alt_slice__3I_3I(*args): # []int32,[]int32
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.slice(int32,int32)\n\tmosek.fusion.Set.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def getSize(self,*args):
    if False: pass
    elif mosek_fusion_Set._match_getSize_(*args): # 
      return self._getSize_(*args)
    elif mosek_fusion_Set._match_alt_getSize_(*args): # 
      return self._getSize_alt_(*args)
    else:
      raise ValueError('Invalid argument list getSize('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.getSize()')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_Set._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_Set._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.toString()')
  @staticmethod
  def make(*args):
    if False: pass
    elif mosek_fusion_Set._match_make__3S(*args): # []string
      return mosek_fusion_Set._make__3S(*args)
    elif mosek_fusion_Set._match_alt_make__3S(*args): # []string
      return mosek_fusion_Set._make_alt__3S(*args)
    elif mosek_fusion_Set._match_make_I(*args): # int32
      return mosek_fusion_Set._make_I(*args)
    elif mosek_fusion_Set._match_alt_make_I(*args): # int32
      return mosek_fusion_Set._make_alt_I(*args)
    elif mosek_fusion_Set._match_make__3I(*args): # []int32
      return mosek_fusion_Set._make__3I(*args)
    elif mosek_fusion_Set._match_alt_make__3I(*args): # []int32
      return mosek_fusion_Set._make_alt__3I(*args)
    elif mosek_fusion_Set._match_make__3Lmosek_4fusion_4Set_2(*args): # []mosek.fusion.Set
      return mosek_fusion_Set._make__3Lmosek_4fusion_4Set_2(*args)
    elif mosek_fusion_Set._match_alt_make__3Lmosek_4fusion_4Set_2(*args): # []mosek.fusion.Set
      return mosek_fusion_Set._make_alt__3Lmosek_4fusion_4Set_2(*args)
    elif mosek_fusion_Set._match_make_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Set_2(*args): # mosek.fusion.Set,mosek.fusion.Set
      return mosek_fusion_Set._make_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Set_2(*args)
    elif mosek_fusion_Set._match_alt_make_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Set_2(*args): # mosek.fusion.Set,mosek.fusion.Set
      return mosek_fusion_Set._make_alt_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Set_2(*args)
    elif mosek_fusion_Set._match_make_II(*args): # int32,int32
      return mosek_fusion_Set._make_II(*args)
    elif mosek_fusion_Set._match_alt_make_II(*args): # int32,int32
      return mosek_fusion_Set._make_alt_II(*args)
    elif mosek_fusion_Set._match_make_III(*args): # int32,int32,int32
      return mosek_fusion_Set._make_III(*args)
    elif mosek_fusion_Set._match_alt_make_III(*args): # int32,int32,int32
      return mosek_fusion_Set._make_alt_III(*args)
    else:
      raise ValueError('Invalid argument list make('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.make(array(string,ndim=1))\n\tmosek.fusion.Set.make(int32)\n\tmosek.fusion.Set.make(array(int32,ndim=1))\n\tmosek.fusion.Set.make(array(mosek.fusion.Set,ndim=1))\n\tmosek.fusion.Set.make(mosek.fusion.Set,mosek.fusion.Set)\n\tmosek.fusion.Set.make(int32,int32)\n\tmosek.fusion.Set.make(int32,int32,int32)')
  def realnd(self,*args):
    if False: pass
    elif mosek_fusion_Set._match_realnd_(*args): # 
      return self._realnd_(*args)
    elif mosek_fusion_Set._match_alt_realnd_(*args): # 
      return self._realnd_alt_(*args)
    else:
      raise ValueError('Invalid argument list realnd('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.realnd()')
  def stride(self,*args):
    if False: pass
    elif mosek_fusion_Set._match_stride_I(*args): # int32
      return self._stride_I(*args)
    elif mosek_fusion_Set._match_alt_stride_I(*args): # int32
      return self._stride_alt_I(*args)
    else:
      raise ValueError('Invalid argument list stride('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.stride(int32)')
  def indexToString(self,*args):
    if False: pass
    elif mosek_fusion_Set._match_indexToString_J(*args): # int64
      return self._indexToString_J(*args)
    elif mosek_fusion_Set._match_alt_indexToString_J(*args): # int64
      return self._indexToString_alt_J(*args)
    else:
      raise ValueError('Invalid argument list indexToString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.indexToString(int64)')
  @staticmethod
  def scalar(*args):
    if False: pass
    elif mosek_fusion_Set._match_scalar_(*args): # 
      return mosek_fusion_Set._scalar_(*args)
    elif mosek_fusion_Set._match_alt_scalar_(*args): # 
      return mosek_fusion_Set._scalar_alt_(*args)
    else:
      raise ValueError('Invalid argument list scalar('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.scalar()')
  def __repr__(self): return 'mosek.fusion.Set'
  @staticmethod
  def _ctor_IJ(nd_,size_):
    o = Set.__new__(Set)
    o._ctor_init_IJ(nd_,size_)
    return o
  @staticmethod
  def __match_ctor_IJ(*args):
    if len(args) != 2: return False
    nd_,size_, = args
    return (__arg_match_I__(nd_) and __arg_match_J__(size_))
  @staticmethod
  def __match_alt_ctor_IJ(*args):
    if len(args) != 2: return False
    nd_,size_, = args
    return (__arg_alt_match_I__(nd_) and __arg_alt_match_J__(size_))
  def _ctor_alt_init_IJ(self,nd_,size_):
    self._ctor_init_IJ(numpy.int32(nd_),numpy.int64(size_))
  def _ctor_init_IJ(self,nd_,size_):
   object.__init__(self)
   self.nd = nd_
   self._nd_p = nd_
   self._size = size_
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("Set(shape=(")._a_I(self._dim_I(0))
   for _1 in range(1,self.nd):
    _0._a_S(",")._a_I(self._dim_I(_1))
   _0._a_S("))")
   return (_0._toString_())
  @staticmethod
  def _match_indexToString_J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_J__(_0))
  @staticmethod
  def _match_alt_indexToString_J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_J__(_0))
  def _indexToString_alt_J(self,_t__0):
    return self._indexToString_J(numpy.int64(__0))
  def _indexToString_J(self,_0):
   pass
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _slice_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._slice__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice__3I_3I(self,_0,_1):
   pass
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _slice_alt_II(self,_t__0,_t__1):
    return self._slice_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_II(self,_0,_1):
   pass
  def _linearidx_alt_III(self,_t__0,_t__1,_t__2):
    return self._linearidx_III(numpy.int32(__0),numpy.int32(__1),numpy.int32(__2))
  def _linearidx_III(self,_0,_1,_2):
   return numpy.int64(numpy.int64(((((_0 * self._dim_I(1)) + _1) * self._dim_I(2)) + _2)))
  def _linearidx_alt_II(self,_t__0,_t__1):
    return self._linearidx_II(numpy.int32(__0),numpy.int32(__1))
  def _linearidx_II(self,_0,_1):
   return numpy.int32(((_0 * self._dim_I(1)) + _1))
  def _linearidx_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._linearidx__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _linearidx__3I(self,_0):
   _1=_0[0]
   for _2 in range(1,int((_0).shape[0])):
    _1 = ((_1 * self._dim_I(_2)) + _0[_2])
   return numpy.int64(_1)
  @staticmethod
  def _match_idxtokey_J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_J__(_0))
  @staticmethod
  def _match_alt_idxtokey_J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_J__(_0))
  def _idxtokey_alt_J(self,_t__0):
    return self._idxtokey_J(numpy.int64(__0))
  def _idxtokey_J(self,_0):
   _1=numpy.zeros((self._nd_p,), dtype=numpy.dtype(numpy.int32))
   _2=_0
   for _3 in range(0,self._nd_p):
    _1[_3] = numpy.int32((_2 // self._stride_I(_3)))
    _2 = (_2 % self._stride_I(_3))
   return (_1)
  @staticmethod
  def _match_getname__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_getname__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _getname_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._getname__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _getname__3I(self,_0):
   pass
  @staticmethod
  def _match_getname_J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_J__(_0))
  @staticmethod
  def _match_alt_getname_J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_J__(_0))
  def _getname_alt_J(self,_t__0):
    return self._getname_J(numpy.int64(__0))
  def _getname_J(self,_0):
   pass
  @staticmethod
  def _match_stride_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_stride_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _stride_alt_I(self,_t__0):
    return self._stride_I(numpy.int32(__0))
  def _stride_I(self,_0):
   pass
  @staticmethod
  def _match_dim_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_dim_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _dim_alt_I(self,_t__0):
    return self._dim_I(numpy.int32(__0))
  def _dim_I(self,_0):
   pass
  @staticmethod
  def _match_make__3Lmosek_4fusion_4Set_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3Lmosek_4fusion_4Set_2__(_0))
  @staticmethod
  def _match_alt_make__3Lmosek_4fusion_4Set_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Set_2__(_0))
  @staticmethod
  def _make_alt__3Lmosek_4fusion_4Set_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Set._make__3Lmosek_4fusion_4Set_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _make__3Lmosek_4fusion_4Set_2(_0):
   return (mosek_fusion_ProductSet._ctor__3Lmosek_4fusion_4Set_2(_0))
  @staticmethod
  def _match_make_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Set_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Set_2__(_0) and __arg_match_Lmosek_4fusion_4Set_2__(_1))
  @staticmethod
  def _match_alt_make_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Set_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Set_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Set_2__(_1))
  @staticmethod
  def _make_alt_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Set_2(_t__0,_t__1):
    return mosek_fusion_Set._make_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Set_2(_0,_1)
  @staticmethod
  def _make_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Set_2(_0,_1):
   return (mosek_fusion_ProductSet._ctor__3Lmosek_4fusion_4Set_2(numpy.array([_0,_1], dtype=numpy.dtype(object))))
  @staticmethod
  def _match_make__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_make__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  @staticmethod
  def _make_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Set._make__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _make__3I(_0):
   return (mosek_fusion_NDSet._ctor__3I(_0))
  @staticmethod
  def _match_make_III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_make_III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _make_alt_III(_t__0,_t__1,_t__2):
    return mosek_fusion_Set._make_III(numpy.int32(__0),numpy.int32(__1),numpy.int32(__2))
  @staticmethod
  def _make_III(_0,_1,_2):
   return (mosek_fusion_NDSet._ctor__3I(numpy.array([_0,_1,_2], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_make_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_make_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _make_alt_II(_t__0,_t__1):
    return mosek_fusion_Set._make_II(numpy.int32(__0),numpy.int32(__1))
  @staticmethod
  def _make_II(_0,_1):
   return (mosek_fusion_NDSet._ctor__3I(numpy.array([_0,_1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_make_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_make_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _make_alt_I(_t__0):
    return mosek_fusion_Set._make_I(numpy.int32(__0))
  @staticmethod
  def _make_I(_0):
   return (mosek_fusion_IntSet._ctor_I(_0))
  @staticmethod
  def _match_scalar_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_scalar_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _scalar_alt_():
    return mosek_fusion_Set._scalar_()
  @staticmethod
  def _scalar_():
   return (mosek.fusion.Set._make_I(1))
  @staticmethod
  def _match_make__3S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3S__(_0))
  @staticmethod
  def _match_alt_make__3S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3S__(_0))
  @staticmethod
  def _make_alt__3S(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Set._make__3S(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _make__3S(_0):
   return (mosek_fusion_StringSet._ctor__3S(_0))
  @staticmethod
  def _match_realnd_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_realnd_(*args):
    if len(args) != 0: return False
    return True
  def _realnd_alt_(self,):
    return self._realnd_()
  def _realnd_(self,):
   if (self.nd==1):
    return numpy.int32(1)
   else:
    _0=0
    _1=0
    while (_1 < self.nd):
     if (self._dim_I(_1)!=1):
      _0 += 1
     _1 += 1
    if (_0==0):
     _0 += 1
    return numpy.int32(_0)
  @staticmethod
  def _match_getSize_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getSize_(*args):
    if len(args) != 0: return False
    return True
  def _getSize_alt_(self,):
    return self._getSize_()
  def _getSize_(self,):
   return numpy.int64(self._size)
  @staticmethod
  def _match_compare_Lmosek_4fusion_4Set_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Set_2__(_0))
  @staticmethod
  def _match_alt_compare_Lmosek_4fusion_4Set_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Set_2__(_0))
  def _compare_alt_Lmosek_4fusion_4Set_2(self,_t__0):
    return self._compare_Lmosek_4fusion_4Set_2(_0)
  def _compare_Lmosek_4fusion_4Set_2(self,_0):
   if ((self._size!=(_0._size)) or (self._realnd_()!=_0._realnd_())):
    return (False)
   _1=0
   _2=0
   while ((_1 < self.nd) and (_2 < (_0.nd))):
    if (self._dim_I(_1)==1):
     _1 += 1
    elif (_0._dim_I(_2)==1):
     _2 += 1
    elif (self._dim_I(_1)!=_0._dim_I(_2)):
     return (False)
    else:
     _1 += 1
     _2 += 1
   return (True)
 return Set
mosek_fusion_Set=__mk_mosek_fusion_Set()
del __mk_mosek_fusion_Set
#BEFORE CLASS
def __mk_mosek_fusion_BaseSet():
 class BaseSet(mosek_fusion_Set):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_J(*args): # int64
      self._ctor_init_J(*args)
    elif self.__match_alt_ctor_J(*args):# int64
      self._ctor_alt_init_J(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.BaseSet.ctor(int64)')
  def dim(self,*args):
    if False: pass
    elif mosek_fusion_BaseSet._match_dim_I(*args): # int32
      return self._dim_I(*args)
    elif mosek_fusion_BaseSet._match_alt_dim_I(*args): # int32
      return self._dim_alt_I(*args)
    else:
      raise ValueError('Invalid argument list dim('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseSet.dim(int32)')
  def __repr__(self): return 'mosek.fusion.BaseSet'
  @staticmethod
  def _ctor_J(size_):
    o = BaseSet.__new__(BaseSet)
    o._ctor_init_J(size_)
    return o
  @staticmethod
  def __match_ctor_J(*args):
    if len(args) != 1: return False
    size_, = args
    return (__arg_match_J__(size_))
  @staticmethod
  def __match_alt_ctor_J(*args):
    if len(args) != 1: return False
    size_, = args
    return (__arg_alt_match_J__(size_))
  def _ctor_alt_init_J(self,size_):
    self._ctor_init_J(numpy.int64(size_))
  def _ctor_init_J(self,size_):
   mosek_fusion_Set._ctor_init_IJ(self,1,size_)
  @staticmethod
  def _match_dim_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_dim_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _dim_alt_I(self,_t__0):
    return self._dim_I(numpy.int32(__0))
  def _dim_I(self,_0):
   if (_0 < 0):
    raise mosek_fusion_IndexError._ctor_S("Invalid dimension")
   elif (_0 > 0):
    return numpy.int32(1)
   else:
    return numpy.int32(numpy.int32(self._size))
 return BaseSet
mosek_fusion_BaseSet=__mk_mosek_fusion_BaseSet()
del __mk_mosek_fusion_BaseSet
#BEFORE CLASS
def __mk_mosek_fusion_IntSet():
 class IntSet(mosek_fusion_BaseSet):
  __slots__ = ['_IntSet__last','_IntSet__first']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_I(*args): # int32
      self._ctor_init_I(*args)
    elif self.__match_alt_ctor_I(*args):# int32
      self._ctor_alt_init_I(*args)
    elif self.__match_ctor_II(*args): # int32,int32
      self._ctor_init_II(*args)
    elif self.__match_alt_ctor_II(*args):# int32,int32
      self._ctor_alt_init_II(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.IntSet.ctor(int32)\n\tmosek.fusion.IntSet.ctor(int32,int32)')
  def indexToString(self,*args):
    if False: pass
    elif mosek_fusion_IntSet._match_indexToString_J(*args): # int64
      return self._indexToString_J(*args)
    elif mosek_fusion_IntSet._match_alt_indexToString_J(*args): # int64
      return self._indexToString_alt_J(*args)
    else:
      raise ValueError('Invalid argument list indexToString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.IntSet.indexToString(int64)')
  def slice(self,*args):
    if False: pass
    elif mosek_fusion_IntSet._match_slice_II(*args): # int32,int32
      return self._slice_II(*args)
    elif mosek_fusion_IntSet._match_alt_slice_II(*args): # int32,int32
      return self._slice_alt_II(*args)
    elif mosek_fusion_IntSet._match_slice__3I_3I(*args): # []int32,[]int32
      return self._slice__3I_3I(*args)
    elif mosek_fusion_IntSet._match_alt_slice__3I_3I(*args): # []int32,[]int32
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.IntSet.slice(int32,int32)\n\tmosek.fusion.IntSet.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def stride(self,*args):
    if False: pass
    elif mosek_fusion_IntSet._match_stride_I(*args): # int32
      return self._stride_I(*args)
    elif mosek_fusion_IntSet._match_alt_stride_I(*args): # int32
      return self._stride_alt_I(*args)
    else:
      raise ValueError('Invalid argument list stride('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.IntSet.stride(int32)')
  def getname(self,*args):
    if False: pass
    elif mosek_fusion_IntSet._match_getname_J(*args): # int64
      return self._getname_J(*args)
    elif mosek_fusion_IntSet._match_alt_getname_J(*args): # int64
      return self._getname_alt_J(*args)
    elif mosek_fusion_IntSet._match_getname__3I(*args): # []int32
      return self._getname__3I(*args)
    elif mosek_fusion_IntSet._match_alt_getname__3I(*args): # []int32
      return self._getname_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list getname('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.IntSet.getname(int64)\n\tmosek.fusion.IntSet.getname(array(int32,ndim=1))')
  def getidx(self,*args):
    if False: pass
    elif mosek_fusion_IntSet._match_getidx_I(*args): # int32
      return self._getidx_I(*args)
    elif mosek_fusion_IntSet._match_alt_getidx_I(*args): # int32
      return self._getidx_alt_I(*args)
    else:
      raise ValueError('Invalid argument list getidx('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.IntSet.getidx(int32)')
  def __repr__(self): return 'mosek.fusion.IntSet'
  @staticmethod
  def _ctor_I(length):
    o = IntSet.__new__(IntSet)
    o._ctor_init_I(length)
    return o
  @staticmethod
  def __match_ctor_I(*args):
    if len(args) != 1: return False
    length, = args
    return (__arg_match_I__(length))
  @staticmethod
  def __match_alt_ctor_I(*args):
    if len(args) != 1: return False
    length, = args
    return (__arg_alt_match_I__(length))
  def _ctor_alt_init_I(self,length):
    self._ctor_init_I(numpy.int32(length))
  def _ctor_init_I(self,length):
   mosek_fusion_BaseSet._ctor_init_J(self,numpy.int64(length))
   self.__first = 0
   self.__last = length
  @staticmethod
  def _ctor_II(first_,last_):
    o = IntSet.__new__(IntSet)
    o._ctor_init_II(first_,last_)
    return o
  @staticmethod
  def __match_ctor_II(*args):
    if len(args) != 2: return False
    first_,last_, = args
    return (__arg_match_I__(first_) and __arg_match_I__(last_))
  @staticmethod
  def __match_alt_ctor_II(*args):
    if len(args) != 2: return False
    first_,last_, = args
    return (__arg_alt_match_I__(first_) and __arg_alt_match_I__(last_))
  def _ctor_alt_init_II(self,first_,last_):
    self._ctor_init_II(numpy.int32(first_),numpy.int32(last_))
  def _ctor_init_II(self,first_,last_):
   mosek_fusion_BaseSet._ctor_init_J(self,numpy.int64((last_ - first_)))
   self.__first = first_
   self.__last = last_
  @staticmethod
  def _match_indexToString_J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_J__(_0))
  @staticmethod
  def _match_alt_indexToString_J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_J__(_0))
  def _indexToString_alt_J(self,_t__0):
    return self._indexToString_J(numpy.int64(__0))
  def _indexToString_J(self,_0):
   return (mosek.fusion.Utils.StringBuffer()._a_I(numpy.int32(_0))._toString_())
  @staticmethod
  def _match_getname__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_getname__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _getname_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._getname__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _getname__3I(self,_0):
   if (int((_0).shape[0])!=1):
    raise mosek_fusion_IndexError._ctor_S("Invalid key specification")
   return (mosek.fusion.Utils.Tools._stringvalue_I(_0[0]))
  @staticmethod
  def _match_getname_J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_J__(_0))
  @staticmethod
  def _match_alt_getname_J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_J__(_0))
  def _getname_alt_J(self,_t__0):
    return self._getname_J(numpy.int64(__0))
  def _getname_J(self,_0):
   return (mosek.fusion.Utils.Tools._stringvalue_J(_0))
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _slice_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._slice__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice__3I_3I(self,_0,_1):
   if ((int((_0).shape[0])!=1) or (int((_1).shape[0])!=1)):
    raise mosek_fusion_SliceError._ctor_S("Invalid slice specification")
   return (self._slice_II(_0[0],_1[0]))
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _slice_alt_II(self,_t__0,_t__1):
    return self._slice_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_II(self,_0,_1):
   if ((_0 < 0) or ((_0 > _1) or (_1 > (self.__last - self.__first)))):
    raise mosek_fusion_SliceError._ctor_S("Invalid slice specification")
   return (mosek_fusion_IntSet._ctor_II((self.__first + _0),(self.__first + _1)))
  @staticmethod
  def _match_getidx_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_getidx_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _getidx_alt_I(self,_t__0):
    return self._getidx_I(numpy.int32(__0))
  def _getidx_I(self,_0):
   if ((_0 < self.__first) or (_0 > self.__last)):
    raise mosek_fusion_IndexError._ctor_S("Index out of bounds")
   return numpy.int32((_0 - self.__first))
  @staticmethod
  def _match_stride_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_stride_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _stride_alt_I(self,_t__0):
    return self._stride_I(numpy.int32(__0))
  def _stride_I(self,_0):
   return numpy.int64(1)
 return IntSet
mosek_fusion_IntSet=__mk_mosek_fusion_IntSet()
del __mk_mosek_fusion_IntSet
#BEFORE CLASS
def __mk_mosek_fusion_StringSet():
 class StringSet(mosek_fusion_BaseSet):
  __slots__ = ['_StringSet__keys']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor__3S(*args): # []string
      self._ctor_init__3S(*args)
    elif self.__match_alt_ctor__3S(*args):# []string
      self._ctor_alt_init__3S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.StringSet.ctor(array(string,ndim=1))')
  def indexToString(self,*args):
    if False: pass
    elif mosek_fusion_StringSet._match_indexToString_J(*args): # int64
      return self._indexToString_J(*args)
    elif mosek_fusion_StringSet._match_alt_indexToString_J(*args): # int64
      return self._indexToString_alt_J(*args)
    else:
      raise ValueError('Invalid argument list indexToString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.StringSet.indexToString(int64)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_StringSet._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_StringSet._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.StringSet.toString()')
  def stride(self,*args):
    if False: pass
    elif mosek_fusion_StringSet._match_stride_I(*args): # int32
      return self._stride_I(*args)
    elif mosek_fusion_StringSet._match_alt_stride_I(*args): # int32
      return self._stride_alt_I(*args)
    else:
      raise ValueError('Invalid argument list stride('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.StringSet.stride(int32)')
  def getname(self,*args):
    if False: pass
    elif mosek_fusion_StringSet._match_getname_J(*args): # int64
      return self._getname_J(*args)
    elif mosek_fusion_StringSet._match_alt_getname_J(*args): # int64
      return self._getname_alt_J(*args)
    elif mosek_fusion_StringSet._match_getname__3I(*args): # []int32
      return self._getname__3I(*args)
    elif mosek_fusion_StringSet._match_alt_getname__3I(*args): # []int32
      return self._getname_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list getname('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.StringSet.getname(int64)\n\tmosek.fusion.StringSet.getname(array(int32,ndim=1))')
  def slice(self,*args):
    if False: pass
    elif mosek_fusion_StringSet._match_slice_II(*args): # int32,int32
      return self._slice_II(*args)
    elif mosek_fusion_StringSet._match_alt_slice_II(*args): # int32,int32
      return self._slice_alt_II(*args)
    elif mosek_fusion_StringSet._match_slice__3I_3I(*args): # []int32,[]int32
      return self._slice__3I_3I(*args)
    elif mosek_fusion_StringSet._match_alt_slice__3I_3I(*args): # []int32,[]int32
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.StringSet.slice(int32,int32)\n\tmosek.fusion.StringSet.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def __repr__(self): return 'mosek.fusion.StringSet'
  @staticmethod
  def _ctor__3S(ks):
    o = StringSet.__new__(StringSet)
    o._ctor_init__3S(ks)
    return o
  @staticmethod
  def __match_ctor__3S(*args):
    if len(args) != 1: return False
    ks, = args
    return (__arg_match__3S__(ks))
  @staticmethod
  def __match_alt_ctor__3S(*args):
    if len(args) != 1: return False
    ks, = args
    return (__arg_alt_match__3S__(ks))
  def _ctor_alt_init__3S(self,ks):
    self._ctor_init__3S(numpy.array(ks,dtype=numpy.dtype(object)))
  def _ctor_init__3S(self,ks):
   mosek_fusion_BaseSet._ctor_init_J(self,numpy.int64(int((ks).shape[0])))
   self.__keys = mosek.fusion.Utils.Tools._arraycopy__3S(ks)
  @staticmethod
  def _match_indexToString_J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_J__(_0))
  @staticmethod
  def _match_alt_indexToString_J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_J__(_0))
  def _indexToString_alt_J(self,_t__0):
    return self._indexToString_J(numpy.int64(__0))
  def _indexToString_J(self,_0):
   return (self.__keys[_0])
  @staticmethod
  def _match_getname__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_getname__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _getname_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._getname__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _getname__3I(self,_0):
   if (int((_0).shape[0])!=1):
    raise mosek_fusion_IndexError._ctor_S("Invalid key specification")
   return (self.__keys[_0[0]])
  @staticmethod
  def _match_getname_J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_J__(_0))
  @staticmethod
  def _match_alt_getname_J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_J__(_0))
  def _getname_alt_J(self,_t__0):
    return self._getname_J(numpy.int64(__0))
  def _getname_J(self,_0):
   return (self.__keys[_0])
  def _slice_1_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._slice_1__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice_1__3I_3I(self,_0,_1):
   if ((int((_0).shape[0])!=1) or ((int((_1).shape[0])!=1) or ((_0[0] < 0) or ((_0[0] > _1[0]) or (_1[0] >= int((self.__keys).shape[0])))))):
    raise mosek_fusion_SliceError._ctor_S("Invalid slice specification")
   return (self._slice_1_II(_0[0],_1[0]))
  def _slice_1_alt_II(self,_t__0,_t__1):
    return self._slice_1_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_1_II(self,_0,_1):
   if ((_0 < 0) or ((_0 > _1) or (_1 > int((self.__keys).shape[0])))):
    raise mosek_fusion_SliceError._ctor_S("Invalid slice specification")
   return (mosek_fusion_StringSet._ctor__3S(numpy.array([self.__keys[(_2 + _0)] for _2 in range(0,(_1 - _0))], dtype=numpy.dtype(object))))
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _slice_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._slice__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice__3I_3I(self,_0,_1):
   return (self._slice_1__3I_3I(_0,_1))
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _slice_alt_II(self,_t__0,_t__1):
    return self._slice_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_II(self,_0,_1):
   return (self._slice_1_II(_0,_1))
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("{'")._a_S(self.__keys[0])._a_S("'")
   _1=1
   while (_1 < int((self.__keys).shape[0])):
    _0._a_S(",'")._a_S(self.__keys[_1])._a_S("'")
    _1 += 1
   _0._a_S("}")
   return (_0._toString_())
  @staticmethod
  def _match_stride_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_stride_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _stride_alt_I(self,_t__0):
    return self._stride_I(numpy.int32(__0))
  def _stride_I(self,_0):
   return numpy.int64(1)
 return StringSet
mosek_fusion_StringSet=__mk_mosek_fusion_StringSet()
del __mk_mosek_fusion_StringSet
#BEFORE CLASS
def __mk_mosek_fusion_NDSet():
 class NDSet(mosek_fusion_Set):
  __slots__ = ['_NDSet__strides','_NDSet__dimdef']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor__3I(*args): # []int32
      self._ctor_init__3I(*args)
    elif self.__match_alt_ctor__3I(*args):# []int32
      self._ctor_alt_init__3I(*args)
    elif self.__match_ctor_II(*args): # int32,int32
      self._ctor_init_II(*args)
    elif self.__match_alt_ctor_II(*args):# int32,int32
      self._ctor_alt_init_II(*args)
    elif self.__match_ctor_III(*args): # int32,int32,int32
      self._ctor_init_III(*args)
    elif self.__match_alt_ctor_III(*args):# int32,int32,int32
      self._ctor_alt_init_III(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.NDSet.ctor(array(int32,ndim=1))\n\tmosek.fusion.NDSet.ctor(int32,int32)\n\tmosek.fusion.NDSet.ctor(int32,int32,int32)')
  def dim(self,*args):
    if False: pass
    elif mosek_fusion_NDSet._match_dim_I(*args): # int32
      return self._dim_I(*args)
    elif mosek_fusion_NDSet._match_alt_dim_I(*args): # int32
      return self._dim_alt_I(*args)
    else:
      raise ValueError('Invalid argument list dim('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NDSet.dim(int32)')
  def stride(self,*args):
    if False: pass
    elif mosek_fusion_NDSet._match_stride_I(*args): # int32
      return self._stride_I(*args)
    elif mosek_fusion_NDSet._match_alt_stride_I(*args): # int32
      return self._stride_alt_I(*args)
    else:
      raise ValueError('Invalid argument list stride('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NDSet.stride(int32)')
  def slice(self,*args):
    if False: pass
    elif mosek_fusion_NDSet._match_slice_II(*args): # int32,int32
      return self._slice_II(*args)
    elif mosek_fusion_NDSet._match_alt_slice_II(*args): # int32,int32
      return self._slice_alt_II(*args)
    elif mosek_fusion_NDSet._match_slice__3I_3I(*args): # []int32,[]int32
      return self._slice__3I_3I(*args)
    elif mosek_fusion_NDSet._match_alt_slice__3I_3I(*args): # []int32,[]int32
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NDSet.slice(int32,int32)\n\tmosek.fusion.NDSet.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def indexToString(self,*args):
    if False: pass
    elif mosek_fusion_NDSet._match_indexToString_J(*args): # int64
      return self._indexToString_J(*args)
    elif mosek_fusion_NDSet._match_alt_indexToString_J(*args): # int64
      return self._indexToString_alt_J(*args)
    else:
      raise ValueError('Invalid argument list indexToString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NDSet.indexToString(int64)')
  def getname(self,*args):
    if False: pass
    elif mosek_fusion_NDSet._match_getname_J(*args): # int64
      return self._getname_J(*args)
    elif mosek_fusion_NDSet._match_alt_getname_J(*args): # int64
      return self._getname_alt_J(*args)
    elif mosek_fusion_NDSet._match_getname__3I(*args): # []int32
      return self._getname__3I(*args)
    elif mosek_fusion_NDSet._match_alt_getname__3I(*args): # []int32
      return self._getname_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list getname('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NDSet.getname(int64)\n\tmosek.fusion.NDSet.getname(array(int32,ndim=1))')
  def __repr__(self): return 'mosek.fusion.NDSet'
  @staticmethod
  def _ctor_III(size0,size1,size2):
    o = NDSet.__new__(NDSet)
    o._ctor_init_III(size0,size1,size2)
    return o
  @staticmethod
  def __match_ctor_III(*args):
    if len(args) != 3: return False
    size0,size1,size2, = args
    return (__arg_match_I__(size0) and __arg_match_I__(size1) and __arg_match_I__(size2))
  @staticmethod
  def __match_alt_ctor_III(*args):
    if len(args) != 3: return False
    size0,size1,size2, = args
    return (__arg_alt_match_I__(size0) and __arg_alt_match_I__(size1) and __arg_alt_match_I__(size2))
  def _ctor_alt_init_III(self,size0,size1,size2):
    self._ctor_init_III(numpy.int32(size0),numpy.int32(size1),numpy.int32(size2))
  def _ctor_init_III(self,size0,size1,size2):
   mosek_fusion_Set._ctor_init_IJ(self,3,numpy.int64(((size0 * size1) * size2)))
   self.__dimdef = numpy.array([size0,size1,size2], dtype=numpy.dtype(numpy.int32))
   self.__strides = numpy.array([numpy.int64((size1 * size2)),numpy.int64(size2),1], dtype=numpy.dtype(numpy.int64))
  @staticmethod
  def _ctor_II(size0,size1):
    o = NDSet.__new__(NDSet)
    o._ctor_init_II(size0,size1)
    return o
  @staticmethod
  def __match_ctor_II(*args):
    if len(args) != 2: return False
    size0,size1, = args
    return (__arg_match_I__(size0) and __arg_match_I__(size1))
  @staticmethod
  def __match_alt_ctor_II(*args):
    if len(args) != 2: return False
    size0,size1, = args
    return (__arg_alt_match_I__(size0) and __arg_alt_match_I__(size1))
  def _ctor_alt_init_II(self,size0,size1):
    self._ctor_init_II(numpy.int32(size0),numpy.int32(size1))
  def _ctor_init_II(self,size0,size1):
   mosek_fusion_Set._ctor_init_IJ(self,2,numpy.int64((size0 * size1)))
   self.__dimdef = numpy.array([size0,size1], dtype=numpy.dtype(numpy.int32))
   self.__strides = numpy.array([numpy.int64(size1),1], dtype=numpy.dtype(numpy.int64))
  @staticmethod
  def _ctor__3I(dims):
    o = NDSet.__new__(NDSet)
    o._ctor_init__3I(dims)
    return o
  @staticmethod
  def __match_ctor__3I(*args):
    if len(args) != 1: return False
    dims, = args
    return (__arg_match__3I__(dims))
  @staticmethod
  def __match_alt_ctor__3I(*args):
    if len(args) != 1: return False
    dims, = args
    return (__arg_alt_match__3I__(dims))
  def _ctor_alt_init__3I(self,dims):
    self._ctor_init__3I(numpy.array(dims,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init__3I(self,dims):
   mosek_fusion_Set._ctor_init_IJ(self,int((dims).shape[0]),mosek.fusion.NDSet.__sumdims__3I(dims))
   for _0 in range(0,self.nd):
    if (dims[_0] < 0):
     raise mosek_fusion_SliceError._ctor_S("Negative dimension size")
   self.__dimdef = numpy.array([dims[_1] for _1 in range(0,int((dims).shape[0]))], dtype=numpy.dtype(numpy.int32))
   self.__strides = numpy.zeros((self.nd,), dtype=numpy.dtype(numpy.int64))
   self.__strides[(self.nd - 1)] = 1
   fragments._c_closure_218(self.__dimdef,self.nd,self.__strides) # src/fusion/NDSet.mbi:63:9-64:49
  @staticmethod
  def _match_indexToString_J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_J__(_0))
  @staticmethod
  def _match_alt_indexToString_J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_J__(_0))
  def _indexToString_alt_J(self,_t__0):
    return self._indexToString_J(numpy.int64(__0))
  def _indexToString_J(self,_0):
   _1=mosek.fusion.Utils.StringBuffer()
   _2=self._idxtokey_J(_0)
   _1._a_I(_2[0])
   for _3 in range(1,int((_2).shape[0])):
    _1._a_S(",")._a_I(_2[_3])
   return (_1._toString_())
  @staticmethod
  def _match_getname__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_getname__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _getname_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._getname__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _getname__3I(self,_0):
   if (self.nd!=int((_0).shape[0])):
    raise mosek_fusion_DimensionError._ctor_S("Key dimensions do not match set dimensions.")
   _1=0
   while (_1 < self.nd):
    if ((_0[_1] < 0) or (_0[_1] >= (self.__dimdef[_1] + 1))):
     raise mosek_fusion_IndexError._ctor_S("Key dimensions do not match set dimensions.")
    _1 += 1
   _2=mosek.fusion.Utils.StringBuffer()
   _2._a_I(_0[0])
   for _3 in range(1,self.nd):
    _2._a_S(",")._a_I(_0[_3])
   return (_2._toString_())
  @staticmethod
  def _match_getname_J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_J__(_0))
  @staticmethod
  def _match_alt_getname_J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_J__(_0))
  def _getname_alt_J(self,_t__0):
    return self._getname_J(numpy.int64(__0))
  def _getname_J(self,_0):
   if (self.nd==1):
    _1=numpy.zeros((self.nd,), dtype=numpy.dtype(numpy.int64))
    _2=_0
    _2 = fragments._c_closure_219(_2,self.nd,_1,self.__strides) # src/fusion/NDSet.mbi:169:11-173:12
    _2 = numpy.int64(_2) # postprocess
    _3=mosek.fusion.Utils.StringBuffer()
    _3._a_J(_0)
    return (_3._toString_())
   else:
    return (self._getname__3I(self._idxtokey_J(_0)))
  @staticmethod
  def _match_dim_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_dim_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _dim_alt_I(self,_t__0):
    return self._dim_I(numpy.int32(__0))
  def _dim_I(self,_0):
   return numpy.int32((1 if ((_0 >= self.nd) ) else self.__dimdef[_0]))
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _slice_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._slice__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice__3I_3I(self,_0,_1):
   if ((self.nd!=int((_0).shape[0])) or (self.nd!=int((_1).shape[0]))):
    raise mosek_fusion_SliceError._ctor_S("Slice dimensions do not match set dimensions.")
   _2=0
   while (_2 < self.nd):
    if ((_0[_2] < 0) or ((_1[_2] < _0[_2]) or (_1[_2] > self.__dimdef[_2]))):
     raise mosek_fusion_SliceError._ctor_S("Slice is out of bounds.")
    _2 += 1
   _3=numpy.array([(_1[_4] - _0[_4]) for _4 in range(0,self.nd)], dtype=numpy.dtype(numpy.int32))
   return (mosek_fusion_NDSet._ctor__3I(_3))
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _slice_alt_II(self,_t__0,_t__1):
    return self._slice_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_II(self,_0,_1):
   if (self.nd!=1):
    raise mosek_fusion_SliceError._ctor_S("Slice dimensions do not match set dimensions.")
   elif ((_0 < 0) or ((_1 < _0) or (_1 > self._size))):
    raise mosek_fusion_SliceError._ctor_S("Slice dimensions do not match set dimensions.")
   return (mosek_fusion_IntSet._ctor_II(_0,_1))
  def _selectidxs_alt__3S(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = self._selectidxs__3S(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _selectidxs__3S(self,_0):
   raise mosek_fusion_IndexError._ctor_S("invalid key type")
  def _linear_1index_1in_1dim_alt_I_3I(self,_t__0,_t__1):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._linear_1index_1in_1dim_I_3I(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _linear_1index_1in_1dim_I_3I(self,_0,_1):
   raise mosek_fusion_IndexError._ctor_S("invalid key type")
  def _linear_1index_1in_1dim_alt_II(self,_t__0,_t__1):
    return self._linear_1index_1in_1dim_II(numpy.int32(__0),numpy.int32(__1))
  def _linear_1index_1in_1dim_II(self,_0,_1):
   if ((_0 < 0) or (_0 >= int((self.__dimdef).shape[0]))):
    raise mosek_fusion_IndexError._ctor_S("dimension index out of bounds")
   if ((_1 < 0) or (_1 >= self.__dimdef[_0])):
    raise mosek_fusion_IndexError._ctor_S("key out of bounds")
   else:
    return numpy.int32(_1)
  @staticmethod
  def __sumdims_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_NDSet.__sumdims__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __sumdims__3I(_0):
   _1=1
   _1 = fragments._c_closure_220(_0,_1) # src/fusion/NDSet.mbi:32:9-33:26
   _1 = numpy.int64(_1) # postprocess
   return numpy.int64(_1)
  @staticmethod
  def _match_stride_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_stride_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _stride_alt_I(self,_t__0):
    return self._stride_I(numpy.int32(__0))
  def _stride_I(self,_0):
   return numpy.int64(self.__strides[_0])
 return NDSet
mosek_fusion_NDSet=__mk_mosek_fusion_NDSet()
del __mk_mosek_fusion_NDSet
#BEFORE CLASS
def __mk_mosek_fusion_ProductSet():
 class ProductSet(mosek_fusion_NDSet):
  __slots__ = ['_ProductSet__sets']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor__3Lmosek_4fusion_4Set_2(*args): # []mosek.fusion.Set
      self._ctor_init__3Lmosek_4fusion_4Set_2(*args)
    elif self.__match_alt_ctor__3Lmosek_4fusion_4Set_2(*args):# []mosek.fusion.Set
      self._ctor_alt_init__3Lmosek_4fusion_4Set_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ProductSet.ctor(array(mosek.fusion.Set,ndim=1))')
  def indexToString(self,*args):
    if False: pass
    elif mosek_fusion_ProductSet._match_indexToString_J(*args): # int64
      return self._indexToString_J(*args)
    elif mosek_fusion_ProductSet._match_alt_indexToString_J(*args): # int64
      return self._indexToString_alt_J(*args)
    else:
      raise ValueError('Invalid argument list indexToString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ProductSet.indexToString(int64)')
  def __repr__(self): return 'mosek.fusion.ProductSet'
  @staticmethod
  def _ctor__3Lmosek_4fusion_4Set_2(ss):
    o = ProductSet.__new__(ProductSet)
    o._ctor_init__3Lmosek_4fusion_4Set_2(ss)
    return o
  @staticmethod
  def __match_ctor__3Lmosek_4fusion_4Set_2(*args):
    if len(args) != 1: return False
    ss, = args
    return (__arg_match__3Lmosek_4fusion_4Set_2__(ss))
  @staticmethod
  def __match_alt_ctor__3Lmosek_4fusion_4Set_2(*args):
    if len(args) != 1: return False
    ss, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Set_2__(ss))
  def _ctor_alt_init__3Lmosek_4fusion_4Set_2(self,ss):
    self._ctor_init__3Lmosek_4fusion_4Set_2(numpy.array(ss,dtype=numpy.dtype(object)))
  def _ctor_init__3Lmosek_4fusion_4Set_2(self,ss):
   mosek_fusion_NDSet._ctor_init__3I(self,mosek.fusion.ProductSet.__computedims__3Lmosek_4fusion_4Set_2(ss))
   self.__sets = numpy.array([ss[_0] for _0 in range(0,int((ss).shape[0]))], dtype=numpy.dtype(object))
  @staticmethod
  def _match_indexToString_J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_J__(_0))
  @staticmethod
  def _match_alt_indexToString_J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_J__(_0))
  def _indexToString_alt_J(self,_t__0):
    return self._indexToString_J(numpy.int64(__0))
  def _indexToString_J(self,_0):
   _1=self._idxtokey_J(_0)
   _2=mosek.fusion.Utils.StringBuffer()
   _3=numpy.array([_1[_4] for _4 in range(0,(self.__sets[0].nd))], dtype=numpy.dtype(numpy.int32))
   _2._a_S(self.__sets[0]._indexToString_J(self.__sets[0]._linearidx__3I(_3)))
   _5=(self.__sets[0].nd)
   for _6 in range(1,int((self.__sets).shape[0])):
    _7=_5
    _5 = (_5 + (self.__sets[_6].nd))
    _8=numpy.array([_1[(_9 + _7)] for _9 in range(0,(_5 - _7))], dtype=numpy.dtype(numpy.int32))
    _2._a_S(",")._a_S(self.__sets[_6]._indexToString_J(self.__sets[_6]._linearidx__3I(_8)))
   return (_2._toString_())
  @staticmethod
  def __computedims_alt__3Lmosek_4fusion_4Set_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_ProductSet.__computedims__3Lmosek_4fusion_4Set_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __computedims__3Lmosek_4fusion_4Set_2(_0):
   _1=0
   for _2 in range(0,int((_0).shape[0])):
    _1 = (_1 + (_0[_2].nd))
   _3=numpy.array([_0[_4]._dim_I(_5) for _4 in range(0,int((_0).shape[0])) for _5 in range(0,(_0[_4].nd))], dtype=numpy.dtype(numpy.int32))
   return (_3)
 return ProductSet
mosek_fusion_ProductSet=__mk_mosek_fusion_ProductSet()
del __mk_mosek_fusion_ProductSet
#BEFORE CLASS
def __mk_mosek_fusion_QConeDomain():
 class QConeDomain(object):
  __slots__ = ['_shape','_int_flag','_axisidx','_key']
  def axis(self,*args):
    if False: pass
    elif mosek_fusion_QConeDomain._match_axis_I(*args): # int32
      return self._axis_I(*args)
    elif mosek_fusion_QConeDomain._match_alt_axis_I(*args): # int32
      return self._axis_alt_I(*args)
    else:
      raise ValueError('Invalid argument list axis('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.QConeDomain.axis(int32)')
  def integral(self,*args):
    if False: pass
    elif mosek_fusion_QConeDomain._match_integral_(*args): # 
      return self._integral_(*args)
    elif mosek_fusion_QConeDomain._match_alt_integral_(*args): # 
      return self._integral_alt_(*args)
    else:
      raise ValueError('Invalid argument list integral('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.QConeDomain.integral()')
  def getAxis(self,*args):
    if False: pass
    elif mosek_fusion_QConeDomain._match_getAxis_(*args): # 
      return self._getAxis_(*args)
    elif mosek_fusion_QConeDomain._match_alt_getAxis_(*args): # 
      return self._getAxis_alt_(*args)
    else:
      raise ValueError('Invalid argument list getAxis('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.QConeDomain.getAxis()')
  def __repr__(self): return 'mosek.fusion.QConeDomain'
  @staticmethod
  def _ctor_Emosek_4fusion_4QConeKey_2_3II(k,d,a):
    o = QConeDomain.__new__(QConeDomain)
    o._ctor_init_Emosek_4fusion_4QConeKey_2_3II(k,d,a)
    return o
  @staticmethod
  def __match_ctor_Emosek_4fusion_4QConeKey_2_3II(*args):
    if len(args) != 3: return False
    k,d,a, = args
    return (__arg_match_Emosek_4fusion_4QConeKey_2__(k) and __arg_match__3I__(d) and __arg_match_I__(a))
  @staticmethod
  def __match_alt_ctor_Emosek_4fusion_4QConeKey_2_3II(*args):
    if len(args) != 3: return False
    k,d,a, = args
    return (__arg_alt_match_Emosek_4fusion_4QConeKey_2__(k) and __arg_alt_match__3I__(d) and __arg_alt_match_I__(a))
  def _ctor_alt_init_Emosek_4fusion_4QConeKey_2_3II(self,k,d,a):
    self._ctor_init_Emosek_4fusion_4QConeKey_2_3II(k,numpy.array(d,dtype=numpy.dtype(numpy.int32)),numpy.int32(a))
  def _ctor_init_Emosek_4fusion_4QConeKey_2_3II(self,k,d,a):
   object.__init__(self)
   self._shape = (mosek.fusion.Set._make__3I(d) if ((d is not None) ) else None)
   self._key = k
   self._axisidx = a
   self._int_flag = False
  def _domainToString_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   if (self._key==mosek.fusion.QConeKey.InQCone):
    if (self._shape is not None):
     _2=self._shape._idxtokey_J(_0)
     _1._a_S(" : element (")._a_I(_2[0])
     for _3 in range(1,int((_2).shape[0])):
      _1._a_S(",")._a_I(_2[_3])
     _1._a_S(") in a quadratic cone of size (")._a_I(self._shape._dim_I(0))
     for _4 in range(1,int((_2).shape[0])):
      _1._a_S(",")._a_I(self._shape._dim_I(_4))
     _1._a_S(")")
    else:
     _1._a_S(" : element in a quadratic cone")
   elif (self._key==mosek.fusion.QConeKey.InRotatedQCone):
    if (self._shape is not None):
     _5=self._shape._idxtokey_J(_0)
     _1._a_S(" : element (")._a_I(_5[0])
     for _6 in range(1,int((_5).shape[0])):
      _1._a_S(",")._a_I(_5[_6])
     _1._a_S(") in a rotated quadratic cone of size (")._a_I(self._shape._dim_I(0))
     for _7 in range(1,int((_5).shape[0])):
      _1._a_S(",")._a_I(self._shape._dim_I(_7))
     _1._a_S(")")
    else:
     _1._a_S(" : element in a rotated quadratic cone")
   return (_1._toString_())
  def _match_1shape_alt_Lmosek_4fusion_4Set_2(self,_t__0):
    return self._match_1shape_Lmosek_4fusion_4Set_2(_0)
  def _match_1shape_Lmosek_4fusion_4Set_2(self,_0):
   return (((self._shape is None) or self._shape._compare_Lmosek_4fusion_4Set_2(_0)))
  @staticmethod
  def _match_integral_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_integral_(*args):
    if len(args) != 0: return False
    return True
  def _integral_alt_(self,):
    return self._integral_()
  def _integral_(self,):
   self._int_flag = True
   return (self)
  @staticmethod
  def _match_getAxis_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getAxis_(*args):
    if len(args) != 0: return False
    return True
  def _getAxis_alt_(self,):
    return self._getAxis_()
  def _getAxis_(self,):
   return numpy.int32(self._axisidx)
  @staticmethod
  def _match_axis_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_axis_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _axis_alt_I(self,_t__0):
    return self._axis_I(numpy.int32(__0))
  def _axis_I(self,_0):
   self._axisidx = _0
   return (self)
 return QConeDomain
mosek_fusion_QConeDomain=__mk_mosek_fusion_QConeDomain()
del __mk_mosek_fusion_QConeDomain
#BEFORE CLASS
def __mk_mosek_fusion_LinPSDDomain():
 class LinPSDDomain(object):
  __slots__ = ['_shape']
  def __repr__(self): return 'mosek.fusion.LinPSDDomain'
  @staticmethod
  def _ctor_():
    o = LinPSDDomain.__new__(LinPSDDomain)
    o._ctor_init_()
    return o
  @staticmethod
  def __match_ctor_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def __match_alt_ctor_(*args):
    if len(args) != 0: return False
    return True
  def _ctor_alt_init_(self,):
    self._ctor_init_()
  def _ctor_init_(self,):
   object.__init__(self)
   self._shape = None
  @staticmethod
  def _ctor_Lmosek_4fusion_4Set_2(shp):
    o = LinPSDDomain.__new__(LinPSDDomain)
    o._ctor_init_Lmosek_4fusion_4Set_2(shp)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Set_2(*args):
    if len(args) != 1: return False
    shp, = args
    return (__arg_match_Lmosek_4fusion_4Set_2__(shp))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Set_2(*args):
    if len(args) != 1: return False
    shp, = args
    return (__arg_alt_match_Lmosek_4fusion_4Set_2__(shp))
  def _ctor_alt_init_Lmosek_4fusion_4Set_2(self,shp):
    self._ctor_init_Lmosek_4fusion_4Set_2(shp)
  def _ctor_init_Lmosek_4fusion_4Set_2(self,shp):
   object.__init__(self)
   self._shape = shp
 return LinPSDDomain
mosek_fusion_LinPSDDomain=__mk_mosek_fusion_LinPSDDomain()
del __mk_mosek_fusion_LinPSDDomain
#BEFORE CLASS
def __mk_mosek_fusion_PSDDomain():
 class PSDDomain(object):
  __slots__ = ['_key','_shape']
  def __repr__(self): return 'mosek.fusion.PSDDomain'
  @staticmethod
  def _ctor_Emosek_4fusion_4PSDKey_2(k):
    o = PSDDomain.__new__(PSDDomain)
    o._ctor_init_Emosek_4fusion_4PSDKey_2(k)
    return o
  @staticmethod
  def __match_ctor_Emosek_4fusion_4PSDKey_2(*args):
    if len(args) != 1: return False
    k, = args
    return (__arg_match_Emosek_4fusion_4PSDKey_2__(k))
  @staticmethod
  def __match_alt_ctor_Emosek_4fusion_4PSDKey_2(*args):
    if len(args) != 1: return False
    k, = args
    return (__arg_alt_match_Emosek_4fusion_4PSDKey_2__(k))
  def _ctor_alt_init_Emosek_4fusion_4PSDKey_2(self,k):
    self._ctor_init_Emosek_4fusion_4PSDKey_2(k)
  def _ctor_init_Emosek_4fusion_4PSDKey_2(self,k):
   object.__init__(self)
   self._shape = None
   self._key = k
  @staticmethod
  def _ctor_Emosek_4fusion_4PSDKey_2Lmosek_4fusion_4Set_2(k,shp):
    o = PSDDomain.__new__(PSDDomain)
    o._ctor_init_Emosek_4fusion_4PSDKey_2Lmosek_4fusion_4Set_2(k,shp)
    return o
  @staticmethod
  def __match_ctor_Emosek_4fusion_4PSDKey_2Lmosek_4fusion_4Set_2(*args):
    if len(args) != 2: return False
    k,shp, = args
    return (__arg_match_Emosek_4fusion_4PSDKey_2__(k) and __arg_match_Lmosek_4fusion_4Set_2__(shp))
  @staticmethod
  def __match_alt_ctor_Emosek_4fusion_4PSDKey_2Lmosek_4fusion_4Set_2(*args):
    if len(args) != 2: return False
    k,shp, = args
    return (__arg_alt_match_Emosek_4fusion_4PSDKey_2__(k) and __arg_alt_match_Lmosek_4fusion_4Set_2__(shp))
  def _ctor_alt_init_Emosek_4fusion_4PSDKey_2Lmosek_4fusion_4Set_2(self,k,shp):
    self._ctor_init_Emosek_4fusion_4PSDKey_2Lmosek_4fusion_4Set_2(k,shp)
  def _ctor_init_Emosek_4fusion_4PSDKey_2Lmosek_4fusion_4Set_2(self,k,shp):
   object.__init__(self)
   self._shape = shp
   self._key = k
  def _domainToString_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   if (self._shape is not None):
    _2=self._shape._idxtokey_J(_0)
    _1._a_S(" : element (")._a_I(_2[0])
    for _3 in range(1,int((_2).shape[0])):
     _1._a_S(",")._a_I(_2[_3])
    _1._a_S(") in a semidefinite cone of size (")._a_I(self._shape._dim_I(0))
    for _4 in range(1,int((_2).shape[0])):
     _1._a_S(",")._a_I(self._shape._dim_I(_4))
    _1._a_S(")")
   else:
    _1._a_S(" : element in a semidefinite cone")
   return (_1._toString_())
 return PSDDomain
mosek_fusion_PSDDomain=__mk_mosek_fusion_PSDDomain()
del __mk_mosek_fusion_PSDDomain
#BEFORE CLASS
def __mk_mosek_fusion_RangeDomain():
 class RangeDomain(object):
  __slots__ = ['_sparse_flag','_cardinal_flag','_RangeDomain__ub','_RangeDomain__lb','_RangeDomain__idxmap','_shape']
  def symmetric(self,*args):
    if False: pass
    elif mosek_fusion_RangeDomain._match_symmetric_(*args): # 
      return self._symmetric_(*args)
    elif mosek_fusion_RangeDomain._match_alt_symmetric_(*args): # 
      return self._symmetric_alt_(*args)
    else:
      raise ValueError('Invalid argument list symmetric('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RangeDomain.symmetric()')
  def sparse(self,*args):
    if False: pass
    elif mosek_fusion_RangeDomain._match_sparse_(*args): # 
      return self._sparse_(*args)
    elif mosek_fusion_RangeDomain._match_alt_sparse_(*args): # 
      return self._sparse_alt_(*args)
    else:
      raise ValueError('Invalid argument list sparse('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RangeDomain.sparse()')
  def integral(self,*args):
    if False: pass
    elif mosek_fusion_RangeDomain._match_integral_(*args): # 
      return self._integral_(*args)
    elif mosek_fusion_RangeDomain._match_alt_integral_(*args): # 
      return self._integral_alt_(*args)
    else:
      raise ValueError('Invalid argument list integral('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RangeDomain.integral()')
  def __repr__(self): return 'mosek.fusion.RangeDomain'
  @staticmethod
  def _ctor__3D_3D_3I_3J(lb_,ub_,dims,inst):
    o = RangeDomain.__new__(RangeDomain)
    o._ctor_init__3D_3D_3I_3J(lb_,ub_,dims,inst)
    return o
  @staticmethod
  def __match_ctor__3D_3D_3I_3J(*args):
    if len(args) != 4: return False
    lb_,ub_,dims,inst, = args
    return (__arg_match__3D__(lb_) and __arg_match__3D__(ub_) and __arg_match__3I__(dims) and __arg_match__3J__(inst))
  @staticmethod
  def __match_alt_ctor__3D_3D_3I_3J(*args):
    if len(args) != 4: return False
    lb_,ub_,dims,inst, = args
    return (__arg_alt_match__3D__(lb_) and __arg_alt_match__3D__(ub_) and __arg_alt_match__3I__(dims) and __arg_alt_match__3J__(inst))
  def _ctor_alt_init__3D_3D_3I_3J(self,lb_,ub_,dims,inst):
    self._ctor_init__3D_3D_3I_3J(numpy.array(lb_,dtype=numpy.dtype(numpy.float64)),numpy.array(ub_,dtype=numpy.dtype(numpy.float64)),numpy.array(dims,dtype=numpy.dtype(numpy.int32)),numpy.array(inst,dtype=numpy.dtype(numpy.int64)))
  def _ctor_init__3D_3D_3I_3J(self,lb_,ub_,dims,inst):
   object.__init__(self)
   self._cardinal_flag = False
   self._sparse_flag = False
   if (dims is None):
    self._shape = None
   else:
    self._shape = mosek.fusion.Set._make__3I(dims)
   if (inst is not None):
    self.__idxmap = mosek.fusion.Utils.IntMap()
    for _0 in range(0,int((lb_).shape[0])):
     self.__idxmap._setItem_JI(inst[_0],_0)
   else:
    self.__idxmap = None
   self.__ub = ub_
   self.__lb = lb_
  @staticmethod
  def _ctor_Lmosek_4fusion_4RangeDomain_2(other):
    o = RangeDomain.__new__(RangeDomain)
    o._ctor_init_Lmosek_4fusion_4RangeDomain_2(other)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_match_Lmosek_4fusion_4RangeDomain_2__(other))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(other))
  def _ctor_alt_init_Lmosek_4fusion_4RangeDomain_2(self,other):
    self._ctor_init_Lmosek_4fusion_4RangeDomain_2(other)
  def _ctor_init_Lmosek_4fusion_4RangeDomain_2(self,other):
   object.__init__(self)
   self._cardinal_flag = (other._cardinal_flag)
   self._sparse_flag = (other._sparse_flag)
   self._shape = (other._shape)
   self.__idxmap = (other.__idxmap)
   self.__ub = (other.__ub)
   self.__lb = (other.__lb)
  @staticmethod
  def _match_symmetric_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_symmetric_(*args):
    if len(args) != 0: return False
    return True
  def _symmetric_alt_(self,):
    return self._symmetric_()
  def _symmetric_(self,):
   return (mosek_fusion_SymmetricRangeDomain._ctor_Lmosek_4fusion_4RangeDomain_2(self))
  @staticmethod
  def _match_sparse_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_sparse_(*args):
    if len(args) != 0: return False
    return True
  def _sparse_alt_(self,):
    return self._sparse_()
  def _sparse_(self,):
   self._sparse_flag = True
   return (self)
  @staticmethod
  def _match_integral_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_integral_(*args):
    if len(args) != 0: return False
    return True
  def _integral_alt_(self,):
    return self._integral_()
  def _integral_(self,):
   self._cardinal_flag = True
   return (self)
  def _domainToString_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   return (_1._a_S(" in [ ")._a_D(self._get_1lb_1item_J(_0))._a_S(",")._a_D(self._get_1ub_1item_J(_0))._a_S("]")._toString_())
  def _match_1shape_alt_Lmosek_4fusion_4Set_2(self,_t__0):
    return self._match_1shape_Lmosek_4fusion_4Set_2(_0)
  def _match_1shape_Lmosek_4fusion_4Set_2(self,_0):
   if (self._shape is None):
    return (True)
   else:
    return (self._shape._compare_Lmosek_4fusion_4Set_2(_0))
  def _get_1ub_1item_alt_J(self,_t__0):
    return self._get_1ub_1item_J(numpy.int64(__0))
  def _get_1ub_1item_J(self,_0):
   if (self.__idxmap is not None):
    if (self.__ub is None):
     return numpy.float64(0.0)
    else:
     if self.__idxmap._hasItem_J(_0):
      return numpy.float64(self.__ub[self.__idxmap._getItem_J(_0)])
     else:
      return numpy.float64(0.0)
   else:
    if (int((self.__ub).shape[0])==1):
     return numpy.float64(self.__ub[0])
    elif (self.__ub is not None):
     return numpy.float64(self.__ub[_0])
    else:
     return numpy.float64(0.0)
  def _get_1lb_1item_alt_J(self,_t__0):
    return self._get_1lb_1item_J(numpy.int64(__0))
  def _get_1lb_1item_J(self,_0):
   if (self.__idxmap is not None):
    if (self.__lb is None):
     return numpy.float64(0.0)
    elif self.__idxmap._hasItem_J(_0):
     return numpy.float64(self.__lb[self.__idxmap._getItem_J(_0)])
    else:
     return numpy.float64(0.0)
   else:
    if (int((self.__lb).shape[0])==1):
     return numpy.float64(self.__lb[0])
    elif (self.__lb is not None):
     return numpy.float64(self.__lb[_0])
    else:
     return numpy.float64(0.0)
 return RangeDomain
mosek_fusion_RangeDomain=__mk_mosek_fusion_RangeDomain()
del __mk_mosek_fusion_RangeDomain
#BEFORE CLASS
def __mk_mosek_fusion_SymmetricRangeDomain():
 class SymmetricRangeDomain(mosek_fusion_RangeDomain):
  __slots__ = ['_dim']
  def __repr__(self): return 'mosek.fusion.SymmetricRangeDomain'
  @staticmethod
  def _ctor_Lmosek_4fusion_4RangeDomain_2(other):
    o = SymmetricRangeDomain.__new__(SymmetricRangeDomain)
    o._ctor_init_Lmosek_4fusion_4RangeDomain_2(other)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_match_Lmosek_4fusion_4RangeDomain_2__(other))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(other))
  def _ctor_alt_init_Lmosek_4fusion_4RangeDomain_2(self,other):
    self._ctor_init_Lmosek_4fusion_4RangeDomain_2(other)
  def _ctor_init_Lmosek_4fusion_4RangeDomain_2(self,other):
   mosek_fusion_RangeDomain._ctor_init_Lmosek_4fusion_4RangeDomain_2(self,other)
   if ((self._shape is not None) and (((self._shape.nd)!=2) or (self._shape._dim_I(0)!=(other._shape)._dim_I(1)))):
    raise mosek_fusion_DimensionError._ctor_S("Only square domains can be symmetric")
   self._dim = (0 if ((self._shape is None) ) else self._shape._dim_I(0))
 return SymmetricRangeDomain
mosek_fusion_SymmetricRangeDomain=__mk_mosek_fusion_SymmetricRangeDomain()
del __mk_mosek_fusion_SymmetricRangeDomain
#BEFORE CLASS
def __mk_mosek_fusion_SymmetricLinearDomain():
 class SymmetricLinearDomain(object):
  __slots__ = ['_sparse_flag','_cardinal_flag','_key','_shape','_dom','_dim']
  def sparse(self,*args):
    if False: pass
    elif mosek_fusion_SymmetricLinearDomain._match_sparse_(*args): # 
      return self._sparse_(*args)
    elif mosek_fusion_SymmetricLinearDomain._match_alt_sparse_(*args): # 
      return self._sparse_alt_(*args)
    else:
      raise ValueError('Invalid argument list sparse('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymmetricLinearDomain.sparse()')
  def integral(self,*args):
    if False: pass
    elif mosek_fusion_SymmetricLinearDomain._match_integral_(*args): # 
      return self._integral_(*args)
    elif mosek_fusion_SymmetricLinearDomain._match_alt_integral_(*args): # 
      return self._integral_alt_(*args)
    else:
      raise ValueError('Invalid argument list integral('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymmetricLinearDomain.integral()')
  def __repr__(self): return 'mosek.fusion.SymmetricLinearDomain'
  @staticmethod
  def _ctor_Lmosek_4fusion_4LinearDomain_2(other):
    o = SymmetricLinearDomain.__new__(SymmetricLinearDomain)
    o._ctor_init_Lmosek_4fusion_4LinearDomain_2(other)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_match_Lmosek_4fusion_4LinearDomain_2__(other))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(other))
  def _ctor_alt_init_Lmosek_4fusion_4LinearDomain_2(self,other):
    self._ctor_init_Lmosek_4fusion_4LinearDomain_2(other)
  def _ctor_init_Lmosek_4fusion_4LinearDomain_2(self,other):
   object.__init__(self)
   self._dom = other
   self._shape = (other._shape)
   self._key = (other._key)
   self._cardinal_flag = (other._cardinal_flag)
   self._sparse_flag = (other._sparse_flag)
   if ((self._shape is not None) and (((self._shape.nd)!=2) or (self._shape._dim_I(0)!=(other._shape)._dim_I(1)))):
    raise mosek_fusion_DimensionError._ctor_S("Only square domains can be symmetric")
   self._dim = (0 if ((self._shape is None) ) else self._shape._dim_I(0))
  @staticmethod
  def _match_sparse_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_sparse_(*args):
    if len(args) != 0: return False
    return True
  def _sparse_alt_(self,):
    return self._sparse_()
  def _sparse_(self,):
   self._sparse_flag = True
   return (self)
  @staticmethod
  def _match_integral_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_integral_(*args):
    if len(args) != 0: return False
    return True
  def _integral_alt_(self,):
    return self._integral_()
  def _integral_(self,):
   self._cardinal_flag = True
   return (self)
  def _domainToString_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   return (self._dom._domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(_0,_1))
  def _match_1shape_alt_Lmosek_4fusion_4Set_2(self,_t__0):
    return self._match_1shape_Lmosek_4fusion_4Set_2(_0)
  def _match_1shape_Lmosek_4fusion_4Set_2(self,_0):
   return (self._dom._match_1shape_Lmosek_4fusion_4Set_2(_0))
  def _get_1rhs_1item_alt_J(self,_t__0):
    return self._get_1rhs_1item_J(numpy.int64(__0))
  def _get_1rhs_1item_J(self,_0):
   return numpy.float64(self._dom._get_1rhs_1item_J(_0))
 return SymmetricLinearDomain
mosek_fusion_SymmetricLinearDomain=__mk_mosek_fusion_SymmetricLinearDomain()
del __mk_mosek_fusion_SymmetricLinearDomain
#BEFORE CLASS
def __mk_mosek_fusion_LinearDomain():
 class LinearDomain(object):
  __slots__ = ['_sparse_flag','_cardinal_flag','_key','_LinearDomain__bnd','_LinearDomain__inst','_shape']
  def sparse(self,*args):
    if False: pass
    elif mosek_fusion_LinearDomain._match_sparse_(*args): # 
      return self._sparse_(*args)
    elif mosek_fusion_LinearDomain._match_alt_sparse_(*args): # 
      return self._sparse_alt_(*args)
    else:
      raise ValueError('Invalid argument list sparse('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearDomain.sparse()')
  def integral(self,*args):
    if False: pass
    elif mosek_fusion_LinearDomain._match_integral_(*args): # 
      return self._integral_(*args)
    elif mosek_fusion_LinearDomain._match_alt_integral_(*args): # 
      return self._integral_alt_(*args)
    else:
      raise ValueError('Invalid argument list integral('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearDomain.integral()')
  def symmetric(self,*args):
    if False: pass
    elif mosek_fusion_LinearDomain._match_symmetric_(*args): # 
      return self._symmetric_(*args)
    elif mosek_fusion_LinearDomain._match_alt_symmetric_(*args): # 
      return self._symmetric_alt_(*args)
    else:
      raise ValueError('Invalid argument list symmetric('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearDomain.symmetric()')
  def __repr__(self): return 'mosek.fusion.LinearDomain'
  @staticmethod
  def _ctor_Emosek_4fusion_4RelationKey_2_3D_3J_3I(k,rhs,sp,dims):
    o = LinearDomain.__new__(LinearDomain)
    o._ctor_init_Emosek_4fusion_4RelationKey_2_3D_3J_3I(k,rhs,sp,dims)
    return o
  @staticmethod
  def __match_ctor_Emosek_4fusion_4RelationKey_2_3D_3J_3I(*args):
    if len(args) != 4: return False
    k,rhs,sp,dims, = args
    return (__arg_match_Emosek_4fusion_4RelationKey_2__(k) and __arg_match__3D__(rhs) and __arg_match__3J__(sp) and __arg_match__3I__(dims))
  @staticmethod
  def __match_alt_ctor_Emosek_4fusion_4RelationKey_2_3D_3J_3I(*args):
    if len(args) != 4: return False
    k,rhs,sp,dims, = args
    return (__arg_alt_match_Emosek_4fusion_4RelationKey_2__(k) and __arg_alt_match__3D__(rhs) and __arg_alt_match__3J__(sp) and __arg_alt_match__3I__(dims))
  def _ctor_alt_init_Emosek_4fusion_4RelationKey_2_3D_3J_3I(self,k,rhs,sp,dims):
    self._ctor_init_Emosek_4fusion_4RelationKey_2_3D_3J_3I(k,numpy.array(rhs,dtype=numpy.dtype(numpy.float64)),numpy.array(sp,dtype=numpy.dtype(numpy.int64)),numpy.array(dims,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Emosek_4fusion_4RelationKey_2_3D_3J_3I(self,k,rhs,sp,dims):
   object.__init__(self)
   self._shape = (mosek.fusion.Set._make__3I(dims) if ((dims is not None) ) else None)
   self._key = k
   self.__bnd = rhs
   if (sp is not None):
    self.__inst = mosek.fusion.Utils.IntMap()
    for _0 in range(0,int((sp).shape[0])):
     self.__inst._setItem_JI(sp[_0],_0)
   else:
    self.__inst = None
   self._cardinal_flag = False
   self._sparse_flag = False
  @staticmethod
  def _ctor_Lmosek_4fusion_4LinearDomain_2(other):
    o = LinearDomain.__new__(LinearDomain)
    o._ctor_init_Lmosek_4fusion_4LinearDomain_2(other)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_match_Lmosek_4fusion_4LinearDomain_2__(other))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(other))
  def _ctor_alt_init_Lmosek_4fusion_4LinearDomain_2(self,other):
    self._ctor_init_Lmosek_4fusion_4LinearDomain_2(other)
  def _ctor_init_Lmosek_4fusion_4LinearDomain_2(self,other):
   object.__init__(self)
   self._shape = (other._shape)
   self.__inst = (other.__inst)
   self.__bnd = (other.__bnd)
   self._key = (other._key)
   self._cardinal_flag = (other._cardinal_flag)
   self._sparse_flag = (other._sparse_flag)
  @staticmethod
  def _match_symmetric_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_symmetric_(*args):
    if len(args) != 0: return False
    return True
  def _symmetric_alt_(self,):
    return self._symmetric_()
  def _symmetric_(self,):
   return (mosek_fusion_SymmetricLinearDomain._ctor_Lmosek_4fusion_4LinearDomain_2(self))
  @staticmethod
  def _match_sparse_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_sparse_(*args):
    if len(args) != 0: return False
    return True
  def _sparse_alt_(self,):
    return self._sparse_()
  def _sparse_(self,):
   self._sparse_flag = True
   return (self)
  @staticmethod
  def _match_integral_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_integral_(*args):
    if len(args) != 0: return False
    return True
  def _integral_alt_(self,):
    return self._integral_()
  def _integral_(self,):
   self._cardinal_flag = True
   return (self)
  def _domainToString_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   if (self._key==mosek.fusion.RelationKey.EqualsTo):
    _1._a_S(" = ")._a_D(self._get_1rhs_1item_J(_0))
   elif (self._key==mosek.fusion.RelationKey.LessThan):
    _1._a_S(" <= ")._a_D(self._get_1rhs_1item_J(_0))
   elif (self._key==mosek.fusion.RelationKey.GreaterThan):
    _1._a_S(" >= ")._a_D(self._get_1rhs_1item_J(_0))
   elif (self._key==mosek.fusion.RelationKey.IsFree):
    _1._a_S(" is unbounded")
   return (_1._toString_())
  def _match_1shape_alt_Lmosek_4fusion_4Set_2(self,_t__0):
    return self._match_1shape_Lmosek_4fusion_4Set_2(_0)
  def _match_1shape_Lmosek_4fusion_4Set_2(self,_0):
   if (self._shape is None):
    return (True)
   else:
    return (self._shape._compare_Lmosek_4fusion_4Set_2(_0))
  def _get_1rhs_1item_alt_J(self,_t__0):
    return self._get_1rhs_1item_J(numpy.int64(__0))
  def _get_1rhs_1item_J(self,_0):
   if (self.__inst is not None):
    if self.__inst._hasItem_J(_0):
     return numpy.float64(self.__bnd[self.__inst._getItem_J(_0)])
    else:
     return numpy.float64(0.0)
   else:
    if self.__scalable_():
     return numpy.float64((self.__bnd[0] if ((self.__bnd is not None) ) else 0.0))
    else:
     return numpy.float64((self.__bnd[_0] if ((self.__bnd is not None) ) else 0.0))
  def __scalable_alt_(self,):
    return self.__scalable_()
  def __scalable_(self,):
   return (((self.__bnd is None) or ((int((self.__bnd).shape[0])==1) and (self.__inst is None))))
 return LinearDomain
mosek_fusion_LinearDomain=__mk_mosek_fusion_LinearDomain()
del __mk_mosek_fusion_LinearDomain
#BEFORE CLASS
def __mk_mosek_fusion_Domain():
 class Domain(object):
  @staticmethod
  def binary(*args):
    if False: pass
    elif mosek_fusion_Domain._match_binary_(*args): # 
      return mosek_fusion_Domain._binary_(*args)
    elif mosek_fusion_Domain._match_alt_binary_(*args): # 
      return mosek_fusion_Domain._binary_alt_(*args)
    elif mosek_fusion_Domain._match_binary__3I(*args): # []int32
      return mosek_fusion_Domain._binary__3I(*args)
    elif mosek_fusion_Domain._match_alt_binary__3I(*args): # []int32
      return mosek_fusion_Domain._binary_alt__3I(*args)
    elif mosek_fusion_Domain._match_binary_I(*args): # int32
      return mosek_fusion_Domain._binary_I(*args)
    elif mosek_fusion_Domain._match_alt_binary_I(*args): # int32
      return mosek_fusion_Domain._binary_alt_I(*args)
    elif mosek_fusion_Domain._match_binary_II(*args): # int32,int32
      return mosek_fusion_Domain._binary_II(*args)
    elif mosek_fusion_Domain._match_alt_binary_II(*args): # int32,int32
      return mosek_fusion_Domain._binary_alt_II(*args)
    else:
      raise ValueError('Invalid argument list binary('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.binary()\n\tmosek.fusion.Domain.binary(array(int32,ndim=1))\n\tmosek.fusion.Domain.binary(int32)\n\tmosek.fusion.Domain.binary(int32,int32)')
  @staticmethod
  def equalsTo(*args):
    if False: pass
    elif mosek_fusion_Domain._match_equalsTo__3D(*args): # []double
      return mosek_fusion_Domain._equalsTo__3D(*args)
    elif mosek_fusion_Domain._match_alt_equalsTo__3D(*args): # []double
      return mosek_fusion_Domain._equalsTo_alt__3D(*args)
    elif mosek_fusion_Domain._match_equalsTo_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_Domain._equalsTo_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Domain._match_alt_equalsTo_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_Domain._equalsTo_alt_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Domain._match_equalsTo__3_5D(*args): # [,]double
      return mosek_fusion_Domain._equalsTo__3_5D(*args)
    elif mosek_fusion_Domain._match_alt_equalsTo__3_5D(*args): # [,]double
      return mosek_fusion_Domain._equalsTo_alt__3_5D(*args)
    elif mosek_fusion_Domain._match_equalsTo_D(*args): # double
      return mosek_fusion_Domain._equalsTo_D(*args)
    elif mosek_fusion_Domain._match_alt_equalsTo_D(*args): # double
      return mosek_fusion_Domain._equalsTo_alt_D(*args)
    elif mosek_fusion_Domain._match_equalsTo_D_3I(*args): # double,[]int32
      return mosek_fusion_Domain._equalsTo_D_3I(*args)
    elif mosek_fusion_Domain._match_alt_equalsTo_D_3I(*args): # double,[]int32
      return mosek_fusion_Domain._equalsTo_alt_D_3I(*args)
    elif mosek_fusion_Domain._match_equalsTo__3D_3I(*args): # []double,[]int32
      return mosek_fusion_Domain._equalsTo__3D_3I(*args)
    elif mosek_fusion_Domain._match_alt_equalsTo__3D_3I(*args): # []double,[]int32
      return mosek_fusion_Domain._equalsTo_alt__3D_3I(*args)
    elif mosek_fusion_Domain._match_equalsTo_DI(*args): # double,int32
      return mosek_fusion_Domain._equalsTo_DI(*args)
    elif mosek_fusion_Domain._match_alt_equalsTo_DI(*args): # double,int32
      return mosek_fusion_Domain._equalsTo_alt_DI(*args)
    elif mosek_fusion_Domain._match_equalsTo_DII(*args): # double,int32,int32
      return mosek_fusion_Domain._equalsTo_DII(*args)
    elif mosek_fusion_Domain._match_alt_equalsTo_DII(*args): # double,int32,int32
      return mosek_fusion_Domain._equalsTo_alt_DII(*args)
    else:
      raise ValueError('Invalid argument list equalsTo('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.equalsTo(array(double,ndim=1))\n\tmosek.fusion.Domain.equalsTo(mosek.fusion.Matrix)\n\tmosek.fusion.Domain.equalsTo(array(double,ndim=2))\n\tmosek.fusion.Domain.equalsTo(double)\n\tmosek.fusion.Domain.equalsTo(double,array(int32,ndim=1))\n\tmosek.fusion.Domain.equalsTo(array(double,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.Domain.equalsTo(double,int32)\n\tmosek.fusion.Domain.equalsTo(double,int32,int32)')
  @staticmethod
  def inQCone(*args):
    if False: pass
    elif mosek_fusion_Domain._match_inQCone_(*args): # 
      return mosek_fusion_Domain._inQCone_(*args)
    elif mosek_fusion_Domain._match_alt_inQCone_(*args): # 
      return mosek_fusion_Domain._inQCone_alt_(*args)
    elif mosek_fusion_Domain._match_inQCone_I(*args): # int32
      return mosek_fusion_Domain._inQCone_I(*args)
    elif mosek_fusion_Domain._match_alt_inQCone_I(*args): # int32
      return mosek_fusion_Domain._inQCone_alt_I(*args)
    elif mosek_fusion_Domain._match_inQCone__3I(*args): # []int32
      return mosek_fusion_Domain._inQCone__3I(*args)
    elif mosek_fusion_Domain._match_alt_inQCone__3I(*args): # []int32
      return mosek_fusion_Domain._inQCone_alt__3I(*args)
    elif mosek_fusion_Domain._match_inQCone_II(*args): # int32,int32
      return mosek_fusion_Domain._inQCone_II(*args)
    elif mosek_fusion_Domain._match_alt_inQCone_II(*args): # int32,int32
      return mosek_fusion_Domain._inQCone_alt_II(*args)
    else:
      raise ValueError('Invalid argument list inQCone('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.inQCone()\n\tmosek.fusion.Domain.inQCone(int32)\n\tmosek.fusion.Domain.inQCone(array(int32,ndim=1))\n\tmosek.fusion.Domain.inQCone(int32,int32)')
  @staticmethod
  def symmetric(*args):
    if False: pass
    elif mosek_fusion_Domain._match_symmetric_Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.LinearDomain
      return mosek_fusion_Domain._symmetric_Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Domain._match_alt_symmetric_Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.LinearDomain
      return mosek_fusion_Domain._symmetric_alt_Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Domain._match_symmetric_Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.RangeDomain
      return mosek_fusion_Domain._symmetric_Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Domain._match_alt_symmetric_Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.RangeDomain
      return mosek_fusion_Domain._symmetric_alt_Lmosek_4fusion_4RangeDomain_2(*args)
    else:
      raise ValueError('Invalid argument list symmetric('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.symmetric(mosek.fusion.LinearDomain)\n\tmosek.fusion.Domain.symmetric(mosek.fusion.RangeDomain)')
  @staticmethod
  def greaterThan(*args):
    if False: pass
    elif mosek_fusion_Domain._match_greaterThan__3D(*args): # []double
      return mosek_fusion_Domain._greaterThan__3D(*args)
    elif mosek_fusion_Domain._match_alt_greaterThan__3D(*args): # []double
      return mosek_fusion_Domain._greaterThan_alt__3D(*args)
    elif mosek_fusion_Domain._match_greaterThan_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_Domain._greaterThan_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Domain._match_alt_greaterThan_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_Domain._greaterThan_alt_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Domain._match_greaterThan__3_5D(*args): # [,]double
      return mosek_fusion_Domain._greaterThan__3_5D(*args)
    elif mosek_fusion_Domain._match_alt_greaterThan__3_5D(*args): # [,]double
      return mosek_fusion_Domain._greaterThan_alt__3_5D(*args)
    elif mosek_fusion_Domain._match_greaterThan_D(*args): # double
      return mosek_fusion_Domain._greaterThan_D(*args)
    elif mosek_fusion_Domain._match_alt_greaterThan_D(*args): # double
      return mosek_fusion_Domain._greaterThan_alt_D(*args)
    elif mosek_fusion_Domain._match_greaterThan_D_3I(*args): # double,[]int32
      return mosek_fusion_Domain._greaterThan_D_3I(*args)
    elif mosek_fusion_Domain._match_alt_greaterThan_D_3I(*args): # double,[]int32
      return mosek_fusion_Domain._greaterThan_alt_D_3I(*args)
    elif mosek_fusion_Domain._match_greaterThan__3D_3I(*args): # []double,[]int32
      return mosek_fusion_Domain._greaterThan__3D_3I(*args)
    elif mosek_fusion_Domain._match_alt_greaterThan__3D_3I(*args): # []double,[]int32
      return mosek_fusion_Domain._greaterThan_alt__3D_3I(*args)
    elif mosek_fusion_Domain._match_greaterThan_DI(*args): # double,int32
      return mosek_fusion_Domain._greaterThan_DI(*args)
    elif mosek_fusion_Domain._match_alt_greaterThan_DI(*args): # double,int32
      return mosek_fusion_Domain._greaterThan_alt_DI(*args)
    elif mosek_fusion_Domain._match_greaterThan_DII(*args): # double,int32,int32
      return mosek_fusion_Domain._greaterThan_DII(*args)
    elif mosek_fusion_Domain._match_alt_greaterThan_DII(*args): # double,int32,int32
      return mosek_fusion_Domain._greaterThan_alt_DII(*args)
    else:
      raise ValueError('Invalid argument list greaterThan('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.greaterThan(array(double,ndim=1))\n\tmosek.fusion.Domain.greaterThan(mosek.fusion.Matrix)\n\tmosek.fusion.Domain.greaterThan(array(double,ndim=2))\n\tmosek.fusion.Domain.greaterThan(double)\n\tmosek.fusion.Domain.greaterThan(double,array(int32,ndim=1))\n\tmosek.fusion.Domain.greaterThan(array(double,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.Domain.greaterThan(double,int32)\n\tmosek.fusion.Domain.greaterThan(double,int32,int32)')
  @staticmethod
  def sparse(*args):
    if False: pass
    elif mosek_fusion_Domain._match_sparse_Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.LinearDomain
      return mosek_fusion_Domain._sparse_Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Domain._match_alt_sparse_Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.LinearDomain
      return mosek_fusion_Domain._sparse_alt_Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Domain._match_sparse_Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.RangeDomain
      return mosek_fusion_Domain._sparse_Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Domain._match_alt_sparse_Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.RangeDomain
      return mosek_fusion_Domain._sparse_alt_Lmosek_4fusion_4RangeDomain_2(*args)
    else:
      raise ValueError('Invalid argument list sparse('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.sparse(mosek.fusion.LinearDomain)\n\tmosek.fusion.Domain.sparse(mosek.fusion.RangeDomain)')
  @staticmethod
  def inRotatedQCone(*args):
    if False: pass
    elif mosek_fusion_Domain._match_inRotatedQCone_(*args): # 
      return mosek_fusion_Domain._inRotatedQCone_(*args)
    elif mosek_fusion_Domain._match_alt_inRotatedQCone_(*args): # 
      return mosek_fusion_Domain._inRotatedQCone_alt_(*args)
    elif mosek_fusion_Domain._match_inRotatedQCone_I(*args): # int32
      return mosek_fusion_Domain._inRotatedQCone_I(*args)
    elif mosek_fusion_Domain._match_alt_inRotatedQCone_I(*args): # int32
      return mosek_fusion_Domain._inRotatedQCone_alt_I(*args)
    elif mosek_fusion_Domain._match_inRotatedQCone__3I(*args): # []int32
      return mosek_fusion_Domain._inRotatedQCone__3I(*args)
    elif mosek_fusion_Domain._match_alt_inRotatedQCone__3I(*args): # []int32
      return mosek_fusion_Domain._inRotatedQCone_alt__3I(*args)
    elif mosek_fusion_Domain._match_inRotatedQCone_II(*args): # int32,int32
      return mosek_fusion_Domain._inRotatedQCone_II(*args)
    elif mosek_fusion_Domain._match_alt_inRotatedQCone_II(*args): # int32,int32
      return mosek_fusion_Domain._inRotatedQCone_alt_II(*args)
    else:
      raise ValueError('Invalid argument list inRotatedQCone('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.inRotatedQCone()\n\tmosek.fusion.Domain.inRotatedQCone(int32)\n\tmosek.fusion.Domain.inRotatedQCone(array(int32,ndim=1))\n\tmosek.fusion.Domain.inRotatedQCone(int32,int32)')
  @staticmethod
  def isTrilPSD(*args):
    if False: pass
    elif mosek_fusion_Domain._match_isTrilPSD_(*args): # 
      return mosek_fusion_Domain._isTrilPSD_(*args)
    elif mosek_fusion_Domain._match_alt_isTrilPSD_(*args): # 
      return mosek_fusion_Domain._isTrilPSD_alt_(*args)
    elif mosek_fusion_Domain._match_isTrilPSD_I(*args): # int32
      return mosek_fusion_Domain._isTrilPSD_I(*args)
    elif mosek_fusion_Domain._match_alt_isTrilPSD_I(*args): # int32
      return mosek_fusion_Domain._isTrilPSD_alt_I(*args)
    elif mosek_fusion_Domain._match_isTrilPSD_II(*args): # int32,int32
      return mosek_fusion_Domain._isTrilPSD_II(*args)
    elif mosek_fusion_Domain._match_alt_isTrilPSD_II(*args): # int32,int32
      return mosek_fusion_Domain._isTrilPSD_alt_II(*args)
    else:
      raise ValueError('Invalid argument list isTrilPSD('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.isTrilPSD()\n\tmosek.fusion.Domain.isTrilPSD(int32)\n\tmosek.fusion.Domain.isTrilPSD(int32,int32)')
  @staticmethod
  def inRange(*args):
    if False: pass
    elif mosek_fusion_Domain._match_inRange_DLmosek_4fusion_4Matrix_2(*args): # double,mosek.fusion.Matrix
      return mosek_fusion_Domain._inRange_DLmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Domain._match_alt_inRange_DLmosek_4fusion_4Matrix_2(*args): # double,mosek.fusion.Matrix
      return mosek_fusion_Domain._inRange_alt_DLmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Domain._match_inRange_Lmosek_4fusion_4Matrix_2D(*args): # mosek.fusion.Matrix,double
      return mosek_fusion_Domain._inRange_Lmosek_4fusion_4Matrix_2D(*args)
    elif mosek_fusion_Domain._match_alt_inRange_Lmosek_4fusion_4Matrix_2D(*args): # mosek.fusion.Matrix,double
      return mosek_fusion_Domain._inRange_alt_Lmosek_4fusion_4Matrix_2D(*args)
    elif mosek_fusion_Domain._match_inRange_DD(*args): # double,double
      return mosek_fusion_Domain._inRange_DD(*args)
    elif mosek_fusion_Domain._match_alt_inRange_DD(*args): # double,double
      return mosek_fusion_Domain._inRange_alt_DD(*args)
    elif mosek_fusion_Domain._match_inRange__3D_3D(*args): # []double,[]double
      return mosek_fusion_Domain._inRange__3D_3D(*args)
    elif mosek_fusion_Domain._match_alt_inRange__3D_3D(*args): # []double,[]double
      return mosek_fusion_Domain._inRange_alt__3D_3D(*args)
    elif mosek_fusion_Domain._match_inRange__3DD(*args): # []double,double
      return mosek_fusion_Domain._inRange__3DD(*args)
    elif mosek_fusion_Domain._match_alt_inRange__3DD(*args): # []double,double
      return mosek_fusion_Domain._inRange_alt__3DD(*args)
    elif mosek_fusion_Domain._match_inRange_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix,mosek.fusion.Matrix
      return mosek_fusion_Domain._inRange_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Domain._match_alt_inRange_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix,mosek.fusion.Matrix
      return mosek_fusion_Domain._inRange_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Domain._match_inRange_D_3D(*args): # double,[]double
      return mosek_fusion_Domain._inRange_D_3D(*args)
    elif mosek_fusion_Domain._match_alt_inRange_D_3D(*args): # double,[]double
      return mosek_fusion_Domain._inRange_alt_D_3D(*args)
    else:
      raise ValueError('Invalid argument list inRange('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.inRange(double,mosek.fusion.Matrix)\n\tmosek.fusion.Domain.inRange(mosek.fusion.Matrix,double)\n\tmosek.fusion.Domain.inRange(double,double)\n\tmosek.fusion.Domain.inRange(array(double,ndim=1),array(double,ndim=1))\n\tmosek.fusion.Domain.inRange(array(double,ndim=1),double)\n\tmosek.fusion.Domain.inRange(mosek.fusion.Matrix,mosek.fusion.Matrix)\n\tmosek.fusion.Domain.inRange(double,array(double,ndim=1))')
  @staticmethod
  def axis(*args):
    if False: pass
    elif mosek_fusion_Domain._match_axis_Lmosek_4fusion_4QConeDomain_2I(*args): # mosek.fusion.QConeDomain,int32
      return mosek_fusion_Domain._axis_Lmosek_4fusion_4QConeDomain_2I(*args)
    elif mosek_fusion_Domain._match_alt_axis_Lmosek_4fusion_4QConeDomain_2I(*args): # mosek.fusion.QConeDomain,int32
      return mosek_fusion_Domain._axis_alt_Lmosek_4fusion_4QConeDomain_2I(*args)
    else:
      raise ValueError('Invalid argument list axis('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.axis(mosek.fusion.QConeDomain,int32)')
  @staticmethod
  def integral(*args):
    if False: pass
    elif mosek_fusion_Domain._match_integral_Lmosek_4fusion_4QConeDomain_2(*args): # mosek.fusion.QConeDomain
      return mosek_fusion_Domain._integral_Lmosek_4fusion_4QConeDomain_2(*args)
    elif mosek_fusion_Domain._match_alt_integral_Lmosek_4fusion_4QConeDomain_2(*args): # mosek.fusion.QConeDomain
      return mosek_fusion_Domain._integral_alt_Lmosek_4fusion_4QConeDomain_2(*args)
    elif mosek_fusion_Domain._match_integral_Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.LinearDomain
      return mosek_fusion_Domain._integral_Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Domain._match_alt_integral_Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.LinearDomain
      return mosek_fusion_Domain._integral_alt_Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Domain._match_integral_Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.RangeDomain
      return mosek_fusion_Domain._integral_Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Domain._match_alt_integral_Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.RangeDomain
      return mosek_fusion_Domain._integral_alt_Lmosek_4fusion_4RangeDomain_2(*args)
    else:
      raise ValueError('Invalid argument list integral('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.integral(mosek.fusion.QConeDomain)\n\tmosek.fusion.Domain.integral(mosek.fusion.LinearDomain)\n\tmosek.fusion.Domain.integral(mosek.fusion.RangeDomain)')
  @staticmethod
  def lessThan(*args):
    if False: pass
    elif mosek_fusion_Domain._match_lessThan__3D(*args): # []double
      return mosek_fusion_Domain._lessThan__3D(*args)
    elif mosek_fusion_Domain._match_alt_lessThan__3D(*args): # []double
      return mosek_fusion_Domain._lessThan_alt__3D(*args)
    elif mosek_fusion_Domain._match_lessThan_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_Domain._lessThan_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Domain._match_alt_lessThan_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_Domain._lessThan_alt_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Domain._match_lessThan__3_5D(*args): # [,]double
      return mosek_fusion_Domain._lessThan__3_5D(*args)
    elif mosek_fusion_Domain._match_alt_lessThan__3_5D(*args): # [,]double
      return mosek_fusion_Domain._lessThan_alt__3_5D(*args)
    elif mosek_fusion_Domain._match_lessThan_D(*args): # double
      return mosek_fusion_Domain._lessThan_D(*args)
    elif mosek_fusion_Domain._match_alt_lessThan_D(*args): # double
      return mosek_fusion_Domain._lessThan_alt_D(*args)
    elif mosek_fusion_Domain._match_lessThan_D_3I(*args): # double,[]int32
      return mosek_fusion_Domain._lessThan_D_3I(*args)
    elif mosek_fusion_Domain._match_alt_lessThan_D_3I(*args): # double,[]int32
      return mosek_fusion_Domain._lessThan_alt_D_3I(*args)
    elif mosek_fusion_Domain._match_lessThan__3D_3I(*args): # []double,[]int32
      return mosek_fusion_Domain._lessThan__3D_3I(*args)
    elif mosek_fusion_Domain._match_alt_lessThan__3D_3I(*args): # []double,[]int32
      return mosek_fusion_Domain._lessThan_alt__3D_3I(*args)
    elif mosek_fusion_Domain._match_lessThan_DI(*args): # double,int32
      return mosek_fusion_Domain._lessThan_DI(*args)
    elif mosek_fusion_Domain._match_alt_lessThan_DI(*args): # double,int32
      return mosek_fusion_Domain._lessThan_alt_DI(*args)
    elif mosek_fusion_Domain._match_lessThan_DII(*args): # double,int32,int32
      return mosek_fusion_Domain._lessThan_DII(*args)
    elif mosek_fusion_Domain._match_alt_lessThan_DII(*args): # double,int32,int32
      return mosek_fusion_Domain._lessThan_alt_DII(*args)
    else:
      raise ValueError('Invalid argument list lessThan('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.lessThan(array(double,ndim=1))\n\tmosek.fusion.Domain.lessThan(mosek.fusion.Matrix)\n\tmosek.fusion.Domain.lessThan(array(double,ndim=2))\n\tmosek.fusion.Domain.lessThan(double)\n\tmosek.fusion.Domain.lessThan(double,array(int32,ndim=1))\n\tmosek.fusion.Domain.lessThan(array(double,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.Domain.lessThan(double,int32)\n\tmosek.fusion.Domain.lessThan(double,int32,int32)')
  @staticmethod
  def inPSDCone(*args):
    if False: pass
    elif mosek_fusion_Domain._match_inPSDCone_(*args): # 
      return mosek_fusion_Domain._inPSDCone_(*args)
    elif mosek_fusion_Domain._match_alt_inPSDCone_(*args): # 
      return mosek_fusion_Domain._inPSDCone_alt_(*args)
    elif mosek_fusion_Domain._match_inPSDCone_I(*args): # int32
      return mosek_fusion_Domain._inPSDCone_I(*args)
    elif mosek_fusion_Domain._match_alt_inPSDCone_I(*args): # int32
      return mosek_fusion_Domain._inPSDCone_alt_I(*args)
    elif mosek_fusion_Domain._match_inPSDCone_II(*args): # int32,int32
      return mosek_fusion_Domain._inPSDCone_II(*args)
    elif mosek_fusion_Domain._match_alt_inPSDCone_II(*args): # int32,int32
      return mosek_fusion_Domain._inPSDCone_alt_II(*args)
    else:
      raise ValueError('Invalid argument list inPSDCone('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.inPSDCone()\n\tmosek.fusion.Domain.inPSDCone(int32)\n\tmosek.fusion.Domain.inPSDCone(int32,int32)')
  @staticmethod
  def unbounded(*args):
    if False: pass
    elif mosek_fusion_Domain._match_unbounded_(*args): # 
      return mosek_fusion_Domain._unbounded_(*args)
    elif mosek_fusion_Domain._match_alt_unbounded_(*args): # 
      return mosek_fusion_Domain._unbounded_alt_(*args)
    elif mosek_fusion_Domain._match_unbounded_I(*args): # int32
      return mosek_fusion_Domain._unbounded_I(*args)
    elif mosek_fusion_Domain._match_alt_unbounded_I(*args): # int32
      return mosek_fusion_Domain._unbounded_alt_I(*args)
    elif mosek_fusion_Domain._match_unbounded__3I(*args): # []int32
      return mosek_fusion_Domain._unbounded__3I(*args)
    elif mosek_fusion_Domain._match_alt_unbounded__3I(*args): # []int32
      return mosek_fusion_Domain._unbounded_alt__3I(*args)
    elif mosek_fusion_Domain._match_unbounded_II(*args): # int32,int32
      return mosek_fusion_Domain._unbounded_II(*args)
    elif mosek_fusion_Domain._match_alt_unbounded_II(*args): # int32,int32
      return mosek_fusion_Domain._unbounded_alt_II(*args)
    else:
      raise ValueError('Invalid argument list unbounded('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.unbounded()\n\tmosek.fusion.Domain.unbounded(int32)\n\tmosek.fusion.Domain.unbounded(array(int32,ndim=1))\n\tmosek.fusion.Domain.unbounded(int32,int32)')
  @staticmethod
  def isLinPSD(*args):
    if False: pass
    elif mosek_fusion_Domain._match_isLinPSD_(*args): # 
      return mosek_fusion_Domain._isLinPSD_(*args)
    elif mosek_fusion_Domain._match_alt_isLinPSD_(*args): # 
      return mosek_fusion_Domain._isLinPSD_alt_(*args)
    elif mosek_fusion_Domain._match_isLinPSD_I(*args): # int32
      return mosek_fusion_Domain._isLinPSD_I(*args)
    elif mosek_fusion_Domain._match_alt_isLinPSD_I(*args): # int32
      return mosek_fusion_Domain._isLinPSD_alt_I(*args)
    elif mosek_fusion_Domain._match_isLinPSD_II(*args): # int32,int32
      return mosek_fusion_Domain._isLinPSD_II(*args)
    elif mosek_fusion_Domain._match_alt_isLinPSD_II(*args): # int32,int32
      return mosek_fusion_Domain._isLinPSD_alt_II(*args)
    else:
      raise ValueError('Invalid argument list isLinPSD('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.isLinPSD()\n\tmosek.fusion.Domain.isLinPSD(int32)\n\tmosek.fusion.Domain.isLinPSD(int32,int32)')
  def __repr__(self): return 'mosek.fusion.Domain'
  @staticmethod
  def __dimsize_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain.__dimsize__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __dimsize__3I(_0):
   _1=1
   _1 = fragments._c_closure_221(_0,_1) # src/fusion/domain.mbi:331:73-114
   _1 = numpy.int64(_1) # postprocess
   return numpy.int64(_1)
  @staticmethod
  def __mkLinearDomain_alt_Emosek_4fusion_4RelationKey_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2Lmosek_4fusion_4Matrix_2(__0,_1)
  @staticmethod
  def __mkLinearDomain_Emosek_4fusion_4RelationKey_2Lmosek_4fusion_4Matrix_2(_0,_1):
   if _1._isSparse_():
    _2=numpy.zeros((_1._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
    _3=numpy.zeros((_1._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
    _4=numpy.zeros((_1._numNonzeros_(),), dtype=numpy.dtype(numpy.float64))
    _1._getDataAsTriplets__3I_3I_3D(_2,_3,_4)
    _5=numpy.array([((_2[_6] * (_1._dimj)) + _3[_6]) for _6 in range(0,int((_2).shape[0]))], dtype=numpy.dtype(numpy.int64))
    return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2_3D_3J_3I(_0,_4,_5,numpy.array([(_1._dimi),(_1._dimj)], dtype=numpy.dtype(numpy.int32))))
   else:
    return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2_3D_3J_3I(_0,_1._getDataAsArray_(),None,numpy.array([(_1._dimi),(_1._dimj)], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def __mkLinearDomain_alt_Emosek_4fusion_4RelationKey_2_3_5D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2_3_5D(_0,_1)
   return _1
  @staticmethod
  def __mkLinearDomain_Emosek_4fusion_4RelationKey_2_3_5D(_0,_1):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2_3D_3J_3I(_0,numpy.array([_1[_2,_3] for _2 in range(0,int((_1).shape[0])) for _3 in range(0,int((_1).shape[1]))], dtype=numpy.dtype(numpy.float64)),None,numpy.array([int((_1).shape[0]),int((_1).shape[1])], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def __mkLinearDomain_alt_Emosek_4fusion_4RelationKey_2_3D_3I(_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2_3D_3I(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __mkLinearDomain_Emosek_4fusion_4RelationKey_2_3D_3I(_0,_1,_2):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2_3D_3J_3I(_0,numpy.array([_1[_3] for _3 in range(0,int((_1).shape[0]))], dtype=numpy.dtype(numpy.float64)),None,numpy.array([_2[_4] for _4 in range(0,int((_2).shape[0]))], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def __mkLinearDomain_alt_Emosek_4fusion_4RelationKey_2_3D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __mkLinearDomain_Emosek_4fusion_4RelationKey_2_3D(_0,_1):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2_3D_3J_3I(_0,numpy.array([_1[_2] for _2 in range(0,int((_1).shape[0]))], dtype=numpy.dtype(numpy.float64)),None,numpy.array([int((_1).shape[0])], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def __mkLinearDomain_alt_Emosek_4fusion_4RelationKey_2D_3I(_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.float64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2D_3I(_0,_1,_2)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __mkLinearDomain_Emosek_4fusion_4RelationKey_2D_3I(_0,_1,_2):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2_3D_3J_3I(_0,numpy.array([_1 for _3 in range(0,mosek.fusion.Domain.__dimsize__3I(_2))], dtype=numpy.dtype(numpy.float64)),None,numpy.array([_2[_4] for _4 in range(0,int((_2).shape[0]))], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def __mkLinearDomain_alt_Emosek_4fusion_4RelationKey_2D(_t__0,_t__1):
    return mosek_fusion_Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2D(__0,numpy.float64(__1))
  @staticmethod
  def __mkLinearDomain_Emosek_4fusion_4RelationKey_2D(_0,_1):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2_3D_3J_3I(_0,numpy.array([_1], dtype=numpy.dtype(numpy.float64)),None,None))
  @staticmethod
  def __inRange_alt__3D_3D_3I(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain.__inRange__3D_3D_3I(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __inRange__3D_3D_3I(_0,_1,_2):
   if (int((_0).shape[0])!=int((_1).shape[0])):
    raise mosek_fusion_LengthError._ctor_S("Mismatching lengths of upper and lower bounds.")
   for _3 in range(0,int((_1).shape[0])):
    if (_0[_3] > _1[_3]):
     raise mosek_fusion_DomainError._ctor_S("Invalid range specified")
   if ((_2 is not None) and (mosek.fusion.Domain.__dimsize__3I(_2)!=int((_0).shape[0]))):
    raise mosek_fusion_LengthError._ctor_S("Mismatching dimensions.")
   return (mosek_fusion_RangeDomain._ctor__3D_3D_3I_3J(_0,_1,_2,None))
  @staticmethod
  def _match_symmetric_Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4RangeDomain_2__(_0))
  @staticmethod
  def _match_alt_symmetric_Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_0))
  @staticmethod
  def _symmetric_alt_Lmosek_4fusion_4RangeDomain_2(_t__0):
    return mosek_fusion_Domain._symmetric_Lmosek_4fusion_4RangeDomain_2(_0)
  @staticmethod
  def _symmetric_Lmosek_4fusion_4RangeDomain_2(_0):
   return (_0._symmetric_())
  @staticmethod
  def _match_symmetric_Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4LinearDomain_2__(_0))
  @staticmethod
  def _match_alt_symmetric_Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_0))
  @staticmethod
  def _symmetric_alt_Lmosek_4fusion_4LinearDomain_2(_t__0):
    return mosek_fusion_Domain._symmetric_Lmosek_4fusion_4LinearDomain_2(_0)
  @staticmethod
  def _symmetric_Lmosek_4fusion_4LinearDomain_2(_0):
   return (_0._symmetric_())
  @staticmethod
  def _match_sparse_Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4RangeDomain_2__(_0))
  @staticmethod
  def _match_alt_sparse_Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_0))
  @staticmethod
  def _sparse_alt_Lmosek_4fusion_4RangeDomain_2(_t__0):
    return mosek_fusion_Domain._sparse_Lmosek_4fusion_4RangeDomain_2(_0)
  @staticmethod
  def _sparse_Lmosek_4fusion_4RangeDomain_2(_0):
   return (_0._sparse_())
  @staticmethod
  def _match_sparse_Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4LinearDomain_2__(_0))
  @staticmethod
  def _match_alt_sparse_Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_0))
  @staticmethod
  def _sparse_alt_Lmosek_4fusion_4LinearDomain_2(_t__0):
    return mosek_fusion_Domain._sparse_Lmosek_4fusion_4LinearDomain_2(_0)
  @staticmethod
  def _sparse_Lmosek_4fusion_4LinearDomain_2(_0):
   return (_0._sparse_())
  @staticmethod
  def _match_integral_Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4RangeDomain_2__(_0))
  @staticmethod
  def _match_alt_integral_Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_0))
  @staticmethod
  def _integral_alt_Lmosek_4fusion_4RangeDomain_2(_t__0):
    return mosek_fusion_Domain._integral_Lmosek_4fusion_4RangeDomain_2(_0)
  @staticmethod
  def _integral_Lmosek_4fusion_4RangeDomain_2(_0):
   return (_0._integral_())
  @staticmethod
  def _match_integral_Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4LinearDomain_2__(_0))
  @staticmethod
  def _match_alt_integral_Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_0))
  @staticmethod
  def _integral_alt_Lmosek_4fusion_4LinearDomain_2(_t__0):
    return mosek_fusion_Domain._integral_Lmosek_4fusion_4LinearDomain_2(_0)
  @staticmethod
  def _integral_Lmosek_4fusion_4LinearDomain_2(_0):
   return (_0._integral_())
  @staticmethod
  def _match_integral_Lmosek_4fusion_4QConeDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4QConeDomain_2__(_0))
  @staticmethod
  def _match_alt_integral_Lmosek_4fusion_4QConeDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4QConeDomain_2__(_0))
  @staticmethod
  def _integral_alt_Lmosek_4fusion_4QConeDomain_2(_t__0):
    return mosek_fusion_Domain._integral_Lmosek_4fusion_4QConeDomain_2(_0)
  @staticmethod
  def _integral_Lmosek_4fusion_4QConeDomain_2(_0):
   return (_0._integral_())
  @staticmethod
  def _match_axis_Lmosek_4fusion_4QConeDomain_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4QConeDomain_2__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_axis_Lmosek_4fusion_4QConeDomain_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4QConeDomain_2__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _axis_alt_Lmosek_4fusion_4QConeDomain_2I(_t__0,_t__1):
    return mosek_fusion_Domain._axis_Lmosek_4fusion_4QConeDomain_2I(_0,numpy.int32(__1))
  @staticmethod
  def _axis_Lmosek_4fusion_4QConeDomain_2I(_0,_1):
   return (_0._axis_I(_1))
  @staticmethod
  def _match_inRotatedQCone__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_inRotatedQCone__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  @staticmethod
  def _inRotatedQCone_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._inRotatedQCone__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _inRotatedQCone__3I(_0):
   return (mosek_fusion_QConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3II(mosek.fusion.QConeKey.InRotatedQCone,numpy.array([_0[_1] for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32)),(int((_0).shape[0]) - 1)))
  @staticmethod
  def _match_inRotatedQCone_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_inRotatedQCone_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _inRotatedQCone_alt_II(_t__0,_t__1):
    return mosek_fusion_Domain._inRotatedQCone_II(numpy.int32(__0),numpy.int32(__1))
  @staticmethod
  def _inRotatedQCone_II(_0,_1):
   return (mosek_fusion_QConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3II(mosek.fusion.QConeKey.InRotatedQCone,numpy.array([_0,_1], dtype=numpy.dtype(numpy.int32)),1))
  @staticmethod
  def _match_inRotatedQCone_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_inRotatedQCone_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _inRotatedQCone_alt_I(_t__0):
    return mosek_fusion_Domain._inRotatedQCone_I(numpy.int32(__0))
  @staticmethod
  def _inRotatedQCone_I(_0):
   return (mosek_fusion_QConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3II(mosek.fusion.QConeKey.InRotatedQCone,numpy.array([_0], dtype=numpy.dtype(numpy.int32)),0))
  @staticmethod
  def _match_inRotatedQCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_inRotatedQCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _inRotatedQCone_alt_():
    return mosek_fusion_Domain._inRotatedQCone_()
  @staticmethod
  def _inRotatedQCone_():
   return (mosek_fusion_QConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3II(mosek.fusion.QConeKey.InRotatedQCone,None,0))
  @staticmethod
  def _match_inQCone__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_inQCone__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  @staticmethod
  def _inQCone_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._inQCone__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _inQCone__3I(_0):
   return (mosek_fusion_QConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3II(mosek.fusion.QConeKey.InQCone,numpy.array([_0[_1] for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32)),(int((_0).shape[0]) - 1)))
  @staticmethod
  def _match_inQCone_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_inQCone_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _inQCone_alt_II(_t__0,_t__1):
    return mosek_fusion_Domain._inQCone_II(numpy.int32(__0),numpy.int32(__1))
  @staticmethod
  def _inQCone_II(_0,_1):
   return (mosek_fusion_QConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3II(mosek.fusion.QConeKey.InQCone,numpy.array([_0,_1], dtype=numpy.dtype(numpy.int32)),1))
  @staticmethod
  def _match_inQCone_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_inQCone_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _inQCone_alt_I(_t__0):
    return mosek_fusion_Domain._inQCone_I(numpy.int32(__0))
  @staticmethod
  def _inQCone_I(_0):
   return (mosek_fusion_QConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3II(mosek.fusion.QConeKey.InQCone,numpy.array([_0], dtype=numpy.dtype(numpy.int32)),0))
  @staticmethod
  def _match_inQCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_inQCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _inQCone_alt_():
    return mosek_fusion_Domain._inQCone_()
  @staticmethod
  def _inQCone_():
   return (mosek_fusion_QConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3II(mosek.fusion.QConeKey.InQCone,None,0))
  @staticmethod
  def _match_isLinPSD_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_isLinPSD_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _isLinPSD_alt_II(_t__0,_t__1):
    return mosek_fusion_Domain._isLinPSD_II(numpy.int32(__0),numpy.int32(__1))
  @staticmethod
  def _isLinPSD_II(_0,_1):
   return (mosek_fusion_LinPSDDomain._ctor_Lmosek_4fusion_4Set_2(mosek_fusion_NDSet._ctor_II(_1,((_0 * (_0 + 1)) // 2))))
  @staticmethod
  def _match_isLinPSD_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_isLinPSD_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _isLinPSD_alt_I(_t__0):
    return mosek_fusion_Domain._isLinPSD_I(numpy.int32(__0))
  @staticmethod
  def _isLinPSD_I(_0):
   return (mosek_fusion_LinPSDDomain._ctor_Lmosek_4fusion_4Set_2(mosek_fusion_IntSet._ctor_I(((_0 * (_0 + 1)) // 2))))
  @staticmethod
  def _match_isLinPSD_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_isLinPSD_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _isLinPSD_alt_():
    return mosek_fusion_Domain._isLinPSD_()
  @staticmethod
  def _isLinPSD_():
   return (mosek_fusion_LinPSDDomain._ctor_())
  @staticmethod
  def _match_isTrilPSD_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_isTrilPSD_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _isTrilPSD_alt_II(_t__0,_t__1):
    return mosek_fusion_Domain._isTrilPSD_II(numpy.int32(__0),numpy.int32(__1))
  @staticmethod
  def _isTrilPSD_II(_0,_1):
   return (mosek_fusion_PSDDomain._ctor_Emosek_4fusion_4PSDKey_2Lmosek_4fusion_4Set_2(mosek.fusion.PSDKey.IsTrilPSD,mosek_fusion_NDSet._ctor_III(_1,_0,_0)))
  @staticmethod
  def _match_isTrilPSD_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_isTrilPSD_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _isTrilPSD_alt_I(_t__0):
    return mosek_fusion_Domain._isTrilPSD_I(numpy.int32(__0))
  @staticmethod
  def _isTrilPSD_I(_0):
   return (mosek_fusion_PSDDomain._ctor_Emosek_4fusion_4PSDKey_2Lmosek_4fusion_4Set_2(mosek.fusion.PSDKey.IsTrilPSD,mosek_fusion_NDSet._ctor_II(_0,_0)))
  @staticmethod
  def _match_isTrilPSD_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_isTrilPSD_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _isTrilPSD_alt_():
    return mosek_fusion_Domain._isTrilPSD_()
  @staticmethod
  def _isTrilPSD_():
   return (mosek_fusion_PSDDomain._ctor_Emosek_4fusion_4PSDKey_2(mosek.fusion.PSDKey.IsTrilPSD))
  @staticmethod
  def _match_inPSDCone_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_inPSDCone_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _inPSDCone_alt_II(_t__0,_t__1):
    return mosek_fusion_Domain._inPSDCone_II(numpy.int32(__0),numpy.int32(__1))
  @staticmethod
  def _inPSDCone_II(_0,_1):
   return (mosek_fusion_PSDDomain._ctor_Emosek_4fusion_4PSDKey_2Lmosek_4fusion_4Set_2(mosek.fusion.PSDKey.IsSymPSD,mosek_fusion_NDSet._ctor_III(_1,_0,_0)))
  @staticmethod
  def _match_inPSDCone_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_inPSDCone_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _inPSDCone_alt_I(_t__0):
    return mosek_fusion_Domain._inPSDCone_I(numpy.int32(__0))
  @staticmethod
  def _inPSDCone_I(_0):
   return (mosek_fusion_PSDDomain._ctor_Emosek_4fusion_4PSDKey_2Lmosek_4fusion_4Set_2(mosek.fusion.PSDKey.IsSymPSD,mosek_fusion_NDSet._ctor_II(_0,_0)))
  @staticmethod
  def _match_inPSDCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_inPSDCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _inPSDCone_alt_():
    return mosek_fusion_Domain._inPSDCone_()
  @staticmethod
  def _inPSDCone_():
   return (mosek_fusion_PSDDomain._ctor_Emosek_4fusion_4PSDKey_2(mosek.fusion.PSDKey.IsSymPSD))
  @staticmethod
  def _match_binary_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_binary_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _binary_alt_():
    return mosek_fusion_Domain._binary_()
  @staticmethod
  def _binary_():
   return (mosek.fusion.Domain._inRange_DD(0.0,1.0)._integral_())
  @staticmethod
  def _match_binary__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_binary__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  @staticmethod
  def _binary_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._binary__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _binary__3I(_0):
   return (mosek.fusion.Domain.__inRange__3D_3D_3I(numpy.array([0.0 for _1 in range(0,mosek.fusion.Domain.__dimsize__3I(_0))], dtype=numpy.dtype(numpy.float64)),numpy.array([1.0 for _2 in range(0,mosek.fusion.Domain.__dimsize__3I(_0))], dtype=numpy.dtype(numpy.float64)),_0)._integral_())
  @staticmethod
  def _match_binary_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_binary_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _binary_alt_II(_t__0,_t__1):
    return mosek_fusion_Domain._binary_II(numpy.int32(__0),numpy.int32(__1))
  @staticmethod
  def _binary_II(_0,_1):
   return (mosek.fusion.Domain.__inRange__3D_3D_3I(numpy.array([0.0 for _2 in range(0,(_1 * _0))], dtype=numpy.dtype(numpy.float64)),numpy.array([1.0 for _3 in range(0,(_1 * _0))], dtype=numpy.dtype(numpy.float64)),numpy.array([_0,_1], dtype=numpy.dtype(numpy.int32)))._integral_())
  @staticmethod
  def _match_binary_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_binary_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _binary_alt_I(_t__0):
    return mosek_fusion_Domain._binary_I(numpy.int32(__0))
  @staticmethod
  def _binary_I(_0):
   return (mosek.fusion.Domain.__inRange__3D_3D_3I(numpy.array([0.0 for _1 in range(0,_0)], dtype=numpy.dtype(numpy.float64)),numpy.array([1.0 for _2 in range(0,_0)], dtype=numpy.dtype(numpy.float64)),numpy.array([_0], dtype=numpy.dtype(numpy.int32)))._integral_())
  @staticmethod
  def _match_inRange_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_inRange_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _inRange_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Domain._inRange_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Matrix_2(_0,_1)
  @staticmethod
  def _inRange_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Matrix_2(_0,_1):
   return (mosek.fusion.Domain.__inRange__3D_3D_3I(_0._getDataAsArray_(),_1._getDataAsArray_(),numpy.array([(_0._dimi),(_0._dimj)], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inRange_Lmosek_4fusion_4Matrix_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_inRange_Lmosek_4fusion_4Matrix_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _inRange_alt_Lmosek_4fusion_4Matrix_2D(_t__0,_t__1):
    return mosek_fusion_Domain._inRange_Lmosek_4fusion_4Matrix_2D(_0,numpy.float64(__1))
  @staticmethod
  def _inRange_Lmosek_4fusion_4Matrix_2D(_0,_1):
   return (mosek.fusion.Domain.__inRange__3D_3D_3I(_0._getDataAsArray_(),numpy.array([_1 for _2 in range(0,((_0._dimi) * (_0._dimj)))], dtype=numpy.dtype(numpy.float64)),numpy.array([(_0._dimi),(_0._dimj)], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inRange_DLmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_inRange_DLmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _inRange_alt_DLmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Domain._inRange_DLmosek_4fusion_4Matrix_2(numpy.float64(__0),_1)
  @staticmethod
  def _inRange_DLmosek_4fusion_4Matrix_2(_0,_1):
   return (mosek.fusion.Domain.__inRange__3D_3D_3I(numpy.array([_0 for _2 in range(0,((_1._dimi) * (_1._dimj)))], dtype=numpy.dtype(numpy.float64)),_1._getDataAsArray_(),numpy.array([(_1._dimi),(_1._dimj)], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inRange__3D_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match__3D__(_1))
  @staticmethod
  def _match_alt_inRange__3D_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match__3D__(_1))
  @staticmethod
  def _inRange_alt__3D_3D(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Domain._inRange__3D_3D(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _inRange__3D_3D(_0,_1):
   return (mosek.fusion.Domain.__inRange__3D_3D_3I(_0,_1,numpy.array([int((_0).shape[0])], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inRange__3DD(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_inRange__3DD(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _inRange_alt__3DD(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=numpy.float64(_t__1)
   _1 = mosek_fusion_Domain._inRange__3DD(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _inRange__3DD(_0,_1):
   return (mosek.fusion.Domain.__inRange__3D_3D_3I(_0,numpy.array([_1 for _2 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.float64)),numpy.array([int((_0).shape[0])], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inRange_D_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match__3D__(_1))
  @staticmethod
  def _match_alt_inRange_D_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match__3D__(_1))
  @staticmethod
  def _inRange_alt_D_3D(_t__0,_t__1):
   _0=numpy.float64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Domain._inRange_D_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _inRange_D_3D(_0,_1):
   return (mosek.fusion.Domain.__inRange__3D_3D_3I(numpy.array([_0 for _2 in range(0,int((_1).shape[0]))], dtype=numpy.dtype(numpy.float64)),_1,numpy.array([int((_1).shape[0])], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inRange_DD(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_inRange_DD(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _inRange_alt_DD(_t__0,_t__1):
    return mosek_fusion_Domain._inRange_DD(numpy.float64(__0),numpy.float64(__1))
  @staticmethod
  def _inRange_DD(_0,_1):
   return (mosek.fusion.Domain.__inRange__3D_3D_3I(numpy.array([_0], dtype=numpy.dtype(numpy.float64)),numpy.array([_1], dtype=numpy.dtype(numpy.float64)),None))
  @staticmethod
  def _match_greaterThan_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _match_alt_greaterThan_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _greaterThan_alt_Lmosek_4fusion_4Matrix_2(_t__0):
    return mosek_fusion_Domain._greaterThan_Lmosek_4fusion_4Matrix_2(_0)
  @staticmethod
  def _greaterThan_Lmosek_4fusion_4Matrix_2(_0):
   return (mosek.fusion.Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2Lmosek_4fusion_4Matrix_2(mosek.fusion.RelationKey.GreaterThan,_0))
  @staticmethod
  def _match_greaterThan__3D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_greaterThan__3D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _greaterThan_alt__3D_3I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._greaterThan__3D_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _greaterThan__3D_3I(_0,_1):
   return (mosek.fusion.Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2_3D(mosek.fusion.RelationKey.GreaterThan,_0))
  @staticmethod
  def _match_greaterThan__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5D__(_0))
  @staticmethod
  def _match_alt_greaterThan__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5D__(_0))
  @staticmethod
  def _greaterThan_alt__3_5D(_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Domain._greaterThan__3_5D(_0)
   return _1
  @staticmethod
  def _greaterThan__3_5D(_0):
   return (mosek.fusion.Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2_3_5D(mosek.fusion.RelationKey.GreaterThan,_0))
  @staticmethod
  def _match_greaterThan__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_greaterThan__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  @staticmethod
  def _greaterThan_alt__3D(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Domain._greaterThan__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _greaterThan__3D(_0):
   return (mosek.fusion.Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2_3D(mosek.fusion.RelationKey.GreaterThan,_0))
  @staticmethod
  def _match_greaterThan_D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_greaterThan_D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _greaterThan_alt_D_3I(_t__0,_t__1):
   _0=numpy.float64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._greaterThan_D_3I(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _greaterThan_D_3I(_0,_1):
   return (mosek.fusion.Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2D_3I(mosek.fusion.RelationKey.GreaterThan,_0,_1))
  @staticmethod
  def _match_greaterThan_DII(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_greaterThan_DII(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _greaterThan_alt_DII(_t__0,_t__1,_t__2):
    return mosek_fusion_Domain._greaterThan_DII(numpy.float64(__0),numpy.int32(__1),numpy.int32(__2))
  @staticmethod
  def _greaterThan_DII(_0,_1,_2):
   return (mosek.fusion.Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2D_3I(mosek.fusion.RelationKey.GreaterThan,_0,numpy.array([_1,_2], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_greaterThan_DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_greaterThan_DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _greaterThan_alt_DI(_t__0,_t__1):
    return mosek_fusion_Domain._greaterThan_DI(numpy.float64(__0),numpy.int32(__1))
  @staticmethod
  def _greaterThan_DI(_0,_1):
   return (mosek.fusion.Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2D_3I(mosek.fusion.RelationKey.GreaterThan,_0,numpy.array([_1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_greaterThan_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_D__(_0))
  @staticmethod
  def _match_alt_greaterThan_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_D__(_0))
  @staticmethod
  def _greaterThan_alt_D(_t__0):
    return mosek_fusion_Domain._greaterThan_D(numpy.float64(__0))
  @staticmethod
  def _greaterThan_D(_0):
   return (mosek.fusion.Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2D(mosek.fusion.RelationKey.GreaterThan,_0))
  @staticmethod
  def _match_lessThan_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _match_alt_lessThan_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _lessThan_alt_Lmosek_4fusion_4Matrix_2(_t__0):
    return mosek_fusion_Domain._lessThan_Lmosek_4fusion_4Matrix_2(_0)
  @staticmethod
  def _lessThan_Lmosek_4fusion_4Matrix_2(_0):
   return (mosek.fusion.Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2Lmosek_4fusion_4Matrix_2(mosek.fusion.RelationKey.LessThan,_0))
  @staticmethod
  def _match_lessThan__3D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_lessThan__3D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _lessThan_alt__3D_3I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._lessThan__3D_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _lessThan__3D_3I(_0,_1):
   return (mosek.fusion.Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2_3D_3I(mosek.fusion.RelationKey.LessThan,_0,_1))
  @staticmethod
  def _match_lessThan__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5D__(_0))
  @staticmethod
  def _match_alt_lessThan__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5D__(_0))
  @staticmethod
  def _lessThan_alt__3_5D(_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Domain._lessThan__3_5D(_0)
   return _1
  @staticmethod
  def _lessThan__3_5D(_0):
   return (mosek.fusion.Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2_3_5D(mosek.fusion.RelationKey.LessThan,_0))
  @staticmethod
  def _match_lessThan__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_lessThan__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  @staticmethod
  def _lessThan_alt__3D(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Domain._lessThan__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _lessThan__3D(_0):
   return (mosek.fusion.Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2_3D(mosek.fusion.RelationKey.LessThan,_0))
  @staticmethod
  def _match_lessThan_D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_lessThan_D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _lessThan_alt_D_3I(_t__0,_t__1):
   _0=numpy.float64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._lessThan_D_3I(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _lessThan_D_3I(_0,_1):
   return (mosek.fusion.Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2D_3I(mosek.fusion.RelationKey.LessThan,_0,_1))
  @staticmethod
  def _match_lessThan_DII(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_lessThan_DII(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _lessThan_alt_DII(_t__0,_t__1,_t__2):
    return mosek_fusion_Domain._lessThan_DII(numpy.float64(__0),numpy.int32(__1),numpy.int32(__2))
  @staticmethod
  def _lessThan_DII(_0,_1,_2):
   return (mosek.fusion.Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2D_3I(mosek.fusion.RelationKey.LessThan,_0,numpy.array([_1,_2], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_lessThan_DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_lessThan_DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _lessThan_alt_DI(_t__0,_t__1):
    return mosek_fusion_Domain._lessThan_DI(numpy.float64(__0),numpy.int32(__1))
  @staticmethod
  def _lessThan_DI(_0,_1):
   return (mosek.fusion.Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2D_3I(mosek.fusion.RelationKey.LessThan,_0,numpy.array([_1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_lessThan_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_D__(_0))
  @staticmethod
  def _match_alt_lessThan_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_D__(_0))
  @staticmethod
  def _lessThan_alt_D(_t__0):
    return mosek_fusion_Domain._lessThan_D(numpy.float64(__0))
  @staticmethod
  def _lessThan_D(_0):
   return (mosek.fusion.Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2D(mosek.fusion.RelationKey.LessThan,_0))
  @staticmethod
  def _match_equalsTo_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _match_alt_equalsTo_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _equalsTo_alt_Lmosek_4fusion_4Matrix_2(_t__0):
    return mosek_fusion_Domain._equalsTo_Lmosek_4fusion_4Matrix_2(_0)
  @staticmethod
  def _equalsTo_Lmosek_4fusion_4Matrix_2(_0):
   return (mosek.fusion.Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2Lmosek_4fusion_4Matrix_2(mosek.fusion.RelationKey.EqualsTo,_0))
  @staticmethod
  def _match_equalsTo__3D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_equalsTo__3D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _equalsTo_alt__3D_3I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._equalsTo__3D_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _equalsTo__3D_3I(_0,_1):
   return (mosek.fusion.Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2_3D_3I(mosek.fusion.RelationKey.EqualsTo,_0,_1))
  @staticmethod
  def _match_equalsTo__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5D__(_0))
  @staticmethod
  def _match_alt_equalsTo__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5D__(_0))
  @staticmethod
  def _equalsTo_alt__3_5D(_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Domain._equalsTo__3_5D(_0)
   return _1
  @staticmethod
  def _equalsTo__3_5D(_0):
   return (mosek.fusion.Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2_3_5D(mosek.fusion.RelationKey.EqualsTo,_0))
  @staticmethod
  def _match_equalsTo__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_equalsTo__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  @staticmethod
  def _equalsTo_alt__3D(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Domain._equalsTo__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _equalsTo__3D(_0):
   return (mosek.fusion.Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2_3D(mosek.fusion.RelationKey.EqualsTo,_0))
  @staticmethod
  def _match_equalsTo_D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_equalsTo_D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _equalsTo_alt_D_3I(_t__0,_t__1):
   _0=numpy.float64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._equalsTo_D_3I(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _equalsTo_D_3I(_0,_1):
   return (mosek.fusion.Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2D_3I(mosek.fusion.RelationKey.EqualsTo,_0,_1))
  @staticmethod
  def _match_equalsTo_DII(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_equalsTo_DII(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _equalsTo_alt_DII(_t__0,_t__1,_t__2):
    return mosek_fusion_Domain._equalsTo_DII(numpy.float64(__0),numpy.int32(__1),numpy.int32(__2))
  @staticmethod
  def _equalsTo_DII(_0,_1,_2):
   return (mosek.fusion.Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2D_3I(mosek.fusion.RelationKey.EqualsTo,_0,numpy.array([_1,_2], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_equalsTo_DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_equalsTo_DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _equalsTo_alt_DI(_t__0,_t__1):
    return mosek_fusion_Domain._equalsTo_DI(numpy.float64(__0),numpy.int32(__1))
  @staticmethod
  def _equalsTo_DI(_0,_1):
   return (mosek.fusion.Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2D_3I(mosek.fusion.RelationKey.EqualsTo,_0,numpy.array([_1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_equalsTo_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_D__(_0))
  @staticmethod
  def _match_alt_equalsTo_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_D__(_0))
  @staticmethod
  def _equalsTo_alt_D(_t__0):
    return mosek_fusion_Domain._equalsTo_D(numpy.float64(__0))
  @staticmethod
  def _equalsTo_D(_0):
   return (mosek.fusion.Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2D(mosek.fusion.RelationKey.EqualsTo,_0))
  @staticmethod
  def _match_unbounded__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_unbounded__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  @staticmethod
  def _unbounded_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._unbounded__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _unbounded__3I(_0):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2_3D_3J_3I(mosek.fusion.RelationKey.IsFree,None,None,numpy.array([_0[_1] for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_unbounded_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_unbounded_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _unbounded_alt_II(_t__0,_t__1):
    return mosek_fusion_Domain._unbounded_II(numpy.int32(__0),numpy.int32(__1))
  @staticmethod
  def _unbounded_II(_0,_1):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2_3D_3J_3I(mosek.fusion.RelationKey.IsFree,None,None,numpy.array([_0,_1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_unbounded_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_unbounded_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _unbounded_alt_I(_t__0):
    return mosek_fusion_Domain._unbounded_I(numpy.int32(__0))
  @staticmethod
  def _unbounded_I(_0):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2_3D_3J_3I(mosek.fusion.RelationKey.IsFree,None,None,numpy.array([_0], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_unbounded_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_unbounded_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _unbounded_alt_():
    return mosek_fusion_Domain._unbounded_()
  @staticmethod
  def _unbounded_():
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2_3D_3J_3I(mosek.fusion.RelationKey.IsFree,None,None,None))
 return Domain
mosek_fusion_Domain=__mk_mosek_fusion_Domain()
del __mk_mosek_fusion_Domain
#BEFORE CLASS
def __mk_mosek_fusion_SymmetricExpr():
 class SymmetricExpr(object):
  __slots__ = ['_SymmetricExpr__xs','_SymmetricExpr__b','_SymmetricExpr__Ms','_SymmetricExpr__n']
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_SymmetricExpr._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_SymmetricExpr._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymmetricExpr.toString()')
  def __repr__(self): return 'mosek.fusion.SymmetricExpr'
  @staticmethod
  def _ctor_I_3Lmosek_4fusion_4SymmetricMatrix_2_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4SymmetricMatrix_2(n,Ms,xs,b):
    o = SymmetricExpr.__new__(SymmetricExpr)
    o._ctor_init_I_3Lmosek_4fusion_4SymmetricMatrix_2_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4SymmetricMatrix_2(n,Ms,xs,b)
    return o
  @staticmethod
  def __match_ctor_I_3Lmosek_4fusion_4SymmetricMatrix_2_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4SymmetricMatrix_2(*args):
    if len(args) != 4: return False
    n,Ms,xs,b, = args
    return (__arg_match_I__(n) and __arg_match__3Lmosek_4fusion_4SymmetricMatrix_2__(Ms) and __arg_match__3Lmosek_4fusion_4Variable_2__(xs) and __arg_match_Lmosek_4fusion_4SymmetricMatrix_2__(b))
  @staticmethod
  def __match_alt_ctor_I_3Lmosek_4fusion_4SymmetricMatrix_2_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4SymmetricMatrix_2(*args):
    if len(args) != 4: return False
    n,Ms,xs,b, = args
    return (__arg_alt_match_I__(n) and __arg_alt_match__3Lmosek_4fusion_4SymmetricMatrix_2__(Ms) and __arg_alt_match__3Lmosek_4fusion_4Variable_2__(xs) and __arg_alt_match_Lmosek_4fusion_4SymmetricMatrix_2__(b))
  def _ctor_alt_init_I_3Lmosek_4fusion_4SymmetricMatrix_2_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4SymmetricMatrix_2(self,n,Ms,xs,b):
    self._ctor_init_I_3Lmosek_4fusion_4SymmetricMatrix_2_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4SymmetricMatrix_2(numpy.int32(n),numpy.array(Ms,dtype=numpy.dtype(object)),numpy.array(xs,dtype=numpy.dtype(object)),b)
  def _ctor_init_I_3Lmosek_4fusion_4SymmetricMatrix_2_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4SymmetricMatrix_2(self,n,Ms,xs,b):
   object.__init__(self)
   (self.__n) = n
   (self.__Ms) = Ms
   (self.__xs) = xs
   (self.__b) = b
  @staticmethod
  def _add_alt_Lmosek_4fusion_4SymmetricExpr_2Lmosek_4fusion_4SymmetricMatrix_2(_t__0,_t__1):
    return mosek_fusion_SymmetricExpr._add_Lmosek_4fusion_4SymmetricExpr_2Lmosek_4fusion_4SymmetricMatrix_2(_0,_1)
  @staticmethod
  def _add_Lmosek_4fusion_4SymmetricExpr_2Lmosek_4fusion_4SymmetricMatrix_2(_0,_1):
   if ((_0.__n)!=_1._getdim_()):
    raise mosek_fusion_DimensionError._ctor_S("Dimension does not match")
   return (mosek_fusion_SymmetricExpr._ctor_I_3Lmosek_4fusion_4SymmetricMatrix_2_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4SymmetricMatrix_2((_0.__n),(_0.__Ms),(_0.__xs),((_0.__b)._add_Lmosek_4fusion_4SymmetricMatrix_2(_1) if (((_0.__b) is not None) ) else _1)))
  @staticmethod
  def _mul_alt_Lmosek_4fusion_4SymmetricExpr_2D(_t__0,_t__1):
    return mosek_fusion_SymmetricExpr._mul_Lmosek_4fusion_4SymmetricExpr_2D(_0,numpy.float64(__1))
  @staticmethod
  def _mul_Lmosek_4fusion_4SymmetricExpr_2D(_0,_1):
   return (mosek_fusion_SymmetricExpr._ctor_I_3Lmosek_4fusion_4SymmetricMatrix_2_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4SymmetricMatrix_2((_0.__n),numpy.array([(_0.__Ms)[_2]._mul_D(_1) for _2 in range(0,int(((_0.__Ms)).shape[0]))], dtype=numpy.dtype(object)),(_0.__xs),((_0.__b)._mul_D(_1) if (((_0.__b) is not None) ) else None)))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4SymmetricExpr_2Lmosek_4fusion_4SymmetricExpr_2(_t__0,_t__1):
    return mosek_fusion_SymmetricExpr._add_Lmosek_4fusion_4SymmetricExpr_2Lmosek_4fusion_4SymmetricExpr_2(_0,_1)
  @staticmethod
  def _add_Lmosek_4fusion_4SymmetricExpr_2Lmosek_4fusion_4SymmetricExpr_2(_0,_1):
   if ((_0.__n)!=(_1.__n)):
    raise mosek_fusion_DimensionError._ctor_S("Mismatching dimensions of operands")
   _2=numpy.zeros(((int(((_0.__Ms)).shape[0]) + int(((_1.__Ms)).shape[0])),), dtype=numpy.dtype(object))
   _3=numpy.zeros(((int(((_0.__xs)).shape[0]) + int(((_1.__xs)).shape[0])),), dtype=numpy.dtype(object))
   _4=int(((_0.__Ms)).shape[0])
   for _5 in range(0,int(((_0.__Ms)).shape[0])):
    _2[_5] = (_0.__Ms)[_5]
   for _6 in range(0,int(((_1.__Ms)).shape[0])):
    _2[(_6 + _4)] = (_1.__Ms)[_6]
   _7=int(((_0.__xs)).shape[0])
   for _8 in range(0,int(((_0.__xs)).shape[0])):
    _3[_8] = (_0.__xs)[_8]
   for _9 in range(0,int(((_1.__xs)).shape[0])):
    _3[(_9 + _7)] = (_1.__xs)[_9]
   _10=(None if ((((_0.__b) is None) and ((_1.__b) is None)) ) else ((_0.__b)._add_Lmosek_4fusion_4SymmetricMatrix_2((_1.__b)) if ((((_0.__b) is not None) and ((_1.__b) is not None)) ) else ((_0.__b) if (((_0.__b) is not None) ) else (_1.__b))))
   return (mosek_fusion_SymmetricExpr._ctor_I_3Lmosek_4fusion_4SymmetricMatrix_2_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4SymmetricMatrix_2((_0.__n),_2,_3,_10))
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("SymmetricExpr( (")._a_I(self.__n)._a_S(",")._a_I(self.__n)._a_S(") )")
   return (_0._toString_())
 return SymmetricExpr
mosek_fusion_SymmetricExpr=__mk_mosek_fusion_SymmetricExpr()
del __mk_mosek_fusion_SymmetricExpr
#BEFORE CLASS
def __mk_mosek_fusion_Expr():
 class Expr(mosek_fusion_Expression,object):
  __slots__ = ['_Expr__varsb','_Expr__inst','_Expr__cof_v','_Expr__x','_Expr__subj','_Expr__ptrb','_Expr__bfix','_Expr__shape_p','_Expr__model']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(*args): # []int64,[]mosek.fusion.Variable,[]int64,[]double,[]double,mosek.fusion.Set,[]int64
      self._ctor_init__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(*args)
    elif self.__match_alt_ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(*args):# []int64,[]mosek.fusion.Variable,[]int64,[]double,[]double,mosek.fusion.Set,[]int64
      self._ctor_alt_init__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.Expr.ctor(array(int64,ndim=1),array(mosek.fusion.Variable,ndim=1),array(int64,ndim=1),array(double,ndim=1),array(double,ndim=1),mosek.fusion.Set,array(int64,ndim=1))')
  @staticmethod
  def sub(*args):
    if False: pass
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.Variable,mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.Variable,mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4Expression_2_3D(*args): # mosek.fusion.Expression,[]double
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4Expression_2_3D(*args): # mosek.fusion.Expression,[]double
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.NDSparseArray,mosek.fusion.Variable
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.NDSparseArray,mosek.fusion.Variable
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Matrix,mosek.fusion.Variable
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Matrix,mosek.fusion.Variable
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Variable,mosek.fusion.Expression
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Variable,mosek.fusion.Expression
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_sub__3DLmosek_4fusion_4Expression_2(*args): # []double,mosek.fusion.Expression
      return mosek_fusion_Expr._sub__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_sub__3DLmosek_4fusion_4Expression_2(*args): # []double,mosek.fusion.Expression
      return mosek_fusion_Expr._sub_alt__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_sub__3DLmosek_4fusion_4Variable_2(*args): # []double,mosek.fusion.Variable
      return mosek_fusion_Expr._sub__3DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_sub__3DLmosek_4fusion_4Variable_2(*args): # []double,mosek.fusion.Variable
      return mosek_fusion_Expr._sub_alt__3DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.NDSparseArray,mosek.fusion.Expression
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.NDSparseArray,mosek.fusion.Expression
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_sub_DLmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression
      return mosek_fusion_Expr._sub_DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_sub_DLmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression
      return mosek_fusion_Expr._sub_alt_DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4Variable_2_3D(*args): # mosek.fusion.Variable,[]double
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4Variable_2_3D(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4Variable_2_3D(*args): # mosek.fusion.Variable,[]double
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4Variable_2_3D(*args)
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4Variable_2D(*args): # mosek.fusion.Variable,double
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4Variable_2D(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4Variable_2D(*args): # mosek.fusion.Variable,double
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4Variable_2D(*args)
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Matrix,mosek.fusion.Expression
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Matrix,mosek.fusion.Expression
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Variable,mosek.fusion.Matrix
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Variable,mosek.fusion.Matrix
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_sub_DLmosek_4fusion_4Variable_2(*args): # double,mosek.fusion.Variable
      return mosek_fusion_Expr._sub_DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_sub_DLmosek_4fusion_4Variable_2(*args): # double,mosek.fusion.Variable
      return mosek_fusion_Expr._sub_alt_DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_sub__3_5DLmosek_4fusion_4Variable_2(*args): # [,]double,mosek.fusion.Variable
      return mosek_fusion_Expr._sub__3_5DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_sub__3_5DLmosek_4fusion_4Variable_2(*args): # [,]double,mosek.fusion.Variable
      return mosek_fusion_Expr._sub_alt__3_5DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_sub__3_5DLmosek_4fusion_4Expression_2(*args): # [,]double,mosek.fusion.Expression
      return mosek_fusion_Expr._sub__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_sub__3_5DLmosek_4fusion_4Expression_2(*args): # [,]double,mosek.fusion.Expression
      return mosek_fusion_Expr._sub_alt__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4Variable_2_3_5D(*args): # mosek.fusion.Variable,[,]double
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4Variable_2_3_5D(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4Variable_2_3_5D(*args): # mosek.fusion.Variable,[,]double
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4Variable_2_3_5D(*args)
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Expression,mosek.fusion.Matrix
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Expression,mosek.fusion.Matrix
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.Expression,mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.Expression,mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4Expression_2_3_5D(*args): # mosek.fusion.Expression,[,]double
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2_3_5D(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4Expression_2_3_5D(*args): # mosek.fusion.Expression,[,]double
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4Expression_2_3_5D(*args)
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,double
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,double
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Expression,mosek.fusion.Variable
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Expression,mosek.fusion.Variable
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    else:
      raise ValueError('Invalid argument list sub('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.sub(mosek.fusion.Variable,mosek.fusion.NDSparseArray)\n\tmosek.fusion.Expr.sub(mosek.fusion.Expression,array(double,ndim=1))\n\tmosek.fusion.Expr.sub(mosek.fusion.NDSparseArray,mosek.fusion.Variable)\n\tmosek.fusion.Expr.sub(mosek.fusion.Matrix,mosek.fusion.Variable)\n\tmosek.fusion.Expr.sub(mosek.fusion.Variable,mosek.fusion.Expression)\n\tmosek.fusion.Expr.sub(array(double,ndim=1),mosek.fusion.Expression)\n\tmosek.fusion.Expr.sub(array(double,ndim=1),mosek.fusion.Variable)\n\tmosek.fusion.Expr.sub(mosek.fusion.NDSparseArray,mosek.fusion.Expression)\n\tmosek.fusion.Expr.sub(double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.sub(mosek.fusion.Variable,array(double,ndim=1))\n\tmosek.fusion.Expr.sub(mosek.fusion.Variable,double)\n\tmosek.fusion.Expr.sub(mosek.fusion.Variable,mosek.fusion.Variable)\n\tmosek.fusion.Expr.sub(mosek.fusion.Matrix,mosek.fusion.Expression)\n\tmosek.fusion.Expr.sub(mosek.fusion.Variable,mosek.fusion.Matrix)\n\tmosek.fusion.Expr.sub(mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.sub(double,mosek.fusion.Variable)\n\tmosek.fusion.Expr.sub(array(double,ndim=2),mosek.fusion.Variable)\n\tmosek.fusion.Expr.sub(array(double,ndim=2),mosek.fusion.Expression)\n\tmosek.fusion.Expr.sub(mosek.fusion.Variable,array(double,ndim=2))\n\tmosek.fusion.Expr.sub(mosek.fusion.Expression,mosek.fusion.Matrix)\n\tmosek.fusion.Expr.sub(mosek.fusion.Expression,mosek.fusion.NDSparseArray)\n\tmosek.fusion.Expr.sub(mosek.fusion.Expression,array(double,ndim=2))\n\tmosek.fusion.Expr.sub(mosek.fusion.Expression,double)\n\tmosek.fusion.Expr.sub(mosek.fusion.Expression,mosek.fusion.Variable)')
  def getModel(self,*args):
    if False: pass
    elif mosek_fusion_Expr._match_getModel_(*args): # 
      return self._getModel_(*args)
    elif mosek_fusion_Expr._match_alt_getModel_(*args): # 
      return self._getModel_alt_(*args)
    else:
      raise ValueError('Invalid argument list getModel('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.getModel()')
  @staticmethod
  def hstack(*args):
    if False: pass
    elif mosek_fusion_Expr._match_hstack__3Lmosek_4fusion_4Expression_2(*args): # []mosek.fusion.Expression
      return mosek_fusion_Expr._hstack__3Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack__3Lmosek_4fusion_4Expression_2(*args): # []mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_alt__3Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_hstack_DLmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_DLmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_alt_DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Variable_2D(*args): # mosek.fusion.Variable,double
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Variable_2D(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Variable_2D(*args): # mosek.fusion.Variable,double
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Variable_2D(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Variable,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Variable,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_hstack_DLmosek_4fusion_4Variable_2(*args): # double,mosek.fusion.Variable
      return mosek_fusion_Expr._hstack_DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_DLmosek_4fusion_4Variable_2(*args): # double,mosek.fusion.Variable
      return mosek_fusion_Expr._hstack_alt_DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,double
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,double
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Expression,mosek.fusion.Variable
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Expression,mosek.fusion.Variable
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_hstack_DLmosek_4fusion_4Variable_2D(*args): # double,mosek.fusion.Variable,double
      return mosek_fusion_Expr._hstack_DLmosek_4fusion_4Variable_2D(*args)
    elif mosek_fusion_Expr._match_alt_hstack_DLmosek_4fusion_4Variable_2D(*args): # double,mosek.fusion.Variable,double
      return mosek_fusion_Expr._hstack_alt_DLmosek_4fusion_4Variable_2D(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Expression_2DD(*args): # mosek.fusion.Expression,double,double
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2DD(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Expression_2DD(*args): # mosek.fusion.Expression,double,double
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Expression_2DD(*args)
    elif mosek_fusion_Expr._match_hstack_DDLmosek_4fusion_4Expression_2(*args): # double,double,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_DDLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_DDLmosek_4fusion_4Expression_2(*args): # double,double,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_alt_DDLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2D(*args): # mosek.fusion.Expression,mosek.fusion.Variable,double
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2D(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2D(*args): # mosek.fusion.Expression,mosek.fusion.Variable,double
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2D(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Variable
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Variable
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,double,mosek.fusion.Variable
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,double,mosek.fusion.Variable
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Variable_2(*args): # mosek.fusion.Expression,double,mosek.fusion.Variable
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Variable_2(*args): # mosek.fusion.Expression,double,mosek.fusion.Variable
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Variable,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Variable,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_hstack_DLmosek_4fusion_4Expression_2D(*args): # double,mosek.fusion.Expression,double
      return mosek_fusion_Expr._hstack_DLmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_hstack_DLmosek_4fusion_4Expression_2D(*args): # double,mosek.fusion.Expression,double
      return mosek_fusion_Expr._hstack_alt_DLmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_hstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # double,mosek.fusion.Expression,mosek.fusion.Variable
      return mosek_fusion_Expr._hstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # double,mosek.fusion.Expression,mosek.fusion.Variable
      return mosek_fusion_Expr._hstack_alt_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_hstack_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Variable,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Variable,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_alt_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_hstack_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # double,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Expr._hstack_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # double,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Expr._hstack_alt_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Expression,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Expression,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_hstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_alt_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Variable,mosek.fusion.Expression,double
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Variable,mosek.fusion.Expression,double
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2D(*args): # mosek.fusion.Variable,mosek.fusion.Variable,double
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2D(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2D(*args): # mosek.fusion.Variable,mosek.fusion.Variable,double
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2D(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,double,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,double,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Expression_2(*args): # mosek.fusion.Variable,double,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Expression_2(*args): # mosek.fusion.Variable,double,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Variable,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Variable,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Expression,mosek.fusion.Variable
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Expression,mosek.fusion.Variable
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Variable_2DD(*args): # mosek.fusion.Variable,double,double
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Variable_2DD(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Variable_2DD(*args): # mosek.fusion.Variable,double,double
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Variable_2DD(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,mosek.fusion.Expression,double
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,mosek.fusion.Expression,double
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_hstack_DDLmosek_4fusion_4Variable_2(*args): # double,double,mosek.fusion.Variable
      return mosek_fusion_Expr._hstack_DDLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_DDLmosek_4fusion_4Variable_2(*args): # double,double,mosek.fusion.Variable
      return mosek_fusion_Expr._hstack_alt_DDLmosek_4fusion_4Variable_2(*args)
    else:
      raise ValueError('Invalid argument list hstack('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.hstack(array(mosek.fusion.Expression,ndim=1))\n\tmosek.fusion.Expr.hstack(double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Variable,double)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Variable,mosek.fusion.Variable)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Variable,mosek.fusion.Expression)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.hstack(double,mosek.fusion.Variable)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Expression,double)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Expression,mosek.fusion.Variable)\n\tmosek.fusion.Expr.hstack(double,mosek.fusion.Variable,double)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Expression,double,double)\n\tmosek.fusion.Expr.hstack(double,double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Expression,mosek.fusion.Variable,double)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Variable)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Variable,double,mosek.fusion.Variable)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Expression,double,mosek.fusion.Variable)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Expression,mosek.fusion.Variable,mosek.fusion.Expression)\n\tmosek.fusion.Expr.hstack(double,mosek.fusion.Expression,double)\n\tmosek.fusion.Expr.hstack(double,mosek.fusion.Expression,mosek.fusion.Variable)\n\tmosek.fusion.Expr.hstack(double,mosek.fusion.Variable,mosek.fusion.Expression)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.hstack(double,mosek.fusion.Variable,mosek.fusion.Variable)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Expression,mosek.fusion.Variable,mosek.fusion.Variable)\n\tmosek.fusion.Expr.hstack(double,mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Expression)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Variable,mosek.fusion.Expression,double)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Variable,mosek.fusion.Variable,double)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Expression,double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Variable,double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Variable,mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Variable,mosek.fusion.Expression,mosek.fusion.Variable)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Variable,double,double)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Expression,mosek.fusion.Expression,double)\n\tmosek.fusion.Expr.hstack(double,double,mosek.fusion.Variable)')
  @staticmethod
  def dot(*args):
    if False: pass
    elif mosek_fusion_Expr._match_dot_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.Variable,mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._dot_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_alt_dot_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.Variable,mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._dot_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_dot_Lmosek_4fusion_4Expression_2_3D(*args): # mosek.fusion.Expression,[]double
      return mosek_fusion_Expr._dot_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_alt_dot_Lmosek_4fusion_4Expression_2_3D(*args): # mosek.fusion.Expression,[]double
      return mosek_fusion_Expr._dot_alt_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_dot_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.NDSparseArray,mosek.fusion.Variable
      return mosek_fusion_Expr._dot_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_dot_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.NDSparseArray,mosek.fusion.Variable
      return mosek_fusion_Expr._dot_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_dot_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Matrix,mosek.fusion.Variable
      return mosek_fusion_Expr._dot_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_dot_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Matrix,mosek.fusion.Variable
      return mosek_fusion_Expr._dot_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_dot__3DLmosek_4fusion_4Expression_2(*args): # []double,mosek.fusion.Expression
      return mosek_fusion_Expr._dot__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_dot__3DLmosek_4fusion_4Expression_2(*args): # []double,mosek.fusion.Expression
      return mosek_fusion_Expr._dot_alt__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_dot__3DLmosek_4fusion_4Variable_2(*args): # []double,mosek.fusion.Variable
      return mosek_fusion_Expr._dot__3DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_dot__3DLmosek_4fusion_4Variable_2(*args): # []double,mosek.fusion.Variable
      return mosek_fusion_Expr._dot_alt__3DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_dot_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.NDSparseArray,mosek.fusion.Expression
      return mosek_fusion_Expr._dot_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_dot_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.NDSparseArray,mosek.fusion.Expression
      return mosek_fusion_Expr._dot_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_dot_Lmosek_4fusion_4Variable_2_3D(*args): # mosek.fusion.Variable,[]double
      return mosek_fusion_Expr._dot_Lmosek_4fusion_4Variable_2_3D(*args)
    elif mosek_fusion_Expr._match_alt_dot_Lmosek_4fusion_4Variable_2_3D(*args): # mosek.fusion.Variable,[]double
      return mosek_fusion_Expr._dot_alt_Lmosek_4fusion_4Variable_2_3D(*args)
    elif mosek_fusion_Expr._match_dot_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Matrix,mosek.fusion.Expression
      return mosek_fusion_Expr._dot_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_dot_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Matrix,mosek.fusion.Expression
      return mosek_fusion_Expr._dot_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_dot_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Variable,mosek.fusion.Matrix
      return mosek_fusion_Expr._dot_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_dot_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Variable,mosek.fusion.Matrix
      return mosek_fusion_Expr._dot_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_dot__3_5DLmosek_4fusion_4Variable_2(*args): # [,]double,mosek.fusion.Variable
      return mosek_fusion_Expr._dot__3_5DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_dot__3_5DLmosek_4fusion_4Variable_2(*args): # [,]double,mosek.fusion.Variable
      return mosek_fusion_Expr._dot_alt__3_5DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_dot__3_5DLmosek_4fusion_4Expression_2(*args): # [,]double,mosek.fusion.Expression
      return mosek_fusion_Expr._dot__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_dot__3_5DLmosek_4fusion_4Expression_2(*args): # [,]double,mosek.fusion.Expression
      return mosek_fusion_Expr._dot_alt__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_dot_Lmosek_4fusion_4Variable_2_3_5D(*args): # mosek.fusion.Variable,[,]double
      return mosek_fusion_Expr._dot_Lmosek_4fusion_4Variable_2_3_5D(*args)
    elif mosek_fusion_Expr._match_alt_dot_Lmosek_4fusion_4Variable_2_3_5D(*args): # mosek.fusion.Variable,[,]double
      return mosek_fusion_Expr._dot_alt_Lmosek_4fusion_4Variable_2_3_5D(*args)
    elif mosek_fusion_Expr._match_dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Expression,mosek.fusion.Matrix
      return mosek_fusion_Expr._dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Expression,mosek.fusion.Matrix
      return mosek_fusion_Expr._dot_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.Expression,mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_alt_dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.Expression,mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._dot_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_dot_Lmosek_4fusion_4Expression_2_3_5D(*args): # mosek.fusion.Expression,[,]double
      return mosek_fusion_Expr._dot_Lmosek_4fusion_4Expression_2_3_5D(*args)
    elif mosek_fusion_Expr._match_alt_dot_Lmosek_4fusion_4Expression_2_3_5D(*args): # mosek.fusion.Expression,[,]double
      return mosek_fusion_Expr._dot_alt_Lmosek_4fusion_4Expression_2_3_5D(*args)
    else:
      raise ValueError('Invalid argument list dot('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.dot(mosek.fusion.Variable,mosek.fusion.NDSparseArray)\n\tmosek.fusion.Expr.dot(mosek.fusion.Expression,array(double,ndim=1))\n\tmosek.fusion.Expr.dot(mosek.fusion.NDSparseArray,mosek.fusion.Variable)\n\tmosek.fusion.Expr.dot(mosek.fusion.Matrix,mosek.fusion.Variable)\n\tmosek.fusion.Expr.dot(array(double,ndim=1),mosek.fusion.Expression)\n\tmosek.fusion.Expr.dot(array(double,ndim=1),mosek.fusion.Variable)\n\tmosek.fusion.Expr.dot(mosek.fusion.NDSparseArray,mosek.fusion.Expression)\n\tmosek.fusion.Expr.dot(mosek.fusion.Variable,array(double,ndim=1))\n\tmosek.fusion.Expr.dot(mosek.fusion.Matrix,mosek.fusion.Expression)\n\tmosek.fusion.Expr.dot(mosek.fusion.Variable,mosek.fusion.Matrix)\n\tmosek.fusion.Expr.dot(array(double,ndim=2),mosek.fusion.Variable)\n\tmosek.fusion.Expr.dot(array(double,ndim=2),mosek.fusion.Expression)\n\tmosek.fusion.Expr.dot(mosek.fusion.Variable,array(double,ndim=2))\n\tmosek.fusion.Expr.dot(mosek.fusion.Expression,mosek.fusion.Matrix)\n\tmosek.fusion.Expr.dot(mosek.fusion.Expression,mosek.fusion.NDSparseArray)\n\tmosek.fusion.Expr.dot(mosek.fusion.Expression,array(double,ndim=2))')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_Expr._match_eval_(*args): # 
      return self._eval_(*args)
    elif mosek_fusion_Expr._match_alt_eval_(*args): # 
      return self._eval_alt_(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.eval()')
  @staticmethod
  def repeat(*args):
    if False: pass
    elif mosek_fusion_Expr._match_repeat_Lmosek_4fusion_4Expression_2II(*args): # mosek.fusion.Expression,int32,int32
      return mosek_fusion_Expr._repeat_Lmosek_4fusion_4Expression_2II(*args)
    elif mosek_fusion_Expr._match_alt_repeat_Lmosek_4fusion_4Expression_2II(*args): # mosek.fusion.Expression,int32,int32
      return mosek_fusion_Expr._repeat_alt_Lmosek_4fusion_4Expression_2II(*args)
    else:
      raise ValueError('Invalid argument list repeat('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.repeat(mosek.fusion.Expression,int32,int32)')
  def numNonzeros(self,*args):
    if False: pass
    elif mosek_fusion_Expr._match_numNonzeros_(*args): # 
      return self._numNonzeros_(*args)
    elif mosek_fusion_Expr._match_alt_numNonzeros_(*args): # 
      return self._numNonzeros_alt_(*args)
    else:
      raise ValueError('Invalid argument list numNonzeros('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.numNonzeros()')
  def pick(self,*args):
    if False: pass
    elif mosek_fusion_Expr._match_pick__3I(*args): # []int32
      return self._pick__3I(*args)
    elif mosek_fusion_Expr._match_alt_pick__3I(*args): # []int32
      return self._pick_alt__3I(*args)
    elif mosek_fusion_Expr._match_pick__3_5I(*args): # [,]int32
      return self._pick__3_5I(*args)
    elif mosek_fusion_Expr._match_alt_pick__3_5I(*args): # [,]int32
      return self._pick_alt__3_5I(*args)
    else:
      raise ValueError('Invalid argument list pick('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.pick(array(int32,ndim=1))\n\tmosek.fusion.Expr.pick(array(int32,ndim=2))')
  @staticmethod
  def stack(*args):
    if False: pass
    elif mosek_fusion_Expr._match_stack__3_3Lmosek_4fusion_4Expression_2(*args): # [][]mosek.fusion.Expression
      return mosek_fusion_Expr._stack__3_3Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_stack__3_3Lmosek_4fusion_4Expression_2(*args): # [][]mosek.fusion.Expression
      return mosek_fusion_Expr._stack_alt__3_3Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_stack_I_3Lmosek_4fusion_4Expression_2(*args): # int32,[]mosek.fusion.Expression
      return mosek_fusion_Expr._stack_I_3Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_I_3Lmosek_4fusion_4Expression_2(*args): # int32,[]mosek.fusion.Expression
      return mosek_fusion_Expr._stack_alt_I_3Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_stack_IDLmosek_4fusion_4Variable_2(*args): # int32,double,mosek.fusion.Variable
      return mosek_fusion_Expr._stack_IDLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_IDLmosek_4fusion_4Variable_2(*args): # int32,double,mosek.fusion.Variable
      return mosek_fusion_Expr._stack_alt_IDLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Expression_2D(*args): # int32,mosek.fusion.Expression,double
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Expression_2D(*args): # int32,mosek.fusion.Expression,double
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args): # int32,mosek.fusion.Variable,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args): # int32,mosek.fusion.Variable,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # int32,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # int32,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # int32,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # int32,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_stack_IDLmosek_4fusion_4Expression_2(*args): # int32,double,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_IDLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_IDLmosek_4fusion_4Expression_2(*args): # int32,double,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_alt_IDLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # int32,mosek.fusion.Expression,mosek.fusion.Variable
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # int32,mosek.fusion.Expression,mosek.fusion.Variable
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Variable_2D(*args): # int32,mosek.fusion.Variable,double
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Variable_2D(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Variable_2D(*args): # int32,mosek.fusion.Variable,double
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Variable_2D(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args): # int32,mosek.fusion.Expression,mosek.fusion.Variable,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args): # int32,mosek.fusion.Expression,mosek.fusion.Variable,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_stack_IDLmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # int32,double,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Expr._stack_IDLmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_IDLmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # int32,double,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Expr._stack_alt_IDLmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_stack_IDDLmosek_4fusion_4Expression_2(*args): # int32,double,double,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_IDDLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_IDDLmosek_4fusion_4Expression_2(*args): # int32,double,double,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_alt_IDDLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # int32,mosek.fusion.Variable,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # int32,mosek.fusion.Variable,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_stack_IDLmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args): # int32,double,mosek.fusion.Variable,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_IDLmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_IDLmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args): # int32,double,mosek.fusion.Variable,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_alt_IDLmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args): # int32,mosek.fusion.Expression,mosek.fusion.Expression,double
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args): # int32,mosek.fusion.Expression,mosek.fusion.Expression,double
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # int32,mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # int32,mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_stack_IDLmosek_4fusion_4Expression_2D(*args): # int32,double,mosek.fusion.Expression,double
      return mosek_fusion_Expr._stack_IDLmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_stack_IDLmosek_4fusion_4Expression_2D(*args): # int32,double,mosek.fusion.Expression,double
      return mosek_fusion_Expr._stack_alt_IDLmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2D(*args): # int32,mosek.fusion.Expression,mosek.fusion.Variable,double
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2D(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2D(*args): # int32,mosek.fusion.Expression,mosek.fusion.Variable,double
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2D(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Variable_2DLmosek_4fusion_4Variable_2(*args): # int32,mosek.fusion.Variable,double,mosek.fusion.Variable
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Variable_2DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Variable_2DLmosek_4fusion_4Variable_2(*args): # int32,mosek.fusion.Variable,double,mosek.fusion.Variable
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Variable_2DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_stack_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # int32,double,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # int32,double,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_alt_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Expression_2DD(*args): # int32,mosek.fusion.Expression,double,double
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2DD(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Expression_2DD(*args): # int32,mosek.fusion.Expression,double,double
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Expression_2DD(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Variable_2DD(*args): # int32,mosek.fusion.Variable,double,double
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Variable_2DD(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Variable_2DD(*args): # int32,mosek.fusion.Variable,double,double
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Variable_2DD(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args): # int32,mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args): # int32,mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_stack_IDDLmosek_4fusion_4Variable_2(*args): # int32,double,double,mosek.fusion.Variable
      return mosek_fusion_Expr._stack_IDDLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_IDDLmosek_4fusion_4Variable_2(*args): # int32,double,double,mosek.fusion.Variable
      return mosek_fusion_Expr._stack_alt_IDDLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_stack_IDLmosek_4fusion_4Variable_2D(*args): # int32,double,mosek.fusion.Variable,double
      return mosek_fusion_Expr._stack_IDLmosek_4fusion_4Variable_2D(*args)
    elif mosek_fusion_Expr._match_alt_stack_IDLmosek_4fusion_4Variable_2D(*args): # int32,double,mosek.fusion.Variable,double
      return mosek_fusion_Expr._stack_alt_IDLmosek_4fusion_4Variable_2D(*args)
    elif mosek_fusion_Expr._match_stack_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # int32,double,mosek.fusion.Expression,mosek.fusion.Variable
      return mosek_fusion_Expr._stack_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # int32,double,mosek.fusion.Expression,mosek.fusion.Variable
      return mosek_fusion_Expr._stack_alt_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args): # int32,mosek.fusion.Expression,double,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args): # int32,mosek.fusion.Expression,double,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Variable_2DLmosek_4fusion_4Expression_2(*args): # int32,mosek.fusion.Variable,double,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Variable_2DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Variable_2DLmosek_4fusion_4Expression_2(*args): # int32,mosek.fusion.Variable,double,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Variable_2DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # int32,mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # int32,mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Variable_2(*args): # int32,mosek.fusion.Expression,double,mosek.fusion.Variable
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Variable_2(*args): # int32,mosek.fusion.Expression,double,mosek.fusion.Variable
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # int32,mosek.fusion.Variable,mosek.fusion.Expression,mosek.fusion.Variable
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # int32,mosek.fusion.Variable,mosek.fusion.Expression,mosek.fusion.Variable
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # int32,mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Variable
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # int32,mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Variable
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2D(*args): # int32,mosek.fusion.Variable,mosek.fusion.Variable,double
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2D(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2D(*args): # int32,mosek.fusion.Variable,mosek.fusion.Variable,double
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2D(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # int32,mosek.fusion.Expression,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # int32,mosek.fusion.Expression,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2D(*args): # int32,mosek.fusion.Variable,mosek.fusion.Expression,double
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2D(*args): # int32,mosek.fusion.Variable,mosek.fusion.Expression,double
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2D(*args)
    else:
      raise ValueError('Invalid argument list stack('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.stack(array(array(mosek.fusion.Expression,ndim=1),ndim=1))\n\tmosek.fusion.Expr.stack(int32,array(mosek.fusion.Expression,ndim=1))\n\tmosek.fusion.Expr.stack(int32,double,mosek.fusion.Variable)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Expression,double)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Variable,mosek.fusion.Expression)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Variable,mosek.fusion.Variable)\n\tmosek.fusion.Expr.stack(int32,double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Expression,mosek.fusion.Variable)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Variable,double)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Expression,mosek.fusion.Variable,mosek.fusion.Expression)\n\tmosek.fusion.Expr.stack(int32,double,mosek.fusion.Variable,mosek.fusion.Variable)\n\tmosek.fusion.Expr.stack(int32,double,double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Variable,mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.stack(int32,double,mosek.fusion.Variable,mosek.fusion.Expression)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Expression,mosek.fusion.Expression,double)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)\n\tmosek.fusion.Expr.stack(int32,double,mosek.fusion.Expression,double)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Expression,mosek.fusion.Variable,double)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Variable,double,mosek.fusion.Variable)\n\tmosek.fusion.Expr.stack(int32,double,mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Expression,double,double)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Variable,double,double)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Expression)\n\tmosek.fusion.Expr.stack(int32,double,double,mosek.fusion.Variable)\n\tmosek.fusion.Expr.stack(int32,double,mosek.fusion.Variable,double)\n\tmosek.fusion.Expr.stack(int32,double,mosek.fusion.Expression,mosek.fusion.Variable)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Expression,double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Variable,double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Expression,double,mosek.fusion.Variable)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Variable,mosek.fusion.Expression,mosek.fusion.Variable)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Variable)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Variable,mosek.fusion.Variable,double)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Expression,mosek.fusion.Variable,mosek.fusion.Variable)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Variable,mosek.fusion.Expression,double)')
  def transpose(self,*args):
    if False: pass
    elif mosek_fusion_Expr._match_transpose_(*args): # 
      return self._transpose_(*args)
    elif mosek_fusion_Expr._match_alt_transpose_(*args): # 
      return self._transpose_alt_(*args)
    else:
      raise ValueError('Invalid argument list transpose('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.transpose()')
  def getShape(self,*args):
    if False: pass
    elif mosek_fusion_Expr._match_getShape_(*args): # 
      return self._getShape_(*args)
    elif mosek_fusion_Expr._match_alt_getShape_(*args): # 
      return self._getShape_alt_(*args)
    else:
      raise ValueError('Invalid argument list getShape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.getShape()')
  @staticmethod
  def vstack(*args):
    if False: pass
    elif mosek_fusion_Expr._match_vstack__3Lmosek_4fusion_4Expression_2(*args): # []mosek.fusion.Expression
      return mosek_fusion_Expr._vstack__3Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack__3Lmosek_4fusion_4Expression_2(*args): # []mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_alt__3Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_vstack_DLmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_DLmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_alt_DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Variable_2D(*args): # mosek.fusion.Variable,double
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Variable_2D(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Variable_2D(*args): # mosek.fusion.Variable,double
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Variable_2D(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Variable,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Variable,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_vstack_DLmosek_4fusion_4Variable_2(*args): # double,mosek.fusion.Variable
      return mosek_fusion_Expr._vstack_DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_DLmosek_4fusion_4Variable_2(*args): # double,mosek.fusion.Variable
      return mosek_fusion_Expr._vstack_alt_DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,double
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,double
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Expression,mosek.fusion.Variable
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Expression,mosek.fusion.Variable
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_vstack_DLmosek_4fusion_4Variable_2D(*args): # double,mosek.fusion.Variable,double
      return mosek_fusion_Expr._vstack_DLmosek_4fusion_4Variable_2D(*args)
    elif mosek_fusion_Expr._match_alt_vstack_DLmosek_4fusion_4Variable_2D(*args): # double,mosek.fusion.Variable,double
      return mosek_fusion_Expr._vstack_alt_DLmosek_4fusion_4Variable_2D(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Expression_2DD(*args): # mosek.fusion.Expression,double,double
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2DD(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Expression_2DD(*args): # mosek.fusion.Expression,double,double
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Expression_2DD(*args)
    elif mosek_fusion_Expr._match_vstack_DDLmosek_4fusion_4Expression_2(*args): # double,double,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_DDLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_DDLmosek_4fusion_4Expression_2(*args): # double,double,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_alt_DDLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2D(*args): # mosek.fusion.Expression,mosek.fusion.Variable,double
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2D(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2D(*args): # mosek.fusion.Expression,mosek.fusion.Variable,double
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2D(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Variable
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Variable
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,double,mosek.fusion.Variable
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,double,mosek.fusion.Variable
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Variable_2(*args): # mosek.fusion.Expression,double,mosek.fusion.Variable
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Variable_2(*args): # mosek.fusion.Expression,double,mosek.fusion.Variable
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Variable,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Variable,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_vstack_DLmosek_4fusion_4Expression_2D(*args): # double,mosek.fusion.Expression,double
      return mosek_fusion_Expr._vstack_DLmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_vstack_DLmosek_4fusion_4Expression_2D(*args): # double,mosek.fusion.Expression,double
      return mosek_fusion_Expr._vstack_alt_DLmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_vstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # double,mosek.fusion.Expression,mosek.fusion.Variable
      return mosek_fusion_Expr._vstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # double,mosek.fusion.Expression,mosek.fusion.Variable
      return mosek_fusion_Expr._vstack_alt_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_vstack_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Variable,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Variable,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_alt_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_vstack_DDD(*args): # double,double,double
      return mosek_fusion_Expr._vstack_DDD(*args)
    elif mosek_fusion_Expr._match_alt_vstack_DDD(*args): # double,double,double
      return mosek_fusion_Expr._vstack_alt_DDD(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_vstack_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # double,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Expr._vstack_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # double,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Expr._vstack_alt_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Expression,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Expression,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_vstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_alt_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Variable,mosek.fusion.Expression,double
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Variable,mosek.fusion.Expression,double
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2D(*args): # mosek.fusion.Variable,mosek.fusion.Variable,double
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2D(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2D(*args): # mosek.fusion.Variable,mosek.fusion.Variable,double
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2D(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,double,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,double,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Expression_2(*args): # mosek.fusion.Variable,double,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Expression_2(*args): # mosek.fusion.Variable,double,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Variable,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Variable,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Expression,mosek.fusion.Variable
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Expression,mosek.fusion.Variable
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Variable_2DD(*args): # mosek.fusion.Variable,double,double
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Variable_2DD(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Variable_2DD(*args): # mosek.fusion.Variable,double,double
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Variable_2DD(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,mosek.fusion.Expression,double
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,mosek.fusion.Expression,double
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_vstack_DDLmosek_4fusion_4Variable_2(*args): # double,double,mosek.fusion.Variable
      return mosek_fusion_Expr._vstack_DDLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_DDLmosek_4fusion_4Variable_2(*args): # double,double,mosek.fusion.Variable
      return mosek_fusion_Expr._vstack_alt_DDLmosek_4fusion_4Variable_2(*args)
    else:
      raise ValueError('Invalid argument list vstack('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.vstack(array(mosek.fusion.Expression,ndim=1))\n\tmosek.fusion.Expr.vstack(double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Variable,double)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Variable,mosek.fusion.Variable)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Variable,mosek.fusion.Expression)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.vstack(double,mosek.fusion.Variable)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Expression,double)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Expression,mosek.fusion.Variable)\n\tmosek.fusion.Expr.vstack(double,mosek.fusion.Variable,double)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Expression,double,double)\n\tmosek.fusion.Expr.vstack(double,double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Expression,mosek.fusion.Variable,double)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Variable)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Variable,double,mosek.fusion.Variable)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Expression,double,mosek.fusion.Variable)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Expression,mosek.fusion.Variable,mosek.fusion.Expression)\n\tmosek.fusion.Expr.vstack(double,mosek.fusion.Expression,double)\n\tmosek.fusion.Expr.vstack(double,mosek.fusion.Expression,mosek.fusion.Variable)\n\tmosek.fusion.Expr.vstack(double,mosek.fusion.Variable,mosek.fusion.Expression)\n\tmosek.fusion.Expr.vstack(double,double,double)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.vstack(double,mosek.fusion.Variable,mosek.fusion.Variable)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Expression,mosek.fusion.Variable,mosek.fusion.Variable)\n\tmosek.fusion.Expr.vstack(double,mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Expression)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Variable,mosek.fusion.Expression,double)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Variable,mosek.fusion.Variable,double)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Expression,double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Variable,double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Variable,mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Variable,mosek.fusion.Expression,mosek.fusion.Variable)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Variable,double,double)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Expression,mosek.fusion.Expression,double)\n\tmosek.fusion.Expr.vstack(double,double,mosek.fusion.Variable)')
  @staticmethod
  def sum(*args):
    if False: pass
    elif mosek_fusion_Expr._match_sum_Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable
      return mosek_fusion_Expr._sum_Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_sum_Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable
      return mosek_fusion_Expr._sum_alt_Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_sum_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      return mosek_fusion_Expr._sum_Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_sum_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      return mosek_fusion_Expr._sum_alt_Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_sum_Lmosek_4fusion_4Expression_2I(*args): # mosek.fusion.Expression,int32
      return mosek_fusion_Expr._sum_Lmosek_4fusion_4Expression_2I(*args)
    elif mosek_fusion_Expr._match_alt_sum_Lmosek_4fusion_4Expression_2I(*args): # mosek.fusion.Expression,int32
      return mosek_fusion_Expr._sum_alt_Lmosek_4fusion_4Expression_2I(*args)
    elif mosek_fusion_Expr._match_sum_Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,int32
      return mosek_fusion_Expr._sum_Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Expr._match_alt_sum_Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,int32
      return mosek_fusion_Expr._sum_alt_Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Expr._match_sum_Lmosek_4fusion_4Variable_2II(*args): # mosek.fusion.Variable,int32,int32
      return mosek_fusion_Expr._sum_Lmosek_4fusion_4Variable_2II(*args)
    elif mosek_fusion_Expr._match_alt_sum_Lmosek_4fusion_4Variable_2II(*args): # mosek.fusion.Variable,int32,int32
      return mosek_fusion_Expr._sum_alt_Lmosek_4fusion_4Variable_2II(*args)
    elif mosek_fusion_Expr._match_sum_Lmosek_4fusion_4Expression_2II(*args): # mosek.fusion.Expression,int32,int32
      return mosek_fusion_Expr._sum_Lmosek_4fusion_4Expression_2II(*args)
    elif mosek_fusion_Expr._match_alt_sum_Lmosek_4fusion_4Expression_2II(*args): # mosek.fusion.Expression,int32,int32
      return mosek_fusion_Expr._sum_alt_Lmosek_4fusion_4Expression_2II(*args)
    else:
      raise ValueError('Invalid argument list sum('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.sum(mosek.fusion.Variable)\n\tmosek.fusion.Expr.sum(mosek.fusion.Expression)\n\tmosek.fusion.Expr.sum(mosek.fusion.Expression,int32)\n\tmosek.fusion.Expr.sum(mosek.fusion.Variable,int32)\n\tmosek.fusion.Expr.sum(mosek.fusion.Variable,int32,int32)\n\tmosek.fusion.Expr.sum(mosek.fusion.Expression,int32,int32)')
  @staticmethod
  def reshape(*args):
    if False: pass
    elif mosek_fusion_Expr._match_reshape_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Set_2(*args): # mosek.fusion.Expression,mosek.fusion.Set
      return mosek_fusion_Expr._reshape_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Set_2(*args)
    elif mosek_fusion_Expr._match_alt_reshape_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Set_2(*args): # mosek.fusion.Expression,mosek.fusion.Set
      return mosek_fusion_Expr._reshape_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Set_2(*args)
    elif mosek_fusion_Expr._match_reshape_Lmosek_4fusion_4Expression_2I(*args): # mosek.fusion.Expression,int32
      return mosek_fusion_Expr._reshape_Lmosek_4fusion_4Expression_2I(*args)
    elif mosek_fusion_Expr._match_alt_reshape_Lmosek_4fusion_4Expression_2I(*args): # mosek.fusion.Expression,int32
      return mosek_fusion_Expr._reshape_alt_Lmosek_4fusion_4Expression_2I(*args)
    elif mosek_fusion_Expr._match_reshape_Lmosek_4fusion_4Expression_2II(*args): # mosek.fusion.Expression,int32,int32
      return mosek_fusion_Expr._reshape_Lmosek_4fusion_4Expression_2II(*args)
    elif mosek_fusion_Expr._match_alt_reshape_Lmosek_4fusion_4Expression_2II(*args): # mosek.fusion.Expression,int32,int32
      return mosek_fusion_Expr._reshape_alt_Lmosek_4fusion_4Expression_2II(*args)
    else:
      raise ValueError('Invalid argument list reshape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.reshape(mosek.fusion.Expression,mosek.fusion.Set)\n\tmosek.fusion.Expr.reshape(mosek.fusion.Expression,int32)\n\tmosek.fusion.Expr.reshape(mosek.fusion.Expression,int32,int32)')
  @staticmethod
  def zeros(*args):
    if False: pass
    elif mosek_fusion_Expr._match_zeros_I(*args): # int32
      return mosek_fusion_Expr._zeros_I(*args)
    elif mosek_fusion_Expr._match_alt_zeros_I(*args): # int32
      return mosek_fusion_Expr._zeros_alt_I(*args)
    else:
      raise ValueError('Invalid argument list zeros('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.zeros(int32)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_Expr._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_Expr._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.toString()')
  def index(self,*args):
    if False: pass
    elif mosek_fusion_Expr._match_index_I(*args): # int32
      return self._index_I(*args)
    elif mosek_fusion_Expr._match_alt_index_I(*args): # int32
      return self._index_alt_I(*args)
    elif mosek_fusion_Expr._match_index__3I(*args): # []int32
      return self._index__3I(*args)
    elif mosek_fusion_Expr._match_alt_index__3I(*args): # []int32
      return self._index_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list index('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.index(int32)\n\tmosek.fusion.Expr.index(array(int32,ndim=1))')
  def shape(self,*args):
    if False: pass
    elif mosek_fusion_Expr._match_shape_(*args): # 
      return self._shape_(*args)
    elif mosek_fusion_Expr._match_alt_shape_(*args): # 
      return self._shape_alt_(*args)
    else:
      raise ValueError('Invalid argument list shape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.shape()')
  @staticmethod
  def constTerm(*args):
    if False: pass
    elif mosek_fusion_Expr._match_constTerm__3D(*args): # []double
      return mosek_fusion_Expr._constTerm__3D(*args)
    elif mosek_fusion_Expr._match_alt_constTerm__3D(*args): # []double
      return mosek_fusion_Expr._constTerm_alt__3D(*args)
    elif mosek_fusion_Expr._match_constTerm_Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._constTerm_Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_alt_constTerm_Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._constTerm_alt_Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_constTerm_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_Expr._constTerm_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_constTerm_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_Expr._constTerm_alt_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_constTerm__3_5D(*args): # [,]double
      return mosek_fusion_Expr._constTerm__3_5D(*args)
    elif mosek_fusion_Expr._match_alt_constTerm__3_5D(*args): # [,]double
      return mosek_fusion_Expr._constTerm_alt__3_5D(*args)
    elif mosek_fusion_Expr._match_constTerm_D(*args): # double
      return mosek_fusion_Expr._constTerm_D(*args)
    elif mosek_fusion_Expr._match_alt_constTerm_D(*args): # double
      return mosek_fusion_Expr._constTerm_alt_D(*args)
    elif mosek_fusion_Expr._match_constTerm_ID(*args): # int32,double
      return mosek_fusion_Expr._constTerm_ID(*args)
    elif mosek_fusion_Expr._match_alt_constTerm_ID(*args): # int32,double
      return mosek_fusion_Expr._constTerm_alt_ID(*args)
    elif mosek_fusion_Expr._match_constTerm_Lmosek_4fusion_4Set_2D(*args): # mosek.fusion.Set,double
      return mosek_fusion_Expr._constTerm_Lmosek_4fusion_4Set_2D(*args)
    elif mosek_fusion_Expr._match_alt_constTerm_Lmosek_4fusion_4Set_2D(*args): # mosek.fusion.Set,double
      return mosek_fusion_Expr._constTerm_alt_Lmosek_4fusion_4Set_2D(*args)
    else:
      raise ValueError('Invalid argument list constTerm('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.constTerm(array(double,ndim=1))\n\tmosek.fusion.Expr.constTerm(mosek.fusion.NDSparseArray)\n\tmosek.fusion.Expr.constTerm(mosek.fusion.Matrix)\n\tmosek.fusion.Expr.constTerm(array(double,ndim=2))\n\tmosek.fusion.Expr.constTerm(double)\n\tmosek.fusion.Expr.constTerm(int32,double)\n\tmosek.fusion.Expr.constTerm(mosek.fusion.Set,double)')
  def size(self,*args):
    if False: pass
    elif mosek_fusion_Expr._match_size_(*args): # 
      return self._size_(*args)
    elif mosek_fusion_Expr._match_alt_size_(*args): # 
      return self._size_alt_(*args)
    else:
      raise ValueError('Invalid argument list size('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.size()')
  @staticmethod
  def mul(*args):
    if False: pass
    elif mosek_fusion_Expr._match_mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Matrix,mosek.fusion.Variable
      return mosek_fusion_Expr._mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Matrix,mosek.fusion.Variable
      return mosek_fusion_Expr._mul_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_mul__3DLmosek_4fusion_4Expression_2(*args): # []double,mosek.fusion.Expression
      return mosek_fusion_Expr._mul__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mul__3DLmosek_4fusion_4Expression_2(*args): # []double,mosek.fusion.Expression
      return mosek_fusion_Expr._mul_alt__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mul__3DLmosek_4fusion_4Variable_2(*args): # []double,mosek.fusion.Variable
      return mosek_fusion_Expr._mul__3DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_mul__3DLmosek_4fusion_4Variable_2(*args): # []double,mosek.fusion.Variable
      return mosek_fusion_Expr._mul_alt__3DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_mul_DLmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression
      return mosek_fusion_Expr._mul_DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mul_DLmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression
      return mosek_fusion_Expr._mul_alt_DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mul_Lmosek_4fusion_4Variable_2_3D(*args): # mosek.fusion.Variable,[]double
      return mosek_fusion_Expr._mul_Lmosek_4fusion_4Variable_2_3D(*args)
    elif mosek_fusion_Expr._match_alt_mul_Lmosek_4fusion_4Variable_2_3D(*args): # mosek.fusion.Variable,[]double
      return mosek_fusion_Expr._mul_alt_Lmosek_4fusion_4Variable_2_3D(*args)
    elif mosek_fusion_Expr._match_mul_Lmosek_4fusion_4Variable_2D(*args): # mosek.fusion.Variable,double
      return mosek_fusion_Expr._mul_Lmosek_4fusion_4Variable_2D(*args)
    elif mosek_fusion_Expr._match_alt_mul_Lmosek_4fusion_4Variable_2D(*args): # mosek.fusion.Variable,double
      return mosek_fusion_Expr._mul_alt_Lmosek_4fusion_4Variable_2D(*args)
    elif mosek_fusion_Expr._match_mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Matrix,mosek.fusion.Expression
      return mosek_fusion_Expr._mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Matrix,mosek.fusion.Expression
      return mosek_fusion_Expr._mul_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mul_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Variable,mosek.fusion.Matrix
      return mosek_fusion_Expr._mul_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_mul_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Variable,mosek.fusion.Matrix
      return mosek_fusion_Expr._mul_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_mul_DLmosek_4fusion_4Variable_2(*args): # double,mosek.fusion.Variable
      return mosek_fusion_Expr._mul_DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_mul_DLmosek_4fusion_4Variable_2(*args): # double,mosek.fusion.Variable
      return mosek_fusion_Expr._mul_alt_DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_mul__3_5DLmosek_4fusion_4Variable_2(*args): # [,]double,mosek.fusion.Variable
      return mosek_fusion_Expr._mul__3_5DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_mul__3_5DLmosek_4fusion_4Variable_2(*args): # [,]double,mosek.fusion.Variable
      return mosek_fusion_Expr._mul_alt__3_5DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_mul_Lmosek_4fusion_4Variable_2_3_5D(*args): # mosek.fusion.Variable,[,]double
      return mosek_fusion_Expr._mul_Lmosek_4fusion_4Variable_2_3_5D(*args)
    elif mosek_fusion_Expr._match_alt_mul_Lmosek_4fusion_4Variable_2_3_5D(*args): # mosek.fusion.Variable,[,]double
      return mosek_fusion_Expr._mul_alt_Lmosek_4fusion_4Variable_2_3_5D(*args)
    elif mosek_fusion_Expr._match_mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Expression,mosek.fusion.Matrix
      return mosek_fusion_Expr._mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Expression,mosek.fusion.Matrix
      return mosek_fusion_Expr._mul_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_mul_Lmosek_4fusion_4Expression_2_3D(*args): # mosek.fusion.Expression,[]double
      return mosek_fusion_Expr._mul_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_alt_mul_Lmosek_4fusion_4Expression_2_3D(*args): # mosek.fusion.Expression,[]double
      return mosek_fusion_Expr._mul_alt_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_mul_Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,double
      return mosek_fusion_Expr._mul_Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_mul_Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,double
      return mosek_fusion_Expr._mul_alt_Lmosek_4fusion_4Expression_2D(*args)
    else:
      raise ValueError('Invalid argument list mul('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.mul(mosek.fusion.Matrix,mosek.fusion.Variable)\n\tmosek.fusion.Expr.mul(array(double,ndim=1),mosek.fusion.Expression)\n\tmosek.fusion.Expr.mul(array(double,ndim=1),mosek.fusion.Variable)\n\tmosek.fusion.Expr.mul(double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.mul(mosek.fusion.Variable,array(double,ndim=1))\n\tmosek.fusion.Expr.mul(mosek.fusion.Variable,double)\n\tmosek.fusion.Expr.mul(mosek.fusion.Matrix,mosek.fusion.Expression)\n\tmosek.fusion.Expr.mul(mosek.fusion.Variable,mosek.fusion.Matrix)\n\tmosek.fusion.Expr.mul(double,mosek.fusion.Variable)\n\tmosek.fusion.Expr.mul(array(double,ndim=2),mosek.fusion.Variable)\n\tmosek.fusion.Expr.mul(mosek.fusion.Variable,array(double,ndim=2))\n\tmosek.fusion.Expr.mul(mosek.fusion.Expression,mosek.fusion.Matrix)\n\tmosek.fusion.Expr.mul(mosek.fusion.Expression,array(double,ndim=1))\n\tmosek.fusion.Expr.mul(mosek.fusion.Expression,double)')
  @staticmethod
  def mulDiag(*args):
    if False: pass
    elif mosek_fusion_Expr._match_mulDiag_Lmosek_4fusion_4Expression_2_3_5D(*args): # mosek.fusion.Expression,[,]double
      return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Expression_2_3_5D(*args)
    elif mosek_fusion_Expr._match_alt_mulDiag_Lmosek_4fusion_4Expression_2_3_5D(*args): # mosek.fusion.Expression,[,]double
      return mosek_fusion_Expr._mulDiag_alt_Lmosek_4fusion_4Expression_2_3_5D(*args)
    elif mosek_fusion_Expr._match_mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Matrix,mosek.fusion.Variable
      return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Matrix,mosek.fusion.Variable
      return mosek_fusion_Expr._mulDiag_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_mulDiag_Lmosek_4fusion_4Variable_2_3_5D(*args): # mosek.fusion.Variable,[,]double
      return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Variable_2_3_5D(*args)
    elif mosek_fusion_Expr._match_alt_mulDiag_Lmosek_4fusion_4Variable_2_3_5D(*args): # mosek.fusion.Variable,[,]double
      return mosek_fusion_Expr._mulDiag_alt_Lmosek_4fusion_4Variable_2_3_5D(*args)
    elif mosek_fusion_Expr._match_mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Matrix,mosek.fusion.Expression
      return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Matrix,mosek.fusion.Expression
      return mosek_fusion_Expr._mulDiag_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Variable,mosek.fusion.Matrix
      return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Variable,mosek.fusion.Matrix
      return mosek_fusion_Expr._mulDiag_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_mulDiag__3_5DLmosek_4fusion_4Variable_2(*args): # [,]double,mosek.fusion.Variable
      return mosek_fusion_Expr._mulDiag__3_5DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_mulDiag__3_5DLmosek_4fusion_4Variable_2(*args): # [,]double,mosek.fusion.Variable
      return mosek_fusion_Expr._mulDiag_alt__3_5DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_mulDiag__3_5DLmosek_4fusion_4Expression_2(*args): # [,]double,mosek.fusion.Expression
      return mosek_fusion_Expr._mulDiag__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mulDiag__3_5DLmosek_4fusion_4Expression_2(*args): # [,]double,mosek.fusion.Expression
      return mosek_fusion_Expr._mulDiag_alt__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Expression,mosek.fusion.Matrix
      return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Expression,mosek.fusion.Matrix
      return mosek_fusion_Expr._mulDiag_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    else:
      raise ValueError('Invalid argument list mulDiag('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.mulDiag(mosek.fusion.Expression,array(double,ndim=2))\n\tmosek.fusion.Expr.mulDiag(mosek.fusion.Matrix,mosek.fusion.Variable)\n\tmosek.fusion.Expr.mulDiag(mosek.fusion.Variable,array(double,ndim=2))\n\tmosek.fusion.Expr.mulDiag(mosek.fusion.Matrix,mosek.fusion.Expression)\n\tmosek.fusion.Expr.mulDiag(mosek.fusion.Variable,mosek.fusion.Matrix)\n\tmosek.fusion.Expr.mulDiag(array(double,ndim=2),mosek.fusion.Variable)\n\tmosek.fusion.Expr.mulDiag(array(double,ndim=2),mosek.fusion.Expression)\n\tmosek.fusion.Expr.mulDiag(mosek.fusion.Expression,mosek.fusion.Matrix)')
  @staticmethod
  def add(*args):
    if False: pass
    elif mosek_fusion_Expr._match_add__3Lmosek_4fusion_4Expression_2(*args): # []mosek.fusion.Expression
      return mosek_fusion_Expr._add__3Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_add__3Lmosek_4fusion_4Expression_2(*args): # []mosek.fusion.Expression
      return mosek_fusion_Expr._add_alt__3Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_add__3Lmosek_4fusion_4Variable_2(*args): # []mosek.fusion.Variable
      return mosek_fusion_Expr._add__3Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_add__3Lmosek_4fusion_4Variable_2(*args): # []mosek.fusion.Variable
      return mosek_fusion_Expr._add_alt__3Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.NDSparseArray,mosek.fusion.Variable
      return mosek_fusion_Expr._add_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.NDSparseArray,mosek.fusion.Variable
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Matrix,mosek.fusion.Variable
      return mosek_fusion_Expr._add_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Matrix,mosek.fusion.Variable
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Variable,mosek.fusion.Expression
      return mosek_fusion_Expr._add_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Variable,mosek.fusion.Expression
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_add__3DLmosek_4fusion_4Expression_2(*args): # []double,mosek.fusion.Expression
      return mosek_fusion_Expr._add__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_add__3DLmosek_4fusion_4Expression_2(*args): # []double,mosek.fusion.Expression
      return mosek_fusion_Expr._add_alt__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_add__3DLmosek_4fusion_4Variable_2(*args): # []double,mosek.fusion.Variable
      return mosek_fusion_Expr._add__3DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_add__3DLmosek_4fusion_4Variable_2(*args): # []double,mosek.fusion.Variable
      return mosek_fusion_Expr._add_alt__3DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.NDSparseArray,mosek.fusion.Expression
      return mosek_fusion_Expr._add_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.NDSparseArray,mosek.fusion.Expression
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_add_DLmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression
      return mosek_fusion_Expr._add_DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_add_DLmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression
      return mosek_fusion_Expr._add_alt_DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4Variable_2_3D(*args): # mosek.fusion.Variable,[]double
      return mosek_fusion_Expr._add_Lmosek_4fusion_4Variable_2_3D(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4Variable_2_3D(*args): # mosek.fusion.Variable,[]double
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4Variable_2_3D(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4Variable_2D(*args): # mosek.fusion.Variable,double
      return mosek_fusion_Expr._add_Lmosek_4fusion_4Variable_2D(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4Variable_2D(*args): # mosek.fusion.Variable,double
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4Variable_2D(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Expr._add_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.Variable,mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._add_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.Variable,mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Matrix,mosek.fusion.Expression
      return mosek_fusion_Expr._add_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Matrix,mosek.fusion.Expression
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Variable,mosek.fusion.Matrix
      return mosek_fusion_Expr._add_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Variable,mosek.fusion.Matrix
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4Expression_2_3D(*args): # mosek.fusion.Expression,[]double
      return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4Expression_2_3D(*args): # mosek.fusion.Expression,[]double
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_add_DLmosek_4fusion_4Variable_2(*args): # double,mosek.fusion.Variable
      return mosek_fusion_Expr._add_DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_add_DLmosek_4fusion_4Variable_2(*args): # double,mosek.fusion.Variable
      return mosek_fusion_Expr._add_alt_DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_add__3_5DLmosek_4fusion_4Variable_2(*args): # [,]double,mosek.fusion.Variable
      return mosek_fusion_Expr._add__3_5DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_add__3_5DLmosek_4fusion_4Variable_2(*args): # [,]double,mosek.fusion.Variable
      return mosek_fusion_Expr._add_alt__3_5DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_add__3_5DLmosek_4fusion_4Expression_2(*args): # [,]double,mosek.fusion.Expression
      return mosek_fusion_Expr._add__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_add__3_5DLmosek_4fusion_4Expression_2(*args): # [,]double,mosek.fusion.Expression
      return mosek_fusion_Expr._add_alt__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4Variable_2_3_5D(*args): # mosek.fusion.Variable,[,]double
      return mosek_fusion_Expr._add_Lmosek_4fusion_4Variable_2_3_5D(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4Variable_2_3_5D(*args): # mosek.fusion.Variable,[,]double
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4Variable_2_3_5D(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Expression,mosek.fusion.Matrix
      return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Expression,mosek.fusion.Matrix
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.Expression,mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.Expression,mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4Expression_2_3_5D(*args): # mosek.fusion.Expression,[,]double
      return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2_3_5D(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4Expression_2_3_5D(*args): # mosek.fusion.Expression,[,]double
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4Expression_2_3_5D(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,double
      return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,double
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Expression,mosek.fusion.Variable
      return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Expression,mosek.fusion.Variable
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    else:
      raise ValueError('Invalid argument list add('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.add(array(mosek.fusion.Expression,ndim=1))\n\tmosek.fusion.Expr.add(array(mosek.fusion.Variable,ndim=1))\n\tmosek.fusion.Expr.add(mosek.fusion.NDSparseArray,mosek.fusion.Variable)\n\tmosek.fusion.Expr.add(mosek.fusion.Matrix,mosek.fusion.Variable)\n\tmosek.fusion.Expr.add(mosek.fusion.Variable,mosek.fusion.Expression)\n\tmosek.fusion.Expr.add(array(double,ndim=1),mosek.fusion.Expression)\n\tmosek.fusion.Expr.add(array(double,ndim=1),mosek.fusion.Variable)\n\tmosek.fusion.Expr.add(mosek.fusion.NDSparseArray,mosek.fusion.Expression)\n\tmosek.fusion.Expr.add(double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.add(mosek.fusion.Variable,array(double,ndim=1))\n\tmosek.fusion.Expr.add(mosek.fusion.Variable,double)\n\tmosek.fusion.Expr.add(mosek.fusion.Variable,mosek.fusion.Variable)\n\tmosek.fusion.Expr.add(mosek.fusion.Variable,mosek.fusion.NDSparseArray)\n\tmosek.fusion.Expr.add(mosek.fusion.Matrix,mosek.fusion.Expression)\n\tmosek.fusion.Expr.add(mosek.fusion.Variable,mosek.fusion.Matrix)\n\tmosek.fusion.Expr.add(mosek.fusion.Expression,array(double,ndim=1))\n\tmosek.fusion.Expr.add(mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.add(double,mosek.fusion.Variable)\n\tmosek.fusion.Expr.add(array(double,ndim=2),mosek.fusion.Variable)\n\tmosek.fusion.Expr.add(array(double,ndim=2),mosek.fusion.Expression)\n\tmosek.fusion.Expr.add(mosek.fusion.Variable,array(double,ndim=2))\n\tmosek.fusion.Expr.add(mosek.fusion.Expression,mosek.fusion.Matrix)\n\tmosek.fusion.Expr.add(mosek.fusion.Expression,mosek.fusion.NDSparseArray)\n\tmosek.fusion.Expr.add(mosek.fusion.Expression,array(double,ndim=2))\n\tmosek.fusion.Expr.add(mosek.fusion.Expression,double)\n\tmosek.fusion.Expr.add(mosek.fusion.Expression,mosek.fusion.Variable)')
  @staticmethod
  def mulElm(*args):
    if False: pass
    elif mosek_fusion_Expr._match_mulElm_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.Variable,mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_alt_mulElm_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.Variable,mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._mulElm_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_mulElm_Lmosek_4fusion_4Expression_2_3D(*args): # mosek.fusion.Expression,[]double
      return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_alt_mulElm_Lmosek_4fusion_4Expression_2_3D(*args): # mosek.fusion.Expression,[]double
      return mosek_fusion_Expr._mulElm_alt_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_mulElm_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.NDSparseArray,mosek.fusion.Variable
      return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_mulElm_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.NDSparseArray,mosek.fusion.Variable
      return mosek_fusion_Expr._mulElm_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_mulElm_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Matrix,mosek.fusion.Variable
      return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_mulElm_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Matrix,mosek.fusion.Variable
      return mosek_fusion_Expr._mulElm_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_mulElm__3DLmosek_4fusion_4Expression_2(*args): # []double,mosek.fusion.Expression
      return mosek_fusion_Expr._mulElm__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mulElm__3DLmosek_4fusion_4Expression_2(*args): # []double,mosek.fusion.Expression
      return mosek_fusion_Expr._mulElm_alt__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mulElm__3DLmosek_4fusion_4Variable_2(*args): # []double,mosek.fusion.Variable
      return mosek_fusion_Expr._mulElm__3DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_mulElm__3DLmosek_4fusion_4Variable_2(*args): # []double,mosek.fusion.Variable
      return mosek_fusion_Expr._mulElm_alt__3DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_mulElm_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.NDSparseArray,mosek.fusion.Expression
      return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mulElm_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.NDSparseArray,mosek.fusion.Expression
      return mosek_fusion_Expr._mulElm_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mulElm_Lmosek_4fusion_4Variable_2_3D(*args): # mosek.fusion.Variable,[]double
      return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Variable_2_3D(*args)
    elif mosek_fusion_Expr._match_alt_mulElm_Lmosek_4fusion_4Variable_2_3D(*args): # mosek.fusion.Variable,[]double
      return mosek_fusion_Expr._mulElm_alt_Lmosek_4fusion_4Variable_2_3D(*args)
    elif mosek_fusion_Expr._match_mulElm_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Matrix,mosek.fusion.Expression
      return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mulElm_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Matrix,mosek.fusion.Expression
      return mosek_fusion_Expr._mulElm_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mulElm_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Variable,mosek.fusion.Matrix
      return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_mulElm_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Variable,mosek.fusion.Matrix
      return mosek_fusion_Expr._mulElm_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_mulElm__3_5DLmosek_4fusion_4Variable_2(*args): # [,]double,mosek.fusion.Variable
      return mosek_fusion_Expr._mulElm__3_5DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_mulElm__3_5DLmosek_4fusion_4Variable_2(*args): # [,]double,mosek.fusion.Variable
      return mosek_fusion_Expr._mulElm_alt__3_5DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_mulElm__3_5DLmosek_4fusion_4Expression_2(*args): # [,]double,mosek.fusion.Expression
      return mosek_fusion_Expr._mulElm__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mulElm__3_5DLmosek_4fusion_4Expression_2(*args): # [,]double,mosek.fusion.Expression
      return mosek_fusion_Expr._mulElm_alt__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mulElm_Lmosek_4fusion_4Variable_2_3_5D(*args): # mosek.fusion.Variable,[,]double
      return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Variable_2_3_5D(*args)
    elif mosek_fusion_Expr._match_alt_mulElm_Lmosek_4fusion_4Variable_2_3_5D(*args): # mosek.fusion.Variable,[,]double
      return mosek_fusion_Expr._mulElm_alt_Lmosek_4fusion_4Variable_2_3_5D(*args)
    elif mosek_fusion_Expr._match_mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Expression,mosek.fusion.Matrix
      return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Expression,mosek.fusion.Matrix
      return mosek_fusion_Expr._mulElm_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.Expression,mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_alt_mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.Expression,mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._mulElm_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_mulElm_Lmosek_4fusion_4Expression_2_3_5D(*args): # mosek.fusion.Expression,[,]double
      return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Expression_2_3_5D(*args)
    elif mosek_fusion_Expr._match_alt_mulElm_Lmosek_4fusion_4Expression_2_3_5D(*args): # mosek.fusion.Expression,[,]double
      return mosek_fusion_Expr._mulElm_alt_Lmosek_4fusion_4Expression_2_3_5D(*args)
    else:
      raise ValueError('Invalid argument list mulElm('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.mulElm(mosek.fusion.Variable,mosek.fusion.NDSparseArray)\n\tmosek.fusion.Expr.mulElm(mosek.fusion.Expression,array(double,ndim=1))\n\tmosek.fusion.Expr.mulElm(mosek.fusion.NDSparseArray,mosek.fusion.Variable)\n\tmosek.fusion.Expr.mulElm(mosek.fusion.Matrix,mosek.fusion.Variable)\n\tmosek.fusion.Expr.mulElm(array(double,ndim=1),mosek.fusion.Expression)\n\tmosek.fusion.Expr.mulElm(array(double,ndim=1),mosek.fusion.Variable)\n\tmosek.fusion.Expr.mulElm(mosek.fusion.NDSparseArray,mosek.fusion.Expression)\n\tmosek.fusion.Expr.mulElm(mosek.fusion.Variable,array(double,ndim=1))\n\tmosek.fusion.Expr.mulElm(mosek.fusion.Matrix,mosek.fusion.Expression)\n\tmosek.fusion.Expr.mulElm(mosek.fusion.Variable,mosek.fusion.Matrix)\n\tmosek.fusion.Expr.mulElm(array(double,ndim=2),mosek.fusion.Variable)\n\tmosek.fusion.Expr.mulElm(array(double,ndim=2),mosek.fusion.Expression)\n\tmosek.fusion.Expr.mulElm(mosek.fusion.Variable,array(double,ndim=2))\n\tmosek.fusion.Expr.mulElm(mosek.fusion.Expression,mosek.fusion.Matrix)\n\tmosek.fusion.Expr.mulElm(mosek.fusion.Expression,mosek.fusion.NDSparseArray)\n\tmosek.fusion.Expr.mulElm(mosek.fusion.Expression,array(double,ndim=2))')
  @staticmethod
  def neg(*args):
    if False: pass
    elif mosek_fusion_Expr._match_neg_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      return mosek_fusion_Expr._neg_Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_neg_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      return mosek_fusion_Expr._neg_alt_Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_neg_Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable
      return mosek_fusion_Expr._neg_Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_neg_Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable
      return mosek_fusion_Expr._neg_alt_Lmosek_4fusion_4Variable_2(*args)
    else:
      raise ValueError('Invalid argument list neg('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.neg(mosek.fusion.Expression)\n\tmosek.fusion.Expr.neg(mosek.fusion.Variable)')
  @staticmethod
  def ones(*args):
    if False: pass
    elif mosek_fusion_Expr._match_ones_I(*args): # int32
      return mosek_fusion_Expr._ones_I(*args)
    elif mosek_fusion_Expr._match_alt_ones_I(*args): # int32
      return mosek_fusion_Expr._ones_alt_I(*args)
    else:
      raise ValueError('Invalid argument list ones('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.ones(int32)')
  @staticmethod
  def flatten(*args):
    if False: pass
    elif mosek_fusion_Expr._match_flatten_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      return mosek_fusion_Expr._flatten_Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_flatten_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      return mosek_fusion_Expr._flatten_alt_Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list flatten('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.flatten(mosek.fusion.Expression)')
  @staticmethod
  def outer(*args):
    if False: pass
    elif mosek_fusion_Expr._match_outer_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Matrix,mosek.fusion.Variable
      return mosek_fusion_Expr._outer_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_outer_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Matrix,mosek.fusion.Variable
      return mosek_fusion_Expr._outer_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_outer__3DLmosek_4fusion_4Expression_2(*args): # []double,mosek.fusion.Expression
      return mosek_fusion_Expr._outer__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_outer__3DLmosek_4fusion_4Expression_2(*args): # []double,mosek.fusion.Expression
      return mosek_fusion_Expr._outer_alt__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_outer__3DLmosek_4fusion_4Variable_2(*args): # []double,mosek.fusion.Variable
      return mosek_fusion_Expr._outer__3DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_outer__3DLmosek_4fusion_4Variable_2(*args): # []double,mosek.fusion.Variable
      return mosek_fusion_Expr._outer_alt__3DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_outer_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Variable,mosek.fusion.Matrix
      return mosek_fusion_Expr._outer_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_outer_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Variable,mosek.fusion.Matrix
      return mosek_fusion_Expr._outer_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_outer_Lmosek_4fusion_4Variable_2_3D(*args): # mosek.fusion.Variable,[]double
      return mosek_fusion_Expr._outer_Lmosek_4fusion_4Variable_2_3D(*args)
    elif mosek_fusion_Expr._match_alt_outer_Lmosek_4fusion_4Variable_2_3D(*args): # mosek.fusion.Variable,[]double
      return mosek_fusion_Expr._outer_alt_Lmosek_4fusion_4Variable_2_3D(*args)
    elif mosek_fusion_Expr._match_outer_Lmosek_4fusion_4Expression_2_3D(*args): # mosek.fusion.Expression,[]double
      return mosek_fusion_Expr._outer_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_alt_outer_Lmosek_4fusion_4Expression_2_3D(*args): # mosek.fusion.Expression,[]double
      return mosek_fusion_Expr._outer_alt_Lmosek_4fusion_4Expression_2_3D(*args)
    else:
      raise ValueError('Invalid argument list outer('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.outer(mosek.fusion.Matrix,mosek.fusion.Variable)\n\tmosek.fusion.Expr.outer(array(double,ndim=1),mosek.fusion.Expression)\n\tmosek.fusion.Expr.outer(array(double,ndim=1),mosek.fusion.Variable)\n\tmosek.fusion.Expr.outer(mosek.fusion.Variable,mosek.fusion.Matrix)\n\tmosek.fusion.Expr.outer(mosek.fusion.Variable,array(double,ndim=1))\n\tmosek.fusion.Expr.outer(mosek.fusion.Expression,array(double,ndim=1))')
  def slice(self,*args):
    if False: pass
    elif mosek_fusion_Expr._match_slice_II(*args): # int32,int32
      return self._slice_II(*args)
    elif mosek_fusion_Expr._match_alt_slice_II(*args): # int32,int32
      return self._slice_alt_II(*args)
    elif mosek_fusion_Expr._match_slice__3I_3I(*args): # []int32,[]int32
      return self._slice__3I_3I(*args)
    elif mosek_fusion_Expr._match_alt_slice__3I_3I(*args): # []int32,[]int32
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.slice(int32,int32)\n\tmosek.fusion.Expr.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def __repr__(self): return 'mosek.fusion.Expr'
  @staticmethod
  def _ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(ptrb_,v,subj_,cof_,bfix_,shp,inst_):
    o = Expr.__new__(Expr)
    o._ctor_init__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(ptrb_,v,subj_,cof_,bfix_,shp,inst_)
    return o
  @staticmethod
  def __match_ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(*args):
    if len(args) != 7: return False
    ptrb_,v,subj_,cof_,bfix_,shp,inst_, = args
    return (__arg_match__3J__(ptrb_) and __arg_match__3Lmosek_4fusion_4Variable_2__(v) and __arg_match__3J__(subj_) and __arg_match__3D__(cof_) and __arg_match__3D__(bfix_) and __arg_match_Lmosek_4fusion_4Set_2__(shp) and __arg_match__3J__(inst_))
  @staticmethod
  def __match_alt_ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(*args):
    if len(args) != 7: return False
    ptrb_,v,subj_,cof_,bfix_,shp,inst_, = args
    return (__arg_alt_match__3J__(ptrb_) and __arg_alt_match__3Lmosek_4fusion_4Variable_2__(v) and __arg_alt_match__3J__(subj_) and __arg_alt_match__3D__(cof_) and __arg_alt_match__3D__(bfix_) and __arg_alt_match_Lmosek_4fusion_4Set_2__(shp) and __arg_alt_match__3J__(inst_))
  def _ctor_alt_init__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(self,ptrb_,v,subj_,cof_,bfix_,shp,inst_):
    self._ctor_init__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(numpy.array(ptrb_,dtype=numpy.dtype(numpy.int64)),numpy.array(v,dtype=numpy.dtype(object)),numpy.array(subj_,dtype=numpy.dtype(numpy.int64)),numpy.array(cof_,dtype=numpy.dtype(numpy.float64)),numpy.array(bfix_,dtype=numpy.dtype(numpy.float64)),shp,numpy.array(inst_,dtype=numpy.dtype(numpy.int64)))
  def _ctor_init__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(self,ptrb_,v,subj_,cof_,bfix_,shp,inst_):
   object.__init__(self)
   self.__model = mosek.fusion.Expr.__extractModel__3Lmosek_4fusion_4Variable_2(v)
   self.__shape_p = shp
   self.__x = v
   self.__varsb = numpy.zeros(((int((self.__x).shape[0]) + 1),), dtype=numpy.dtype(numpy.int64))
   for _0 in range(0,int((self.__x).shape[0])):
    self.__varsb[(_0 + 1)] = (self.__varsb[_0] + (self.__x[_0]._shape_()._size))
   _1=(int((ptrb_).shape[0]) - 1)
   _2=ptrb_[(int((ptrb_).shape[0]) - 1)]
   mosek.fusion.Expr.__validateData__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(ptrb_,v,subj_,cof_,bfix_,self.__shape_p,inst_)
   if (inst_ is not None):
    self.__inst = mosek.fusion.Utils.Tools._arraycopy__3J(inst_)
   else:
    self.__inst = None
   self.__shape_p = (mosek.fusion.Set._make_I((int((ptrb_).shape[0]) - 1)) if ((shp is None) ) else shp)
   self.__subj = numpy.zeros((_2,), dtype=numpy.dtype(numpy.int64))
   self.__cof_v = numpy.zeros((_2,), dtype=numpy.dtype(numpy.float64))
   self.__ptrb = numpy.zeros((int((ptrb_).shape[0]),), dtype=numpy.dtype(numpy.int64))
   self.__bfix = (None if ((bfix_ is None) ) else numpy.zeros((int((bfix_).shape[0]),), dtype=numpy.dtype(numpy.float64)))
   mosek.fusion.Utils.Tools._arraycopy__3JI_3JII(ptrb_,0,self.__ptrb,0,int((self.__ptrb).shape[0]))
   mosek.fusion.Utils.Tools._arraycopy__3JJ_3JJJ(subj_,0,self.__subj,0,_2)
   mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ(cof_,0,self.__cof_v,0,_2)
   if (self.__bfix is not None):
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(bfix_,0,self.__bfix,0,int((self.__bfix).shape[0]))
  @staticmethod
  def _ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(ptrb_,v,subj_,cof_,bfix_,shp,inst_,unchecked_):
    o = Expr.__new__(Expr)
    o._ctor_init__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(ptrb_,v,subj_,cof_,bfix_,shp,inst_,unchecked_)
    return o
  @staticmethod
  def __match_ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(*args):
    if len(args) != 8: return False
    ptrb_,v,subj_,cof_,bfix_,shp,inst_,unchecked_, = args
    return (__arg_match__3J__(ptrb_) and __arg_match__3Lmosek_4fusion_4Variable_2__(v) and __arg_match__3J__(subj_) and __arg_match__3D__(cof_) and __arg_match__3D__(bfix_) and __arg_match_Lmosek_4fusion_4Set_2__(shp) and __arg_match__3J__(inst_) and __arg_match_I__(unchecked_))
  @staticmethod
  def __match_alt_ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(*args):
    if len(args) != 8: return False
    ptrb_,v,subj_,cof_,bfix_,shp,inst_,unchecked_, = args
    return (__arg_alt_match__3J__(ptrb_) and __arg_alt_match__3Lmosek_4fusion_4Variable_2__(v) and __arg_alt_match__3J__(subj_) and __arg_alt_match__3D__(cof_) and __arg_alt_match__3D__(bfix_) and __arg_alt_match_Lmosek_4fusion_4Set_2__(shp) and __arg_alt_match__3J__(inst_) and __arg_alt_match_I__(unchecked_))
  def _ctor_alt_init__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(self,ptrb_,v,subj_,cof_,bfix_,shp,inst_,unchecked_):
    self._ctor_init__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(numpy.array(ptrb_,dtype=numpy.dtype(numpy.int64)),numpy.array(v,dtype=numpy.dtype(object)),numpy.array(subj_,dtype=numpy.dtype(numpy.int64)),numpy.array(cof_,dtype=numpy.dtype(numpy.float64)),numpy.array(bfix_,dtype=numpy.dtype(numpy.float64)),shp,numpy.array(inst_,dtype=numpy.dtype(numpy.int64)),numpy.int32(unchecked_))
  def _ctor_init__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(self,ptrb_,v,subj_,cof_,bfix_,shp,inst_,unchecked_):
   object.__init__(self)
   self.__model = mosek.fusion.Expr.__extractModel__3Lmosek_4fusion_4Variable_2(v)
   (self.__shape_p) = shp
   self.__x = v
   self.__ptrb = ptrb_
   self.__subj = subj_
   self.__cof_v = cof_
   if (int((self.__subj).shape[0])!=int((self.__cof_v).shape[0])):
    raise mosek_fusion_SparseFormatError._ctor_S("Mismatching subj and cof")
   self.__varsb = numpy.zeros(((int((self.__x).shape[0]) + 1),), dtype=numpy.dtype(numpy.int64))
   for _0 in range(0,int((self.__x).shape[0])):
    self.__varsb[(_0 + 1)] = (self.__varsb[_0] + (self.__x[_0]._shape_()._size))
   self.__bfix = bfix_
   self.__shape_p = (mosek_fusion_IntSet._ctor_I((int((ptrb_).shape[0]) - 1)) if ((shp is None) ) else shp)
   self.__inst = inst_
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2(e):
    o = Expr.__new__(Expr)
    o._ctor_init_Lmosek_4fusion_4Expression_2(e)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    e, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(e))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    e, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(e))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2(self,e):
    self._ctor_init_Lmosek_4fusion_4Expression_2(e)
  def _ctor_init_Lmosek_4fusion_4Expression_2(self,e):
   object.__init__(self)
   _1=e
   if   isinstance(_1,mosek_fusion_Expr):
    ee=_1
    self.__model = (ee.__model)
    self.__shape_p = (ee.__shape_p)
    self.__ptrb = (ee.__ptrb)
    self.__subj = (ee.__subj)
    self.__x = (ee.__x)
    self.__cof_v = (ee.__cof_v)
    self.__bfix = (ee.__bfix)
    self.__varsb = (ee.__varsb)
    self.__inst = (ee.__inst)
   else:
    ee=_1
    _1=ee._eval_()
    self.__model = e._getModel_()
    self.__shape_p = (_1.shape)
    self.__ptrb = (_1.ptrb)
    self.__subj = (_1.subj)
    self.__x = (_1.x)
    self.__cof_v = (_1.cof)
    self.__bfix = (_1.bfix)
    self.__varsb = numpy.zeros(((int((self.__x).shape[0]) + 1),), dtype=numpy.dtype(numpy.int64))
    for _2 in range(0,int((self.__x).shape[0])):
     self.__varsb[(_2 + 1)] = (self.__varsb[_2] + (self.__x[_2]._shape_()._size))
    self.__inst = (_1.inst)
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("Expr(ndim=(")._a_I(self.__shape_p._dim_I(0))
   for _1 in range(1,(self.__shape_p.nd)):
    _0._a_S(",")._a_I(self.__shape_p._dim_I(_1))
   _0._a_S("),\n     [ ")
   if (int((self.__ptrb).shape[0]) > 1):
    if (self.__inst is None):
     self.__tostr_Lmosek_4fusion_4Utils_4StringBuffer_2I(_0,0)
     for _2 in range(1,(int((self.__ptrb).shape[0]) - 1)):
      _0._a_S(",\n       ")
      self.__tostr_Lmosek_4fusion_4Utils_4StringBuffer_2I(_0,_2)
    else:
     if (int((self.__inst).shape[0]) > 0):
      _0._a_S("(")._a__3I(self.__shape_p._idxtokey_J(self.__inst[0]))._a_S(") -> ")
      self.__tostr_Lmosek_4fusion_4Utils_4StringBuffer_2I(_0,0)
      for _3 in range(1,(int((self.__ptrb).shape[0]) - 1)):
       _0._a_S(",\n       (")._a__3I(self.__shape_p._idxtokey_J(self.__inst[_3]))._a_S(") -> ")
       self.__tostr_Lmosek_4fusion_4Utils_4StringBuffer_2I(_0,_3)
   _0._a_S(" ])")
   return (_0._toString_())
  def __tostr_alt_Lmosek_4fusion_4Utils_4StringBuffer_2I(self,_t__0,_t__1):
    return self.__tostr_Lmosek_4fusion_4Utils_4StringBuffer_2I(_0,numpy.int32(__1))
  def __tostr_Lmosek_4fusion_4Utils_4StringBuffer_2I(self,_0,_1):
   for _2 in range(self.__ptrb[_1],self.__ptrb[(_1 + 1)]):
    _3=self.__subj[_2]
    _4=self.__cof_v[_2]
    if (_4 < 0):
     _5=0
     _5 = fragments._c_closure_222(_3,_5,self.__varsb) # src/fusion/Expr.mbi:5852:13-43
     _5 = numpy.int32(_5) # postprocess
     if ((_4 < (- 1.0)) or (_4 > (- 1.0))):
      _0._a_S(" - ")._a_D((- _4))._a_S(" ")
     else:
      _0._a_S(" - ")._a_S(" ")
     self.__x[_5]._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2((_3 - self.__varsb[_5]),_0)
    else:
     _6=0
     _6 = fragments._c_closure_223(_3,_6,self.__varsb) # src/fusion/Expr.mbi:5863:13-43
     _6 = numpy.int32(_6) # postprocess
     if ((_4 < 1.0) or (_4 > 1.0)):
      _0._a_S(" + ")._a_D(_4)._a_S(" ")
     else:
      _0._a_S(" + ")._a_S(" ")
     self.__x[_6]._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2((_3 - self.__varsb[_6]),_0)
   if (self.__bfix is not None):
    if (self.__bfix[_1] < 0.0):
     _0._a_S(" - ")._a_D((- self.__bfix[_1]))
    else:
     _0._a_S(" + ")._a_D(self.__bfix[_1])
  @staticmethod
  def __varstack_alt__3_3Lmosek_4fusion_4Variable_2(_t__0):
   _0=_monty.makeJaggedArray(_t__0,(1,1),numpy.dtype(object))
   _1 = mosek_fusion_Expr.__varstack__3_3Lmosek_4fusion_4Variable_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __varstack__3_3Lmosek_4fusion_4Variable_2(_0):
   return (numpy.array([_0[_1][_2] for _1 in range(0,int((_0).shape[0])) for _2 in range(0,int((_0[_1]).shape[0]))], dtype=numpy.dtype(object)))
  @staticmethod
  def __varstack_alt__3Lmosek_4fusion_4Variable_2_3Lmosek_4fusion_4Variable_2(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1=numpy.array(_t__1,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Expr.__varstack__3Lmosek_4fusion_4Variable_2_3Lmosek_4fusion_4Variable_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __varstack__3Lmosek_4fusion_4Variable_2_3Lmosek_4fusion_4Variable_2(_0,_1):
   if (_0 is None):
    return (_1)
   elif (_1 is None):
    return (_0)
   else:
    _2=numpy.zeros(((int((_0).shape[0]) + int((_1).shape[0])),), dtype=numpy.dtype(object))
    for _3 in range(0,int((_0).shape[0])):
     _2[_3] = _0[_3]
    for _4 in range(0,int((_1).shape[0])):
     _2[(_4 + int((_0).shape[0]))] = _1[_4]
    return (_2)
  @staticmethod
  def _match_flatten_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _match_alt_flatten_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _flatten_alt_Lmosek_4fusion_4Expression_2(_t__0):
    return mosek_fusion_Expr._flatten_Lmosek_4fusion_4Expression_2(_0)
  @staticmethod
  def _flatten_Lmosek_4fusion_4Expression_2(_0):
   if (_0 is None):
    raise ValueError("Arguments for flatten may not be null")
   return (mosek.fusion.Expr._reshape_Lmosek_4fusion_4Expression_2I(_0,numpy.int32((_0._shape_()._size))))
  @staticmethod
  def _match_reshape_Lmosek_4fusion_4Expression_2II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_reshape_Lmosek_4fusion_4Expression_2II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _reshape_alt_Lmosek_4fusion_4Expression_2II(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._reshape_Lmosek_4fusion_4Expression_2II(_0,numpy.int32(__1),numpy.int32(__2))
  @staticmethod
  def _reshape_Lmosek_4fusion_4Expression_2II(_0,_1,_2):
   if (_0 is None):
    raise ValueError("Arguments for reshape may not be null")
   return (mosek.fusion.Expr._reshape_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Set_2(_0,mosek_fusion_NDSet._ctor_II(_1,_2)))
  @staticmethod
  def _match_reshape_Lmosek_4fusion_4Expression_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_reshape_Lmosek_4fusion_4Expression_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _reshape_alt_Lmosek_4fusion_4Expression_2I(_t__0,_t__1):
    return mosek_fusion_Expr._reshape_Lmosek_4fusion_4Expression_2I(_0,numpy.int32(__1))
  @staticmethod
  def _reshape_Lmosek_4fusion_4Expression_2I(_0,_1):
   if (_0 is None):
    raise ValueError("Arguments for reshape may not be null")
   return (mosek.fusion.Expr._reshape_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Set_2(_0,mosek_fusion_IntSet._ctor_I(_1)))
  @staticmethod
  def _match_reshape_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Set_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Set_2__(_1))
  @staticmethod
  def _match_alt_reshape_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Set_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Set_2__(_1))
  @staticmethod
  def _reshape_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Set_2(_t__0,_t__1):
    return mosek_fusion_Expr._reshape_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Set_2(_0,_1)
  @staticmethod
  def _reshape_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Set_2(_0,_1):
   if ((_0 is None) or (_1 is None)):
    raise ValueError("Arguments for reshape may not be null")
   if ((_1._size)!=(_0._shape_()._size)):
    raise mosek_fusion_DimensionError._ctor_S("New shape has wrong number of elements")
   _3=_0
   if   isinstance(_3,mosek_fusion_Expr):
    e_=_3
    return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI((e_.__ptrb),(e_.__x),(e_.__subj),(e_.__cof_v),(e_.__bfix),_1,(e_.__inst),1))
   else:
    e_=_3
    _3=_0._eval_()
    return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI((_3.ptrb),(_3.x),(_3.subj),(_3.cof),(_3.bfix),_1,(_3.inst),1))
  @staticmethod
  def _match_size_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_size_(*args):
    if len(args) != 0: return False
    return True
  def _size_alt_(self,):
    return self._size_()
  def _size_(self,):
   return numpy.int64((long((self.__ptrb).shape[0]) - 1))
  @staticmethod
  def _match_eval_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_eval_(*args):
    if len(args) != 0: return False
    return True
  def _eval_alt_(self,):
    return self._eval_()
  def _eval_(self,):
   _0=(None if ((self.__bfix is None) ) else mosek.fusion.Utils.Tools._arraycopy__3D(self.__bfix))
   _1=(None if ((self.__inst is None) ) else mosek.fusion.Utils.Tools._arraycopy__3J(self.__inst))
   return (mosek_fusion_FlatExpr._ctor__3D_3J_3J_3Lmosek_4fusion_4Variable_2_3DLmosek_4fusion_4Set_2_3J(_0,mosek.fusion.Utils.Tools._arraycopy__3J(self.__ptrb),mosek.fusion.Utils.Tools._arraycopy__3J(self.__subj),self.__x,mosek.fusion.Utils.Tools._arraycopy__3D(self.__cof_v),self.__shape_p,self.__inst))
  @staticmethod
  def _match_zeros_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_zeros_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _zeros_alt_I(_t__0):
    return mosek_fusion_Expr._zeros_I(numpy.int32(__0))
  @staticmethod
  def _zeros_I(_0):
   _1=mosek.fusion.Utils.Tools._makevector_JI(0,(1 + _0))
   _2=numpy.zeros((0,), dtype=numpy.dtype(object))
   _3=numpy.zeros((0,), dtype=numpy.dtype(numpy.int64))
   _4=numpy.zeros((0,), dtype=numpy.dtype(numpy.float64))
   _5=mosek.fusion.Utils.Tools._zeros_I(_0)
   return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(_1,_2,_3,_4,_5,None,None,1))
  @staticmethod
  def _match_ones_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_ones_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _ones_alt_I(_t__0):
    return mosek_fusion_Expr._ones_I(numpy.int32(__0))
  @staticmethod
  def _ones_I(_0):
   _1=mosek.fusion.Utils.Tools._makevector_JI(0,(1 + _0))
   _2=numpy.zeros((0,), dtype=numpy.dtype(numpy.int64))
   _3=numpy.zeros((0,), dtype=numpy.dtype(numpy.float64))
   _4=mosek.fusion.Utils.Tools._ones_I(_0)
   return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(_1,numpy.zeros((0,), dtype=numpy.dtype(object)),_2,_3,_4,None,None,1))
  @staticmethod
  def _match_constTerm_Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4NDSparseArray_2__(_0))
  @staticmethod
  def _match_alt_constTerm_Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_0))
  @staticmethod
  def _constTerm_alt_Lmosek_4fusion_4NDSparseArray_2(_t__0):
    return mosek_fusion_Expr._constTerm_Lmosek_4fusion_4NDSparseArray_2(_0)
  @staticmethod
  def _constTerm_Lmosek_4fusion_4NDSparseArray_2(_0):
   _1=mosek.fusion.Set._make__3I((_0._dims))
   _2=numpy.zeros(((int(((_0._inst)).shape[0]) + 1),), dtype=numpy.dtype(numpy.int64))
   _3=numpy.zeros((0,), dtype=numpy.dtype(object))
   _4=numpy.zeros((0,), dtype=numpy.dtype(numpy.int64))
   _5=numpy.zeros((0,), dtype=numpy.dtype(numpy.float64))
   _6=mosek.fusion.Utils.Tools._arraycopy__3D((_0._cof))
   _7=mosek.fusion.Utils.Tools._arraycopy__3J((_0._inst))
   return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_2,_3,_4,_5,_6,_1,_7))
  @staticmethod
  def _match_constTerm_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _match_alt_constTerm_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _constTerm_alt_Lmosek_4fusion_4Matrix_2(_t__0):
    return mosek_fusion_Expr._constTerm_Lmosek_4fusion_4Matrix_2(_0)
  @staticmethod
  def _constTerm_Lmosek_4fusion_4Matrix_2(_0):
   _1=mosek.fusion.Set._make_II(_0._numRows_(),_0._numColumns_())
   _2=numpy.zeros(((_0._numNonzeros_() + 1),), dtype=numpy.dtype(numpy.int64))
   _3=numpy.zeros((0,), dtype=numpy.dtype(object))
   _4=numpy.zeros((0,), dtype=numpy.dtype(numpy.int64))
   _5=numpy.zeros((0,), dtype=numpy.dtype(numpy.float64))
   _6=None
   _7=None
   if _0._isSparse_():
    _8=numpy.zeros((_0._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
    _9=numpy.zeros((_0._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
    _10=numpy.zeros((_0._numNonzeros_(),), dtype=numpy.dtype(numpy.float64))
    _0._getDataAsTriplets__3I_3I_3D(_8,_9,_10)
    _6 = _10
    _7 = numpy.array([((numpy.int64(_8[_11]) * _0._numColumns_()) + _9[_11]) for _11 in range(0,_0._numNonzeros_())], dtype=numpy.dtype(numpy.int64))
   else:
    _6 = _0._getDataAsArray_()
   return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_2,_3,_4,_5,_6,_1,_7))
  @staticmethod
  def _match_constTerm_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_D__(_0))
  @staticmethod
  def _match_alt_constTerm_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_D__(_0))
  @staticmethod
  def _constTerm_alt_D(_t__0):
    return mosek_fusion_Expr._constTerm_D(numpy.float64(__0))
  @staticmethod
  def _constTerm_D(_0):
   _1=numpy.array([0,0], dtype=numpy.dtype(numpy.int64))
   _2=numpy.zeros((0,), dtype=numpy.dtype(object))
   _3=numpy.zeros((0,), dtype=numpy.dtype(numpy.int64))
   _4=numpy.zeros((0,), dtype=numpy.dtype(numpy.float64))
   _5=numpy.array([_0], dtype=numpy.dtype(numpy.float64))
   return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(_1,_2,_3,_4,_5,None,None,1))
  @staticmethod
  def _match_constTerm_Lmosek_4fusion_4Set_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Set_2__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_constTerm_Lmosek_4fusion_4Set_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Set_2__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _constTerm_alt_Lmosek_4fusion_4Set_2D(_t__0,_t__1):
    return mosek_fusion_Expr._constTerm_Lmosek_4fusion_4Set_2D(_0,numpy.float64(__1))
  @staticmethod
  def _constTerm_Lmosek_4fusion_4Set_2D(_0,_1):
   _2=mosek.fusion.Utils.Tools._makevector_JI(0,(numpy.int32((_0._size)) + 1))
   _3=numpy.zeros((0,), dtype=numpy.dtype(object))
   _4=numpy.zeros((0,), dtype=numpy.dtype(numpy.int64))
   _5=numpy.zeros((0,), dtype=numpy.dtype(numpy.float64))
   _6=mosek.fusion.Utils.Tools._makevector_DI(_1,numpy.int32((_0._size)))
   return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(_2,_3,_4,_5,_6,_0,None,1))
  @staticmethod
  def _match_constTerm_ID(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_constTerm_ID(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _constTerm_alt_ID(_t__0,_t__1):
    return mosek_fusion_Expr._constTerm_ID(numpy.int32(__0),numpy.float64(__1))
  @staticmethod
  def _constTerm_ID(_0,_1):
   _2=mosek.fusion.Utils.Tools._makevector_JI(0,(_0 + 1))
   _3=numpy.zeros((0,), dtype=numpy.dtype(object))
   _4=numpy.zeros((0,), dtype=numpy.dtype(numpy.int64))
   _5=numpy.zeros((0,), dtype=numpy.dtype(numpy.float64))
   _6=mosek.fusion.Utils.Tools._makevector_DI(_1,_0)
   return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(_2,_3,_4,_5,_6,None,None,1))
  @staticmethod
  def _match_constTerm__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5D__(_0))
  @staticmethod
  def _match_alt_constTerm__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5D__(_0))
  @staticmethod
  def _constTerm_alt__3_5D(_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._constTerm__3_5D(_0)
   return _1
  @staticmethod
  def _constTerm__3_5D(_0):
   if (_0 is None):
    raise ValueError("Arguments for constTerm may not be null")
   _1=(int((_0).shape[0]) * int((_0).shape[1]))
   _2=mosek.fusion.Utils.Tools._makevector_JI(0,(_1 + 1))
   _3=numpy.zeros((0,), dtype=numpy.dtype(object))
   _4=numpy.zeros((0,), dtype=numpy.dtype(numpy.int64))
   _5=numpy.zeros((0,), dtype=numpy.dtype(numpy.float64))
   _6=numpy.zeros((_1,), dtype=numpy.dtype(numpy.float64))
   _7=0
   for _8 in range(0,int((_0).shape[0])):
    for _9 in range(0,int((_0).shape[1])):
     _6[_7] = _0[_8,_9]
     _7 += 1
   return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(_2,_3,_4,_5,_6,mosek.fusion.Set._make_II(int((_0).shape[0]),int((_0).shape[1])),None,1))
  @staticmethod
  def _match_constTerm__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_constTerm__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  @staticmethod
  def _constTerm_alt__3D(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._constTerm__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _constTerm__3D(_0):
   if (_0 is None):
    raise ValueError("Arguments for constTerm may not be null")
   _1=mosek.fusion.Utils.Tools._makevector_JI(0,(int((_0).shape[0]) + 1))
   _2=numpy.zeros((0,), dtype=numpy.dtype(object))
   _3=numpy.zeros((0,), dtype=numpy.dtype(numpy.int64))
   _4=numpy.zeros((0,), dtype=numpy.dtype(numpy.float64))
   _5=mosek.fusion.Utils.Tools._arraycopy__3D(_0)
   return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(_1,_2,_3,_4,_5,None,None,1))
  @staticmethod
  def _match_numNonzeros_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_numNonzeros_(*args):
    if len(args) != 0: return False
    return True
  def _numNonzeros_alt_(self,):
    return self._numNonzeros_()
  def _numNonzeros_(self,):
   return numpy.int64(long((self.__cof_v).shape[0]))
  @staticmethod
  def __sum_1expr_alt_Lmosek_4fusion_4Expression_2II(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr.__sum_1expr_Lmosek_4fusion_4Expression_2II(_0,numpy.int32(__1),numpy.int32(__2))
  @staticmethod
  def __sum_1expr_Lmosek_4fusion_4Expression_2II(_0,_1,_2):
   if ((_1 < 0) or ((_2 <= _1) or ((_0._shape_().nd) < _2))):
    raise mosek_fusion_DimensionError._ctor_S("The sum-dimension is invalid or out of bounds")
   _3=_0._eval_()
   if (((_3.shape)._size)==0):
    _4=numpy.zeros(((((_3.shape).nd) - (_2 - _1)),), dtype=numpy.dtype(numpy.int32))
    _5=1
    _6=1
    _7=1
    for _8 in range(0,_1):
     _5 *= (_3.shape)._dim_I(_8)
     _4[_8] = (_3.shape)._dim_I(_8)
    for _9 in range(_1,_2):
     _6 *= (_3.shape)._dim_I(_9)
    for _10 in range(_2,((_3.shape).nd)):
     _7 *= (_3.shape)._dim_I(_10)
     _4[(_10 - _2)] = (_3.shape)._dim_I(_10)
    if ((_5==0) or (_7==0)):
     return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(numpy.array([0], dtype=numpy.dtype(numpy.int64)),(_3.x),numpy.zeros((0,), dtype=numpy.dtype(numpy.int64)),numpy.zeros((0,), dtype=numpy.dtype(numpy.float64)),numpy.zeros((0,), dtype=numpy.dtype(numpy.float64)),mosek.fusion.Set._make__3I(_4),None))
    else:
     return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(numpy.array([0], dtype=numpy.dtype(numpy.int64)),(_3.x),numpy.zeros((0,), dtype=numpy.dtype(numpy.int64)),numpy.zeros((0,), dtype=numpy.dtype(numpy.float64)),numpy.zeros((0,), dtype=numpy.dtype(numpy.float64)),mosek.fusion.Set._make__3I(_4),numpy.zeros((0,), dtype=numpy.dtype(numpy.int64))))
   else:
    _11=(_3.inst)
    if (_11 is None):
     _11 = mosek.fusion.Utils.Tools._range_JJ(0,(long(((_3.ptrb)).shape[0]) - 1))
    _12=numpy.zeros((int((_11).shape[0]),), dtype=numpy.dtype(numpy.int64))
    _13=numpy.zeros((int((_11).shape[0]),), dtype=numpy.dtype(numpy.int64))
    _14=1
    _15=1
    _16=1
    for _17 in range(0,_1):
     _14 *= (_3.shape)._dim_I(_17)
    for _18 in range(_1,_2):
     _15 *= (_3.shape)._dim_I(_18)
    for _19 in range(_2,((_3.shape).nd)):
     _16 *= (_3.shape)._dim_I(_19)
    fragments._c_closure_224(_15,_16,_11,_12,_13) # src/fusion/Expr.mbi:5516:13-5521:14
    _20=mosek.fusion.Utils.Tools._range_JJ(0,long((_11).shape[0]))
    mosek.fusion.CommonTools._argQsort__3J_3J_3JJJ(_20,_12,_13,0,long((_11).shape[0]))
    _21=1
    _21 = fragments._c_closure_225(_12,_21,_20) # src/fusion/Expr.mbi:5530:11-5531:59
    _21 = numpy.int64(_21) # postprocess
    _22=numpy.zeros(((_21 + 1),), dtype=numpy.dtype(numpy.int64))
    _23=numpy.zeros((int(((_3.subj)).shape[0]),), dtype=numpy.dtype(numpy.int64))
    _24=numpy.zeros((int(((_3.cof)).shape[0]),), dtype=numpy.dtype(numpy.float64))
    _25=0
    for _26 in range(0,_21):
     _27=_25
     _28=_12[_20[_25]]
     _25 = fragments._c_closure_226(_25,_28,_12,_20) # src/fusion/Expr.mbi:5542:38-87
     _25 = numpy.int32(_25) # postprocess
     _22[(_26 + 1)] = _22[_26]
     for _29 in range(_27,_25):
      _30=((_3.ptrb)[(_20[_29] + 1)] - (_3.ptrb)[_20[_29]])
      mosek.fusion.Utils.Tools._arraycopy__3JJ_3JJJ((_3.subj),(_3.ptrb)[_20[_29]],_23,_22[(_26 + 1)],_30)
      mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ((_3.cof),(_3.ptrb)[_20[_29]],_24,_22[(_26 + 1)],_30)
      _22[(_26 + 1)] = (_22[(_26 + 1)] + _30)
    _31=None
    if ((_3.bfix) is not None):
     _31 = numpy.zeros((_21,), dtype=numpy.dtype(numpy.float64))
     _32=0
     for _33 in range(0,_21):
      _34=_32
      _35=_12[_20[_32]]
      _32 = fragments._c_closure_227(_32,_35,_12,_20) # src/fusion/Expr.mbi:5563:38-87
      _32 = numpy.int32(_32) # postprocess
      for _36 in range(_34,_32):
       _31[_33] += (_3.bfix)[_20[_36]]
    _38=numpy.zeros(((((_3.shape).nd) - (_2 - _1)),), dtype=numpy.dtype(numpy.int32))
    _39=0
    for _40 in range(0,_1):
     _38[_39] = (_3.shape)._dim_I(_40)
     _39 += 1
    for _41 in range(_2,((_3.shape).nd)):
     _38[_39] = (_3.shape)._dim_I(_41)
     _39 += 1
    _37 = mosek_fusion_NDSet._ctor__3I(_38)
    _42=None
    if (_21 < (_37._size)):
     _42 = numpy.zeros((_21,), dtype=numpy.dtype(numpy.int64))
     _42[0] = _12[_20[0]]
     _43=0
     _43 = fragments._c_closure_228(_43,_12,_21,_20,_42) # src/fusion/Expr.mbi:5584:13-5588:14
     _43 = numpy.int32(_43) # postprocess
    return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_22,(_3.x),_23,_24,_31,_37,_42))
  @staticmethod
  def __sum_1var_alt_Lmosek_4fusion_4Variable_2II(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr.__sum_1var_Lmosek_4fusion_4Variable_2II(_0,numpy.int32(__1),numpy.int32(__2))
  @staticmethod
  def __sum_1var_Lmosek_4fusion_4Variable_2II(_0,_1,_2):
   if ((_1 < 0) or ((_2 <= _1) or (_2 > (_0._shape_().nd)))):
    raise mosek_fusion_DimensionError._ctor_S("The sum-dimension is invalid or out of bounds")
   if ((_0._shape_()._size)==0):
    _3=((_0._shape_().nd) - (_2 - _1))
    if (_3 < 1):
     _3 = 1
    _4=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
    _5=1
    _6=1
    _7=1
    for _8 in range(0,_1):
     _5 *= _0._shape_()._dim_I(_8)
     _4[_8] = _0._shape_()._dim_I(_8)
    for _9 in range(_1,_2):
     _6 *= _0._shape_()._dim_I(_9)
    for _10 in range(_2,(_0._shape_().nd)):
     _7 *= _0._shape_()._dim_I(_10)
     _4[(_10 - _2)] = _0._shape_()._dim_I(_10)
    if ((_1==0) and ((_2==(_0._shape_().nd)) and (_6==0))):
     _4[0] = 1
    if ((_5==0) or (_7==0)):
     return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(numpy.array([0], dtype=numpy.dtype(numpy.int64)),numpy.zeros((0,), dtype=numpy.dtype(object)),numpy.zeros((0,), dtype=numpy.dtype(numpy.int64)),numpy.zeros((0,), dtype=numpy.dtype(numpy.float64)),numpy.zeros((0,), dtype=numpy.dtype(numpy.float64)),mosek.fusion.Set._make__3I(_4),None))
    else:
     return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(numpy.array([0,0], dtype=numpy.dtype(numpy.int64)),numpy.zeros((0,), dtype=numpy.dtype(object)),numpy.zeros((0,), dtype=numpy.dtype(numpy.int64)),numpy.zeros((0,), dtype=numpy.dtype(numpy.float64)),None,mosek.fusion.Set._make__3I(_4),None))
   else:
    _11=((_0._shape_().nd) - (_2 - _1))
    if (_11==0):
     _11 = 1
     _12 = mosek_fusion_IntSet._ctor_I(1)
    else:
     _13=numpy.zeros((_11,), dtype=numpy.dtype(numpy.int32))
     _14=0
     for _15 in range(0,_1):
      _13[_14] = _0._shape_()._dim_I(_15)
      _14 += 1
     for _16 in range(_2,(_0._shape_().nd)):
      _13[_14] = _0._shape_()._dim_I(_16)
      _14 += 1
     if (_11 > 1):
      _12 = mosek_fusion_NDSet._ctor__3I(_13)
     else:
      _12 = mosek_fusion_IntSet._ctor_I(_13[0])
    _17=1
    for _18 in range(_1,_2):
     _17 *= _0._shape_()._dim_I(_18)
    _19=(mosek.fusion.Utils.Tools._range_JJJ(0,((_0._shape_()._size) + 1),_17) if ((_17 > 0) ) else numpy.array([0], dtype=numpy.dtype(numpy.int64)))
    _20=mosek.fusion.Utils.Tools._ones_I(numpy.int32((_0._shape_()._size)))
    _21=None
    _22=1
    _23=1
    _24=1
    for _25 in range(0,_1):
     _22 *= _0._shape_()._dim_I(_25)
    for _26 in range(_1,_2):
     _23 *= _0._shape_()._dim_I(_26)
    for _27 in range(_2,(_0._shape_().nd)):
     _24 *= _0._shape_()._dim_I(_27)
    _28=numpy.array([((((_29 * _23) * _24) + (_31 * _24)) + _30) for _29 in range(0,_22) for _30 in range(0,_24) for _31 in range(0,_23)], dtype=numpy.dtype(numpy.int64))
    return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_19,numpy.array([_0], dtype=numpy.dtype(object)),_28,_20,_21,_12,None))
  @staticmethod
  def _match_sum_Lmosek_4fusion_4Expression_2II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_sum_Lmosek_4fusion_4Expression_2II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _sum_alt_Lmosek_4fusion_4Expression_2II(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._sum_Lmosek_4fusion_4Expression_2II(_0,numpy.int32(__1),numpy.int32(__2))
  @staticmethod
  def _sum_Lmosek_4fusion_4Expression_2II(_0,_1,_2):
   return (mosek.fusion.Expr.__sum_1expr_Lmosek_4fusion_4Expression_2II(_0,_1,_2))
  @staticmethod
  def _match_sum_Lmosek_4fusion_4Expression_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_sum_Lmosek_4fusion_4Expression_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _sum_alt_Lmosek_4fusion_4Expression_2I(_t__0,_t__1):
    return mosek_fusion_Expr._sum_Lmosek_4fusion_4Expression_2I(_0,numpy.int32(__1))
  @staticmethod
  def _sum_Lmosek_4fusion_4Expression_2I(_0,_1):
   if ((_1 < 0) or ((_0._shape_().nd) <= _1)):
    raise mosek_fusion_DimensionError._ctor_S("The sum-dimension is invalid or out of bounds")
   return (mosek.fusion.Expr.__sum_1expr_Lmosek_4fusion_4Expression_2II(_0,_1,(_1 + 1)))
  @staticmethod
  def _match_sum_Lmosek_4fusion_4Variable_2II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_sum_Lmosek_4fusion_4Variable_2II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _sum_alt_Lmosek_4fusion_4Variable_2II(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._sum_Lmosek_4fusion_4Variable_2II(_0,numpy.int32(__1),numpy.int32(__2))
  @staticmethod
  def _sum_Lmosek_4fusion_4Variable_2II(_0,_1,_2):
   return (mosek.fusion.Expr.__sum_1var_Lmosek_4fusion_4Variable_2II(_0,_1,_2))
  @staticmethod
  def _match_sum_Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_sum_Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _sum_alt_Lmosek_4fusion_4Variable_2I(_t__0,_t__1):
    return mosek_fusion_Expr._sum_Lmosek_4fusion_4Variable_2I(_0,numpy.int32(__1))
  @staticmethod
  def _sum_Lmosek_4fusion_4Variable_2I(_0,_1):
   if (_0 is None):
    raise ValueError("Arguments for sum may not be null")
   return (mosek.fusion.Expr.__sum_1var_Lmosek_4fusion_4Variable_2II(_0,_1,(_1 + 1)))
  @staticmethod
  def _match_sum_Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _match_alt_sum_Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _sum_alt_Lmosek_4fusion_4Variable_2(_t__0):
    return mosek_fusion_Expr._sum_Lmosek_4fusion_4Variable_2(_0)
  @staticmethod
  def _sum_Lmosek_4fusion_4Variable_2(_0):
   if (_0 is None):
    raise ValueError("Arguments for sum may not be null")
   return (mosek.fusion.Expr.__sum_1var_Lmosek_4fusion_4Variable_2II(_0,0,(_0._shape_().nd)))
  @staticmethod
  def _match_sum_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _match_alt_sum_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _sum_alt_Lmosek_4fusion_4Expression_2(_t__0):
    return mosek_fusion_Expr._sum_Lmosek_4fusion_4Expression_2(_0)
  @staticmethod
  def _sum_Lmosek_4fusion_4Expression_2(_0):
   if (_0 is None):
    raise ValueError("Arguments for neg may not be null")
   _1=_0._eval_()
   _2=numpy.array([0,long(((_1.cof)).shape[0])], dtype=numpy.dtype(numpy.int64))
   _3=mosek.fusion.Utils.Tools._arraycopy__3J((_1.subj))
   _4=mosek.fusion.Utils.Tools._arraycopy__3D((_1.cof))
   if ((_1.bfix) is not None):
    _6=0.0
    _7=0
    while (_7 < int(((_1.bfix)).shape[0])):
     _6 = (_6 + (_1.bfix)[_7])
     _7 += 1
    _5 = numpy.array([_6], dtype=numpy.dtype(numpy.float64))
   else:
    _5 = None
   return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(_2,(_1.x),_3,_4,_5,None,None,1))
  @staticmethod
  def _match_neg_Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _match_alt_neg_Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _neg_alt_Lmosek_4fusion_4Variable_2(_t__0):
    return mosek_fusion_Expr._neg_Lmosek_4fusion_4Variable_2(_0)
  @staticmethod
  def _neg_Lmosek_4fusion_4Variable_2(_0):
   if (_0 is None):
    raise ValueError("Arguments for neg may not be null")
   _1=mosek.fusion.Utils.Tools._range_J(((_0._shape_()._size) + 1))
   _2=mosek.fusion.Utils.Tools._range_J((_0._shape_()._size))
   _3=numpy.array([(- 1.0) for _4 in range(0,(_0._shape_()._size))], dtype=numpy.dtype(numpy.float64))
   return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(_1,numpy.array([_0], dtype=numpy.dtype(object)),_2,_3,None,_0._shape_(),None,1))
  @staticmethod
  def _match_neg_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _match_alt_neg_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _neg_alt_Lmosek_4fusion_4Expression_2(_t__0):
    return mosek_fusion_Expr._neg_Lmosek_4fusion_4Expression_2(_0)
  @staticmethod
  def _neg_Lmosek_4fusion_4Expression_2(_0):
   if (_0 is None):
    raise ValueError("Arguments for neg may not be null")
   _1=_0._eval_()
   _2=numpy.array([(- (_1.cof)[_3]) for _3 in range(0,int(((_1.cof)).shape[0]))], dtype=numpy.dtype(numpy.float64))
   _4=(None if (((_1.bfix) is None) ) else numpy.array([(- (_1.bfix)[_5]) for _5 in range(0,int(((_1.bfix)).shape[0]))], dtype=numpy.dtype(numpy.float64)))
   return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI((_1.ptrb),(_1.x),(_1.subj),_2,_4,(_1.shape),(_1.inst),1))
  @staticmethod
  def __mul_1_1_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr.__mul_1_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def __mul_1_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1):
   _2=_0
   _3=_1
   if ((_1._shape_().nd) > 2):
    raise mosek_fusion_DimensionError._ctor_S("Expression operand must have 1 or 2 dimensions")
   if (_1._shape_()._dim_I(0)!=(_2._dimj)):
    raise mosek_fusion_DimensionError._ctor_S("Dimensions of operands do not match")
   _4=_1._eval_()
   _6=(_4.shape)._dim_I(0)
   _7=1
   _8=1
   if (((_4.shape).nd)==2):
    _7 = (_4.shape)._dim_I(1)
    _8 = 2
    _5 = mosek_fusion_NDSet._ctor_II((_2._dimi),_7)
   else:
    _5 = mosek_fusion_IntSet._ctor_I((_2._dimi))
   _11=_2
   if   isinstance(_11,mosek_fusion_DenseMatrix):
    m=_11
    if ((_4.inst) is None):
     _11=((m._dimi) * _7)
     _12=numpy.zeros(((_11 + 1),), dtype=numpy.dtype(numpy.int64))
     _13=numpy.zeros((((_4.nnz) * (m._dimi)),), dtype=numpy.dtype(numpy.int64))
     _14=numpy.zeros((((_4.nnz) * (m._dimi)),), dtype=numpy.dtype(numpy.float64))
     _15=(None if (((_4.bfix) is None) ) else numpy.zeros((_11,), dtype=numpy.dtype(numpy.float64)))
     _16=1
     _17=0
     while (_17 < (m._dimi)):
      _18=0
      while (_18 < _7):
       _19=_12[(_16 - 1)]
       _20=0
       while (_20 < _6):
        _21=((_20 * _7) + _18)
        _22=((_4.ptrb)[(_21 + 1)] - (_4.ptrb)[_21])
        _23=(m._data)[((_17 * (m._dimj)) + _20)]
        _24=0
        while (_24 < _22):
         _14[(_19 + _24)] = ((_4.cof)[((_4.ptrb)[_21] + _24)] * _23)
         _13[(_19 + _24)] = (_4.subj)[((_4.ptrb)[_21] + _24)]
         _24 += 1
        _19 = (_19 + _22)
        if ((_4.bfix) is not None):
         _15[(_16 - 1)] = (_15[(_16 - 1)] + ((_4.bfix)[_21] * _23))
        _20 += 1
       _12[_16] = _19
       _16 += 1
       _18 += 1
      _17 += 1
     _9 = mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_12,(_4.x),_13,_14,_15,_5,None)
    else:
     _25=int(((_4.inst)).shape[0])
     _26=numpy.zeros((_25,), dtype=numpy.dtype(numpy.int32))
     _27=numpy.zeros((_25,), dtype=numpy.dtype(numpy.int32))
     _28=mosek.fusion.Utils.Tools._range_J(long(((_4.inst)).shape[0]))
     _29=0
     while (_29 < _25):
      _26[_29] = numpy.int32(((_4.inst)[_29] // _7))
      _27[_29] = numpy.int32(((_4.inst)[_29] - _26[_29]))
      _29 += 1
     mosek.fusion.Utils.Tools._argsort__3J_3I_3IJJ(_28,_27,_26,0,_25)
     _30=0
     _30 = fragments._c_closure_229(_27,_25,_30,_28) # src/fusion/Expr.mbi:5010:13-5014:14
     _30 = numpy.int32(_30) # postprocess
     _31=(_30 * (m._dimi))
     _32=numpy.zeros(((_31 + 1),), dtype=numpy.dtype(numpy.int64))
     _33=numpy.zeros((((_4.nnz) * (m._dimi)),), dtype=numpy.dtype(numpy.int64))
     _34=numpy.zeros((((_4.nnz) * (m._dimi)),), dtype=numpy.dtype(numpy.float64))
     _35=(None if (((_4.bfix) is None) ) else numpy.zeros((_31,), dtype=numpy.dtype(numpy.float64)))
     _36=(None if ((_30 >= _7) ) else numpy.zeros((_31,), dtype=numpy.dtype(numpy.int64)))
     _37=0
     _38=0
     while (_38 < (m._dimi)):
      _39=numpy.int64(((m._dimj) * _38))
      _40=0
      while (_40 < _25):
       if ((_40==0) or (_27[_28[_40]] > _27[_28[(_40 - 1)]])):
        _37 += 1
        _32[_37] = _32[(_37 - 1)]
        if (_36 is not None):
         _36[(_37 - 1)] = ((numpy.int64(_38) * _7) + _27[_28[_40]])
       _41=(_4.ptrb)[_28[_40]]
       _42=((_4.ptrb)[(_28[_40] + 1)] - _41)
       _43=(m._data)[(_39 + _26[_28[_40]])]
       _44=0
       while (_44 < _42):
        _33[(_32[_37] + _44)] = (_4.subj)[(_41 + _44)]
        _34[(_32[_37] + _44)] = ((_4.cof)[(_41 + _44)] * _43)
        _44 += 1
       if (_35 is not None):
        _35[(_37 - 1)] = (_35[(_37 - 1)] + ((_4.bfix)[_28[_40]] * _43))
       if (_36 is not None):
        _36[(_37 - 1)] = numpy.int64(_27[_28[_40]])
       _32[_37] = (_32[_37] + _42)
       _40 += 1
      _38 += 1
     _9 = mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_32,(_4.x),_33,_34,_35,_5,_36)
   else:
    m=_11
    _45=m._numNonzeros_()
    _46=numpy.zeros((_45,), dtype=numpy.dtype(numpy.int32))
    _47=numpy.zeros((_45,), dtype=numpy.dtype(numpy.int32))
    _48=numpy.zeros((_45,), dtype=numpy.dtype(numpy.float64))
    m._getDataAsTriplets__3I_3I_3D(_46,_47,_48)
    if ((_4.inst) is None):
     _49=1
     _49 = fragments._c_closure_230(_46,_49,_45) # src/fusion/Expr.mbi:5082:13-85
     _49 = numpy.int64(_49) # postprocess
     _50=(_49 * _7)
     _51=numpy.zeros(((_50 + 1),), dtype=numpy.dtype(numpy.int64))
     _52=0
     _53=_46[0]
     _54=0
     for _55 in range(0,_45):
      if (_53 < _46[_55]):
       _54 = (_54 + _7)
       _53 = _46[_55]
      for _56 in range(0,_7):
       _57=((_47[_55] * _7) + _56)
       _58=((_4.ptrb)[(_57 + 1)] - (_4.ptrb)[_57])
       _52 = (_52 + _58)
       _51[((_54 + _56) + 1)] = (_51[((_54 + _56) + 1)] + _58)
     _59=numpy.zeros((_52,), dtype=numpy.dtype(numpy.int64))
     _60=numpy.zeros((_52,), dtype=numpy.dtype(numpy.float64))
     _61=(None if (((_4.bfix) is None) ) else numpy.zeros((_50,), dtype=numpy.dtype(numpy.float64)))
     fragments._c_closure_231(_50,_51) # src/fusion/Expr.mbi:5113:13-85
     _62=(None if ((_49 >= (m._dimi)) ) else numpy.zeros((_50,), dtype=numpy.dtype(numpy.int64)))
     _63=0
     _64=_46[0]
     _65=0
     while (_65 < _45):
      _66=_48[_65]
      if (_64 < _46[_65]):
       _63 = (_63 + _7)
       _64 = _46[_65]
      _67=0
      while (_67 < _7):
       _68=((_47[_65] * _7) + _67)
       _69=((_4.ptrb)[(_68 + 1)] - (_4.ptrb)[_68])
       _70=0
       while (_70 < _69):
        _60[(_51[(_63 + _67)] + _70)] = ((_4.cof)[((_4.ptrb)[_68] + _70)] * _66)
        _59[(_51[(_63 + _67)] + _70)] = (_4.subj)[((_4.ptrb)[_68] + _70)]
        _70 += 1
       if (_61 is not None):
        _61[(_63 + _67)] = (_61[(_63 + _67)] + ((_4.bfix)[_68] * _66))
       _51[(_63 + _67)] = (_51[(_63 + _67)] + _69)
       if (_62 is not None):
        _62[(_63 + _67)] = numpy.int64(((_46[_65] * _7) + _67))
       _67 += 1
      _65 += 1
     fragments._c_closure_232(_51) # src/fusion/Expr.mbi:5161:13-5162:35
     _51[0] = 0
     _9 = mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_51,(_4.x),_59,_60,_61,_5,_62)
    else:
     _71=_2._numNonzeros_()
     _72=int(((_4.inst)).shape[0])
     _73=numpy.zeros((_72,), dtype=numpy.dtype(numpy.int32))
     _74=numpy.zeros((_72,), dtype=numpy.dtype(numpy.int32))
     _75=mosek.fusion.Utils.Tools._range_J(long(((_4.inst)).shape[0]))
     _76=0
     while (_76 < _72):
      _73[_76] = numpy.int32(((_4.inst)[_76] // _7))
      _74[_76] = numpy.int32(((_4.inst)[_76] - _73[_76]))
      _76 += 1
     mosek.fusion.Utils.Tools._argsort__3J_3I_3IJJ(_75,_74,_73,0,_72)
     _77=0
     _78=0
     _79=0
     while (_79 < _71):
      _80=_79
      _80 = fragments._c_closure_233(_71,_80,_79,_46) # src/fusion/Expr.mbi:5189:50-145
      _80 = numpy.int32(_80) # postprocess
      _81=_46[_79]
      _82=_74[_75[0]]
      _83=0
      while (_83 < _72):
       _84 = fragments._c_closure_234(_74,_72,_75,_84,_83) # src/fusion/Expr.mbi:5200:21-5203:23
       _84 = numpy.int32(_84) # postprocess
       _85=_79
       _86=_83
       _87=_78
       while ((_85 < _80) and (_86 < _84)):
        if (_47[_85] < _73[_75[_86]]):
         _85 += 1
        elif (_47[_85] > _73[_75[_86]]):
         _86 += 1
        else:
         _78 = (_78 + ((_4.ptrb)[(_75[_86] + 1)] - (_4.ptrb)[_75[_86]]))
         _86 += 1
         _85 += 1
       if (_87 < _78):
        _77 += 1
       _83 = _84
      _79 = _80
     _88=numpy.zeros(((_77 + 1),), dtype=numpy.dtype(numpy.int64))
     _89=numpy.zeros((_78,), dtype=numpy.dtype(numpy.int64))
     _90=numpy.zeros((_78,), dtype=numpy.dtype(numpy.float64))
     _91=numpy.zeros((_77,), dtype=numpy.dtype(numpy.int64))
     _92=(None if (((_4.bfix) is None) ) else numpy.zeros((_77,), dtype=numpy.dtype(numpy.float64)))
     _93=0
     _94=0
     _95=0
     _96=0
     while (_96 < _71):
      _97=_96
      _97 = fragments._c_closure_235(_71,_97,_96,_46) # src/fusion/Expr.mbi:5252:50-145
      _97 = numpy.int32(_97) # postprocess
      _98=_46[_96]
      _99=_74[_75[0]]
      _100=0
      while (_100 < _72):
       _101 = fragments._c_closure_236(_74,_72,_75,_101,_100) # src/fusion/Expr.mbi:5260:21-5263:23
       _101 = numpy.int32(_101) # postprocess
       _102=_96
       _103=_100
       _104=_94
       while ((_102 < _97) and (_103 < _101)):
        if (_47[_102] < _73[_75[_103]]):
         _102 += 1
        elif (_47[_102] > _73[_75[_103]]):
         _103 += 1
        else:
         _105=(_4.ptrb)[_75[_103]]
         _106=((_4.ptrb)[(_75[_103] + 1)] - _105)
         mosek.fusion.Utils.Tools._arraycopy__3JJ_3JJJ((_4.subj),(_4.ptrb)[_75[_103]],_89,_94,_106)
         _107=0
         while (_107 < _106):
          _90[(_94 + _107)] = ((_4.cof)[(_105 + _107)] * _48[_102])
          _107 += 1
         if (_92 is not None):
          _92[_95] = (_92[_95] + ((_4.bfix)[_75[_103]] * _48[_102]))
         _94 = (_94 + _106)
         _103 += 1
         _102 += 1
       if (_104 < _94):
        _91[_95] = (numpy.int64((_46[_96] * _7)) + _74[_75[_100]])
        _95 += 1
        _88[_95] = _94
       _100 = _101
      _96 = _97
     _9 = mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_88,(_4.x),_89,_90,_92,_5,_91)
   return (_9)
  @staticmethod
  def __sparseMatrixVector_alt__3J_3I_3D_3D_3DI(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.float64))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=numpy.int32(_t__5)
   _1 = mosek_fusion_Expr.__sparseMatrixVector__3J_3I_3D_3D_3DI(_0,_1,_2,_3,_4,_5)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __sparseMatrixVector__3J_3I_3D_3D_3DI(_0,_1,_2,_3,_4,_5):
   fragments._c_closure_237(_2,_0,_1,_3,_5,_4) # src/fusion/Expr.mbi:4890:7-4904:8
  @staticmethod
  def __sparseMatmul_alt__3J_3I_3D_3J_3I_3D_3J_3I_3DII_3I(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7,_t__8,_t__9,_t__10,_t__11):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int64))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int32))
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.float64))
   _6=numpy.array(_t__6,dtype=numpy.dtype(numpy.int64))
   _7=numpy.array(_t__7,dtype=numpy.dtype(numpy.int32))
   _8=numpy.array(_t__8,dtype=numpy.dtype(numpy.float64))
   _9=numpy.int32(_t__9)
   _10=numpy.int32(_t__10)
   _11=numpy.array(_t__11,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Expr.__sparseMatmul__3J_3I_3D_3J_3I_3D_3J_3I_3DII_3I(_0,_1,_2,_3,_4,_5,_6,_7,_8,_9,_10,_11)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__6[:] = _6
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__7[:] = _7
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__8[:] = _8
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__11[:] = _11
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __sparseMatmul__3J_3I_3D_3J_3I_3D_3J_3I_3DII_3I(_0,_1,_2,_3,_4,_5,_6,_7,_8,_9,_10,_11):
   _12=0
   _13=0
   _14=numpy.zeros((_10,), dtype=numpy.dtype(numpy.float64))
   fragments._c_closure_238(_10,_11,_14) # src/fusion/Expr.mbi:4839:9-4843:10
   _15=0
   while (_15 < _9):
    _13 = _12
    _12 = fragments._c_closure_239(_5,_3,_15,_4,_8,_6,_7,_1,_11,_12,_13,_14) # src/fusion/Expr.mbi:4850:11-4871:12
    _12 = numpy.int32(_12) # postprocess
    mosek.fusion.Utils.Tools._sort__3III(_1,_13,_12)
    fragments._c_closure_240(_2,_1,_12,_13,_14) # src/fusion/Expr.mbi:4874:11-4878:12
    _15 += 1
  @staticmethod
  def __computeNz_alt__3J_3I_3J_3III_3I_3J(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.int32(_t__4)
   _5=numpy.int32(_t__5)
   _6=numpy.array(_t__6,dtype=numpy.dtype(numpy.int32))
   _7=numpy.array(_t__7,dtype=numpy.dtype(numpy.int64))
   _1 = mosek_fusion_Expr.__computeNz__3J_3I_3J_3III_3I_3J(_0,_1,_2,_3,_4,_5,_6,_7)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__6[:] = _6
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__7[:] = _7
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __computeNz__3J_3I_3J_3III_3I_3J(_0,_1,_2,_3,_4,_5,_6,_7):
   _8=0
   _9=0
   fragments._c_closure_241(_5,_6) # src/fusion/Expr.mbi:4788:10-4791:11
   _9,_8 = fragments._c_closure_242(_0,_1,_2,_3,_7,_6,_9,_8,_4) # src/fusion/Expr.mbi:4793:10-4813:11
   _9 = numpy.int32(_9) # postprocess
   _8 = numpy.int64(_8) # postprocess
   _7[_4] = _8
   return numpy.int64(_8)
  @staticmethod
  def _match_mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _mulDiag_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_0,_1)
  @staticmethod
  def _mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_0,_1):
   if ((_0 is None) or (_1 is None)):
    raise ValueError("Arguments for mulDiag may not be null")
   _2=_0
   _3=_1
   if (((_2._shape_().nd)!=2) or (((_3._dimj)!=_2._shape_()._dim_I(0)) or ((_3._dimi)!=_2._shape_()._dim_I(1)))):
    raise mosek_fusion_DimensionError._ctor_S("Mismatching dimensions of operands")
   _4=numpy.int64((_3._dimj))
   _6=_3
   if   isinstance(_6,mosek_fusion_DenseMatrix):
    m=_6
    _6=(_4 * (m._dimi))
    _7=mosek.fusion.Utils.Tools._range_JJJ(0,(_4 * (1 + _4)),_4)
    _8=mosek.fusion.Utils.Tools._range_JJ(0,_6)
    _9=numpy.zeros((_6,), dtype=numpy.dtype(numpy.float64))
    _10=0
    _11=0
    while (_11 < (m._dimj)):
     _12=0
     while (_12 < (m._dimi)):
      _9[_10] = (m._data)[((_12 * _4) + _11)]
      _10 += 1
      _12 += 1
     _11 += 1
    return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(_7,numpy.array([_0], dtype=numpy.dtype(object)),_8,_9,None,None,None,1))
   else:
    m=_6
    _13=m._numNonzeros_()
    _14=numpy.zeros(((_4 + 1),), dtype=numpy.dtype(numpy.int64))
    _15=numpy.zeros((_13,), dtype=numpy.dtype(numpy.int64))
    _16=numpy.zeros((_13,), dtype=numpy.dtype(numpy.float64))
    _17=numpy.zeros((_13,), dtype=numpy.dtype(numpy.int32))
    _18=numpy.zeros((_13,), dtype=numpy.dtype(numpy.int32))
    _19=numpy.zeros((_13,), dtype=numpy.dtype(numpy.float64))
    m._getDataAsTriplets__3I_3I_3D(_17,_18,_19)
    _20=0
    while (_20 < _13):
     _14[(_18[_20] + 1)] += 1
     _20 += 1
    fragments._c_closure_243(_4,_14) # src/fusion/Expr.mbi:4752:11-77
    _21=0
    while (_21 < _13):
     _22=_14[_18[_21]]
     _16[_22] = _19[_21]
     _15[_22] = numpy.int64(((_18[_21] * (m._dimi)) + _17[_21]))
     _14[_18[_21]] += 1
     _21 += 1
    fragments._c_closure_244(_4,_14) # src/fusion/Expr.mbi:4761:11-63
    _14[0] = 0
    return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(_14,numpy.array([_0], dtype=numpy.dtype(object)),_15,_16,None,None,None,1))
  @staticmethod
  def _match_mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _mulDiag_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def _mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_0,_1):
   if ((_1 is None) or (_0 is None)):
    raise ValueError("Arguments for mulDiag may not be null")
   _2=_0
   _3=_1
   if (((_3._shape_().nd)!=2) or (((_2._dimj)!=_3._shape_()._dim_I(0)) or ((_2._dimi)!=_3._shape_()._dim_I(1)))):
    raise mosek_fusion_DimensionError._ctor_S("Mismatching dimensions of operands")
   _5=_2
   if   isinstance(_5,mosek_fusion_DenseMatrix):
    m=_5
    _5=mosek.fusion.Utils.Tools._range_JJJ(0,numpy.int64(((m._dimj) * (1 + (m._dimi)))),numpy.int64((m._dimj)))
    _6=numpy.zeros((((m._dimi) * (m._dimj)),), dtype=numpy.dtype(numpy.int64))
    _7=numpy.array([(numpy.int64(_8) + ((m._dimi) * _9)) for _8 in range(0,(m._dimi)) for _9 in range(0,(m._dimj))], dtype=numpy.dtype(numpy.int64))
    _10=(m._data)
    return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(_5,numpy.array([_1], dtype=numpy.dtype(object)),_7,_10,None,None,None,1))
   elif isinstance(_5,mosek_fusion_SparseMatrix):
    _11=_5
    _12=numpy.zeros((((_11._dimi) + 1),), dtype=numpy.dtype(numpy.int64))
    _13=numpy.array([numpy.int64((((_11._subj)[_14] * (_11._dimi)) + (_11._subi)[_14])) for _14 in range(0,(_11._nnz))], dtype=numpy.dtype(numpy.int64))
    _15=(_11._val)
    _16=(_11._nnz)
    for _17 in range(0,_16):
     _12[((_11._subi)[_17] + 1)] += 1
    for _18 in range(0,(_11._dimi)):
     _12[(_18 + 1)] = (_12[_18] + _12[(_18 + 1)])
    return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(_12,numpy.array([_1], dtype=numpy.dtype(object)),_13,_15,None,None,None,1))
   else:
    m=_5
    raise mosek_fusion_MatrixError._ctor_S("Unknown matrix type used.")
  @staticmethod
  def _match_mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _mulDiag_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,_1)
  @staticmethod
  def _mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,_1):
   if ((_1 is None) or (_0 is None)):
    raise ValueError("Arguments for mulDiag may not be null")
   _2=_0
   _3=_1
   _5=_2._eval_()
   if (((_5.shape).nd)!=2):
    raise mosek_fusion_DimensionError._ctor_S("Expression operand must have 2 dimensions")
   if (((_5.shape)._dim_I(0)!=(_3._dimj)) or ((_5.shape)._dim_I(1)!=(_3._dimi))):
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
   _6=(_5.shape)._dim_I(0)
   _7=(_5.shape)._dim_I(1)
   _9=_3
   if   isinstance(_9,mosek_fusion_DenseMatrix):
    m=_9
    if ((_5.inst) is None):
     _9=numpy.zeros(((_6 + 1),), dtype=numpy.dtype(numpy.int64))
     _10=numpy.zeros(((_5.nnz),), dtype=numpy.dtype(numpy.int64))
     _11=numpy.zeros(((_5.nnz),), dtype=numpy.dtype(numpy.float64))
     _12=(None if (((_5.bfix) is None) ) else numpy.zeros((_6,), dtype=numpy.dtype(numpy.float64)))
     _13=None
     _14=None
     _15=0
     for _16 in range(0,_6):
      _9[(_16 + 1)] = _9[_16]
      for _17 in range(0,_7):
       _18=((_5.ptrb)[(_15 + 1)] - (_5.ptrb)[_15])
       _19=(m._data)[((_17 * _6) + _16)]
       mosek.fusion.Utils.Tools._arraycopy__3JJ_3JJJ((_5.subj),(_5.ptrb)[_15],_10,_9[(_16 + 1)],_18)
       for _20 in range(0,_18):
        _11[(_9[(_16 + 1)] + _20)] = (_19 * (_5.cof)[((_5.ptrb)[_15] + _20)])
       if (_12 is not None):
        _12[_16] += (_19 * (_5.bfix)[_15])
       _9[(_16 + 1)] = (_9[(_16 + 1)] + _18)
       _15 += 1
     _4 = mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_9,(_5.x),_10,_11,_12,_14,_13)
    else:
     _21=0
     _22=(- 1)
     for _23 in range(0,int(((_5.inst)).shape[0])):
      _24=((_5.inst)[_23] // numpy.int64(_7))
      if (_22 < _24):
       _22 = _24
       _21 += 1
     _25=numpy.zeros(((_21 + 1),), dtype=numpy.dtype(numpy.int64))
     _26=numpy.zeros(((_5.nnz),), dtype=numpy.dtype(numpy.int64))
     _27=numpy.zeros(((_5.nnz),), dtype=numpy.dtype(numpy.float64))
     _28=(None if (((_5.bfix) is None) ) else numpy.zeros((_21,), dtype=numpy.dtype(numpy.float64)))
     _29=(None if ((_21 >= _6) ) else numpy.zeros((_21,), dtype=numpy.dtype(numpy.int64)))
     _30=mosek_fusion_IntSet._ctor_I(_6)
     _31=(- 1)
     _32=0
     _33=0
     while (_33 < int(((_5.inst)).shape[0])):
      _34=((_5.inst)[_33] // numpy.int64(_7))
      _35=((_5.inst)[_33] - (_34 * numpy.int64(_7)))
      if (_31 < _34):
       _31 = _34
       if (_29 is not None):
        _29[_32] = _34
       _32 += 1
       _25[_32] = _25[(_32 - 1)]
      _36=((_5.ptrb)[(_33 + 1)] - (_5.ptrb)[_33])
      mosek.fusion.Utils.Tools._arraycopy__3JJ_3JJJ((_5.subj),(_5.ptrb)[_33],_26,_25[_32],_36)
      _37=(m._data)[((_35 * _6) + _34)]
      for _38 in range(0,_36):
       _27[(_25[_32] + _38)] = (_37 * (_5.cof)[((_5.ptrb)[_33] + _38)])
      if (_28 is not None):
       _28[(_32 - 1)] += (_37 * (_5.bfix)[_33])
      _25[_32] = (_25[_32] + _36)
      _33 += 1
     _4 = mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_25,(_5.x),_26,_27,_28,_30,_29)
   else:
    m=_9
    _39=m._numNonzeros_()
    _40=numpy.zeros((_39,), dtype=numpy.dtype(numpy.int32))
    _41=numpy.zeros((_39,), dtype=numpy.dtype(numpy.int32))
    _42=numpy.zeros((_39,), dtype=numpy.dtype(numpy.float64))
    _43=mosek.fusion.Utils.Tools._range_J(numpy.int64(_39))
    m._getDataAsTriplets__3I_3I_3D(_40,_41,_42)
    mosek.fusion.Utils.Tools._argsort__3J_3I_3IJJ(_43,_41,_40,0,_39)
    if ((_5.inst) is None):
     _44=0
     _45=0
     _46=(- 1)
     _47=0
     while (_47 < _39):
      if (_46 < _41[_43[_47]]):
       _44 += 1
       _46 = _41[_43[_47]]
      _48=((_41[_43[_47]] * (m._dimi)) + _40[_43[_47]])
      _45 = (_45 + ((_5.ptrb)[(_48 + 1)] - (_5.ptrb)[_48]))
      _47 += 1
     _49=numpy.zeros(((_44 + 1),), dtype=numpy.dtype(numpy.int64))
     _50=numpy.zeros((_45,), dtype=numpy.dtype(numpy.int64))
     _51=numpy.zeros((_45,), dtype=numpy.dtype(numpy.float64))
     _52=(None if (((_5.bfix) is None) ) else numpy.zeros((_44,), dtype=numpy.dtype(numpy.float64)))
     _53=(None if ((_44 >= (m._dimj)) ) else numpy.zeros((_44,), dtype=numpy.dtype(numpy.int64)))
     _54=mosek_fusion_IntSet._ctor_I((m._dimj))
     _55=(- 1)
     _56=0
     for _57 in range(0,_39):
      if (_55 < _41[_43[_57]]):
       _55 = _41[_43[_57]]
       if (_53 is not None):
        _53[_56] = _55
       _56 += 1
       _49[_56] = _49[(_56 - 1)]
      _58=((_41[_43[_57]] * (m._dimi)) + _40[_43[_57]])
      _59=((_5.ptrb)[(_58 + 1)] - (_5.ptrb)[_58])
      mosek.fusion.Utils.Tools._arraycopy__3JJ_3JJJ((_5.subj),(_5.ptrb)[_58],_50,_49[_56],_59)
      for _60 in range(0,_59):
       _51[(_49[_56] + _60)] = ((_5.cof)[((_5.ptrb)[_58] + _60)] * _42[_43[_57]])
      if (_52 is not None):
       _52[_55] += ((_5.bfix)[_58] * _42[_43[_57]])
      _49[_56] = (_49[_56] + _59)
     _4 = mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_49,(_5.x),_50,_51,_52,_54,_53)
    else:
     _61=0
     _62=0
     _63=0
     _64=0
     _65=(- 1)
     while ((_63 < int(((_5.inst)).shape[0])) and (_64 < _39)):
      _66=((_5.inst)[_63] // _7)
      _67=((_5.inst)[_63] - (_66 * _7))
      if (_66 < _41[_43[_64]]):
       _63 += 1
      elif (_66 > _41[_43[_64]]):
       _64 += 1
      elif (_67 < _40[_43[_64]]):
       _63 += 1
      elif (_67 > _40[_43[_64]]):
       _64 += 1
      else:
       if (_65 < _66):
        _61 += 1
        _65 = _66
       _62 = (_62 + ((_5.ptrb)[(_63 + 1)] - (_5.ptrb)[_63]))
       _63 += 1
       _64 += 1
     _68=numpy.zeros(((_61 + 1),), dtype=numpy.dtype(numpy.int64))
     _69=numpy.zeros((_62,), dtype=numpy.dtype(numpy.int64))
     _70=numpy.zeros((_62,), dtype=numpy.dtype(numpy.float64))
     _71=(None if (((_5.bfix) is None) ) else numpy.zeros((_61,), dtype=numpy.dtype(numpy.float64)))
     _72=(None if ((_61 >= _6) ) else numpy.zeros((_61,), dtype=numpy.dtype(numpy.int64)))
     _73=mosek_fusion_IntSet._ctor_I(_6)
     _74=0
     _75=0
     _76=(- 1)
     _77=0
     while ((_74 < int(((_5.inst)).shape[0])) and (_75 < _39)):
      _78=((_5.inst)[_74] // numpy.int64(_7))
      _79=((_5.inst)[_74] - (_78 * numpy.int64(_7)))
      if (_78 < _41[_43[_75]]):
       _74 += 1
      elif (_78 > _41[_43[_75]]):
       _75 += 1
      elif (_79 < _40[_43[_75]]):
       _74 += 1
      elif (_79 > _40[_43[_75]]):
       _75 += 1
      else:
       if (_76 < _78):
        if (_72 is not None):
         _72[_77] = _78
        _77 += 1
        _68[_77] = _68[(_77 - 1)]
        _76 = _78
       _80=((_5.ptrb)[(_74 + 1)] - (_5.ptrb)[_74])
       _81=_42[_43[_75]]
       mosek.fusion.Utils.Tools._arraycopy__3JJ_3JJJ((_5.subj),(_5.ptrb)[_74],_69,_68[_77],_80)
       _82=0
       while (_82 < _80):
        _70[(_68[_77] + _82)] = (_81 * (_5.cof)[((_5.ptrb)[_74] + _82)])
        _82 += 1
       if (_71 is not None):
        _71[(_77 - 1)] = (_71[(_77 - 1)] + (_81 * (_5.bfix)[_74]))
       _68[_77] = (_68[_77] + _80)
       _74 += 1
       _75 += 1
     _4 = mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_68,(_5.x),_69,_70,_71,_73,_72)
   return (_4)
  @staticmethod
  def _match_mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _mulDiag_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1):
   if ((_0 is None) or (_1 is None)):
    raise ValueError("Arguments for mulDiag may not be null")
   _2=_0
   _3=_1
   _5=_3._eval_()
   if (((_5.shape).nd)!=2):
    raise mosek_fusion_DimensionError._ctor_S("Expression operand must have 2 dimensions")
   if (((_5.shape)._dim_I(0)!=(_2._dimj)) or ((_5.shape)._dim_I(1)!=(_2._dimi))):
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
   _6=(_5.shape)._dim_I(0)
   _7=(_5.shape)._dim_I(1)
   if ((_5.inst) is not None):
    _8 = numpy.zeros(((long(((_5.ptrb)).shape[0]) - 1),), dtype=numpy.dtype(numpy.int64))
    _9 = mosek.fusion.Utils.Tools._range_J(long((_8).shape[0]))
    for _10 in range(0,int((_8).shape[0])):
     _11=((_5.inst)[_10] // numpy.int64(_7))
     _12=((_5.inst)[_10] % numpy.int64(_7))
     _8[_10] = ((_12 * _6) + _11)
    mosek.fusion.CommonTools._argQsort__3J_3J_3JJJ(_9,_8,None,0,long((_9).shape[0]))
   else:
    _8 = numpy.array([((numpy.int64((_13 % _7)) * _6) + (_13 // _7)) for _13 in range(0,(int(((_5.ptrb)).shape[0]) - 1))], dtype=numpy.dtype(numpy.int64))
    _9 = numpy.array([((numpy.int64((_14 % _6)) * _7) + (_14 // _6)) for _14 in range(0,(int(((_5.ptrb)).shape[0]) - 1))], dtype=numpy.dtype(numpy.int64))
   _16=_2
   if   isinstance(_16,mosek_fusion_DenseMatrix):
    m=_16
    _16=0
    if ((_5.inst) is None):
     _16 = numpy.int64(_7)
    else:
     _17=(- 1)
     for _18 in range(0,int((_8).shape[0])):
      _19=numpy.int32((_8[_9[_18]] // numpy.int64((m._dimj))))
      if (_19 > _17):
       _16 += 1
       _17 = _19
    _20=long(((_5.subj)).shape[0])
    _21=numpy.zeros(((_16 + 1),), dtype=numpy.dtype(numpy.int64))
    _22=numpy.zeros((_20,), dtype=numpy.dtype(numpy.int64))
    _23=numpy.zeros((_20,), dtype=numpy.dtype(numpy.float64))
    _24=None
    _25=numpy.zeros((_16,), dtype=numpy.dtype(numpy.int64))
    _26=(- 1)
    _27=0
    for _28 in range(0,int((_8).shape[0])):
     _29=numpy.int32((_8[_9[_28]] // numpy.int64(_6)))
     if (_29 > _26):
      _27 += 1
      _26 = _29
      _21[_27] = _21[(_27 - 1)]
      _25[(_27 - 1)] = numpy.int64(_29)
     _30=((_5.ptrb)[(_9[_28] + 1)] - (_5.ptrb)[_9[_28]])
     for _31 in range(0,_30):
      _22[(_21[_27] + _31)] = (_5.subj)[((_5.ptrb)[_9[_28]] + _31)]
      _23[(_21[_27] + _31)] = ((_5.cof)[((_5.ptrb)[_9[_28]] + _31)] * (m._data)[_8[_9[_28]]])
     _21[_27] = (_21[_27] + _30)
    if ((_5.bfix) is not None):
     _32=(- 1)
     _33=0
     _24 = numpy.zeros((_16,), dtype=numpy.dtype(numpy.float64))
     for _34 in range(0,int((_8).shape[0])):
      _35=numpy.int32((_8[_9[_34]] // numpy.int64((m._dimj))))
      if (_35 > _32):
       _33 += 1
       _32 = _35
      _24[(_33 - 1)] += ((m._data)[_8[_9[_34]]] * (_5.bfix)[_9[_34]])
    _4 = mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_21,(_5.x),_22,_23,_24,None,(_25 if ((int((_25).shape[0]) < (m._dimi)) ) else None))
   else:
    m=_16
    _36=numpy.zeros((m._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
    _37=numpy.zeros((m._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
    _38=numpy.zeros((m._numNonzeros_(),), dtype=numpy.dtype(numpy.float64))
    _39=m._numNonzeros_()
    _40=m._numRows_()
    _41=m._numColumns_()
    m._getDataAsTriplets__3I_3I_3D(_36,_37,_38)
    _42=0
    _43=0
    _44=(- 1)
    _45=0
    _46=0
    while ((_45 < _39) and (_46 < int((_8).shape[0]))):
     _47=((_36[_45] * _41) + _37[_45])
     if (_47 < _8[_9[_46]]):
      _45 += 1
     elif (_47 > _8[_9[_46]]):
      _46 += 1
     else:
      if (_44 < _36[_45]):
       _44 = _36[_45]
       _42 += 1
      _43 = (_43 + ((_5.ptrb)[(_9[_46] + 1)] - (_5.ptrb)[_9[_46]]))
      _46 += 1
      _45 += 1
    _48=numpy.zeros(((_42 + 1),), dtype=numpy.dtype(numpy.int64))
    _49=numpy.zeros((_43,), dtype=numpy.dtype(numpy.int64))
    _50=numpy.zeros((_43,), dtype=numpy.dtype(numpy.float64))
    _51=None
    _52=numpy.zeros((_42,), dtype=numpy.dtype(numpy.int64))
    _53=(- 1)
    _54=0
    _55=0
    _56=0
    while ((_54 < _39) and (_55 < int((_8).shape[0]))):
     _57=((_36[_54] * _41) + _37[_54])
     if (_57 < _8[_9[_55]]):
      _54 += 1
     elif (_57 > _8[_9[_55]]):
      _55 += 1
     else:
      if (_53 < _36[_54]):
       _53 = _36[_54]
       _56 += 1
       _52[(_56 - 1)] = numpy.int64(_53)
       _48[_56] = _48[(_56 - 1)]
      _58=((_5.ptrb)[(_9[_55] + 1)] - (_5.ptrb)[_9[_55]])
      for _59 in range(0,_58):
       _49[(_48[_56] + _59)] = (_5.subj)[((_5.ptrb)[_9[_55]] + _59)]
       _50[_48[(_56 + _59)]] = ((_5.cof)[((_5.ptrb)[_9[_55]] + _59)] * _38[_54])
      _48[_56] = (_48[_56] + _58)
      _55 += 1
      _54 += 1
    if ((_5.bfix) is not None):
     _60=(- 1)
     _61=0
     _62=0
     _63=0
     _51 = numpy.zeros((_42,), dtype=numpy.dtype(numpy.float64))
     while ((_61 < _39) and (_62 < int((_8).shape[0]))):
      _64=((_36[_61] * _41) + _37[_61])
      if (_64 < _8[_9[_62]]):
       _61 += 1
      elif (_64 > _8[_9[_62]]):
       _62 += 1
      else:
       if (_60 < _36[_61]):
        _60 = _36[_61]
        _63 += 1
       _51[(_63 - 1)] = (_51[(_63 - 1)] + ((_5.bfix)[_9[_62]] * _38[_61]))
       _62 += 1
       _61 += 1
    if (int((_52).shape[0])==(m._dimi)):
     _52 = None
    _4 = mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_48,(_5.x),_49,_50,_51,mosek.fusion.Set._make_I((m._dimi)),_52)
   return (_4)
  @staticmethod
  def _match_mulDiag_Lmosek_4fusion_4Variable_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match__3_5D__(_1))
  @staticmethod
  def _match_alt_mulDiag_Lmosek_4fusion_4Variable_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match__3_5D__(_1))
  @staticmethod
  def _mulDiag_alt_Lmosek_4fusion_4Variable_2_3_5D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Variable_2_3_5D(_0,_1)
   return _1
  @staticmethod
  def _mulDiag_Lmosek_4fusion_4Variable_2_3_5D(_0,_1):
   return (mosek.fusion.Expr._mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_0,mosek.fusion.Matrix._dense__3_5D(_1)))
  @staticmethod
  def _match_mulDiag__3_5DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3_5D__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_mulDiag__3_5DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3_5D__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _mulDiag_alt__3_5DLmosek_4fusion_4Variable_2(_t__0,_t__1):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._mulDiag__3_5DLmosek_4fusion_4Variable_2(_0,_1)
   return _1
  @staticmethod
  def _mulDiag__3_5DLmosek_4fusion_4Variable_2(_0,_1):
   return (mosek.fusion.Expr._mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(mosek.fusion.Matrix._dense__3_5D(_0),_1))
  @staticmethod
  def _match_mulDiag_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match__3_5D__(_1))
  @staticmethod
  def _match_alt_mulDiag_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match__3_5D__(_1))
  @staticmethod
  def _mulDiag_alt_Lmosek_4fusion_4Expression_2_3_5D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Expression_2_3_5D(_0,_1)
   return _1
  @staticmethod
  def _mulDiag_Lmosek_4fusion_4Expression_2_3_5D(_0,_1):
   return (mosek.fusion.Expr._mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,mosek.fusion.Matrix._dense__3_5D(_1)))
  @staticmethod
  def _match_mulDiag__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3_5D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_mulDiag__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3_5D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _mulDiag_alt__3_5DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._mulDiag__3_5DLmosek_4fusion_4Expression_2(_0,_1)
   return _1
  @staticmethod
  def _mulDiag__3_5DLmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr._mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(mosek.fusion.Matrix._dense__3_5D(_0),_1))
  @staticmethod
  def __mulElm_1_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr.__mulElm_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def __mulElm_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1):
   if ((_0._numRows_()!=_1._shape_()._dim_I(0)) or ((_0._numColumns_()!=_1._shape_()._dim_I(1)) or ((_0._numRows_() * _0._numColumns_())!=_1._shape_()._getSize_()))):
    raise mosek_fusion_DimensionError._ctor_S("Dimensions of operands do not match")
   _2=_0._numNonzeros_()
   _3=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int32))
   _4=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int32))
   _5=numpy.zeros((_2,), dtype=numpy.dtype(numpy.float64))
   _0._getDataAsTriplets__3I_3I_3D(_3,_4,_5)
   _6=numpy.array([((_3[_7] * _0._numColumns_()) + _4[_7]) for _7 in range(0,_2)], dtype=numpy.dtype(numpy.int64))
   _8=_1._eval_()
   return (mosek.fusion.Expr.__dotmul_1__3J_3D_3J_3J_3D_3D_3J_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2(_6,_5,(_8.ptrb),(_8.subj),(_8.cof),(_8.bfix),(_8.inst),(_8.x),(_8.shape)))
  @staticmethod
  def __mulElm_1_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr.__mulElm_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def __mulElm_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_0,_1):
   if ((_0._numRows_()!=_1._shape_()._dim_I(0)) or ((_0._numColumns_()!=_1._shape_()._dim_I(1)) or ((_0._numRows_() * _0._numColumns_())!=_1._shape_()._getSize_()))):
    raise mosek_fusion_DimensionError._ctor_S("Dimensions of operands do not match")
   _2=_0._numNonzeros_()
   _3=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int32))
   _4=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int32))
   _5=numpy.zeros((_2,), dtype=numpy.dtype(numpy.float64))
   _0._getDataAsTriplets__3I_3I_3D(_3,_4,_5)
   _6=numpy.array([((_3[_7] * _0._numColumns_()) + _4[_7]) for _7 in range(0,_2)], dtype=numpy.dtype(numpy.int64))
   return (mosek.fusion.Expr.__dotmul_1__3J_3DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2(_6,_5,_1,_1._shape_()))
  @staticmethod
  def __mulElm_1_alt__3DLmosek_4fusion_4Variable_2(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr.__mulElm_1__3DLmosek_4fusion_4Variable_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __mulElm_1__3DLmosek_4fusion_4Variable_2(_0,_1):
   if ((_1 is None) or (_0 is None)):
    raise ValueError("Arguments for mulElm may not be null")
   if ((_1._shape_()._dim_I(0)!=int((_0).shape[0])) or (_1._shape_()._getSize_()!=long((_0).shape[0]))):
    raise mosek_fusion_DimensionError._ctor_S("Dimensions of operands do not match")
   return (mosek.fusion.Expr.__dotmul_1__3J_3DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2(mosek.fusion.Utils.Tools._range_JJ(0,long((_0).shape[0])),_0,_1,_1._shape_()))
  @staticmethod
  def __mulElm_1_alt__3DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr.__mulElm_1__3DLmosek_4fusion_4Expression_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __mulElm_1__3DLmosek_4fusion_4Expression_2(_0,_1):
   if ((_0 is None) or (_1 is None)):
    raise ValueError("Arguments for mulElm may not be null")
   if ((_1._shape_()._dim_I(0)!=int((_0).shape[0])) or (_1._shape_()._getSize_()!=long((_0).shape[0]))):
    raise mosek_fusion_DimensionError._ctor_S("Dimensions of operands do not match")
   _2=_1._eval_()
   return (mosek.fusion.Expr.__dotmul_1__3J_3D_3J_3J_3D_3D_3J_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2(mosek.fusion.Utils.Tools._range_JJ(0,long((_0).shape[0])),_0,(_2.ptrb),(_2.subj),(_2.cof),(_2.bfix),(_2.inst),(_2.x),(_2.shape)))
  @staticmethod
  def __mulElm_1_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr.__mulElm_1_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def __mulElm_1_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_0,_1):
   if ((_0 is None) or (_1 is None)):
    raise ValueError("Arguments for mulElm may not be null")
   for _2 in range(0,int(((_0._dims)).shape[0])):
    if ((_0._dims)[_2]!=_1._shape_()._dim_I(_2)):
     raise mosek_fusion_DimensionError._ctor_S("Dimensions of operands do not match")
   for _3 in range(int(((_0._dims)).shape[0]),(_1._shape_().nd)):
    if (1!=_1._shape_()._dim_I(_3)):
     raise mosek_fusion_DimensionError._ctor_S("Dimensions of operands do not match")
   for _4 in range(0,int(((_0._dims)).shape[0])):
    if ((_0._dims)[_4]!=_1._shape_()._dim_I(_4)):
     raise mosek_fusion_LengthError._ctor_S("Dimension mismatch")
   _5=_1._eval_()
   return (mosek.fusion.Expr.__dotmul_1__3J_3D_3J_3J_3D_3D_3J_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2((_0._inst),(_0._cof),(_5.ptrb),(_5.subj),(_5.cof),(_5.bfix),(_5.inst),(_5.x),(_5.shape)))
  @staticmethod
  def __mulElm_1_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr.__mulElm_1_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def __mulElm_1_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(_0,_1):
   if ((_1._shape_().nd)!=int(((_0._dims)).shape[0])):
    raise mosek_fusion_LengthError._ctor_S("Dimension mismatch")
   for _2 in range(0,int(((_0._dims)).shape[0])):
    if ((_0._dims)[_2]!=_1._shape_()._dim_I(_2)):
     raise mosek_fusion_LengthError._ctor_S("Dimension mismatch")
   return (mosek.fusion.Expr.__dotmul_1__3J_3DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2((_0._inst),(_0._cof),_1,_1._shape_()))
  @staticmethod
  def __dotmul_1_alt__3J_3DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2(_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=_t__2
   _3=_t__3
   _1 = mosek_fusion_Expr.__dotmul_1__3J_3DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __dotmul_1__3J_3DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2(_0,_1,_2,_3):
   _4=int((_0).shape[0])
   _5=mosek.fusion.Utils.Tools._range_J((long((_0).shape[0]) + 1))
   _6=mosek.fusion.Utils.Tools._arraycopy__3J(_0)
   _7=mosek.fusion.Utils.Tools._arraycopy__3D(_1)
   _8=None
   return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_5,numpy.array([_2], dtype=numpy.dtype(object)),_6,_7,_8,_3,_0))
  @staticmethod
  def __dotmul_1_alt__3J_3D_3J_3J_3D_3D_3J_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7,_t__8):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int64))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.float64))
   _6=numpy.array(_t__6,dtype=numpy.dtype(numpy.int64))
   _7=numpy.array(_t__7,dtype=numpy.dtype(object))
   _8=_t__8
   _1 = mosek_fusion_Expr.__dotmul_1__3J_3D_3J_3J_3D_3D_3J_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2(_0,_1,_2,_3,_4,_5,_6,_7,_8)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__6[:] = _6
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__7[:] = _7
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __dotmul_1__3J_3D_3J_3J_3D_3D_3J_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2(_0,_1,_2,_3,_4,_5,_6,_7,_8):
   _9=int((_0).shape[0])
   _10=(_6 if ((_6 is not None) ) else mosek.fusion.Utils.Tools._range_JJ(0,(long((_2).shape[0]) - 1)))
   _11=int((_10).shape[0])
   _12=0
   _13=0
   _13,_12 = fragments._c_closure_245(_10,_11,_2,_0,_9,_13,_12) # src/fusion/Expr.mbi:3906:9-3919:10
   _13 = numpy.int32(_13) # postprocess
   _12 = numpy.int64(_12) # postprocess
   _14=numpy.zeros((_12,), dtype=numpy.dtype(numpy.int64))
   _15=numpy.zeros((_12,), dtype=numpy.dtype(numpy.float64))
   _16=numpy.zeros(((_13 + 1),), dtype=numpy.dtype(numpy.int64))
   _17=numpy.zeros((_13,), dtype=numpy.dtype(numpy.int64))
   _18=(None if ((_5 is None) ) else numpy.zeros((_13,), dtype=numpy.dtype(numpy.float64)))
   fragments._c_closure_246(_18,_15,_5,_4,_10,_11,_2,_3,_17,_0,_9,_1,_16,_14) # src/fusion/Expr.mbi:3927:9-3963:10
   return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_16,_7,_14,_15,_18,_8,(_17 if ((int((_17).shape[0]) < (_8._size)) ) else None)))
  @staticmethod
  def _match_mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _mul_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1):
   if ((_0 is None) or (_1 is None)):
    raise ValueError("Arguments for mul may not be null")
   _2=None
   _3=_1._eval_()
   _4=_0._numRows_()
   _5=_0._numColumns_()
   _6=None
   if ((((_3.shape).nd)==1) and ((_3.shape)._dim_I(0)==1)):
    _2 = mosek.fusion.Expr.__mul_10DExpr_1Matrix__3J_3D_3D_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2((_3.subj),(_3.cof),(_3.bfix),(_3.x),_0)
   else:
    if ((((_3.shape).nd)==1) and ((_3.shape)._dim_I(0)==_5)):
     _8 = 1
     _7 = (_3.shape)._dim_I(0)
     _6 = mosek_fusion_IntSet._ctor_I(_4)
    elif ((((_3.shape).nd)==2) and ((_3.shape)._dim_I(0)==_5)):
     _7 = (_3.shape)._dim_I(0)
     _8 = (_3.shape)._dim_I(1)
     _6 = mosek_fusion_NDSet._ctor_II(_4,_8)
    else:
     raise mosek_fusion_DimensionError._ctor_S("Expression operand must be one- or two-dimensional, and dimensions must match for multiplication")
    if (((_3.inst) is None) and (not _0._isSparse_())):
     _2 = mosek.fusion.Expr.__mul_1DMatrix_12DDExpr__3J_3J_3D_3D_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2II_3DII((_3.ptrb),(_3.subj),(_3.cof),(_3.bfix),(_3.x),_6,_7,_8,_0._getDataAsArray_(),_4,_5)
    else:
     _9=_0._numNonzeros_()
     _10=numpy.zeros((_9,), dtype=numpy.dtype(numpy.int32))
     _11=numpy.zeros((_9,), dtype=numpy.dtype(numpy.int32))
     _12=numpy.zeros((_9,), dtype=numpy.dtype(numpy.float64))
     _0._getDataAsTriplets__3I_3I_3D(_10,_11,_12)
     _13=(_3.inst)
     if (_13 is None):
      _13 = mosek.fusion.Utils.Tools._range_JJ(0,(long(((_3.ptrb)).shape[0]) - 1))
     _2 = mosek.fusion.Expr.__mul_1SMatrix_12DSExpr__3J_3J_3D_3D_3J_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2II_3I_3I_3DII((_3.ptrb),(_3.subj),(_3.cof),(_3.bfix),_13,(_3.x),_6,_7,_8,_10,_11,_12,_4,_5)
   return (_2)
  @staticmethod
  def _match_mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _mul_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Expr._mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,_1)
  @staticmethod
  def _mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,_1):
   if ((_1 is None) or (_0 is None)):
    raise ValueError("Arguments for mul may not be null")
   _2=None
   _3=_0._eval_()
   _4=_1._numRows_()
   _5=_1._numColumns_()
   if ((((_3.shape).nd)==1) and ((_3.shape)._dim_I(0)==1)):
    _2 = mosek.fusion.Expr.__mul_10DExpr_1Matrix__3J_3D_3D_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2((_3.subj),(_3.cof),(_3.bfix),(_3.x),_1)
   else:
    _6=None
    if ((((_3.shape).nd)==1) and ((_3.shape)._dim_I(0)==_4)):
     _7 = 1
     _8 = (_3.shape)._dim_I(0)
     _6 = mosek_fusion_IntSet._ctor_I(_5)
    elif ((((_3.shape).nd)==2) and ((_3.shape)._dim_I(1)==_4)):
     _7 = (_3.shape)._dim_I(0)
     _8 = (_3.shape)._dim_I(1)
     _6 = mosek_fusion_NDSet._ctor_II(_7,_5)
    else:
     raise mosek_fusion_DimensionError._ctor_S("Expression operand must be one- or two-dimensional, and dimensions must match for multiplication")
    if (((_3.inst) is None) and (not _1._isSparse_())):
     _2 = mosek.fusion.Expr.__mul_12DDExpr_1DMatrix__3J_3J_3D_3D_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2II_3DII((_3.ptrb),(_3.subj),(_3.cof),(_3.bfix),(_3.x),_6,_7,_8,_1._getDataAsArray_(),_4,_5)
    else:
     _9=_1._numNonzeros_()
     _10=numpy.zeros((_9,), dtype=numpy.dtype(numpy.int32))
     _11=numpy.zeros((_9,), dtype=numpy.dtype(numpy.int32))
     _12=numpy.zeros((_9,), dtype=numpy.dtype(numpy.float64))
     _1._getDataAsTriplets__3I_3I_3D(_10,_11,_12)
     _13=(_3.inst)
     if (_13 is None):
      _13 = mosek.fusion.Utils.Tools._range_JJ(0,(long(((_3.ptrb)).shape[0]) - 1))
     _2 = mosek.fusion.Expr.__mul_12DSExpr_1SMatrix__3J_3J_3D_3D_3J_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2II_3I_3I_3DII((_3.ptrb),(_3.subj),(_3.cof),(_3.bfix),(_3.inst),(_3.x),_6,_7,_8,_10,_11,_12,_4,_5)
   return (_2)
  @staticmethod
  def _match_mul_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match__3D__(_1))
  @staticmethod
  def _match_alt_mul_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match__3D__(_1))
  @staticmethod
  def _mul_alt_Lmosek_4fusion_4Expression_2_3D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._mul_Lmosek_4fusion_4Expression_2_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _mul_Lmosek_4fusion_4Expression_2_3D(_0,_1):
   if ((_1 is None) or (_0 is None)):
    raise ValueError("Arguments for mul may not be null")
   _2=None
   _3=int((_1).shape[0])
   _4=1
   _5=_0._eval_()
   if ((((_5.shape).nd)==1) and ((_5.shape)._dim_I(0)==1)):
    _2 = mosek.fusion.Expr.__mul_10DExpr_1Matrix__3J_3D_3D_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2((_5.subj),(_5.cof),(_5.bfix),(_5.x),mosek_fusion_DenseMatrix._ctor_II_3D(int((_1).shape[0]),1,_1))
   else:
    _8=None
    if (((_5.shape).nd)==1):
     _8 = mosek_fusion_IntSet._ctor_I(1)
     _7 = (_5.shape)._dim_I(0)
     _6 = 1
    elif ((_5.shape)._realnd_()==2):
     _8 = mosek_fusion_IntSet._ctor_I((_5.shape)._dim_I(0))
     _6 = (_5.shape)._dim_I(0)
     _7 = (_5.shape)._dim_I(1)
    else:
     raise mosek_fusion_DimensionError._ctor_S("Expression operand must be one- or two-dimensional")
    if (_7!=_3):
     raise mosek_fusion_DimensionError._ctor_S("Mismatching dimensions of operands")
    if ((_5.inst) is None):
     _2 = mosek.fusion.Expr.__mul_12DDExpr_1DMatrix__3J_3J_3D_3D_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2II_3DII((_5.ptrb),(_5.subj),(_5.cof),(_5.bfix),(_5.x),_8,_6,_7,_1,_3,_4)
    else:
     _2 = mosek.fusion.Expr.__mul_12DSExpr_1SMatrix__3J_3J_3D_3D_3J_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2II_3I_3I_3DII((_5.ptrb),(_5.subj),(_5.cof),(_5.bfix),(_5.inst),(_5.x),_8,_6,_7,mosek.fusion.Utils.Tools._range_II(0,_3),mosek.fusion.Utils.Tools._makevector_II(0,_3),_1,_3,_4)
   return (_2)
  @staticmethod
  def _match_mul__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_mul__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _mul_alt__3DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._mul__3DLmosek_4fusion_4Expression_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _mul__3DLmosek_4fusion_4Expression_2(_0,_1):
   if ((_0 is None) or (_1 is None)):
    raise ValueError("Arguments for mul may not be null")
   _2=1
   _3=int((_0).shape[0])
   _4=None
   _5=_1._eval_()
   if ((((_5.shape).nd)==1) and ((_5.shape)._dim_I(0)==1)):
    _4 = mosek.fusion.Expr.__mul_10DExpr_1Matrix__3J_3D_3D_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2((_5.subj),(_5.cof),(_5.bfix),(_5.x),mosek_fusion_DenseMatrix._ctor_II_3D(1,int((_0).shape[0]),_0))
   else:
    _8=None
    if (((_5.shape).nd)==1):
     _7 = 1
     _6 = (_5.shape)._dim_I(0)
     _8 = mosek_fusion_IntSet._ctor_I(1)
    elif (((_5.shape).nd)==2):
     _8 = mosek_fusion_IntSet._ctor_I((_5.shape)._dim_I(1))
     _6 = (_5.shape)._dim_I(0)
     _7 = (_5.shape)._dim_I(1)
    else:
     raise mosek_fusion_DimensionError._ctor_S("Mismatching dimensions of operands")
    if (_6!=_3):
     raise mosek_fusion_DimensionError._ctor_S("Mismatching dimensions of operands")
    if ((_5.inst) is None):
     _4 = mosek.fusion.Expr.__mul_1DMatrix_12DDExpr__3J_3J_3D_3D_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2II_3DII((_5.ptrb),(_5.subj),(_5.cof),(_5.bfix),(_5.x),_8,_6,_7,_0,_2,_3)
    else:
     _4 = mosek.fusion.Expr.__mul_1SMatrix_12DSExpr__3J_3J_3D_3D_3J_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2II_3I_3I_3DII((_5.ptrb),(_5.subj),(_5.cof),(_5.bfix),(_5.inst),(_5.x),_8,_6,_7,mosek.fusion.Utils.Tools._makevector_II(0,_3),mosek.fusion.Utils.Tools._range_II(0,_3),_0,_2,_3)
   return (_4)
  @staticmethod
  def _match_mul_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_mul_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _mul_alt_DLmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._mul_DLmosek_4fusion_4Expression_2(numpy.float64(__0),_1)
  @staticmethod
  def _mul_DLmosek_4fusion_4Expression_2(_0,_1):
   if (_1 is None):
    raise ValueError("Arguments for mul may not be null")
   _2=_1._eval_()
   for _3 in range(0,int(((_2.cof)).shape[0])):
    (_2.cof)[_3] = ((_2.cof)[_3] * _0)
   if ((_2.bfix) is not None):
    for _4 in range(0,int(((_2.bfix)).shape[0])):
     (_2.bfix)[_4] = ((_2.bfix)[_4] * _0)
   return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI((_2.ptrb),(_2.x),(_2.subj),(_2.cof),(_2.bfix),(_2.shape),(_2.inst),1))
  @staticmethod
  def _match_mul_Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_mul_Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _mul_alt_Lmosek_4fusion_4Expression_2D(_t__0,_t__1):
    return mosek_fusion_Expr._mul_Lmosek_4fusion_4Expression_2D(_0,numpy.float64(__1))
  @staticmethod
  def _mul_Lmosek_4fusion_4Expression_2D(_0,_1):
   if (_0 is None):
    raise ValueError("Arguments for mul may not be null")
   return (mosek.fusion.Expr._mul_DLmosek_4fusion_4Expression_2(_1,_0))
  @staticmethod
  def __mul_1SMatrix_12DSExpr_alt__3J_3J_3D_3D_3J_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2II_3I_3I_3DII(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7,_t__8,_t__9,_t__10,_t__11,_t__12,_t__13):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.float64))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int64))
   _5=numpy.array(_t__5,dtype=numpy.dtype(object))
   _6=_t__6
   _7=numpy.int32(_t__7)
   _8=numpy.int32(_t__8)
   _9=numpy.array(_t__9,dtype=numpy.dtype(numpy.int32))
   _10=numpy.array(_t__10,dtype=numpy.dtype(numpy.int32))
   _11=numpy.array(_t__11,dtype=numpy.dtype(numpy.float64))
   _12=numpy.int32(_t__12)
   _13=numpy.int32(_t__13)
   _1 = mosek_fusion_Expr.__mul_1SMatrix_12DSExpr__3J_3J_3D_3D_3J_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2II_3I_3I_3DII(_0,_1,_2,_3,_4,_5,_6,_7,_8,_9,_10,_11,_12,_13)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__9[:] = _9
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__10[:] = _10
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__11[:] = _11
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __mul_1SMatrix_12DSExpr__3J_3J_3D_3D_3J_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2II_3I_3I_3DII(_0,_1,_2,_3,_4,_5,_6,_7,_8,_9,_10,_11,_12,_13):
   _14=None
   _15=numpy.array([numpy.int32((_4[_16] // _8)) for _16 in range(0,int((_4).shape[0]))], dtype=numpy.dtype(numpy.int32))
   _17=numpy.array([numpy.int32((_4[_18] % _8)) for _18 in range(0,int((_4).shape[0]))], dtype=numpy.dtype(numpy.int32))
   _19=mosek.fusion.Utils.Tools._range_JJ(0,long((_4).shape[0]))
   _20=int((_9).shape[0])
   _21=int((_4).shape[0])
   _22=_12
   _23=_8
   mosek.fusion.CommonTools._argQsort__3J_3I_3IJJ(_19,_17,_15,0,long((_4).shape[0]))
   _24=0
   _25=0
   _25,_24 = fragments._c_closure_247(_21,_0,_15,_17,_20,_9,_10,_19,_25,_24) # src/fusion/Expr.mbi:3432:9-3467:10
   _25 = numpy.int64(_25) # postprocess
   _24 = numpy.int32(_24) # postprocess
   _26=numpy.zeros((_24,), dtype=numpy.dtype(numpy.int64))
   _27=numpy.zeros(((_24 + 1),), dtype=numpy.dtype(numpy.int64))
   _28=numpy.zeros((_25,), dtype=numpy.dtype(numpy.int64))
   _29=numpy.zeros((_25,), dtype=numpy.dtype(numpy.float64))
   _30=None
   fragments._c_closure_248(_29,_2,_8,_21,_0,_1,_15,_17,_26,_11,_20,_9,_10,_19,_27,_28) # src/fusion/Expr.mbi:3476:9-3522:10
   if (_3 is not None):
    _30 = numpy.zeros((_24,), dtype=numpy.dtype(numpy.float64))
    _31=0
    _31 = fragments._c_closure_249(_30,_31,_3,_21,_15,_17,_11,_20,_9,_10,_19) # src/fusion/Expr.mbi:3530:11-3563:12
    _31 = numpy.int32(_31) # postprocess
   if (int((_26).shape[0])==(_22 * _23)):
    _26 = None
   _14 = mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_27,_5,_28,_29,_30,_6,_26)
   return (_14)
  @staticmethod
  def __mul_12DSExpr_1SMatrix_alt__3J_3J_3D_3D_3J_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2II_3I_3I_3DII(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7,_t__8,_t__9,_t__10,_t__11,_t__12,_t__13):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.float64))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int64))
   _5=numpy.array(_t__5,dtype=numpy.dtype(object))
   _6=_t__6
   _7=numpy.int32(_t__7)
   _8=numpy.int32(_t__8)
   _9=numpy.array(_t__9,dtype=numpy.dtype(numpy.int32))
   _10=numpy.array(_t__10,dtype=numpy.dtype(numpy.int32))
   _11=numpy.array(_t__11,dtype=numpy.dtype(numpy.float64))
   _12=numpy.int32(_t__12)
   _13=numpy.int32(_t__13)
   _1 = mosek_fusion_Expr.__mul_12DSExpr_1SMatrix__3J_3J_3D_3D_3J_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2II_3I_3I_3DII(_0,_1,_2,_3,_4,_5,_6,_7,_8,_9,_10,_11,_12,_13)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__9[:] = _9
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__10[:] = _10
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__11[:] = _11
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __mul_12DSExpr_1SMatrix__3J_3J_3D_3D_3J_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2II_3I_3I_3DII(_0,_1,_2,_3,_4,_5,_6,_7,_8,_9,_10,_11,_12,_13):
   _14=None
   _15=_7
   _16=_13
   _17=long((_11).shape[0])
   _18=long((_4).shape[0])
   _19=mosek.fusion.Utils.Tools._range_JJ(0,long((_9).shape[0]))
   mosek.fusion.CommonTools._argQsort__3J_3I_3IJJ(_19,_10,_9,0,long((_9).shape[0]))
   _20=0
   _21=0
   _21,_20 = fragments._c_closure_250(_8,_4,_18,_0,_17,_9,_10,_19,_21,_20) # src/fusion/Expr.mbi:3254:9-3287:10
   _21 = numpy.int64(_21) # postprocess
   _20 = numpy.int32(_20) # postprocess
   _22=numpy.zeros(((_20 + 1),), dtype=numpy.dtype(numpy.int64))
   _23=numpy.zeros((_20,), dtype=numpy.dtype(numpy.int64))
   _24=numpy.zeros((_21,), dtype=numpy.dtype(numpy.int64))
   _25=numpy.zeros((_21,), dtype=numpy.dtype(numpy.float64))
   _26=None
   fragments._c_closure_251(_25,_2,_8,_4,_18,_0,_1,_23,_11,_17,_9,_10,_19,_22,_16,_24) # src/fusion/Expr.mbi:3296:9-3342:10
   if (_3 is not None):
    _26 = numpy.zeros((_20,), dtype=numpy.dtype(numpy.float64))
    _27=0
    _27 = fragments._c_closure_252(_26,_27,_3,_8,_4,_18,_11,_17,_9,_10,_19) # src/fusion/Expr.mbi:3349:11-3385:12
    _27 = numpy.int32(_27) # postprocess
   if (int((_23).shape[0])==(_15 * _16)):
    _23 = None
   _14 = mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_22,_5,_24,_25,_26,_6,_23)
   return (_14)
  @staticmethod
  def __mul_1DMatrix_12DDExpr_alt__3J_3J_3D_3D_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2II_3DII(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7,_t__8,_t__9,_t__10):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.float64))
   _4=numpy.array(_t__4,dtype=numpy.dtype(object))
   _5=_t__5
   _6=numpy.int32(_t__6)
   _7=numpy.int32(_t__7)
   _8=numpy.array(_t__8,dtype=numpy.dtype(numpy.float64))
   _9=numpy.int32(_t__9)
   _10=numpy.int32(_t__10)
   _1 = mosek_fusion_Expr.__mul_1DMatrix_12DDExpr__3J_3J_3D_3D_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2II_3DII(_0,_1,_2,_3,_4,_5,_6,_7,_8,_9,_10)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__8[:] = _8
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __mul_1DMatrix_12DDExpr__3J_3J_3D_3D_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2II_3DII(_0,_1,_2,_3,_4,_5,_6,_7,_8,_9,_10):
   _12=_9
   _13=_7
   _14=(numpy.int64(_12) * numpy.int64(_13))
   _15=numpy.zeros(((_14 + 1),), dtype=numpy.dtype(numpy.int64))
   _16=numpy.zeros(((int((_1).shape[0]) * _9),), dtype=numpy.dtype(numpy.int64))
   _17=numpy.zeros(((int((_1).shape[0]) * _9),), dtype=numpy.dtype(numpy.float64))
   _18=None
   fragments._c_closure_253(_17,_2,_6,_7,_0,_1,_8,_9,_10,_15,_16) # src/fusion/Expr.mbi:3182:9-3201:10
   if (_3 is not None):
    _19=0
    _18 = numpy.zeros((_14,), dtype=numpy.dtype(numpy.float64))
    _19 = fragments._c_closure_254(_18,_19,_3,_6,_7,_8,_9,_10) # src/fusion/Expr.mbi:3207:11-3213:14
    _19 = numpy.int32(_19) # postprocess
   _11 = mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_15,_4,_16,_17,_18,_5,None)
   return (_11)
  @staticmethod
  def __mul_12DDExpr_1DMatrix_alt__3J_3J_3D_3D_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2II_3DII(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7,_t__8,_t__9,_t__10):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.float64))
   _4=numpy.array(_t__4,dtype=numpy.dtype(object))
   _5=_t__5
   _6=numpy.int32(_t__6)
   _7=numpy.int32(_t__7)
   _8=numpy.array(_t__8,dtype=numpy.dtype(numpy.float64))
   _9=numpy.int32(_t__9)
   _10=numpy.int32(_t__10)
   _1 = mosek_fusion_Expr.__mul_12DDExpr_1DMatrix__3J_3J_3D_3D_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2II_3DII(_0,_1,_2,_3,_4,_5,_6,_7,_8,_9,_10)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__8[:] = _8
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __mul_12DDExpr_1DMatrix__3J_3J_3D_3D_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2II_3DII(_0,_1,_2,_3,_4,_5,_6,_7,_8,_9,_10):
   _12=_6
   _13=_10
   _14=numpy.zeros((((_6 * _10) + 1),), dtype=numpy.dtype(numpy.int64))
   _15=None
   _16=numpy.zeros(((int((_1).shape[0]) * _10),), dtype=numpy.dtype(numpy.int64))
   _17=numpy.zeros(((int((_1).shape[0]) * _10),), dtype=numpy.dtype(numpy.float64))
   _18=None
   fragments._c_closure_255(_17,_2,_7,_0,_1,_8,_9,_10,_14,_12,_13,_16) # src/fusion/Expr.mbi:3111:9-3134:10
   if (_3 is not None):
    _18 = numpy.zeros(((_12 * _13),), dtype=numpy.dtype(numpy.float64))
    _19=0
    _19 = fragments._c_closure_256(_18,_3,_7,_8,_9,_10,_19,_12,_13) # src/fusion/Expr.mbi:3140:11-3147:14
    _19 = numpy.int32(_19) # postprocess
   _11 = mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_14,_4,_16,_17,_18,_5,_15)
   return (_11)
  @staticmethod
  def __mul_10DExpr_1Matrix_alt__3J_3D_3D_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=numpy.array(_t__3,dtype=numpy.dtype(object))
   _4=_t__4
   _1 = mosek_fusion_Expr.__mul_10DExpr_1Matrix__3J_3D_3D_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_0,_1,_2,_3,_4)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __mul_10DExpr_1Matrix__3J_3D_3D_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_0,_1,_2,_3,_4):
   _5=None
   _6=_4._numRows_()
   _7=_4._numColumns_()
   _8=_4._numNonzeros_()
   _10=None
   _11=None
   _12=mosek.fusion.Utils.Tools._range_JJJ(0,((_8 * long((_0).shape[0])) + 1),long((_0).shape[0]))
   _13=numpy.zeros(((_8 * int((_0).shape[0])),), dtype=numpy.dtype(numpy.int64))
   _14=numpy.zeros(((_8 * int((_0).shape[0])),), dtype=numpy.dtype(numpy.float64))
   _15=None
   _16=None
   if (not _4._isSparse_()):
    _9 = _4._getDataAsArray_()
   else:
    _10 = numpy.zeros((_8,), dtype=numpy.dtype(numpy.int32))
    _11 = numpy.zeros((_8,), dtype=numpy.dtype(numpy.int32))
    _9 = numpy.zeros((_8,), dtype=numpy.dtype(numpy.float64))
    _16 = numpy.zeros((_8,), dtype=numpy.dtype(numpy.int64))
    _4._getDataAsTriplets__3I_3I_3D(_10,_11,_9)
    fragments._c_closure_257(_16,_7,_10,_11) # src/fusion/Expr.mbi:3055:11-3056:57
   fragments._c_closure_258(_14,_1,_0,_9,_8,_13) # src/fusion/Expr.mbi:3060:9-3069:10
   if (_2 is not None):
    _15 = numpy.zeros((_8,), dtype=numpy.dtype(numpy.float64))
    fragments._c_closure_259(_15,_2,_9,_8) # src/fusion/Expr.mbi:3074:11-3075:42
   _5 = mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_12,_3,_13,_14,_15,mosek_fusion_NDSet._ctor_II(_6,_7),_16)
   return (_5)
  @staticmethod
  def _match_mul_Lmosek_4fusion_4Variable_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match__3_5D__(_1))
  @staticmethod
  def _match_alt_mul_Lmosek_4fusion_4Variable_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match__3_5D__(_1))
  @staticmethod
  def _mul_alt_Lmosek_4fusion_4Variable_2_3_5D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._mul_Lmosek_4fusion_4Variable_2_3_5D(_0,_1)
   return _1
  @staticmethod
  def _mul_Lmosek_4fusion_4Variable_2_3_5D(_0,_1):
   if ((_1 is None) or (_0 is None)):
    raise ValueError("Arguments for mul may not be null")
   if (int((_1).shape[0])==0):
    _2=numpy.array([0,0], dtype=numpy.dtype(numpy.int64))
    _3=numpy.zeros((0,), dtype=numpy.dtype(numpy.int64))
    _4=numpy.zeros((0,), dtype=numpy.dtype(numpy.float64))
    return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(_2,numpy.array([_0], dtype=numpy.dtype(object)),_3,_4,None,None,None,1))
   else:
    return (mosek.fusion.Expr._mul_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_0,mosek_fusion_DenseMatrix._ctor__3_5D(_1)))
  @staticmethod
  def _match_mul__3_5DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3_5D__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_mul__3_5DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3_5D__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _mul_alt__3_5DLmosek_4fusion_4Variable_2(_t__0,_t__1):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._mul__3_5DLmosek_4fusion_4Variable_2(_0,_1)
   return _1
  @staticmethod
  def _mul__3_5DLmosek_4fusion_4Variable_2(_0,_1):
   if ((_0 is None) or (_1 is None)):
    raise ValueError("Arguments for mul may not be null")
   return (mosek.fusion.Expr._mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(mosek_fusion_DenseMatrix._ctor__3_5D(_0),_1))
  @staticmethod
  def _match_mul_Lmosek_4fusion_4Variable_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_mul_Lmosek_4fusion_4Variable_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _mul_alt_Lmosek_4fusion_4Variable_2D(_t__0,_t__1):
    return mosek_fusion_Expr._mul_Lmosek_4fusion_4Variable_2D(_0,numpy.float64(__1))
  @staticmethod
  def _mul_Lmosek_4fusion_4Variable_2D(_0,_1):
   if (_0 is None):
    raise ValueError("Arguments for mul may not be null")
   return (mosek.fusion.Expr._mul_DLmosek_4fusion_4Variable_2(_1,_0))
  @staticmethod
  def _match_mul_DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_mul_DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _mul_alt_DLmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr._mul_DLmosek_4fusion_4Variable_2(numpy.float64(__0),_1)
  @staticmethod
  def _mul_DLmosek_4fusion_4Variable_2(_0,_1):
   if (_1 is None):
    raise ValueError("Arguments for mul may not be null")
   _2=_0
   _3=_1
   _4=mosek.fusion.Utils.Tools._range_JJ(0,((_3._shape_()._size) + 1))
   _5=mosek.fusion.Utils.Tools._makevector_DI(_2,numpy.int32((_3._shape_()._size)))
   _6=mosek.fusion.Utils.Tools._range_JJ(0,(_3._shape_()._size))
   _7=None
   return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_4,numpy.array([_1], dtype=numpy.dtype(object)),_6,_5,_7,_3._shape_(),None))
  @staticmethod
  def _match_mul__3DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_mul__3DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _mul_alt__3DLmosek_4fusion_4Variable_2(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._mul__3DLmosek_4fusion_4Variable_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _mul__3DLmosek_4fusion_4Variable_2(_0,_1):
   if ((_1 is None) or (_0 is None)):
    raise ValueError("Arguments for mul may not be null")
   _2=_0
   _3=_1
   if (((_3._shape_()._size)==1) or ((_3._shape_().nd)==1)):
    return (mosek.fusion.Expr._mul_Lmosek_4fusion_4Variable_2_3D(_3,_2))
   elif (((_1._shape_().nd)==1) and (_1._shape_()._dim_I(0)==int((_0).shape[0]))):
    return (mosek.fusion.Expr._dot_Lmosek_4fusion_4Variable_2_3D(_1,_0))
   elif ((_3._shape_().nd)==2):
    if (_3._shape_()._dim_I(0)!=int((_2).shape[0])):
     raise mosek_fusion_DimensionError._ctor_S("Dimensions of operands do not match")
    _4=_3._shape_()._dim_I(0)
    _5=_3._shape_()._dim_I(1)
    _6=numpy.array([_7 for _7 in range(0,((_5 + 1) * _4),_4)], dtype=numpy.dtype(numpy.int64))
    _8=numpy.zeros(((_3._shape_()._size),), dtype=numpy.dtype(numpy.float64))
    fragments._c_closure_260(_8,_2,_5,_4) # src/fusion/Expr.mbi:2949:11-2950:63
    _9=numpy.array([((_11 * _5) + _10) for _10 in range(0,_5) for _11 in range(0,_4)], dtype=numpy.dtype(numpy.int64))
    return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(_6,numpy.array([_3], dtype=numpy.dtype(object)),_9,_8,None,None,None,1))
   else:
    raise mosek_fusion_DimensionError._ctor_S("Dimensions of operands do not match")
  @staticmethod
  def _match_mul_Lmosek_4fusion_4Variable_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match__3D__(_1))
  @staticmethod
  def _match_alt_mul_Lmosek_4fusion_4Variable_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match__3D__(_1))
  @staticmethod
  def _mul_alt_Lmosek_4fusion_4Variable_2_3D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._mul_Lmosek_4fusion_4Variable_2_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _mul_Lmosek_4fusion_4Variable_2_3D(_0,_1):
   if ((_0 is None) or (_1 is None)):
    raise ValueError("Arguments for mul may not be null")
   _2=_0
   _3=_1
   if ((_2._shape_()._size)==0):
    _4=numpy.array([0,0], dtype=numpy.dtype(numpy.int64))
    _5=numpy.zeros((0,), dtype=numpy.dtype(numpy.int64))
    _6=numpy.zeros((0,), dtype=numpy.dtype(numpy.float64))
    return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(_4,numpy.array([_0], dtype=numpy.dtype(object)),_5,_6,None,None,None,1))
   elif ((_2._shape_()._size)==1):
    _7=mosek.fusion.Utils.Tools._range_JJ(0,(long((_3).shape[0]) + 1))
    _8=mosek.fusion.Utils.Tools._makevector_JI(0,int((_3).shape[0]))
    _9=mosek.fusion.Utils.Tools._arraycopy__3D(_3)
    _10=None
    return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(_7,numpy.array([_0], dtype=numpy.dtype(object)),_8,_9,_10,None,None,1))
   elif (((_0._shape_().nd)==1) and (_0._shape_()._dim_I(0)==int((_1).shape[0]))):
    return (mosek.fusion.Expr._dot_Lmosek_4fusion_4Variable_2_3D(_0,_1))
   elif ((_2._shape_().nd)==2):
    if (_2._shape_()._dim_I(1)!=int((_3).shape[0])):
     raise mosek_fusion_DimensionError._ctor_S("Dimensions of operands do not match")
    _11=numpy.array([_12 for _12 in range(0,((_2._shape_()._size) + _2._shape_()._dim_I(1)),_2._shape_()._dim_I(1))], dtype=numpy.dtype(numpy.int64))
    _13=numpy.array([_14 for _14 in range(0,(_2._shape_()._size))], dtype=numpy.dtype(numpy.int64))
    _15=numpy.zeros(((_2._shape_()._size),), dtype=numpy.dtype(numpy.float64))
    _16=numpy.int64(_2._shape_()._dim_I(1))
    for _17 in range(0,_2._shape_()._dim_I(0)):
     mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ(_3,0,_15,(_17 * _16),_16)
    _18=None
    return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(_11,numpy.array([_0], dtype=numpy.dtype(object)),_13,_15,_18,None,None,1))
   else:
    raise mosek_fusion_DimensionError._ctor_S("Dimensions of operands do not match")
  @staticmethod
  def _match_mul_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_mul_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _mul_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Expr._mul_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_0,_1)
  @staticmethod
  def _mul_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_0,_1):
   if ((_0 is None) or (_1 is None)):
    raise ValueError("Arguments for mul may not be null")
   _2=_0
   _3=_1
   _4=_1._numRows_()
   _5=_1._numColumns_()
   _8=_1._numNonzeros_()
   if (((_0._shape_().nd)==1) and (_0._shape_()._dim_I(0)==1)):
    return (mosek.fusion.Expr._mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_1,_0))
   else:
    if ((_2._shape_().nd)==1):
     if ((_3._dimi)!=(_2._shape_()._size)):
      raise mosek_fusion_LengthError._ctor_S("Operand shapes do not match.")
     _7 = 1
     _6 = _2._shape_()._dim_I(0)
    elif ((_2._shape_().nd)==2):
     if ((_1._dimi)!=_0._shape_()._dim_I(1)):
      raise mosek_fusion_LengthError._ctor_S("Operand shapes do not match.")
     _7 = _2._shape_()._dim_I(0)
     _6 = _2._shape_()._dim_I(1)
    else:
     raise mosek_fusion_LengthError._ctor_S("Variable must be one- or two-dimensional.")
    _9=_7
    _10=_5
    _11=None
    if ((_0._shape_().nd)==1):
     _11 = mosek_fusion_IntSet._ctor_I(_10)
    else:
     _11 = mosek_fusion_NDSet._ctor_II(_9,_10)
    if (not _1._isSparse_()):
     _12=(numpy.int64(_9) * numpy.int64(_10))
     _13=_1._getDataAsArray_()
     _14=numpy.array([_15 for _15 in range(0,(((numpy.int64(_9) * _10) * _6) + 1),_6)], dtype=numpy.dtype(numpy.int64))
     _16=numpy.array([((numpy.int64(_17) * _6) + _19) for _17 in range(0,_9) for _18 in range(0,_10) for _19 in range(0,_6)], dtype=numpy.dtype(numpy.int64))
     _20=numpy.array([_13[((_23 * _5) + _22)] for _21 in range(0,_9) for _22 in range(0,_10) for _23 in range(0,_6)], dtype=numpy.dtype(numpy.float64))
     return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_14,numpy.array([_0], dtype=numpy.dtype(object)),_16,_20,None,_11,None))
    elif (_8 > 0):
     _24=numpy.zeros((_8,), dtype=numpy.dtype(numpy.int32))
     _25=numpy.zeros((_8,), dtype=numpy.dtype(numpy.int32))
     _26=numpy.zeros((_8,), dtype=numpy.dtype(numpy.float64))
     _27=numpy.array([_28 for _28 in range(0,_8)], dtype=numpy.dtype(numpy.int64))
     _1._getDataAsTriplets__3I_3I_3D(_24,_25,_26)
     if (_8 > _5):
      mosek.fusion.Sort._argbucketsort__3J_3IJJII(_27,_25,0,_8,0,_5)
     else:
      mosek.fusion.Sort._argsort__3J_3IJJZ(_27,_25,0,_8,False)
     _29=0
     _29 = fragments._c_closure_261(_29,_8,_25,_27) # src/fusion/Expr.mbi:2823:13-2827:14
     _29 = numpy.int64(_29) # postprocess
     _30=(_29 * numpy.int64(_7))
     _31=numpy.zeros(((_30 + 1),), dtype=numpy.dtype(numpy.int64))
     _32=numpy.zeros((_30,), dtype=numpy.dtype(numpy.int64))
     _33=numpy.zeros(((_8 * _7),), dtype=numpy.dtype(numpy.int64))
     _34=numpy.zeros(((_8 * _7),), dtype=numpy.dtype(numpy.float64))
     fragments._c_closure_262(_34,_32,_26,_8,_24,_25,_27,_31,_9,_10,_33,_6) # src/fusion/Expr.mbi:2835:13-2857:14
     return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_31,numpy.array([_0], dtype=numpy.dtype(object)),_33,_34,None,_11,_32))
    else:
     return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(numpy.array([0], dtype=numpy.dtype(numpy.int64)),numpy.array([_0], dtype=numpy.dtype(object)),numpy.zeros((0,), dtype=numpy.dtype(numpy.int64)),numpy.zeros((0,), dtype=numpy.dtype(numpy.float64)),None,_11,numpy.zeros((0,), dtype=numpy.dtype(numpy.int64))))
  @staticmethod
  def _match_mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _mul_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr._mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def _mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_0,_1):
   if ((_1 is None) or (_0 is None)):
    raise ValueError("Arguments for mul may not be null")
   _2=_1._shape_()
   _3=_0._numRows_()
   _4=_0._numColumns_()
   if ((_2.nd)==1):
    _5 = _2._dim_I(0)
    _6 = 1
   elif ((_2.nd)==2):
    _5 = _2._dim_I(0)
    _6 = _2._dim_I(1)
   else:
    raise mosek_fusion_LengthError._ctor_S("Operand shapes do not match.")
   _7=_3
   _8=_6
   _10=None
   if (((_1._shape_().nd)==1) and (_1._shape_()._dim_I(0)==1)):
    _10 = mosek_fusion_NDSet._ctor_II(_3,_4)
   elif ((_1._shape_().nd)==1):
    _10 = mosek_fusion_IntSet._ctor_I(_7)
   else:
    _10 = mosek_fusion_NDSet._ctor_II(_7,_8)
   if (((_2.nd)==1) and (_2._dim_I(0)==1)):
    if _0._isSparse_():
     _11=numpy.zeros((_0._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
     _12=numpy.zeros((_0._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
     _13=numpy.zeros((_0._numNonzeros_(),), dtype=numpy.dtype(numpy.float64))
     _0._getDataAsTriplets__3I_3I_3D(_11,_12,_13)
     _14=numpy.array([((numpy.int64(_11[_15]) * _4) + _12[_15]) for _15 in range(0,int((_12).shape[0]))], dtype=numpy.dtype(numpy.int64))
     _9 = mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(mosek.fusion.Utils.Tools._range_JJ(0,(_0._numNonzeros_() + 1)),numpy.array([_1], dtype=numpy.dtype(object)),mosek.fusion.Utils.Tools._makevector_JI(0,numpy.int32(_0._numNonzeros_())),_13,None,_10,_14)
    else:
     _9 = mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(mosek.fusion.Utils.Tools._range_JJ(0,(_0._numNonzeros_() + 1)),numpy.array([_1], dtype=numpy.dtype(object)),numpy.array([0 for _16 in range(0,_0._numNonzeros_())], dtype=numpy.dtype(numpy.int64)),_0._getDataAsArray_(),None,_10,None)
   elif (_4==_5):
    if _0._isSparse_():
     if (_0._numNonzeros_() > 0):
      _17=numpy.zeros((_0._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
      _18=numpy.zeros((_0._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
      _19=numpy.zeros((_0._numNonzeros_(),), dtype=numpy.dtype(numpy.float64))
      _20=int((_19).shape[0])
      _0._getDataAsTriplets__3I_3I_3D(_17,_18,_19)
      _21=(int((_19).shape[0]) * _6)
      _22=0
      _22 = fragments._c_closure_263(_20,_22,_17) # src/fusion/Expr.mbi:2646:15-2652:16
      _22 = numpy.int32(_22) # postprocess
      _23=(_22 * _6)
      _24=numpy.zeros(((_23 + 1),), dtype=numpy.dtype(numpy.int64))
      _25=numpy.zeros((_23,), dtype=numpy.dtype(numpy.int64))
      _26=numpy.zeros((_21,), dtype=numpy.dtype(numpy.int64))
      _27=numpy.zeros((_21,), dtype=numpy.dtype(numpy.float64))
      fragments._c_closure_264(_27,_25,_19,_20,_22,_17,_18,_24,_26,_6) # src/fusion/Expr.mbi:2660:15-2686:16
      if (int((_25).shape[0])==(_7 * _8)):
       _25 = None
      _9 = mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_24,numpy.array([_1], dtype=numpy.dtype(object)),_26,_27,None,_10,_25)
     else:
      _9 = mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(numpy.array([0], dtype=numpy.dtype(numpy.int64)),numpy.array([_1], dtype=numpy.dtype(object)),numpy.zeros((0,), dtype=numpy.dtype(numpy.int64)),numpy.zeros((0,), dtype=numpy.dtype(numpy.float64)),None,_10,numpy.zeros((0,), dtype=numpy.dtype(numpy.int64)))
    else:
     _28=((_3 * _4) * _6)
     _29=_0._getDataAsArray_()
     _30=mosek.fusion.Utils.Tools._range_JJJ(0,(_28 + 1),(_4 if ((_4 > 0) ) else 1))
     _31=numpy.zeros((_28,), dtype=numpy.dtype(numpy.int64))
     _32=numpy.zeros((_28,), dtype=numpy.dtype(numpy.float64))
     fragments._c_closure_265(_32,_29,_4,_7,_8,_31,_6) # src/fusion/Expr.mbi:2711:13-2721:14
     _9 = mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_30,numpy.array([_1], dtype=numpy.dtype(object)),_31,_32,None,_10,None)
   else:
    raise mosek_fusion_LengthError._ctor_S("Operand shapes do not match.")
   return (_9)
  @staticmethod
  def __dot_1_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr.__dot_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def __dot_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1):
   if ((_0._numRows_()!=_1._shape_()._dim_I(0)) or ((_0._numColumns_()!=_1._shape_()._dim_I(1)) or ((_0._numRows_() * _0._numColumns_())!=_1._shape_()._getSize_()))):
    raise mosek_fusion_DimensionError._ctor_S("Dimensions of operands do not match")
   _2=_0._numNonzeros_()
   _3=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int32))
   _4=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int32))
   _5=numpy.zeros((_2,), dtype=numpy.dtype(numpy.float64))
   _0._getDataAsTriplets__3I_3I_3D(_3,_4,_5)
   _6=numpy.array([((_3[_7] * _0._numColumns_()) + _4[_7]) for _7 in range(0,_2)], dtype=numpy.dtype(numpy.int64))
   _8=_1._eval_()
   return (mosek.fusion.Expr.__inner_1__3J_3D_3J_3J_3D_3D_3J_3Lmosek_4fusion_4Variable_2(_6,_5,(_8.ptrb),(_8.subj),(_8.cof),(_8.bfix),(_8.inst),(_8.x)))
  @staticmethod
  def __dot_1_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr.__dot_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def __dot_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_0,_1):
   if ((_0._numRows_()!=_1._shape_()._dim_I(0)) or ((_0._numColumns_()!=_1._shape_()._dim_I(1)) or ((_0._numRows_() * _0._numColumns_())!=_1._shape_()._getSize_()))):
    raise mosek_fusion_DimensionError._ctor_S("Dimensions of operands do not match")
   _2=_0._numNonzeros_()
   _3=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int32))
   _4=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int32))
   _5=numpy.zeros((_2,), dtype=numpy.dtype(numpy.float64))
   _0._getDataAsTriplets__3I_3I_3D(_3,_4,_5)
   _6=numpy.array([((_3[_7] * _0._numColumns_()) + _4[_7]) for _7 in range(0,_2)], dtype=numpy.dtype(numpy.int64))
   return (mosek.fusion.Expr.__inner_1__3J_3DLmosek_4fusion_4Variable_2(_6,_5,_1))
  @staticmethod
  def __dot_1_alt__3DLmosek_4fusion_4Variable_2(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr.__dot_1__3DLmosek_4fusion_4Variable_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __dot_1__3DLmosek_4fusion_4Variable_2(_0,_1):
   if ((_1 is None) or (_0 is None)):
    raise ValueError("Arguments for dot may not be null")
   if ((_1._shape_()._dim_I(0)!=int((_0).shape[0])) or ((_1._shape_()._size)!=long((_0).shape[0]))):
    raise mosek_fusion_DimensionError._ctor_S("Dimensions of operands do not match")
   return (mosek.fusion.Expr.__inner_1__3J_3DLmosek_4fusion_4Variable_2(mosek.fusion.Utils.Tools._range_JJ(0,long((_0).shape[0])),_0,_1))
  @staticmethod
  def __dot_1_alt__3DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr.__dot_1__3DLmosek_4fusion_4Expression_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __dot_1__3DLmosek_4fusion_4Expression_2(_0,_1):
   if ((_0 is None) or (_1 is None)):
    raise ValueError("Arguments for dot may not be null")
   if ((_1._shape_()._dim_I(0)!=int((_0).shape[0])) or ((_1._shape_()._size)!=long((_0).shape[0]))):
    raise mosek_fusion_DimensionError._ctor_S("Dimensions of operands do not match")
   _2=_1._eval_()
   return (mosek.fusion.Expr.__inner_1__3J_3D_3J_3J_3D_3D_3J_3Lmosek_4fusion_4Variable_2(mosek.fusion.Utils.Tools._range_JJ(0,long((_0).shape[0])),_0,(_2.ptrb),(_2.subj),(_2.cof),(_2.bfix),(_2.inst),(_2.x)))
  @staticmethod
  def __dot_1_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr.__dot_1_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def __dot_1_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_0,_1):
   if ((_0 is None) or (_1 is None)):
    raise ValueError("Arguments for dot may not be null")
   for _2 in range(0,int(((_0._dims)).shape[0])):
    if ((_0._dims)[_2]!=_1._shape_()._dim_I(_2)):
     raise mosek_fusion_DimensionError._ctor_S("Dimensions of operands do not match")
   for _3 in range(int(((_0._dims)).shape[0]),(_1._shape_().nd)):
    if (1!=_1._shape_()._dim_I(_3)):
     raise mosek_fusion_DimensionError._ctor_S("Dimensions of operands do not match")
   for _4 in range(0,int(((_0._dims)).shape[0])):
    if ((_0._dims)[_4]!=_1._shape_()._dim_I(_4)):
     raise mosek_fusion_LengthError._ctor_S("Dimension mismatch")
   _5=_1._eval_()
   return (mosek.fusion.Expr.__inner_1__3J_3D_3J_3J_3D_3D_3J_3Lmosek_4fusion_4Variable_2((_0._inst),(_0._cof),(_5.ptrb),(_5.subj),(_5.cof),(_5.bfix),(_5.inst),(_5.x)))
  @staticmethod
  def __dot_1_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr.__dot_1_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def __dot_1_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(_0,_1):
   if ((_1._shape_().nd)!=int(((_0._dims)).shape[0])):
    raise mosek_fusion_LengthError._ctor_S("Dimension mismatch")
   for _2 in range(0,int(((_0._dims)).shape[0])):
    if ((_0._dims)[_2]!=_1._shape_()._dim_I(_2)):
     raise mosek_fusion_LengthError._ctor_S("Dimension mismatch")
   return (mosek.fusion.Expr.__inner_1__3J_3DLmosek_4fusion_4Variable_2((_0._inst),(_0._cof),_1))
  @staticmethod
  def __inner_1_alt__3J_3DLmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=_t__2
   _1 = mosek_fusion_Expr.__inner_1__3J_3DLmosek_4fusion_4Variable_2(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __inner_1__3J_3DLmosek_4fusion_4Variable_2(_0,_1,_2):
   _3=int((_0).shape[0])
   _4=numpy.array([0,long((_1).shape[0])], dtype=numpy.dtype(numpy.int64))
   _5=mosek.fusion.Utils.Tools._arraycopy__3J(_0)
   _6=mosek.fusion.Utils.Tools._arraycopy__3D(_1)
   _7=None
   return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_4,numpy.array([_2], dtype=numpy.dtype(object)),_5,_6,_7,mosek.fusion.Set._scalar_(),None))
  @staticmethod
  def __inner_1_alt__3J_3D_3J_3J_3D_3D_3J_3Lmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int64))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.float64))
   _6=numpy.array(_t__6,dtype=numpy.dtype(numpy.int64))
   _7=numpy.array(_t__7,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Expr.__inner_1__3J_3D_3J_3J_3D_3D_3J_3Lmosek_4fusion_4Variable_2(_0,_1,_2,_3,_4,_5,_6,_7)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__6[:] = _6
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__7[:] = _7
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __inner_1__3J_3D_3J_3J_3D_3D_3J_3Lmosek_4fusion_4Variable_2(_0,_1,_2,_3,_4,_5,_6,_7):
   _8=int((_0).shape[0])
   _9=(_6 if ((_6 is not None) ) else mosek.fusion.Utils.Tools._range_JJ(0,(long((_2).shape[0]) - 1)))
   _10=int((_9).shape[0])
   _11=0
   _11 = fragments._c_closure_266(_9,_10,_2,_0,_8,_11) # src/fusion/Expr.mbi:2354:9-2366:10
   _11 = numpy.int64(_11) # postprocess
   _12=numpy.zeros((_11,), dtype=numpy.dtype(numpy.int64))
   _13=numpy.zeros((_11,), dtype=numpy.dtype(numpy.float64))
   _14=numpy.zeros((1,), dtype=numpy.dtype(numpy.float64))
   _15=numpy.array([0,_11], dtype=numpy.dtype(numpy.int64))
   fragments._c_closure_267(_13,_4,_9,_10,_2,_3,_0,_8,_1,_12) # src/fusion/Expr.mbi:2373:9-2390:10
   fragments._c_closure_268(_14,_5,_9,_10,_0,_8,_1) # src/fusion/Expr.mbi:2392:9-2405:10
   return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_15,_7,_12,_13,_14,mosek.fusion.Set._scalar_(),None))
  @staticmethod
  def _match_outer__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_outer__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _outer_alt__3DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._outer__3DLmosek_4fusion_4Expression_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _outer__3DLmosek_4fusion_4Expression_2(_0,_1):
   if (((_1._shape_().nd)!=1) or ((_1._shape_().nd)!=1)):
    raise mosek_fusion_DimensionError._ctor_S("Arguments must be one-dimensional")
   if (_1._shape_()._dim_I(0)!=int((_0).shape[0])):
    raise mosek_fusion_DimensionError._ctor_S("Argument lengths do not match")
   _2=_1._eval_()
   return (mosek.fusion.Expr.__outer_1_I_3J_3J_3D_3D_3J_3Lmosek_4fusion_4Variable_2_3D_3IIZ((_2.shape)._dim_I(0),(_2.ptrb),(_2.subj),(_2.cof),(_2.bfix),(_2.inst),(_2.x),_0,numpy.array([_3 for _3 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32)),int((_0).shape[0]),True))
  @staticmethod
  def _match_outer_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match__3D__(_1))
  @staticmethod
  def _match_alt_outer_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match__3D__(_1))
  @staticmethod
  def _outer_alt_Lmosek_4fusion_4Expression_2_3D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._outer_Lmosek_4fusion_4Expression_2_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _outer_Lmosek_4fusion_4Expression_2_3D(_0,_1):
   if (((_0._shape_().nd)!=1) or ((_0._shape_().nd)!=1)):
    raise mosek_fusion_DimensionError._ctor_S("Arguments must be one-dimensional")
   _2=_0._eval_()
   return (mosek.fusion.Expr.__outer_1_I_3J_3J_3D_3D_3J_3Lmosek_4fusion_4Variable_2_3D_3IIZ((_2.shape)._dim_I(0),(_2.ptrb),(_2.subj),(_2.cof),(_2.bfix),(_2.inst),(_2.x),_1,numpy.array([_3 for _3 in range(0,int((_1).shape[0]))], dtype=numpy.dtype(numpy.int32)),int((_1).shape[0]),False))
  @staticmethod
  def _match_outer_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_outer_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _outer_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr._outer_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def _outer_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_0,_1):
   if (not (((_1._shape_().nd)==1) or (((_1._shape_().nd)==2) and (_1._shape_()._dim_I(1)==1)))):
    raise mosek_fusion_DimensionError._ctor_S("Variable argument must be one-dimensional")
   if ((_0._dimj)!=1):
    raise mosek_fusion_DimensionError._ctor_S("Constant matrix must be a column-vector")
   _3=_0
   if   isinstance(_3,mosek_fusion_DenseMatrix):
    m=_3
    return (mosek.fusion.Expr.__outer_1_Lmosek_4fusion_4Variable_2I_3D_3IIZ(_1,_1._shape_()._dim_I(0),(m._data),None,int(((m._data)).shape[0]),True))
   else:
    mx=_3
    _3=numpy.zeros((mx._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
    _4=numpy.zeros((mx._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
    _5=numpy.zeros((mx._numNonzeros_(),), dtype=numpy.dtype(numpy.float64))
    mx._getDataAsTriplets__3I_3I_3D(_3,_4,_5)
    return (mosek.fusion.Expr.__outer_1_Lmosek_4fusion_4Variable_2I_3D_3IIZ(_1,_1._shape_()._dim_I(0),_5,_3,(mx._dimi),True))
  @staticmethod
  def _match_outer_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_outer_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _outer_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Expr._outer_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_0,_1)
  @staticmethod
  def _outer_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_0,_1):
   if (not (((_0._shape_().nd)==1) or (((_0._shape_().nd)==2) and (_0._shape_()._dim_I(1)==1)))):
    raise mosek_fusion_DimensionError._ctor_S("Variable argument must be one-dimensional")
   if ((_1._dimj)!=1):
    raise mosek_fusion_DimensionError._ctor_S("Constant matrix must be a column-vector")
   _3=_1
   if   isinstance(_3,mosek_fusion_DenseMatrix):
    m=_3
    return (mosek.fusion.Expr.__outer_1_Lmosek_4fusion_4Variable_2I_3D_3IIZ(_0,_0._shape_()._dim_I(0),(m._data),None,int(((m._data)).shape[0]),False))
   else:
    mx=_3
    _3=numpy.zeros((_1._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
    _4=numpy.zeros((mx._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
    _5=numpy.zeros((mx._numNonzeros_(),), dtype=numpy.dtype(numpy.float64))
    mx._getDataAsTriplets__3I_3I_3D(_3,_4,_5)
    return (mosek.fusion.Expr.__outer_1_Lmosek_4fusion_4Variable_2I_3D_3IIZ(_0,_0._shape_()._dim_I(0),_5,_3,(mx._dimi),False))
  @staticmethod
  def _match_outer__3DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_outer__3DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _outer_alt__3DLmosek_4fusion_4Variable_2(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._outer__3DLmosek_4fusion_4Variable_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _outer__3DLmosek_4fusion_4Variable_2(_0,_1):
   if (not (((_1._shape_().nd)==1) or (((_1._shape_().nd)==2) and (_1._shape_()._dim_I(1)==1)))):
    raise mosek_fusion_DimensionError._ctor_S("Variable argument must be one-dimensional")
   return (mosek.fusion.Expr.__outer_1_Lmosek_4fusion_4Variable_2I_3D_3IIZ(_1,_1._shape_()._dim_I(0),_0,None,int((_0).shape[0]),True))
  @staticmethod
  def _match_outer_Lmosek_4fusion_4Variable_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match__3D__(_1))
  @staticmethod
  def _match_alt_outer_Lmosek_4fusion_4Variable_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match__3D__(_1))
  @staticmethod
  def _outer_alt_Lmosek_4fusion_4Variable_2_3D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._outer_Lmosek_4fusion_4Variable_2_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _outer_Lmosek_4fusion_4Variable_2_3D(_0,_1):
   if (not (((_0._shape_().nd)==1) or (((_0._shape_().nd)==2) and (_0._shape_()._dim_I(1)==1)))):
    raise mosek_fusion_DimensionError._ctor_S("Variable argument must be one-dimensional")
   return (mosek.fusion.Expr.__outer_1_Lmosek_4fusion_4Variable_2I_3D_3IIZ(_0,_0._shape_()._dim_I(0),_1,None,int((_1).shape[0]),False))
  @staticmethod
  def __outer_1_alt_I_3J_3J_3D_3D_3J_3Lmosek_4fusion_4Variable_2_3D_3IIZ(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7,_t__8,_t__9,_t__10):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.float64))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.int64))
   _6=numpy.array(_t__6,dtype=numpy.dtype(object))
   _7=numpy.array(_t__7,dtype=numpy.dtype(numpy.float64))
   _8=numpy.array(_t__8,dtype=numpy.dtype(numpy.int32))
   _9=numpy.int32(_t__9)
   _10=_t__10
   _1 = mosek_fusion_Expr.__outer_1_I_3J_3J_3D_3D_3J_3Lmosek_4fusion_4Variable_2_3D_3IIZ(_0,_1,_2,_3,_4,_5,_6,_7,_8,_9,_10)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__6[:] = _6
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__7[:] = _7
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__8[:] = _8
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __outer_1_I_3J_3J_3D_3D_3J_3Lmosek_4fusion_4Variable_2_3D_3IIZ(_0,_1,_2,_3,_4,_5,_6,_7,_8,_9,_10):
   _11=(mosek.fusion.Set._make_II(_0,_9) if ((not _10) ) else mosek.fusion.Set._make_II(_9,_0))
   _12=(int((_7).shape[0]) * int((_5).shape[0]))
   _13=(int((_7).shape[0]) * int((_2).shape[0]))
   _14=numpy.zeros(((_12 + 1),), dtype=numpy.dtype(numpy.int64))
   _15=numpy.zeros((_13,), dtype=numpy.dtype(numpy.int64))
   _16=numpy.zeros((_13,), dtype=numpy.dtype(numpy.float64))
   _17=(numpy.zeros((_12,), dtype=numpy.dtype(numpy.float64)) if ((_4 is not None) ) else None)
   _18=numpy.zeros((_12,), dtype=numpy.dtype(numpy.int64))
   _19=numpy.int32(_14[(int((_14).shape[0]) - 1)])
   fragments._c_closure_269(_7,_17,_16,_9,_4,_3,_5,_19,_1,_2,_14,_8,_15,_10) # src/fusion/Expr.mbi:2150:9-2217:10
   return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_14,_6,_15,_16,_17,_11,_18))
  @staticmethod
  def __outer_1_alt_Lmosek_4fusion_4Variable_2I_3D_3IIZ(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=_t__0
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.int32(_t__4)
   _5=_t__5
   _1 = mosek_fusion_Expr.__outer_1_Lmosek_4fusion_4Variable_2I_3D_3IIZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __outer_1_Lmosek_4fusion_4Variable_2I_3D_3IIZ(_0,_1,_2,_3,_4,_5):
   _6=(mosek.fusion.Set._make_II(_1,_4) if ((not _5) ) else mosek.fusion.Set._make_II(_4,_1))
   _7=numpy.zeros((((int((_2).shape[0]) * _1) + 1),), dtype=numpy.dtype(numpy.int64))
   _8=numpy.zeros(((int((_2).shape[0]) * _1),), dtype=numpy.dtype(numpy.int64))
   _9=numpy.zeros(((int((_2).shape[0]) * _1),), dtype=numpy.dtype(numpy.float64))
   _10=None
   _11=(None if ((_4==int((_2).shape[0])) ) else numpy.zeros(((int((_2).shape[0]) * _1),), dtype=numpy.dtype(numpy.int64)))
   fragments._c_closure_270(_2,_9,_4,_11,_7,_3,_8,_5,_1) # src/fusion/Expr.mbi:2055:9-2108:10
   return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_7,numpy.array([_0], dtype=numpy.dtype(object)),_8,_9,_10,_6,_11))
  @staticmethod
  def _match_pick__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5I__(_0))
  @staticmethod
  def _match_alt_pick__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5I__(_0))
  def _pick_alt__3_5I(self,_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3_5I(_0)
   return _1
  def _pick__3_5I(self,_0):
   _1=_0
   if ((self.__shape_p.nd)!=int((_1).shape[1])):
    raise mosek_fusion_DimensionError._ctor_S("Invalid index size")
   for _2 in range(0,int((_1).shape[0])):
    for _3 in range(0,int((_1).shape[1])):
     if ((_1[_2,_3] < 0) or (_1[_2,_3] >= self.__shape_p._dim_I(_3))):
      raise mosek_fusion_IndexError._ctor_S("Index is out of bounds")
   return (self.__pick_1__3J(numpy.array([self.__shape_p._linearidx__3I(numpy.array([_1[_4,_5] for _5 in range(0,int((_1).shape[1]))], dtype=numpy.dtype(numpy.int32))) for _4 in range(0,int((_1).shape[0]))], dtype=numpy.dtype(numpy.int64))))
  @staticmethod
  def _match_pick__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_pick__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _pick_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _pick__3I(self,_0):
   if ((self.__shape_p.nd)!=1):
    raise mosek_fusion_DimensionError._ctor_S("Method is only valid for one-dimensional expressions")
   for _1 in range(0,int((_0).shape[0])):
    if ((_0[_1] < 0) or (_0[_1] >= self.__shape_p._dim_I(0))):
     raise mosek_fusion_IndexError._ctor_S("Index is out of bounds")
   return (self.__pick_1__3J(numpy.array([_0[_2] for _2 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int64))))
  def __pick_1_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self.__pick_1__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __pick_1__3J(self,_0):
   if (int((_0).shape[0])==0):
    return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(numpy.array([0], dtype=numpy.dtype(numpy.int64)),self.__x,numpy.zeros((0,), dtype=numpy.dtype(numpy.int64)),numpy.zeros((0,), dtype=numpy.dtype(numpy.float64)),None,mosek.fusion.Set._make_I(0),None))
   if (self.__inst is None):
    _1=0
    _2=numpy.zeros(((int((_0).shape[0]) + 1),), dtype=numpy.dtype(numpy.int64))
    _1 = fragments._c_closure_271(_0,self.__ptrb,_1,_2) # src/fusion/Expr.mbi:1909:11-1913:12
    _1 = numpy.int64(_1) # postprocess
    _3=numpy.zeros((_1,), dtype=numpy.dtype(numpy.int64))
    _4=numpy.zeros((_1,), dtype=numpy.dtype(numpy.float64))
    _5=None
    fragments._c_closure_272(self.__cof_v,_0,self.__ptrb,_4,_2,_3,self.__subj) # src/fusion/Expr.mbi:1918:11-1924:12
    if (self.__bfix is not None):
     _5 = numpy.array([self.__bfix[_0[_6]] for _6 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.float64))
    _7=None
    _8=mosek.fusion.Set._make_I(int((_0).shape[0]))
    return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_2,self.__x,_3,_4,_5,_8,_7))
   else:
    _9=numpy.array([_10 for _10 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int64))
    mosek.fusion.Sort._argsort__3J_3J(_9,_0)
    _11=0
    _12=0
    _11,_12 = fragments._c_closure_273(_0,self.__inst,_9,self.__ptrb,_11,_12) # src/fusion/Expr.mbi:1942:11-1954:12
    _11 = numpy.int32(_11) # postprocess
    _12 = numpy.int64(_12) # postprocess
    _13=numpy.zeros((_11,), dtype=numpy.dtype(numpy.int64))
    _14=numpy.zeros(((_11 + 1),), dtype=numpy.dtype(numpy.int64))
    _15=numpy.zeros((_12,), dtype=numpy.dtype(numpy.int64))
    _16=numpy.zeros((_12,), dtype=numpy.dtype(numpy.float64))
    _17=None
    _18=mosek.fusion.Set._make_I(int((_0).shape[0]))
    _19=numpy.array([(- 1) for _20 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32))
    fragments._c_closure_274(_0,self.__inst,_9,_19) # src/fusion/Expr.mbi:1964:11-1975:12
    fragments._c_closure_275(self.__cof_v,self.__ptrb,_16,_13,_14,_15,_19,self.__subj) # src/fusion/Expr.mbi:1977:11-1991:12
    if (self.__bfix is not None):
     _17 = numpy.zeros((_11,), dtype=numpy.dtype(numpy.float64))
     _21=0
     _21 = fragments._c_closure_276(self.__bfix,_21,_17,_19) # src/fusion/Expr.mbi:1997:13-2002:16
     _21 = numpy.int32(_21) # postprocess
    return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_14,self.__x,_15,_16,_17,_18,_13))
  @staticmethod
  def _match_stack__3_3Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_3Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _match_alt_stack__3_3Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_3Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _stack_alt__3_3Lmosek_4fusion_4Expression_2(_t__0):
   _0=_monty.makeJaggedArray(_t__0,(1,1),numpy.dtype(object))
   _1 = mosek_fusion_Expr._stack__3_3Lmosek_4fusion_4Expression_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _stack__3_3Lmosek_4fusion_4Expression_2(_0):
   if (_0 is None):
    raise ValueError("Argument exprs may not be null")
   for _1 in range(0,int((_0).shape[0])):
    _2=_0[_1]
    if (_2 is None):
     raise ValueError("Arguments for stack may not be null")
    for _3 in range(0,int((_2).shape[0])):
     if (_2[_3] is None):
      raise ValueError("Arguments for stack may not be null")
   _4=numpy.array([mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(_0[_5],1) for _5 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(object))
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(_4,0))
  @staticmethod
  def _match_vstack_DDD(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_D__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_vstack_DDD(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _vstack_alt_DDD(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_DDD(numpy.float64(__0),numpy.float64(__1),numpy.float64(__2))
  @staticmethod
  def _vstack_DDD(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),mosek.fusion.Expr._constTerm_D(_1),mosek.fusion.Expr._constTerm_D(_2)], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_DDLmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_D__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _match_alt_vstack_DDLmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _vstack_alt_DDLmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_DDLmosek_4fusion_4Variable_2(numpy.float64(__0),numpy.float64(__1),_2)
  @staticmethod
  def _vstack_DDLmosek_4fusion_4Variable_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),mosek.fusion.Expr._constTerm_D(_1),_2._asExpr_()], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_DDLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_D__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_vstack_DDLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _vstack_alt_DDLmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_DDLmosek_4fusion_4Expression_2(numpy.float64(__0),numpy.float64(__1),_2)
  @staticmethod
  def _vstack_DDLmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),mosek.fusion.Expr._constTerm_D(_1),_2], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_DLmosek_4fusion_4Variable_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_vstack_DLmosek_4fusion_4Variable_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _vstack_alt_DLmosek_4fusion_4Variable_2D(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_DLmosek_4fusion_4Variable_2D(numpy.float64(__0),_1,numpy.float64(__2))
  @staticmethod
  def _vstack_DLmosek_4fusion_4Variable_2D(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),_1._asExpr_(),mosek.fusion.Expr._constTerm_D(_2)], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _match_alt_vstack_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _vstack_alt_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(numpy.float64(__0),_1,_2)
  @staticmethod
  def _vstack_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),_1._asExpr_(),_2._asExpr_()], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_vstack_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _vstack_alt_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(numpy.float64(__0),_1,_2)
  @staticmethod
  def _vstack_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),_1._asExpr_(),_2], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_DLmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_vstack_DLmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _vstack_alt_DLmosek_4fusion_4Expression_2D(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_DLmosek_4fusion_4Expression_2D(numpy.float64(__0),_1,numpy.float64(__2))
  @staticmethod
  def _vstack_DLmosek_4fusion_4Expression_2D(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),_1,mosek.fusion.Expr._constTerm_D(_2)], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _match_alt_vstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _vstack_alt_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(numpy.float64(__0),_1,_2)
  @staticmethod
  def _vstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),_1,_2._asExpr_()], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_vstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _vstack_alt_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(numpy.float64(__0),_1,_2)
  @staticmethod
  def _vstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),_1,_2], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Variable_2DD(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_D__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Variable_2DD(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Variable_2DD(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Variable_2DD(_0,numpy.float64(__1),numpy.float64(__2))
  @staticmethod
  def _vstack_Lmosek_4fusion_4Variable_2DD(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0._asExpr_(),mosek.fusion.Expr._constTerm_D(_1),mosek.fusion.Expr._constTerm_D(_2)], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_D__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Variable_2(_0,numpy.float64(__1),_2)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Variable_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0._asExpr_(),mosek.fusion.Expr._constTerm_D(_1),_2._asExpr_()], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_D__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Expression_2(_0,numpy.float64(__1),_2)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0._asExpr_(),mosek.fusion.Expr._constTerm_D(_1),_2], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2D(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2D(_0,_1,numpy.float64(__2))
  @staticmethod
  def _vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2D(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0._asExpr_(),_1._asExpr_(),mosek.fusion.Expr._constTerm_D(_2)], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1,_2)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0._asExpr_(),_1._asExpr_(),_2._asExpr_()], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_0,_1,_2)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0._asExpr_(),_1._asExpr_(),_2], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2D(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2D(_0,_1,numpy.float64(__2))
  @staticmethod
  def _vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2D(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0._asExpr_(),_1,mosek.fusion.Expr._constTerm_D(_2)], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_0,_1,_2)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0._asExpr_(),_1,_2._asExpr_()], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1,_2)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0._asExpr_(),_1,_2], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Expression_2DD(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_D__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Expression_2DD(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Expression_2DD(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2DD(_0,numpy.float64(__1),numpy.float64(__2))
  @staticmethod
  def _vstack_Lmosek_4fusion_4Expression_2DD(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,mosek.fusion.Expr._constTerm_D(_1),mosek.fusion.Expr._constTerm_D(_2)], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_D__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Variable_2(_0,numpy.float64(__1),_2)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Variable_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,mosek.fusion.Expr._constTerm_D(_1),_2._asExpr_()], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_D__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(_0,numpy.float64(__1),_2)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,mosek.fusion.Expr._constTerm_D(_1),_2], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2D(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2D(_0,_1,numpy.float64(__2))
  @staticmethod
  def _vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2D(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,_1._asExpr_(),mosek.fusion.Expr._constTerm_D(_2)], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1,_2)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,_1._asExpr_(),_2._asExpr_()], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_0,_1,_2)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,_1._asExpr_(),_2], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(_0,_1,numpy.float64(__2))
  @staticmethod
  def _vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,_1,mosek.fusion.Expr._constTerm_D(_2)], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_0,_1,_2)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,_1,_2._asExpr_()], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1,_2)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,_1,_2], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_vstack_DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _vstack_alt_DLmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr._vstack_DLmosek_4fusion_4Variable_2(numpy.float64(__0),_1)
  @staticmethod
  def _vstack_DLmosek_4fusion_4Variable_2(_0,_1):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),_1._asExpr_()], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_vstack_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _vstack_alt_DLmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._vstack_DLmosek_4fusion_4Expression_2(numpy.float64(__0),_1)
  @staticmethod
  def _vstack_DLmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),_1], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Variable_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Variable_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Variable_2D(_t__0,_t__1):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Variable_2D(_0,numpy.float64(__1))
  @staticmethod
  def _vstack_Lmosek_4fusion_4Variable_2D(_0,_1):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0._asExpr_(),mosek.fusion.Expr._constTerm_D(_1)], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0._asExpr_(),_1._asExpr_()], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0._asExpr_(),_1], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Expression_2D(_t__0,_t__1):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2D(_0,numpy.float64(__1))
  @staticmethod
  def _vstack_Lmosek_4fusion_4Expression_2D(_0,_1):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,mosek.fusion.Expr._constTerm_D(_1)], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_0,_1):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,_1._asExpr_()], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,_1], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack__3Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _match_alt_vstack__3Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _vstack_alt__3Lmosek_4fusion_4Expression_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Expr._vstack__3Lmosek_4fusion_4Expression_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _vstack__3Lmosek_4fusion_4Expression_2(_0):
   if (_0 is None):
    raise ValueError("Argument exprs may not be null")
   for _1 in range(0,int((_0).shape[0])):
    if (_0[_1] is None):
     raise ValueError("Arguments for vstack may not be null")
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(_0,0))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1,_2)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1,_2):
   if ((_0 is None) or ((_1 is None) or (_2 is None))):
    raise ValueError("Arguments e1, e2 and e3 may not be null")
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,_1,_2], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_0,_1,_2)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,_1,_2._asExpr_()], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(_0,_1,numpy.float64(__2))
  @staticmethod
  def _hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,_1,mosek.fusion.Expr._constTerm_D(_2)], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_0,_1,_2)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,_1._asExpr_(),_2], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1,_2)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,_1._asExpr_(),_2._asExpr_()], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2D(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2D(_0,_1,numpy.float64(__2))
  @staticmethod
  def _hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2D(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,_1._asExpr_(),mosek.fusion.Expr._constTerm_D(_2)], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_D__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(_0,numpy.float64(__1),_2)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,mosek.fusion.Expr._constTerm_D(_1),_2], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_D__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Variable_2(_0,numpy.float64(__1),_2)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Variable_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,mosek.fusion.Expr._constTerm_D(_1),_2._asExpr_()], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Expression_2DD(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_D__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Expression_2DD(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Expression_2DD(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2DD(_0,numpy.float64(__1),numpy.float64(__2))
  @staticmethod
  def _hstack_Lmosek_4fusion_4Expression_2DD(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,mosek.fusion.Expr._constTerm_D(_1),mosek.fusion.Expr._constTerm_D(_2)], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1,_2)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0._asExpr_(),_1,_2], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_0,_1,_2)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0._asExpr_(),_1,_2._asExpr_()], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2D(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2D(_0,_1,numpy.float64(__2))
  @staticmethod
  def _hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2D(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0._asExpr_(),_1,mosek.fusion.Expr._constTerm_D(_2)], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_0,_1,_2)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0._asExpr_(),_1._asExpr_(),_2], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1,_2)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0._asExpr_(),_1._asExpr_(),_2._asExpr_()], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2D(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2D(_0,_1,numpy.float64(__2))
  @staticmethod
  def _hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2D(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0._asExpr_(),_1._asExpr_(),mosek.fusion.Expr._constTerm_D(_2)], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_D__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Expression_2(_0,numpy.float64(__1),_2)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0._asExpr_(),mosek.fusion.Expr._constTerm_D(_1),_2], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_D__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Variable_2(_0,numpy.float64(__1),_2)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Variable_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0._asExpr_(),mosek.fusion.Expr._constTerm_D(_1),_2._asExpr_()], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Variable_2DD(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_D__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Variable_2DD(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Variable_2DD(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Variable_2DD(_0,numpy.float64(__1),numpy.float64(__2))
  @staticmethod
  def _hstack_Lmosek_4fusion_4Variable_2DD(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0._asExpr_(),mosek.fusion.Expr._constTerm_D(_1),mosek.fusion.Expr._constTerm_D(_2)], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_hstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _hstack_alt_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(numpy.float64(__0),_1,_2)
  @staticmethod
  def _hstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),_1,_2], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _match_alt_hstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _hstack_alt_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(numpy.float64(__0),_1,_2)
  @staticmethod
  def _hstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),_1,_2._asExpr_()], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_DLmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_hstack_DLmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _hstack_alt_DLmosek_4fusion_4Expression_2D(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_DLmosek_4fusion_4Expression_2D(numpy.float64(__0),_1,numpy.float64(__2))
  @staticmethod
  def _hstack_DLmosek_4fusion_4Expression_2D(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),_1,mosek.fusion.Expr._constTerm_D(_2)], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_hstack_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _hstack_alt_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(numpy.float64(__0),_1,_2)
  @staticmethod
  def _hstack_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),_1._asExpr_(),_2], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _match_alt_hstack_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _hstack_alt_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(numpy.float64(__0),_1,_2)
  @staticmethod
  def _hstack_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),_1._asExpr_(),_2._asExpr_()], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_DLmosek_4fusion_4Variable_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_hstack_DLmosek_4fusion_4Variable_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _hstack_alt_DLmosek_4fusion_4Variable_2D(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_DLmosek_4fusion_4Variable_2D(numpy.float64(__0),_1,numpy.float64(__2))
  @staticmethod
  def _hstack_DLmosek_4fusion_4Variable_2D(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),_1._asExpr_(),mosek.fusion.Expr._constTerm_D(_2)], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_DDLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_D__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_hstack_DDLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _hstack_alt_DDLmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_DDLmosek_4fusion_4Expression_2(numpy.float64(__0),numpy.float64(__1),_2)
  @staticmethod
  def _hstack_DDLmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),mosek.fusion.Expr._constTerm_D(_1),_2], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_DDLmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_D__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _match_alt_hstack_DDLmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _hstack_alt_DDLmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_DDLmosek_4fusion_4Variable_2(numpy.float64(__0),numpy.float64(__1),_2)
  @staticmethod
  def _hstack_DDLmosek_4fusion_4Variable_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),mosek.fusion.Expr._constTerm_D(_1),_2._asExpr_()], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0._asExpr_(),_1], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0._asExpr_(),_1._asExpr_()], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Variable_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Variable_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Variable_2D(_t__0,_t__1):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Variable_2D(_0,numpy.float64(__1))
  @staticmethod
  def _hstack_Lmosek_4fusion_4Variable_2D(_0,_1):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0._asExpr_(),mosek.fusion.Expr._constTerm_D(_1)], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_hstack_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _hstack_alt_DLmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._hstack_DLmosek_4fusion_4Expression_2(numpy.float64(__0),_1)
  @staticmethod
  def _hstack_DLmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),_1], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_hstack_DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _hstack_alt_DLmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr._hstack_DLmosek_4fusion_4Variable_2(numpy.float64(__0),_1)
  @staticmethod
  def _hstack_DLmosek_4fusion_4Variable_2(_0,_1):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),_1._asExpr_()], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_0,_1):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,_1._asExpr_()], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Expression_2D(_t__0,_t__1):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2D(_0,numpy.float64(__1))
  @staticmethod
  def _hstack_Lmosek_4fusion_4Expression_2D(_0,_1):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,mosek.fusion.Expr._constTerm_D(_1)], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,_1], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack__3Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _match_alt_hstack__3Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _hstack_alt__3Lmosek_4fusion_4Expression_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Expr._hstack__3Lmosek_4fusion_4Expression_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _hstack__3Lmosek_4fusion_4Expression_2(_0):
   if (_0 is None):
    raise ValueError("Argument exprs may not be null")
   for _1 in range(0,int((_0).shape[0])):
    if (_0[_1] is None):
     raise ValueError("Arguments for hstack may not be null")
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(_0,1))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_match_Lmosek_4fusion_4Expression_2__(_3))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_3))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(numpy.int32(__0),_1,_2,_3)
  @staticmethod
  def _stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1,_2,_3):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1,_2,_3], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_match_Lmosek_4fusion_4Variable_2__(_3))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_3))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(numpy.int32(__0),_1,_2,_3)
  @staticmethod
  def _stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_0,_1,_2,_3):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1,_2,_3._asExpr_()], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_match_D__(_3))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_alt_match_D__(_3))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(numpy.int32(__0),_1,_2,numpy.float64(__3))
  @staticmethod
  def _stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(_0,_1,_2,_3):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1,_2,mosek.fusion.Expr._constTerm_D(_3)], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2) and __arg_match_Lmosek_4fusion_4Expression_2__(_3))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_3))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(numpy.int32(__0),_1,_2,_3)
  @staticmethod
  def _stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_0,_1,_2,_3):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1,_2._asExpr_(),_3], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2) and __arg_match_Lmosek_4fusion_4Variable_2__(_3))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_3))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(numpy.int32(__0),_1,_2,_3)
  @staticmethod
  def _stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1,_2,_3):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1,_2._asExpr_(),_3._asExpr_()], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2D(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2) and __arg_match_D__(_3))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2D(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2) and __arg_alt_match_D__(_3))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2D(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2D(numpy.int32(__0),_1,_2,numpy.float64(__3))
  @staticmethod
  def _stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2D(_0,_1,_2,_3):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1,_2._asExpr_(),mosek.fusion.Expr._constTerm_D(_3)], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_D__(_2) and __arg_match_Lmosek_4fusion_4Expression_2__(_3))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_D__(_2) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_3))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(numpy.int32(__0),_1,numpy.float64(__2),_3)
  @staticmethod
  def _stack_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(_0,_1,_2,_3):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1,mosek.fusion.Expr._constTerm_D(_2),_3], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_D__(_2) and __arg_match_Lmosek_4fusion_4Variable_2__(_3))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_D__(_2) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_3))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Variable_2(numpy.int32(__0),_1,numpy.float64(__2),_3)
  @staticmethod
  def _stack_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Variable_2(_0,_1,_2,_3):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1,mosek.fusion.Expr._constTerm_D(_2),_3._asExpr_()], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Expression_2DD(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_D__(_2) and __arg_match_D__(_3))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Expression_2DD(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_D__(_2) and __arg_alt_match_D__(_3))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Expression_2DD(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2DD(numpy.int32(__0),_1,numpy.float64(__2),numpy.float64(__3))
  @staticmethod
  def _stack_ILmosek_4fusion_4Expression_2DD(_0,_1,_2,_3):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1,mosek.fusion.Expr._constTerm_D(_2),mosek.fusion.Expr._constTerm_D(_3)], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_match_Lmosek_4fusion_4Expression_2__(_3))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_3))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(numpy.int32(__0),_1,_2,_3)
  @staticmethod
  def _stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1,_2,_3):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1._asExpr_(),_2,_3], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_match_Lmosek_4fusion_4Variable_2__(_3))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_3))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(numpy.int32(__0),_1,_2,_3)
  @staticmethod
  def _stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_0,_1,_2,_3):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1._asExpr_(),_2,_3._asExpr_()], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_match_D__(_3))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_alt_match_D__(_3))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2D(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2D(numpy.int32(__0),_1,_2,numpy.float64(__3))
  @staticmethod
  def _stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2D(_0,_1,_2,_3):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1._asExpr_(),_2,mosek.fusion.Expr._constTerm_D(_3)], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2) and __arg_match_Lmosek_4fusion_4Expression_2__(_3))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_3))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(numpy.int32(__0),_1,_2,_3)
  @staticmethod
  def _stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_0,_1,_2,_3):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1._asExpr_(),_2._asExpr_(),_3], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2) and __arg_match_Lmosek_4fusion_4Variable_2__(_3))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_3))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(numpy.int32(__0),_1,_2,_3)
  @staticmethod
  def _stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1,_2,_3):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1._asExpr_(),_2._asExpr_(),_3._asExpr_()], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2D(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2) and __arg_match_D__(_3))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2D(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2) and __arg_alt_match_D__(_3))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2D(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2D(numpy.int32(__0),_1,_2,numpy.float64(__3))
  @staticmethod
  def _stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2D(_0,_1,_2,_3):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1._asExpr_(),_2._asExpr_(),mosek.fusion.Expr._constTerm_D(_3)], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Variable_2DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_D__(_2) and __arg_match_Lmosek_4fusion_4Expression_2__(_3))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Variable_2DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_D__(_2) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_3))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Variable_2DLmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Variable_2DLmosek_4fusion_4Expression_2(numpy.int32(__0),_1,numpy.float64(__2),_3)
  @staticmethod
  def _stack_ILmosek_4fusion_4Variable_2DLmosek_4fusion_4Expression_2(_0,_1,_2,_3):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1._asExpr_(),mosek.fusion.Expr._constTerm_D(_2),_3], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Variable_2DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_D__(_2) and __arg_match_Lmosek_4fusion_4Variable_2__(_3))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Variable_2DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_D__(_2) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_3))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Variable_2DLmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Variable_2DLmosek_4fusion_4Variable_2(numpy.int32(__0),_1,numpy.float64(__2),_3)
  @staticmethod
  def _stack_ILmosek_4fusion_4Variable_2DLmosek_4fusion_4Variable_2(_0,_1,_2,_3):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1._asExpr_(),mosek.fusion.Expr._constTerm_D(_2),_3._asExpr_()], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Variable_2DD(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_D__(_2) and __arg_match_D__(_3))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Variable_2DD(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_D__(_2) and __arg_alt_match_D__(_3))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Variable_2DD(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Variable_2DD(numpy.int32(__0),_1,numpy.float64(__2),numpy.float64(__3))
  @staticmethod
  def _stack_ILmosek_4fusion_4Variable_2DD(_0,_1,_2,_3):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1._asExpr_(),mosek.fusion.Expr._constTerm_D(_2),mosek.fusion.Expr._constTerm_D(_3)], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_D__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_match_Lmosek_4fusion_4Expression_2__(_3))
  @staticmethod
  def _match_alt_stack_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_3))
  @staticmethod
  def _stack_alt_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(numpy.int32(__0),numpy.float64(__1),_2,_3)
  @staticmethod
  def _stack_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1,_2,_3):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_1),_2,_3], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_D__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_match_Lmosek_4fusion_4Variable_2__(_3))
  @staticmethod
  def _match_alt_stack_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_3))
  @staticmethod
  def _stack_alt_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(numpy.int32(__0),numpy.float64(__1),_2,_3)
  @staticmethod
  def _stack_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_0,_1,_2,_3):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_1),_2,_3._asExpr_()], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_IDLmosek_4fusion_4Expression_2D(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_D__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_match_D__(_3))
  @staticmethod
  def _match_alt_stack_IDLmosek_4fusion_4Expression_2D(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_alt_match_D__(_3))
  @staticmethod
  def _stack_alt_IDLmosek_4fusion_4Expression_2D(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_IDLmosek_4fusion_4Expression_2D(numpy.int32(__0),numpy.float64(__1),_2,numpy.float64(__3))
  @staticmethod
  def _stack_IDLmosek_4fusion_4Expression_2D(_0,_1,_2,_3):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_1),_2,mosek.fusion.Expr._constTerm_D(_3)], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_IDLmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_D__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2) and __arg_match_Lmosek_4fusion_4Expression_2__(_3))
  @staticmethod
  def _match_alt_stack_IDLmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_3))
  @staticmethod
  def _stack_alt_IDLmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_IDLmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(numpy.int32(__0),numpy.float64(__1),_2,_3)
  @staticmethod
  def _stack_IDLmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_0,_1,_2,_3):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_1),_2._asExpr_(),_3], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_IDLmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_D__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2) and __arg_match_Lmosek_4fusion_4Variable_2__(_3))
  @staticmethod
  def _match_alt_stack_IDLmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_3))
  @staticmethod
  def _stack_alt_IDLmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_IDLmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(numpy.int32(__0),numpy.float64(__1),_2,_3)
  @staticmethod
  def _stack_IDLmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1,_2,_3):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_1),_2._asExpr_(),_3._asExpr_()], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_IDLmosek_4fusion_4Variable_2D(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_D__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2) and __arg_match_D__(_3))
  @staticmethod
  def _match_alt_stack_IDLmosek_4fusion_4Variable_2D(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2) and __arg_alt_match_D__(_3))
  @staticmethod
  def _stack_alt_IDLmosek_4fusion_4Variable_2D(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_IDLmosek_4fusion_4Variable_2D(numpy.int32(__0),numpy.float64(__1),_2,numpy.float64(__3))
  @staticmethod
  def _stack_IDLmosek_4fusion_4Variable_2D(_0,_1,_2,_3):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_1),_2._asExpr_(),mosek.fusion.Expr._constTerm_D(_3)], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_IDDLmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_D__(_1) and __arg_match_D__(_2) and __arg_match_Lmosek_4fusion_4Expression_2__(_3))
  @staticmethod
  def _match_alt_stack_IDDLmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_D__(_2) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_3))
  @staticmethod
  def _stack_alt_IDDLmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_IDDLmosek_4fusion_4Expression_2(numpy.int32(__0),numpy.float64(__1),numpy.float64(__2),_3)
  @staticmethod
  def _stack_IDDLmosek_4fusion_4Expression_2(_0,_1,_2,_3):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_1),mosek.fusion.Expr._constTerm_D(_2),_3], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_IDDLmosek_4fusion_4Variable_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_D__(_1) and __arg_match_D__(_2) and __arg_match_Lmosek_4fusion_4Variable_2__(_3))
  @staticmethod
  def _match_alt_stack_IDDLmosek_4fusion_4Variable_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_D__(_2) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_3))
  @staticmethod
  def _stack_alt_IDDLmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_IDDLmosek_4fusion_4Variable_2(numpy.int32(__0),numpy.float64(__1),numpy.float64(__2),_3)
  @staticmethod
  def _stack_IDDLmosek_4fusion_4Variable_2(_0,_1,_2,_3):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_1),mosek.fusion.Expr._constTerm_D(_2),_3._asExpr_()], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(numpy.int32(__0),_1,_2)
  @staticmethod
  def _stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1._asExpr_(),_2], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(numpy.int32(__0),_1,_2)
  @staticmethod
  def _stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1._asExpr_(),_2._asExpr_()], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Variable_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Variable_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Variable_2D(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Variable_2D(numpy.int32(__0),_1,numpy.float64(__2))
  @staticmethod
  def _stack_ILmosek_4fusion_4Variable_2D(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1._asExpr_(),mosek.fusion.Expr._constTerm_D(_2)], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_IDLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_D__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_stack_IDLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _stack_alt_IDLmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._stack_IDLmosek_4fusion_4Expression_2(numpy.int32(__0),numpy.float64(__1),_2)
  @staticmethod
  def _stack_IDLmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_1),_2], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_IDLmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_D__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _match_alt_stack_IDLmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _stack_alt_IDLmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._stack_IDLmosek_4fusion_4Variable_2(numpy.int32(__0),numpy.float64(__1),_2)
  @staticmethod
  def _stack_IDLmosek_4fusion_4Variable_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_1),_2._asExpr_()], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(numpy.int32(__0),_1,_2)
  @staticmethod
  def _stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1,_2._asExpr_()], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Expression_2D(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2D(numpy.int32(__0),_1,numpy.float64(__2))
  @staticmethod
  def _stack_ILmosek_4fusion_4Expression_2D(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1,mosek.fusion.Expr._constTerm_D(_2)], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(numpy.int32(__0),_1,_2)
  @staticmethod
  def _stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1,_2], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_I_3Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match__3Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_stack_I_3Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match__3Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _stack_alt_I_3Lmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Expr._stack_I_3Lmosek_4fusion_4Expression_2(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _stack_I_3Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(_1,_0))
  @staticmethod
  def _stack_1_alt__3Lmosek_4fusion_4Expression_2I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_Expr._stack_1__3Lmosek_4fusion_4Expression_2I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _stack_1__3Lmosek_4fusion_4Expression_2I(_0,_1):
   if (int((_0).shape[0])==0):
    return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(numpy.array([0], dtype=numpy.dtype(numpy.int64)),numpy.zeros((0,), dtype=numpy.dtype(object)),numpy.zeros((0,), dtype=numpy.dtype(numpy.int64)),numpy.zeros((0,), dtype=numpy.dtype(numpy.float64)),None,mosek.fusion.Set._make_I(0),numpy.zeros((0,), dtype=numpy.dtype(numpy.int64)),1))
   if (int((_0).shape[0])==1):
    return (_0[0])
   _2=(_1 + 1)
   for _3 in range(0,int((_0).shape[0])):
    if ((_0[_3]._shape_().nd) > _2):
     _2 = (_0[_3]._shape_().nd)
   _4=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(object))
   _5=_0[0]
   _6=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int32))
   _7=True
   _8=False
   _9=None
   _10=0
   _11=None
   if ((_5._shape_().nd) < _1):
    raise mosek_fusion_LengthError._ctor_S("Invalid stack dimension")
   for _12 in range(0,int((_4).shape[0])):
    _13=_0[_12]
    for _14 in range(0,(_13._shape_().nd)):
     if ((_1!=_14) and (_5._shape_()._dim_I(_14)!=_13._shape_()._dim_I(_14))):
      raise mosek_fusion_DimensionError._ctor_S("Mismatching dimensions")
    _6[_1] = (_6[_1] + _13._shape_()._dim_I(_1))
    _4[_12] = _0[_12]._eval_()
    _10 = (_10 + int(((_4[_12].x)).shape[0]))
    _7 = (_7 and ((_4[_12].inst) is None))
    _8 = (_8 or ((_4[_12].bfix) is not None))
   _15=numpy.zeros((int((_4).shape[0]),), dtype=numpy.dtype(numpy.int64))
   _11 = numpy.zeros((_10,), dtype=numpy.dtype(object))
   _16=0
   for _17 in range(0,int((_4).shape[0])):
    for _18 in range(0,int(((_4[_17].x)).shape[0])):
     _11[_16] = (_4[_17].x)[_18]
     _16 += 1
   for _19 in range(1,int((_4).shape[0])):
    _15[_19] = _15[(_19 - 1)]
    for _20 in range(0,int(((_4[(_19 - 1)].x)).shape[0])):
     _15[_19] = (_15[_19] + (_4[(_19 - 1)].x)[_20]._size_())
   for _21 in range(0,_2):
    if (_21!=_1):
     _6[_21] = _5._shape_()._dim_I(_21)
   _22=mosek_fusion_NDSet._ctor__3I(_6)
   _23=(_4[0].nnz)
   _24=(int(((_4[0].ptrb)).shape[0]) - 1)
   for _25 in range(1,int((_0).shape[0])):
    _23 = (_23 + (_4[_25].nnz))
    _24 = ((_24 + int(((_4[_25].ptrb)).shape[0])) - 1)
   _26=(None if ((not _8) ) else numpy.zeros((_24,), dtype=numpy.dtype(numpy.float64)))
   _27=_monty.initJaggedArray([(_4[_28].ptrb) for _28 in range(0,int((_4).shape[0]))], 1)
   _29=_monty.initJaggedArray([(_4[_30].subj) for _30 in range(0,int((_4).shape[0]))], 1)
   _31=_monty.initJaggedArray([(_4[_32].cof) for _32 in range(0,int((_4).shape[0]))], 1)
   _33=_monty.initJaggedArray([(_4[_34].bfix) for _34 in range(0,int((_4).shape[0]))], 1)
   _35=_monty.initJaggedArray([(_4[_36].inst) for _36 in range(0,int((_4).shape[0]))], 1)
   _37=numpy.array([(_4[_38].nnz) for _38 in range(0,int((_4).shape[0]))], dtype=numpy.dtype(numpy.int64))
   _39=numpy.array([((_4[_40].shape)._size) for _40 in range(0,int((_4).shape[0]))], dtype=numpy.dtype(numpy.int64))
   if (_1==0):
    _41=numpy.zeros(((_24 + 1),), dtype=numpy.dtype(numpy.int64))
    _42=numpy.zeros((_23,), dtype=numpy.dtype(numpy.int64))
    _43=numpy.zeros((_23,), dtype=numpy.dtype(numpy.float64))
    _44=(None if (_7 ) else numpy.zeros((_24,), dtype=numpy.dtype(numpy.int64)))
    _45=0
    _46=0
    _47=0
    _47,_46,_45 = fragments._c_closure_277(_26,_43,_47,_33,_31,_35,_37,_27,_39,_29,_44,_7,_46,_45,_41,_42,_15) # src/fusion/Expr.mbi:1508:11-1538:12
    _47 = numpy.int64(_47) # postprocess
    _46 = numpy.int64(_46) # postprocess
    _45 = numpy.int64(_45) # postprocess
    _9 = mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_41,_11,_42,_43,_26,_22,_44)
   else:
    _48=numpy.zeros(((_24 + 1),), dtype=numpy.dtype(numpy.int64))
    _49=numpy.zeros((_23,), dtype=numpy.dtype(numpy.int64))
    _50=numpy.zeros((_23,), dtype=numpy.dtype(numpy.float64))
    _51=None
    _52=0
    _53=0
    _54=0
    _55=1
    _55 = fragments._c_closure_278(_1,_55,_6) # src/fusion/Expr.mbi:1565:11-1566:34
    _55 = numpy.int32(_55) # postprocess
    _56=1
    _56 = fragments._c_closure_279(_56,_1,_6) # src/fusion/Expr.mbi:1568:11-1569:36
    _56 = numpy.int32(_56) # postprocess
    _57=_56
    _56 = (_56 * _6[_1])
    _58=numpy.array([(_57 * (_4[_59].shape)._dim_I(_1)) for _59 in range(0,int((_4).shape[0]))], dtype=numpy.dtype(numpy.int32))
    _60=numpy.zeros((int((_4).shape[0]),), dtype=numpy.dtype(numpy.int64))
    if _7:
     for _61 in range(0,_55):
      for _62 in range(0,int((_4).shape[0])):
       _63=((_4[_62].ptrb)[(_60[_62] + _58[_62])] - (_4[_62].ptrb)[_60[_62]])
       mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ((_4[_62].cof),(_4[_62].ptrb)[_60[_62]],_50,_53,_63)
       if ((_4[_62].bfix) is not None):
        mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ((_4[_62].bfix),_60[_62],_26,_52,numpy.int64(_58[_62]))
       _64=(_4[_62].ptrb)[_60[_62]]
       for _65 in range(0,_63):
        _49[(_53 + _65)] = ((_4[_62].subj)[(_64 + _65)] + _15[_62])
       for _66 in range(0,_58[_62]):
        _48[((_52 + _66) + 1)] = (((_4[_62].ptrb)[((_60[_62] + _66) + 1)] - (_4[_62].ptrb)[(_60[_62] + _66)]) + _48[(_52 + _66)])
       _53 = (_53 + _63)
       _52 = (_52 + _58[_62])
       _54 = (_54 + ((_4[_62].shape)._size))
       _60[_62] = (_60[_62] + _58[_62])
     _9 = mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_48,_11,_49,_50,_26,_22,_51)
    else:
     _67=numpy.zeros((int((_4).shape[0]),), dtype=numpy.dtype(numpy.int64))
     _51 = numpy.zeros((_24,), dtype=numpy.dtype(numpy.int64))
     for _68 in range(0,_55):
      for _69 in range(0,int((_4).shape[0])):
       if (((_4[_69].inst) is None) or ((((_4[_69].shape)._size)==int(((_4[_69].inst)).shape[0])) and (int(((_4[_69].inst)).shape[0]) > 0))):
        _70=((_4[_69].ptrb)[(_60[_69] + _58[_69])] - (_4[_69].ptrb)[_60[_69]])
        mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ((_4[_69].cof),(_4[_69].ptrb)[_60[_69]],_50,_53,_70)
        if ((_4[_69].bfix) is not None):
         mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ((_4[_69].bfix),_60[_69],_26,_52,numpy.int64(_58[_69]))
        _71=(_4[_69].ptrb)[_60[_69]]
        for _72 in range(0,_70):
         _49[(_53 + _72)] = ((_4[_69].subj)[(_71 + _72)] + _15[_69])
        for _73 in range(0,_58[_69]):
         _48[((_52 + _73) + 1)] = (((_4[_69].ptrb)[((_60[_69] + _73) + 1)] - (_4[_69].ptrb)[(_60[_69] + _73)]) + _48[_52])
        fragments._c_closure_280(_54,_58,_69,_51,_52) # src/fusion/Expr.mbi:1640:19-1641:44
        _53 = (_53 + _70)
        _52 = (_52 + _58[_69])
        _54 = (_54 + _58[_69])
        _60[_69] = (_60[_69] + _58[_69])
       elif (int(((_4[_69].inst)).shape[0]) > 0):
        _74=0
        _75=0
        while ((_4[_69].inst)[(_60[_69] + _75)] < (_67[_69] + _58[_69])):
         _75 += 1
        _74 = _75
        _76=((_4[_69].ptrb)[(_60[_69] + _74)] - (_4[_69].ptrb)[_60[_69]])
        mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ((_4[_69].cof),(_4[_69].ptrb)[_60[_69]],_50,_53,_76)
        if ((_4[_69].bfix) is not None):
         mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ((_4[_69].bfix),_60[_69],_26,_52,_74)
        _77=(_4[_69].ptrb)[_60[_69]]
        for _78 in range(0,_76):
         _49[(_53 + _78)] = ((_4[_69].subj)[(_77 + _78)] + _15[_69])
        for _79 in range(0,_74):
         _48[((_52 + _79) + 1)] = (((_4[_69].ptrb)[((_60[_69] + _79) + 1)] - (_4[_69].ptrb)[(_60[_69] + _79)]) + _48[(_52 + _79)])
        _80=(_58[_69] * _68)
        for _81 in range(0,_74):
         _51[(_52 + _81)] = (((_4[_69].inst)[_81] - _80) + _54)
        _53 += _76
        _52 += _74
        _54 += _58[_69]
        _60[_69] += _74
        _67[_69] += _58[_69]
       else:
        pass
     _9 = mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_48,_11,_49,_50,_26,_22,_51)
   return (_9)
  @staticmethod
  def _match_repeat_Lmosek_4fusion_4Expression_2II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_repeat_Lmosek_4fusion_4Expression_2II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _repeat_alt_Lmosek_4fusion_4Expression_2II(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._repeat_Lmosek_4fusion_4Expression_2II(_0,numpy.int32(__1),numpy.int32(__2))
  @staticmethod
  def _repeat_Lmosek_4fusion_4Expression_2II(_0,_1,_2):
   if (_1 <= 0):
    raise mosek_fusion_DimensionError._ctor_S("Cannot repeat Expression 0 or less times")
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0 for _3 in range(0,_1)], dtype=numpy.dtype(object)),_2))
  @staticmethod
  def _match_add__3Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _match_alt_add__3Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _add_alt__3Lmosek_4fusion_4Expression_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Expr._add__3Lmosek_4fusion_4Expression_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _add__3Lmosek_4fusion_4Expression_2(_0):
   if (int((_0).shape[0])==0):
    return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(numpy.array([0], dtype=numpy.dtype(numpy.int64)),numpy.zeros((0,), dtype=numpy.dtype(object)),numpy.zeros((0,), dtype=numpy.dtype(numpy.int64)),numpy.zeros((0,), dtype=numpy.dtype(numpy.float64)),None,mosek.fusion.Set._make_I(0),numpy.zeros((0,), dtype=numpy.dtype(numpy.int64)),1))
   _1=None
   if (_0 is None):
    raise ValueError("Argument exps may not be null")
   if ((int((_0).shape[0]) > 0) and (_0[0] is None)):
    raise ValueError("Argument exps may not contain null")
   _2=(_0[0]._shape_()._size)
   _3=(_0[0]._shape_() if ((_0[0]._shape_() is not None) ) else mosek.fusion.Set._make_I(numpy.int32(_2)))
   _4=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(object))
   _5=0
   _6=True
   _7=False
   _8=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int64))
   _10=0
   for _11 in range(0,int((_0).shape[0])):
    if (_0[_11] is None):
     raise ValueError("Argument exps may not contain null")
    _4[_11] = _0[_11]._eval_()
    if (not (_4[_11].shape)._compare_Lmosek_4fusion_4Set_2(_3)):
     raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
    if ((_4[_11].bfix) is not None):
     _7 = True
    _5 = (_5 + (_4[_11].nnz))
    _6 = (_6 and ((_4[_11].inst) is None))
    _10 = (_10 + int(((_4[_11].x)).shape[0]))
   _9 = numpy.zeros((_10,), dtype=numpy.dtype(object))
   _12=0
   for _13 in range(0,int((_4).shape[0])):
    for _14 in range(0,int(((_4[_13].x)).shape[0])):
     _9[_12] = (_4[_13].x)[_14]
     _12 += 1
   for _15 in range(1,int((_0).shape[0])):
    _8[_15] = _8[(_15 - 1)]
    for _16 in range(0,int(((_4[(_15 - 1)].x)).shape[0])):
     _8[_15] = (_8[_15] + (_4[(_15 - 1)].x)[_16]._size_())
   if _6:
    _17=numpy.zeros(((_2 + 1),), dtype=numpy.dtype(numpy.int64))
    _18=numpy.zeros((_5,), dtype=numpy.dtype(numpy.int64))
    _19=numpy.zeros((_5,), dtype=numpy.dtype(numpy.float64))
    _20=None
    _21=None
    for _22 in range(0,_2):
     _17[(_22 + 1)] = _17[_22]
     for _23 in range(0,int((_4).shape[0])):
      _24=((_4[_23].ptrb)[(_22 + 1)] - (_4[_23].ptrb)[_22])
      mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ((_4[_23].cof),(_4[_23].ptrb)[_22],_19,_17[(_22 + 1)],_24)
      for _25 in range(0,_24):
       _18[(_17[(_22 + 1)] + _25)] = ((_4[_23].subj)[((_4[_23].ptrb)[_22] + _25)] + _8[_23])
      _17[(_22 + 1)] += _24
    if _7:
     _20 = numpy.zeros((_2,), dtype=numpy.dtype(numpy.float64))
     for _26 in range(0,_2):
      for _27 in range(0,int((_4).shape[0])):
       if ((_4[_27].bfix) is not None):
        _20[_26] += (_4[_27].bfix)[_26]
    _1 = mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_17,_9,_18,_19,_20,_3,_21)
   else:
    _28=numpy.zeros((int((_4).shape[0]),), dtype=numpy.dtype(numpy.int32))
    _29=numpy.zeros((int((_4).shape[0]),), dtype=numpy.dtype(numpy.int32))
    _30=numpy.zeros((int((_4).shape[0]),), dtype=numpy.dtype(object))
    for _31 in range(0,int((_4).shape[0])):
     if ((_4[_31].inst) is not None):
      _30[_31] = (_4[_31].inst)
     else:
      _30[_31] = mosek.fusion.Utils.Tools._range_J((long(((_4[_31].ptrb)).shape[0]) - 1))
     _29[_31] = int((_30[_31]).shape[0])
    _32=0
    _33=mosek.fusion.Utils.Tools._range_I(int((_4).shape[0]))
    _34=int((_4).shape[0])
    while (_34 > 0):
     _35=_30[_33[0]][_28[_33[0]]]
     _35 = fragments._c_closure_281(_28,_30,_34,_35,_33) # src/fusion/Expr.mbi:1279:15-119
     _35 = numpy.int64(_35) # postprocess
     _32 += 1
     for _36 in range(0,_34):
      if (_30[_33[_36]][_28[_33[_36]]]==_35):
       _28[_33[_36]] += 1
     _34 = fragments._c_closure_282(_29,_28,_34,_33) # src/fusion/Expr.mbi:1285:15-1294:23
     _34 = numpy.int32(_34) # postprocess
    _37=numpy.zeros((_32,), dtype=numpy.dtype(numpy.int64))
    _38=numpy.zeros(((_32 + 1),), dtype=numpy.dtype(numpy.int64))
    _39=numpy.zeros((_5,), dtype=numpy.dtype(numpy.float64))
    _40=numpy.zeros((_5,), dtype=numpy.dtype(numpy.int64))
    _41=None
    fragments._c_closure_283(_28) # src/fusion/Expr.mbi:1305:13-50
    _42=0
    _43=mosek.fusion.Utils.Tools._range_I(int((_4).shape[0]))
    _44=int((_4).shape[0])
    while (_44 > 0):
     _45=_30[_43[0]][_28[_43[0]]]
     _45 = fragments._c_closure_284(_28,_30,_44,_45,_43) # src/fusion/Expr.mbi:1312:15-119
     _45 = numpy.int64(_45) # postprocess
     _37[_42] = _45
     _38[(_42 + 1)] = _38[_42]
     for _46 in range(0,_44):
      if (_30[_43[_46]][_28[_43[_46]]]==_45):
       _47=_43[_46]
       _48=(_4[_47].ptrb)[_28[_47]]
       _49=((_4[_47].ptrb)[(_28[_47] + 1)] - _48)
       mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ((_4[_47].cof),_48,_39,_38[(_42 + 1)],_49)
       for _50 in range(0,_49):
        _40[(_38[(_42 + 1)] + _50)] = ((_4[_47].subj)[(_48 + _50)] + _8[_47])
       _38[(_42 + 1)] = (_38[(_42 + 1)] + _49)
       _28[_47] += 1
     _44 = fragments._c_closure_285(_29,_28,_44,_43) # src/fusion/Expr.mbi:1329:15-1338:23
     _44 = numpy.int32(_44) # postprocess
     _42 += 1
    if _7:
     fragments._c_closure_286(_28) # src/fusion/Expr.mbi:1346:13-50
     _51=0
     _52=0
     for _53 in range(0,int((_4).shape[0])):
      if ((_4[_53].bfix) is not None):
       _52 += 1
     _54=numpy.zeros((_52,), dtype=numpy.dtype(numpy.int64))
     _55=0
     _56=0
     while (_56 < _52):
      if ((_4[_55].bfix) is not None):
       _54[_56] = _55
       _56 += 1
      _55 += 1
     _41 = numpy.zeros((_32,), dtype=numpy.dtype(numpy.float64))
     while (_52 > 0):
      _57=_30[_54[0]][_28[_54[0]]]
      _57 = fragments._c_closure_287(_28,_30,_52,_57,_54) # src/fusion/Expr.mbi:1355:15-119
      _57 = numpy.int64(_57) # postprocess
      for _58 in range(0,_52):
       if (_30[_54[_58]][_28[_54[_58]]]==_57):
        _41[_51] = (_41[_51] + (_4[_54[_58]].bfix)[_28[_54[_58]]])
        _28[_54[_58]] += 1
      _52 = fragments._c_closure_288(_29,_28,_52,_54) # src/fusion/Expr.mbi:1363:15-1372:23
      _52 = numpy.int32(_52) # postprocess
      _51 += 1
    if (_32==(_3._size)):
     _37 = None
    _1 = mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_38,_9,_40,_39,_41,_3,_37)
   return (_1)
  @staticmethod
  def _match_add__3Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _match_alt_add__3Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _add_alt__3Lmosek_4fusion_4Variable_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Expr._add__3Lmosek_4fusion_4Variable_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _add__3Lmosek_4fusion_4Variable_2(_0):
   if (_0 is None):
    raise ValueError("Argument vs may not be null")
   if (int((_0).shape[0])==0):
    return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(numpy.array([0], dtype=numpy.dtype(numpy.int64)),None,numpy.zeros((0,), dtype=numpy.dtype(numpy.int64)),numpy.zeros((0,), dtype=numpy.dtype(numpy.float64)),None,mosek.fusion.Set._make_I(0),numpy.zeros((0,), dtype=numpy.dtype(numpy.int64)),1))
   if ((int((_0).shape[0]) > 0) and (_0[0] is None)):
    raise ValueError("Argument vs may contain null")
   _1=_0[0]._shape_()
   _2=(_1.nd)
   _3=(_1._size)
   _4=(_1._size)
   for _5 in range(1,int((_0).shape[0])):
    if (_0[_5] is None):
     raise ValueError("Argument vs may not contain null")
    elif (not _1._compare_Lmosek_4fusion_4Set_2(_0[_5]._shape_())):
     raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
   _6=(_3 * int((_0).shape[0]))
   _7=mosek.fusion.Utils.Tools._range_JJJ(0,(_6 + int((_0).shape[0])),int((_0).shape[0]))
   _8=numpy.array([(_9 + (_10 * _3)) for _9 in range(0,_3) for _10 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int64))
   _11=numpy.array([1 for _12 in range(0,_6)], dtype=numpy.dtype(numpy.float64))
   return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(_7,_0,_8,_11,None,_1,None,1))
  @staticmethod
  def __add_1_alt_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,numpy.float64(__1),_2,numpy.float64(__3))
  @staticmethod
  def __add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,_1,_2,_3):
   if ((_0._getModel_() is not None) and ((_2._getModel_() is not None) and (_0._getModel_() is not _2._getModel_()))):
    _4=mosek.fusion.Utils.StringBuffer()
    _5=(_0._getModel_()._getName_() if ((int(len(_0._getModel_()._getName_())) > 0) ) else "?")
    _6=(_2._getModel_()._getName_() if ((int(len(_2._getModel_()._getName_())) > 0) ) else "?")
    _4._a_S("Operands belong to different models: '")._a_S(_5)._a_S("' and '")._a_S(_6)._a_S("'")
    raise mosek_fusion_ModelError._ctor_S(_4._toString_())
   _7=((_0._shape_().nd) if (((_0._shape_().nd) >= (_2._shape_().nd)) ) else (_2._shape_().nd))
   for _8 in range(0,_7):
    if (_0._shape_()._dim_I(_8)!=_2._shape_()._dim_I(_8)):
     raise mosek_fusion_DimensionError._ctor_S("Dimensions mismatch")
   _9=_0._eval_()
   _10=_2._eval_()
   _11=(((_9.inst) is not None) and ((_10.inst) is not None))
   _12=(_9.shape)
   _13=(_9.inst)
   _14=(_10.inst)
   if (_13 is None):
    _13 = mosek.fusion.Utils.Tools._range_J((_12._size))
   if (_14 is None):
    _14 = mosek.fusion.Utils.Tools._range_J((_12._size))
   _15=0
   _15 = fragments._c_closure_289(_13,_14,_15) # src/fusion/Expr.mbi:979:9-989:10
   _15 = numpy.int32(_15) # postprocess
   _16=numpy.zeros((_15,), dtype=numpy.dtype(numpy.int64))
   _17=0
   for _18 in range(0,int(((_9.x)).shape[0])):
    _17 = (_17 + (_9.x)[_18]._size_())
   _19=numpy.zeros(((_15 + 1),), dtype=numpy.dtype(numpy.int64))
   _20=numpy.zeros(((int(((_9.subj)).shape[0]) + int(((_10.subj)).shape[0])),), dtype=numpy.dtype(numpy.int64))
   _21=numpy.zeros(((int(((_9.subj)).shape[0]) + int(((_10.subj)).shape[0])),), dtype=numpy.dtype(numpy.float64))
   _22=mosek.fusion.Expr.__varstack__3Lmosek_4fusion_4Variable_2_3Lmosek_4fusion_4Variable_2((_9.x),(_10.x))
   _23=(None if ((((_9.bfix) is None) and ((_10.bfix) is None)) ) else numpy.zeros((_15,), dtype=numpy.dtype(numpy.float64)))
   _24=(_9.ptrb)
   _25=(_9.subj)
   _26=(_9.cof)
   _27=(_9.bfix)
   _28=(_10.ptrb)
   _29=(_10.subj)
   _30=(_10.cof)
   _31=(_10.bfix)
   fragments._c_closure_290(_23,_21,_27,_26,_24,_25,_31,_30,_28,_29,_16,_13,_14,_1,_3,_19,_20,_17) # src/fusion/Expr.mbi:1014:11-1109:12
   return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_19,_22,_20,_21,_23,_12,(None if ((int((_16).shape[0])==(_12._size)) ) else _16)))
  @staticmethod
  def _match_transpose_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_transpose_(*args):
    if len(args) != 0: return False
    return True
  def _transpose_alt_(self,):
    return self._transpose_()
  def _transpose_(self,):
   _0=self
   if ((_0._shape_().nd) > 2):
    raise mosek_fusion_DimensionError._ctor_S("Wrong dimensions for transpose")
   if ((_0._shape_().nd)==1):
    return (mosek.fusion.Expr._reshape_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Set_2(_0,mosek.fusion.Set._make_II(1,_0._shape_()._dim_I(0))))
   elif (_0._shape_()._dim_I(0)==1):
    return (mosek.fusion.Expr._reshape_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Set_2(_0,mosek.fusion.Set._make_II(1,_0._shape_()._dim_I(1))))
   elif (_0._shape_()._dim_I(1)==1):
    return (mosek.fusion.Expr._reshape_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Set_2(_0,mosek.fusion.Set._make_I(_0._shape_()._dim_I(0))))
   _1=_0._eval_()
   _2=(_1.inst)
   _3=(_1.bfix)
   _4=(_1.ptrb)
   _5=(_1.subj)
   _6=(_1.cof)
   if ((_1.inst) is not None):
    _7=(_1.shape)._dim_I(0)
    _8=(_1.shape)._dim_I(1)
    _9=int(((_1.inst)).shape[0])
    _10=int(((_1.subj)).shape[0])
    _11=(None if (((_1.bfix) is None) ) else numpy.zeros((_9,), dtype=numpy.dtype(numpy.float64)))
    _12=numpy.zeros((_9,), dtype=numpy.dtype(numpy.int64))
    _13=numpy.zeros(((_9 + 1),), dtype=numpy.dtype(numpy.int64))
    _14=numpy.zeros((_10,), dtype=numpy.dtype(numpy.int64))
    _15=numpy.zeros((_10,), dtype=numpy.dtype(numpy.float64))
    _16=mosek.fusion.Set._make_II(_8,_7)
    _17=(_1.x)
    _18=numpy.array([(_2[_19] // _8) for _19 in range(0,_9)], dtype=numpy.dtype(numpy.int64))
    _20=numpy.array([(_2[_21] % _8) for _21 in range(0,_9)], dtype=numpy.dtype(numpy.int64))
    _22=numpy.zeros((_9,), dtype=numpy.dtype(numpy.int64))
    _23=numpy.zeros(((_9 + 1),), dtype=numpy.dtype(numpy.int64))
    for _24 in range(0,_9):
     _23[(_20[_24] + 1)] += 1
    fragments._c_closure_291(_9,_23) # src/fusion/Expr.mbi:875:13-51
    for _25 in range(0,_9):
     _22[_23[_20[_25]]] = _25
     _23[_20[_25]] += 1
    fragments._c_closure_292(_3,_9,_22,_11) # src/fusion/Expr.mbi:878:13-79
    fragments._c_closure_293(_7,_18,_20,_9,_22,_12) # src/fusion/Expr.mbi:879:13-82
    fragments._c_closure_294(_4,_9,_22,_13) # src/fusion/Expr.mbi:880:13-96
    fragments._c_closure_295(_6,_4,_5,_9,_22,_15,_13,_14) # src/fusion/Expr.mbi:881:13-885:14
    return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(_13,_17,_14,_15,_11,_16,_12,1))
   else:
    _26=(_1.shape)._dim_I(0)
    _27=(_1.shape)._dim_I(1)
    _28=numpy.zeros((int(((_1.ptrb)).shape[0]),), dtype=numpy.dtype(numpy.int64))
    _29=numpy.zeros((int(((_1.subj)).shape[0]),), dtype=numpy.dtype(numpy.int64))
    _30=numpy.zeros((int(((_1.cof)).shape[0]),), dtype=numpy.dtype(numpy.float64))
    _31=(numpy.zeros(((_26 * _27),), dtype=numpy.dtype(numpy.float64)) if ((_3 is not None) ) else None)
    _32=mosek.fusion.Set._make_II(_27,_26)
    fragments._c_closure_296(_26,_27,_3,_6,_4,_5,_31,_30,_28,_29) # src/fusion/Expr.mbi:900:11-927:12
    return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(_28,(_1.x),_29,_30,_31,_32,None,1))
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _slice_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._slice__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice__3I_3I(self,_0,_1):
   if (int((_0).shape[0])!=int((_1).shape[0])):
    raise mosek_fusion_LengthError._ctor_S("Length firsta and lasta do not match")
   if (int((_0).shape[0])!=(self.__shape_p.nd)):
    raise mosek_fusion_LengthError._ctor_S("Length firsta and lasta do not match shape")
   for _2 in range(0,int((_0).shape[0])):
    if ((_0[_2] < 0) or ((_0[_2] > _1[_2]) or (_1[_2] > self.__shape_p._dim_I(_2)))):
     raise mosek_fusion_IndexError._ctor_S("Index is invalid or out of bounds")
   _3=numpy.array([(_1[_4] - _0[_4]) for _4 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32))
   _5=mosek_fusion_NDSet._ctor__3I(_3)
   if (self.__inst is None):
    _6=1
    _6 = fragments._c_closure_297(_0,_1,_6) # src/fusion/Expr.mbi:727:31-107
    _6 = numpy.int64(_6) # postprocess
    _7=self.__shape_p._linearidx__3I(_0)
    _8=mosek_fusion_IndexCounter._ctor_J_3ILmosek_4fusion_4Set_2(_7,_3,self.__shape_p)
    _9=0
    for _10 in range(0,_6):
     _11=_8._get_()
     _9 = (_9 + (self.__ptrb[(_11 + 1)] - self.__ptrb[_11]))
     _8._inc_()
    _12=numpy.zeros(((_6 + 1),), dtype=numpy.dtype(numpy.int64))
    _13=numpy.zeros((_9,), dtype=numpy.dtype(numpy.int64))
    _14=numpy.zeros((_9,), dtype=numpy.dtype(numpy.float64))
    _8._reset_()
    for _15 in range(0,_6):
     _16=_8._get_()
     mosek.fusion.Utils.Tools._arraycopy__3JJ_3JJJ(self.__subj,self.__ptrb[_16],_13,_12[_15],(self.__ptrb[(_16 + 1)] - self.__ptrb[_16]))
     mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ(self.__cof_v,self.__ptrb[_16],_14,_12[_15],(self.__ptrb[(_16 + 1)] - self.__ptrb[_16]))
     _12[(_15 + 1)] = (_12[_15] + (self.__ptrb[(_16 + 1)] - self.__ptrb[_16]))
     _8._inc_()
    _17=None
    if (self.__bfix is not None):
     _8._reset_()
     for _18 in range(0,_6):
      _17[_18] = self.__bfix[_8._get_()]
      _8._inc_()
    return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_12,self.__x,_13,_14,_17,_5,None))
   else:
    _19=0
    _20=0
    for _21 in range(0,int((self.__inst).shape[0])):
     _22=self.__shape_p._idxtokey_J(self.__inst[_21])
     _23=True
     for _24 in range(0,(self.__shape_p.nd)):
      _23 = (_23 and ((_0[_24] <= _22[_24]) and (_22[_24] < _1[_24])))
     if _23:
      _19 += 1
      _20 = (_20 + (self.__ptrb[(_21 + 1)] - self.__ptrb[_21]))
    _25=numpy.zeros(((_19 + 1),), dtype=numpy.dtype(numpy.int64))
    _26=numpy.zeros((_20,), dtype=numpy.dtype(numpy.int64))
    _27=numpy.zeros((_20,), dtype=numpy.dtype(numpy.float64))
    _28=None
    _29=numpy.zeros((_19,), dtype=numpy.dtype(numpy.int64))
    _30=0
    for _31 in range(0,int((self.__inst).shape[0])):
     _32=self.__shape_p._idxtokey_J(self.__inst[_31])
     _33=True
     for _34 in range(0,(self.__shape_p.nd)):
      _33 = (_33 and ((_0[_34] <= _32[_34]) and (_32[_34] < _1[_34])))
     if _33:
      mosek.fusion.Utils.Tools._arraycopy__3JJ_3JJJ(self.__subj,self.__ptrb[_31],_26,_25[_30],(self.__ptrb[(_31 + 1)] - self.__ptrb[_31]))
      mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ(self.__cof_v,self.__ptrb[_31],_27,_25[_30],(self.__ptrb[(_31 + 1)] - self.__ptrb[_31]))
      _25[(_30 + 1)] = ((_25[_30] + self.__ptrb[(_31 + 1)]) - self.__ptrb[_31])
      _29[_30] = _5._linearidx__3I(numpy.array([(_32[_35] - _0[_35]) for _35 in range(0,int((_32).shape[0]))], dtype=numpy.dtype(numpy.int32)))
      _30 += 1
    if (self.__bfix is not None):
     _28 = numpy.zeros((_19,), dtype=numpy.dtype(numpy.float64))
     _36=0
     for _37 in range(0,int((self.__inst).shape[0])):
      _38=self.__shape_p._idxtokey_J(self.__inst[_37])
      _39=True
      for _40 in range(0,(self.__shape_p.nd)):
       _39 = (_39 and ((_0[_40] <= _38[_40]) and (_38[_40] < _1[_40])))
      if _39:
       _28[_36] = self.__bfix[_37]
       _36 += 1
    return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_25,self.__x,_26,_27,_28,_5,_29))
  @staticmethod
  def _match_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _index_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._index__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _index__3I(self,_0):
   _1=numpy.array([(_0[_2] + 1) for _2 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32))
   return (self._slice__3I_3I(_0,_1))
  @staticmethod
  def _match_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _index_alt_I(self,_t__0):
    return self._index_I(numpy.int32(__0))
  def _index_I(self,_0):
   return (self._slice__3I_3I(numpy.array([_0], dtype=numpy.dtype(numpy.int32)),numpy.array([(_0 + 1)], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _slice_alt_II(self,_t__0,_t__1):
    return self._slice_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_II(self,_0,_1):
   return (self._slice__3I_3I(numpy.array([_0], dtype=numpy.dtype(numpy.int32)),numpy.array([_1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_mulElm_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_mulElm_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _mulElm_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _mulElm_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__mulElm_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1))
  @staticmethod
  def _match_mulElm_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_mulElm_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _mulElm_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def _mulElm_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_0,_1):
   return (mosek.fusion.Expr.__mulElm_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_0,_1))
  @staticmethod
  def _match_mulElm_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4NDSparseArray_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_mulElm_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _mulElm_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def _mulElm_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(_0,_1):
   return (mosek.fusion.Expr.__mulElm_1_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(_0,_1))
  @staticmethod
  def _match_mulElm_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4NDSparseArray_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_mulElm_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _mulElm_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _mulElm_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__mulElm_1_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_0,_1))
  @staticmethod
  def _match_mulElm__3_5DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3_5D__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_mulElm__3_5DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3_5D__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _mulElm_alt__3_5DLmosek_4fusion_4Variable_2(_t__0,_t__1):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._mulElm__3_5DLmosek_4fusion_4Variable_2(_0,_1)
   return _1
  @staticmethod
  def _mulElm__3_5DLmosek_4fusion_4Variable_2(_0,_1):
   return (mosek.fusion.Expr.__mulElm_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(mosek.fusion.Matrix._dense__3_5D(_0),_1))
  @staticmethod
  def _match_mulElm__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3_5D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_mulElm__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3_5D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _mulElm_alt__3_5DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._mulElm__3_5DLmosek_4fusion_4Expression_2(_0,_1)
   return _1
  @staticmethod
  def _mulElm__3_5DLmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__mulElm_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(mosek.fusion.Matrix._dense__3_5D(_0),_1))
  @staticmethod
  def _match_mulElm__3DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_mulElm__3DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _mulElm_alt__3DLmosek_4fusion_4Variable_2(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._mulElm__3DLmosek_4fusion_4Variable_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _mulElm__3DLmosek_4fusion_4Variable_2(_0,_1):
   return (mosek.fusion.Expr.__mulElm_1__3DLmosek_4fusion_4Variable_2(_0,_1))
  @staticmethod
  def _match_mulElm__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_mulElm__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _mulElm_alt__3DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._mulElm__3DLmosek_4fusion_4Expression_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _mulElm__3DLmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__mulElm_1__3DLmosek_4fusion_4Expression_2(_0,_1))
  @staticmethod
  def _match_mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _mulElm_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,_1)
  @staticmethod
  def _mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,_1):
   return (mosek.fusion.Expr.__mulElm_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_1,_0))
  @staticmethod
  def _match_mulElm_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match__3_5D__(_1))
  @staticmethod
  def _match_alt_mulElm_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match__3_5D__(_1))
  @staticmethod
  def _mulElm_alt_Lmosek_4fusion_4Expression_2_3_5D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Expression_2_3_5D(_0,_1)
   return _1
  @staticmethod
  def _mulElm_Lmosek_4fusion_4Expression_2_3_5D(_0,_1):
   return (mosek.fusion.Expr.__mulElm_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(mosek.fusion.Matrix._dense__3_5D(_1),_0))
  @staticmethod
  def _match_mulElm_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match__3D__(_1))
  @staticmethod
  def _match_alt_mulElm_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match__3D__(_1))
  @staticmethod
  def _mulElm_alt_Lmosek_4fusion_4Expression_2_3D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Expression_2_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _mulElm_Lmosek_4fusion_4Expression_2_3D(_0,_1):
   return (mosek.fusion.Expr.__mulElm_1__3DLmosek_4fusion_4Expression_2(_1,_0))
  @staticmethod
  def _match_mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4NDSparseArray_2__(_1))
  @staticmethod
  def _match_alt_mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_1))
  @staticmethod
  def _mulElm_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_t__0,_t__1):
    return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_0,_1)
  @staticmethod
  def _mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_0,_1):
   return (mosek.fusion.Expr.__mulElm_1_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_1,_0))
  @staticmethod
  def _match_mulElm_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_mulElm_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _mulElm_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_0,_1)
  @staticmethod
  def _mulElm_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_0,_1):
   return (mosek.fusion.Expr.__mulElm_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_1,_0))
  @staticmethod
  def _match_mulElm_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4NDSparseArray_2__(_1))
  @staticmethod
  def _match_alt_mulElm_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_1))
  @staticmethod
  def _mulElm_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(_t__0,_t__1):
    return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(_0,_1)
  @staticmethod
  def _mulElm_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(_0,_1):
   return (mosek.fusion.Expr.__mulElm_1_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(_1,_0))
  @staticmethod
  def _match_mulElm_Lmosek_4fusion_4Variable_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match__3_5D__(_1))
  @staticmethod
  def _match_alt_mulElm_Lmosek_4fusion_4Variable_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match__3_5D__(_1))
  @staticmethod
  def _mulElm_alt_Lmosek_4fusion_4Variable_2_3_5D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Variable_2_3_5D(_0,_1)
   return _1
  @staticmethod
  def _mulElm_Lmosek_4fusion_4Variable_2_3_5D(_0,_1):
   return (mosek.fusion.Expr.__mulElm_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(mosek.fusion.Matrix._dense__3_5D(_1),_0))
  @staticmethod
  def _match_mulElm_Lmosek_4fusion_4Variable_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match__3D__(_1))
  @staticmethod
  def _match_alt_mulElm_Lmosek_4fusion_4Variable_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match__3D__(_1))
  @staticmethod
  def _mulElm_alt_Lmosek_4fusion_4Variable_2_3D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Variable_2_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _mulElm_Lmosek_4fusion_4Variable_2_3D(_0,_1):
   return (mosek.fusion.Expr.__mulElm_1__3DLmosek_4fusion_4Variable_2(_1,_0))
  @staticmethod
  def _match_dot_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_dot_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _dot_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._dot_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _dot_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__dot_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1))
  @staticmethod
  def _match_dot_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_dot_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _dot_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr._dot_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def _dot_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_0,_1):
   return (mosek.fusion.Expr.__dot_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_0,_1))
  @staticmethod
  def _match_dot_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4NDSparseArray_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_dot_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _dot_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr._dot_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def _dot_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(_0,_1):
   return (mosek.fusion.Expr.__dot_1_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(_0,_1))
  @staticmethod
  def _match_dot_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4NDSparseArray_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_dot_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _dot_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._dot_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _dot_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__dot_1_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_0,_1))
  @staticmethod
  def _match_dot__3_5DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3_5D__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_dot__3_5DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3_5D__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _dot_alt__3_5DLmosek_4fusion_4Variable_2(_t__0,_t__1):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._dot__3_5DLmosek_4fusion_4Variable_2(_0,_1)
   return _1
  @staticmethod
  def _dot__3_5DLmosek_4fusion_4Variable_2(_0,_1):
   return (mosek.fusion.Expr.__dot_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(mosek.fusion.Matrix._dense__3_5D(_0),_1))
  @staticmethod
  def _match_dot__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3_5D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_dot__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3_5D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _dot_alt__3_5DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._dot__3_5DLmosek_4fusion_4Expression_2(_0,_1)
   return _1
  @staticmethod
  def _dot__3_5DLmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__dot_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(mosek.fusion.Matrix._dense__3_5D(_0),_1))
  @staticmethod
  def _match_dot__3DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_dot__3DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _dot_alt__3DLmosek_4fusion_4Variable_2(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._dot__3DLmosek_4fusion_4Variable_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _dot__3DLmosek_4fusion_4Variable_2(_0,_1):
   return (mosek.fusion.Expr.__dot_1__3DLmosek_4fusion_4Variable_2(_0,_1))
  @staticmethod
  def _match_dot__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_dot__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _dot_alt__3DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._dot__3DLmosek_4fusion_4Expression_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _dot__3DLmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__dot_1__3DLmosek_4fusion_4Expression_2(_0,_1))
  @staticmethod
  def _match_dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _dot_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Expr._dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,_1)
  @staticmethod
  def _dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,_1):
   return (mosek.fusion.Expr.__dot_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_1,_0))
  @staticmethod
  def _match_dot_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match__3_5D__(_1))
  @staticmethod
  def _match_alt_dot_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match__3_5D__(_1))
  @staticmethod
  def _dot_alt_Lmosek_4fusion_4Expression_2_3_5D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._dot_Lmosek_4fusion_4Expression_2_3_5D(_0,_1)
   return _1
  @staticmethod
  def _dot_Lmosek_4fusion_4Expression_2_3_5D(_0,_1):
   return (mosek.fusion.Expr.__dot_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(mosek.fusion.Matrix._dense__3_5D(_1),_0))
  @staticmethod
  def _match_dot_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match__3D__(_1))
  @staticmethod
  def _match_alt_dot_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match__3D__(_1))
  @staticmethod
  def _dot_alt_Lmosek_4fusion_4Expression_2_3D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._dot_Lmosek_4fusion_4Expression_2_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _dot_Lmosek_4fusion_4Expression_2_3D(_0,_1):
   return (mosek.fusion.Expr.__dot_1__3DLmosek_4fusion_4Expression_2(_1,_0))
  @staticmethod
  def _match_dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4NDSparseArray_2__(_1))
  @staticmethod
  def _match_alt_dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_1))
  @staticmethod
  def _dot_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_t__0,_t__1):
    return mosek_fusion_Expr._dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_0,_1)
  @staticmethod
  def _dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_0,_1):
   return (mosek.fusion.Expr.__dot_1_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_1,_0))
  @staticmethod
  def _match_dot_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4NDSparseArray_2__(_1))
  @staticmethod
  def _match_alt_dot_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_1))
  @staticmethod
  def _dot_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(_t__0,_t__1):
    return mosek_fusion_Expr._dot_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(_0,_1)
  @staticmethod
  def _dot_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(_0,_1):
   return (mosek.fusion.Expr.__dot_1_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(_1,_0))
  @staticmethod
  def _match_dot_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_dot_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _dot_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Expr._dot_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_0,_1)
  @staticmethod
  def _dot_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_0,_1):
   return (mosek.fusion.Expr.__dot_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_1,_0))
  @staticmethod
  def _match_dot_Lmosek_4fusion_4Variable_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match__3_5D__(_1))
  @staticmethod
  def _match_alt_dot_Lmosek_4fusion_4Variable_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match__3_5D__(_1))
  @staticmethod
  def _dot_alt_Lmosek_4fusion_4Variable_2_3_5D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._dot_Lmosek_4fusion_4Variable_2_3_5D(_0,_1)
   return _1
  @staticmethod
  def _dot_Lmosek_4fusion_4Variable_2_3_5D(_0,_1):
   return (mosek.fusion.Expr.__dot_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(mosek.fusion.Matrix._dense__3_5D(_1),_0))
  @staticmethod
  def _match_dot_Lmosek_4fusion_4Variable_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match__3D__(_1))
  @staticmethod
  def _match_alt_dot_Lmosek_4fusion_4Variable_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match__3D__(_1))
  @staticmethod
  def _dot_alt_Lmosek_4fusion_4Variable_2_3D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._dot_Lmosek_4fusion_4Variable_2_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _dot_Lmosek_4fusion_4Variable_2_3D(_0,_1):
   return (mosek.fusion.Expr.__dot_1__3DLmosek_4fusion_4Variable_2(_1,_0))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4NDSparseArray_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr._sub_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def _sub_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(mosek.fusion.Expr._constTerm_Lmosek_4fusion_4NDSparseArray_2(_0),1.0,_1._asExpr_(),(- 1.0)))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4NDSparseArray_2__(_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(_t__0,_t__1):
    return mosek_fusion_Expr._sub_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(_0,_1)
  @staticmethod
  def _sub_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0._asExpr_(),1.0,mosek.fusion.Expr._constTerm_Lmosek_4fusion_4NDSparseArray_2(_1),(- 1.0)))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr._sub_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def _sub_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(mosek.fusion.Expr._constTerm_Lmosek_4fusion_4Matrix_2(_0),1.0,_1._asExpr_(),(- 1.0)))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Expr._sub_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_0,_1)
  @staticmethod
  def _sub_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0._asExpr_(),1.0,mosek.fusion.Expr._constTerm_Lmosek_4fusion_4Matrix_2(_1),(- 1.0)))
  @staticmethod
  def _match_sub_DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_sub_DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _sub_alt_DLmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr._sub_DLmosek_4fusion_4Variable_2(numpy.float64(__0),_1)
  @staticmethod
  def _sub_DLmosek_4fusion_4Variable_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(mosek.fusion.Expr._constTerm_Lmosek_4fusion_4Set_2D(_1._shape_(),_0),1.0,_1._asExpr_(),(- 1.0)))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4Variable_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4Variable_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4Variable_2D(_t__0,_t__1):
    return mosek_fusion_Expr._sub_Lmosek_4fusion_4Variable_2D(_0,numpy.float64(__1))
  @staticmethod
  def _sub_Lmosek_4fusion_4Variable_2D(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0._asExpr_(),1.0,mosek.fusion.Expr._constTerm_Lmosek_4fusion_4Set_2D(_0._shape_(),_1),(- 1.0)))
  @staticmethod
  def _match_sub__3_5DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3_5D__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_sub__3_5DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3_5D__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _sub_alt__3_5DLmosek_4fusion_4Variable_2(_t__0,_t__1):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._sub__3_5DLmosek_4fusion_4Variable_2(_0,_1)
   return _1
  @staticmethod
  def _sub__3_5DLmosek_4fusion_4Variable_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(mosek.fusion.Expr._constTerm__3_5D(_0),1.0,_1._asExpr_(),(- 1.0)))
  @staticmethod
  def _match_sub__3DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_sub__3DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _sub_alt__3DLmosek_4fusion_4Variable_2(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._sub__3DLmosek_4fusion_4Variable_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _sub__3DLmosek_4fusion_4Variable_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(mosek.fusion.Expr._constTerm__3D(_0),1.0,_1._asExpr_(),(- 1.0)))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4Variable_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match__3_5D__(_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4Variable_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match__3_5D__(_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4Variable_2_3_5D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._sub_Lmosek_4fusion_4Variable_2_3_5D(_0,_1)
   return _1
  @staticmethod
  def _sub_Lmosek_4fusion_4Variable_2_3_5D(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0._asExpr_(),1.0,mosek.fusion.Expr._constTerm__3_5D(_1),(- 1.0)))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4Variable_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match__3D__(_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4Variable_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match__3D__(_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4Variable_2_3D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._sub_Lmosek_4fusion_4Variable_2_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _sub_Lmosek_4fusion_4Variable_2_3D(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0._asExpr_(),1.0,mosek.fusion.Expr._constTerm__3D(_1),(- 1.0)))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr._sub_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def _sub_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0._asExpr_(),1.0,_1._asExpr_(),(- 1.0)))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4NDSparseArray_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._sub_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _sub_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(mosek.fusion.Expr._constTerm_Lmosek_4fusion_4NDSparseArray_2(_0),1.0,_1,(- 1.0)))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4NDSparseArray_2__(_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_t__0,_t__1):
    return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_0,_1)
  @staticmethod
  def _sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,mosek.fusion.Expr._constTerm_Lmosek_4fusion_4NDSparseArray_2(_1),(- 1.0)))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._sub_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _sub_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(mosek.fusion.Expr._constTerm_Lmosek_4fusion_4Matrix_2(_0),1.0,_1,(- 1.0)))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,_1)
  @staticmethod
  def _sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,mosek.fusion.Expr._constTerm_Lmosek_4fusion_4Matrix_2(_1),(- 1.0)))
  @staticmethod
  def _match_sub_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_sub_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _sub_alt_DLmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._sub_DLmosek_4fusion_4Expression_2(numpy.float64(__0),_1)
  @staticmethod
  def _sub_DLmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(mosek.fusion.Expr._constTerm_Lmosek_4fusion_4Set_2D(_1._shape_(),_0),1.0,_1,(- 1.0)))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4Expression_2D(_t__0,_t__1):
    return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2D(_0,numpy.float64(__1))
  @staticmethod
  def _sub_Lmosek_4fusion_4Expression_2D(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,mosek.fusion.Expr._constTerm_Lmosek_4fusion_4Set_2D(_0._shape_(),_1),(- 1.0)))
  @staticmethod
  def _match_sub__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3_5D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_sub__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3_5D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _sub_alt__3_5DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._sub__3_5DLmosek_4fusion_4Expression_2(_0,_1)
   return _1
  @staticmethod
  def _sub__3_5DLmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(mosek.fusion.Expr._constTerm__3_5D(_0),1.0,_1,(- 1.0)))
  @staticmethod
  def _match_sub__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_sub__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _sub_alt__3DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._sub__3DLmosek_4fusion_4Expression_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _sub__3DLmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(mosek.fusion.Expr._constTerm__3D(_0),1.0,_1,(- 1.0)))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match__3_5D__(_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match__3_5D__(_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4Expression_2_3_5D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2_3_5D(_0,_1)
   return _1
  @staticmethod
  def _sub_Lmosek_4fusion_4Expression_2_3_5D(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,mosek.fusion.Expr._constTerm__3_5D(_1),(- 1.0)))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match__3D__(_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match__3D__(_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4Expression_2_3D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _sub_Lmosek_4fusion_4Expression_2_3D(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,mosek.fusion.Expr._constTerm__3D(_1),(- 1.0)))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._sub_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _sub_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0._asExpr_(),1.0,_1,(- 1.0)))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def _sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,_1._asExpr_(),(- 1.0)))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,_1,(- 1.0)))
  @staticmethod
  def _match_add_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4NDSparseArray_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr._add_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def _add_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(mosek.fusion.Expr._constTerm_Lmosek_4fusion_4NDSparseArray_2(_0),1.0,_1._asExpr_(),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4NDSparseArray_2__(_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(_t__0,_t__1):
    return mosek_fusion_Expr._add_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(_0,_1)
  @staticmethod
  def _add_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(mosek.fusion.Expr._constTerm_Lmosek_4fusion_4NDSparseArray_2(_1),1.0,_0._asExpr_(),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr._add_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def _add_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(mosek.fusion.Expr._constTerm_Lmosek_4fusion_4Matrix_2(_0),1.0,_1._asExpr_(),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Expr._add_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_0,_1)
  @staticmethod
  def _add_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(mosek.fusion.Expr._constTerm_Lmosek_4fusion_4Matrix_2(_1),1.0,_0._asExpr_(),1.0))
  @staticmethod
  def _match_add_DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_add_DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _add_alt_DLmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr._add_DLmosek_4fusion_4Variable_2(numpy.float64(__0),_1)
  @staticmethod
  def _add_DLmosek_4fusion_4Variable_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(mosek.fusion.Expr._constTerm_Lmosek_4fusion_4Set_2D(_1._shape_(),_0),1.0,_1._asExpr_(),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4Variable_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Variable_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4Variable_2D(_t__0,_t__1):
    return mosek_fusion_Expr._add_Lmosek_4fusion_4Variable_2D(_0,numpy.float64(__1))
  @staticmethod
  def _add_Lmosek_4fusion_4Variable_2D(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(mosek.fusion.Expr._constTerm_Lmosek_4fusion_4Set_2D(_0._shape_(),_1),1.0,_0._asExpr_(),1.0))
  @staticmethod
  def _match_add__3_5DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3_5D__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_add__3_5DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3_5D__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _add_alt__3_5DLmosek_4fusion_4Variable_2(_t__0,_t__1):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._add__3_5DLmosek_4fusion_4Variable_2(_0,_1)
   return _1
  @staticmethod
  def _add__3_5DLmosek_4fusion_4Variable_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(mosek.fusion.Expr._constTerm__3_5D(_0),1.0,_1._asExpr_(),1.0))
  @staticmethod
  def _match_add__3DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_add__3DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _add_alt__3DLmosek_4fusion_4Variable_2(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._add__3DLmosek_4fusion_4Variable_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _add__3DLmosek_4fusion_4Variable_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(mosek.fusion.Expr._constTerm__3D(_0),1.0,_1._asExpr_(),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4Variable_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match__3_5D__(_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Variable_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match__3_5D__(_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4Variable_2_3_5D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._add_Lmosek_4fusion_4Variable_2_3_5D(_0,_1)
   return _1
  @staticmethod
  def _add_Lmosek_4fusion_4Variable_2_3_5D(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(mosek.fusion.Expr._constTerm__3_5D(_1),1.0,_0._asExpr_(),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4Variable_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match__3D__(_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Variable_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match__3D__(_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4Variable_2_3D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._add_Lmosek_4fusion_4Variable_2_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _add_Lmosek_4fusion_4Variable_2_3D(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(mosek.fusion.Expr._constTerm__3D(_1),1.0,_0._asExpr_(),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr._add_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def _add_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0._asExpr_(),1.0,_1._asExpr_(),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4NDSparseArray_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._add_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _add_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_1,1.0,mosek.fusion.Expr._constTerm_Lmosek_4fusion_4NDSparseArray_2(_0),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4NDSparseArray_2__(_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_t__0,_t__1):
    return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_0,_1)
  @staticmethod
  def _add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,mosek.fusion.Expr._constTerm_Lmosek_4fusion_4NDSparseArray_2(_1),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._add_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _add_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_1,1.0,mosek.fusion.Expr._constTerm_Lmosek_4fusion_4Matrix_2(_0),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,_1)
  @staticmethod
  def _add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,mosek.fusion.Expr._constTerm_Lmosek_4fusion_4Matrix_2(_1),1.0))
  @staticmethod
  def _match_add_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_add_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _add_alt_DLmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._add_DLmosek_4fusion_4Expression_2(numpy.float64(__0),_1)
  @staticmethod
  def _add_DLmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_1,1.0,mosek.fusion.Expr._constTerm_Lmosek_4fusion_4Set_2D(_1._shape_(),_0),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4Expression_2D(_t__0,_t__1):
    return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2D(_0,numpy.float64(__1))
  @staticmethod
  def _add_Lmosek_4fusion_4Expression_2D(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,mosek.fusion.Expr._constTerm_Lmosek_4fusion_4Set_2D(_0._shape_(),_1),1.0))
  @staticmethod
  def _match_add__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3_5D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_add__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3_5D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _add_alt__3_5DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._add__3_5DLmosek_4fusion_4Expression_2(_0,_1)
   return _1
  @staticmethod
  def _add__3_5DLmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_1,1.0,mosek.fusion.Expr._constTerm__3_5D(_0),1.0))
  @staticmethod
  def _match_add__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_add__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _add_alt__3DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._add__3DLmosek_4fusion_4Expression_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _add__3DLmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_1,1.0,mosek.fusion.Expr._constTerm__3D(_0),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match__3_5D__(_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match__3_5D__(_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4Expression_2_3_5D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2_3_5D(_0,_1)
   return _1
  @staticmethod
  def _add_Lmosek_4fusion_4Expression_2_3_5D(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,mosek.fusion.Expr._constTerm__3_5D(_1),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match__3D__(_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match__3D__(_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4Expression_2_3D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _add_Lmosek_4fusion_4Expression_2_3D(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,mosek.fusion.Expr._constTerm__3D(_1),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._add_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _add_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0._asExpr_(),1.0,_1,1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def _add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,_1._asExpr_(),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,_1,1.0))
  @staticmethod
  def _match_shape_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_shape_(*args):
    if len(args) != 0: return False
    return True
  def _shape_alt_(self,):
    return self._shape_()
  def _shape_(self,):
   return (self.__shape_p)
  @staticmethod
  def _match_getShape_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getShape_(*args):
    if len(args) != 0: return False
    return True
  def _getShape_alt_(self,):
    return self._getShape_()
  def _getShape_(self,):
   return (self.__shape_p)
  @staticmethod
  def _match_getModel_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getModel_(*args):
    if len(args) != 0: return False
    return True
  def _getModel_alt_(self,):
    return self._getModel_()
  def _getModel_(self,):
   return (self.__model)
  @staticmethod
  def __validateData_alt__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(object))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.float64))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _6=numpy.array(_t__6,dtype=numpy.dtype(numpy.int64))
   _1 = mosek_fusion_Expr.__validateData__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_0,_1,_2,_3,_4,_5,_6)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__6[:] = _6
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __validateData__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_0,_1,_2,_3,_4,_5,_6):
   _7=(int((_0).shape[0]) - 1)
   _8=_0[(int((_0).shape[0]) - 1)]
   _9=0
   if (_1 is None):
    raise mosek_fusion_ExpressionError._ctor_S("Array v must not be null")
   for _10 in range(0,int((_1).shape[0])):
    if (_1[_10] is None):
     raise mosek_fusion_ExpressionError._ctor_S("Array elements of v must not be null")
    else:
     _9 = (_9 + _1[_10]._size_())
   if (int((_0).shape[0]) < 1):
    raise mosek_fusion_ExpressionError._ctor_S("Array 'ptrb' in expression has wrong size")
   if (_8!=int((_2).shape[0])):
    raise mosek_fusion_ExpressionError._ctor_S("Array 'subj' in expression has wrong size")
   if (_8!=int((_3).shape[0])):
    raise mosek_fusion_ExpressionError._ctor_S("Array 'cof' in expression has wrong size")
   if ((_4 is not None) and (_7!=int((_4).shape[0]))):
    raise mosek_fusion_ExpressionError._ctor_S("Array 'bfix' in expression has wrong length")
   if (_5 is not None):
    if ((_6 is not None) and (int((_6).shape[0]) < (_5._size))):
     _11=_6
     if (int((_11).shape[0])!=(int((_0).shape[0]) - 1)):
      raise mosek_fusion_ExpressionError._ctor_S("Array 'inst' in expression has wrong length")
     if (int((_11).shape[0]) > 0):
      if ((_11[0] < 0) or (_11[0] >= (_5._size))):
       raise mosek_fusion_ExpressionError._ctor_S("Array 'inst' contains an invalid index")
      _12=True
      _13=(_5._size)
      _12 = fragments._c_closure_298(_11,_12,_13) # src/fusion/Expr.mbi:457:15-463:16
      if (not _12):
       raise mosek_fusion_ExpressionError._ctor_S("Invalid array 'inst'")
    else:
     if ((_5._size)!=(long((_0).shape[0]) - 1)):
      raise mosek_fusion_ExpressionError._ctor_S("Array 'ptrb' in expression has wrong length")
   elif (_6 is not None):
    raise mosek_fusion_ExpressionError._ctor_S("Undefined expression shape")
   _14=False
   _15=False
   if (_0[0]!=0):
    raise mosek_fusion_ExpressionError._ctor_S("Invalid 'ptrb' argument in expression")
   _16=True
   _16 = fragments._c_closure_299(_7,_0,_16) # src/fusion/Expr.mbi:483:9-484:64
   if (not _16):
    raise mosek_fusion_ExpressionError._ctor_S("Invalid 'ptrb' argument in expression")
   _17=True
   _17 = fragments._c_closure_300(_8,_9,_2,_17) # src/fusion/Expr.mbi:489:9-490:69
   if (not _17):
    raise mosek_fusion_ExpressionError._ctor_S("Invalid 'subj' argument in expression")
  @staticmethod
  def __extractModel_alt__3Lmosek_4fusion_4Variable_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Expr.__extractModel__3Lmosek_4fusion_4Variable_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __extractModel__3Lmosek_4fusion_4Variable_2(_0):
   return ((None if (((_0 is None) or (int((_0).shape[0])==0)) ) else _0[0]._getModel_()))
 return Expr
mosek_fusion_Expr=__mk_mosek_fusion_Expr()
del __mk_mosek_fusion_Expr
#BEFORE CLASS
def __mk_mosek_fusion_FlatExpr():
 class FlatExpr(object):
  __slots__ = ['inst','shape','nnz','cof','x','subj','ptrb','bfix']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4FlatExpr_2(*args): # mosek.fusion.FlatExpr
      self._ctor_init_Lmosek_4fusion_4FlatExpr_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4FlatExpr_2(*args):# mosek.fusion.FlatExpr
      self._ctor_alt_init_Lmosek_4fusion_4FlatExpr_2(*args)
    elif self.__match_ctor__3D_3J_3J_3Lmosek_4fusion_4Variable_2_3DLmosek_4fusion_4Set_2_3J(*args): # []double,[]int64,[]int64,[]mosek.fusion.Variable,[]double,mosek.fusion.Set,[]int64
      self._ctor_init__3D_3J_3J_3Lmosek_4fusion_4Variable_2_3DLmosek_4fusion_4Set_2_3J(*args)
    elif self.__match_alt_ctor__3D_3J_3J_3Lmosek_4fusion_4Variable_2_3DLmosek_4fusion_4Set_2_3J(*args):# []double,[]int64,[]int64,[]mosek.fusion.Variable,[]double,mosek.fusion.Set,[]int64
      self._ctor_alt_init__3D_3J_3J_3Lmosek_4fusion_4Variable_2_3DLmosek_4fusion_4Set_2_3J(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.FlatExpr.ctor(mosek.fusion.FlatExpr)\n\tmosek.fusion.FlatExpr.ctor(array(double,ndim=1),array(int64,ndim=1),array(int64,ndim=1),array(mosek.fusion.Variable,ndim=1),array(double,ndim=1),mosek.fusion.Set,array(int64,ndim=1))')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_FlatExpr._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_FlatExpr._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.FlatExpr.toString()')
  def size(self,*args):
    if False: pass
    elif mosek_fusion_FlatExpr._match_size_(*args): # 
      return self._size_(*args)
    elif mosek_fusion_FlatExpr._match_alt_size_(*args): # 
      return self._size_alt_(*args)
    else:
      raise ValueError('Invalid argument list size('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.FlatExpr.size()')
  def __repr__(self): return 'mosek.fusion.FlatExpr'
  @staticmethod
  def _ctor_Lmosek_4fusion_4FlatExpr_2(e):
    o = FlatExpr.__new__(FlatExpr)
    o._ctor_init_Lmosek_4fusion_4FlatExpr_2(e)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4FlatExpr_2(*args):
    if len(args) != 1: return False
    e, = args
    return (__arg_match_Lmosek_4fusion_4FlatExpr_2__(e))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4FlatExpr_2(*args):
    if len(args) != 1: return False
    e, = args
    return (__arg_alt_match_Lmosek_4fusion_4FlatExpr_2__(e))
  def _ctor_alt_init_Lmosek_4fusion_4FlatExpr_2(self,e):
    self._ctor_init_Lmosek_4fusion_4FlatExpr_2(e)
  def _ctor_init_Lmosek_4fusion_4FlatExpr_2(self,e):
   object.__init__(self)
   if ((e.bfix) is not None):
    self.bfix = mosek.fusion.Utils.Tools._arraycopy__3D((e.bfix))
   else:
    self.bfix = None
   self.ptrb = mosek.fusion.Utils.Tools._arraycopy__3J((e.ptrb))
   self.subj = mosek.fusion.Utils.Tools._arraycopy__3J((e.subj))
   self.x = (e.x)
   self.cof = mosek.fusion.Utils.Tools._arraycopy__3D((e.cof))
   self.nnz = (e.nnz)
   self.shape = (e.shape)
   self.inst = (e.inst)
  @staticmethod
  def _ctor__3D_3J_3J_3Lmosek_4fusion_4Variable_2_3DLmosek_4fusion_4Set_2_3J(bfix_,ptrb_,subj_,x_,cof_,shape_,inst_):
    o = FlatExpr.__new__(FlatExpr)
    o._ctor_init__3D_3J_3J_3Lmosek_4fusion_4Variable_2_3DLmosek_4fusion_4Set_2_3J(bfix_,ptrb_,subj_,x_,cof_,shape_,inst_)
    return o
  @staticmethod
  def __match_ctor__3D_3J_3J_3Lmosek_4fusion_4Variable_2_3DLmosek_4fusion_4Set_2_3J(*args):
    if len(args) != 7: return False
    bfix_,ptrb_,subj_,x_,cof_,shape_,inst_, = args
    return (__arg_match__3D__(bfix_) and __arg_match__3J__(ptrb_) and __arg_match__3J__(subj_) and __arg_match__3Lmosek_4fusion_4Variable_2__(x_) and __arg_match__3D__(cof_) and __arg_match_Lmosek_4fusion_4Set_2__(shape_) and __arg_match__3J__(inst_))
  @staticmethod
  def __match_alt_ctor__3D_3J_3J_3Lmosek_4fusion_4Variable_2_3DLmosek_4fusion_4Set_2_3J(*args):
    if len(args) != 7: return False
    bfix_,ptrb_,subj_,x_,cof_,shape_,inst_, = args
    return (__arg_alt_match__3D__(bfix_) and __arg_alt_match__3J__(ptrb_) and __arg_alt_match__3J__(subj_) and __arg_alt_match__3Lmosek_4fusion_4Variable_2__(x_) and __arg_alt_match__3D__(cof_) and __arg_alt_match_Lmosek_4fusion_4Set_2__(shape_) and __arg_alt_match__3J__(inst_))
  def _ctor_alt_init__3D_3J_3J_3Lmosek_4fusion_4Variable_2_3DLmosek_4fusion_4Set_2_3J(self,bfix_,ptrb_,subj_,x_,cof_,shape_,inst_):
    self._ctor_init__3D_3J_3J_3Lmosek_4fusion_4Variable_2_3DLmosek_4fusion_4Set_2_3J(numpy.array(bfix_,dtype=numpy.dtype(numpy.float64)),numpy.array(ptrb_,dtype=numpy.dtype(numpy.int64)),numpy.array(subj_,dtype=numpy.dtype(numpy.int64)),numpy.array(x_,dtype=numpy.dtype(object)),numpy.array(cof_,dtype=numpy.dtype(numpy.float64)),shape_,numpy.array(inst_,dtype=numpy.dtype(numpy.int64)))
  def _ctor_init__3D_3J_3J_3Lmosek_4fusion_4Variable_2_3DLmosek_4fusion_4Set_2_3J(self,bfix_,ptrb_,subj_,x_,cof_,shape_,inst_):
   object.__init__(self)
   if ((bfix_ is not None) and (int((bfix_).shape[0])!=(int((ptrb_).shape[0]) - 1))):
    raise mosek_fusion_SparseFormatError._ctor_S("Mismatching lengths of bfix and ptrb")
   if ((cof_ is None) or ((subj_ is None) or (int((subj_).shape[0])!=int((cof_).shape[0])))):
    raise mosek_fusion_SparseFormatError._ctor_S("Mismatching lengths of subj and cof")
   if (shape_ is not None):
    if (inst_ is not None):
     if (int((inst_).shape[0])!=(int((ptrb_).shape[0]) - 1)):
      raise mosek_fusion_SparseFormatError._ctor_S("Mismatching lengths of inst and ptrb")
    elif ((shape_._size)!=(long((ptrb_).shape[0]) - 1)):
     raise mosek_fusion_SparseFormatError._ctor_S("Mismatching shape and ptrb")
   self.bfix = bfix_
   self.ptrb = ptrb_
   self.subj = subj_
   self.x = x_
   self.cof = cof_
   self.nnz = self.ptrb[(int((self.ptrb).shape[0]) - 1)]
   self.shape = shape_
   self.inst = inst_
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("FlatExpr:")._lf_()._a_S("+-----------------")._lf_()._a_S("| ptrb[")._a_I(int((self.ptrb).shape[0]))._a_S("] = ")._a__3J(self.ptrb)._lf_()._a_S("| subj[")._a_I(int((self.subj).shape[0]))._a_S("] = ")._a__3J(self.subj)._lf_()._a_S("| cof [")._a_I(int((self.cof).shape[0]))._a_S("] = ")._a__3D(self.cof)._lf_()._a_S("| bfix[")
   if (self.bfix is not None):
    _0._a_I(int((self.bfix).shape[0]))
   _0._a_S("] = ")._a__3D(self.bfix)._lf_()._a_S("| inst[")
   if (self.inst is not None):
    _0._a_I(int((self.inst).shape[0]))
   _0._a_S("] = ")._a__3J(self.inst)._lf_()._a_S("+-----------------")
   return (_0._toString_())
  @staticmethod
  def _match_size_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_size_(*args):
    if len(args) != 0: return False
    return True
  def _size_alt_(self,):
    return self._size_()
  def _size_(self,):
   return numpy.int32((int((self.ptrb).shape[0]) - 1))
 return FlatExpr
mosek_fusion_FlatExpr=__mk_mosek_fusion_FlatExpr()
del __mk_mosek_fusion_FlatExpr
#BEFORE CLASS
def __mk_mosek_fusion_SymmetricMatrix():
 class SymmetricMatrix(object):
  __slots__ = ['_SymmetricMatrix__nnz','_SymmetricMatrix__scale','_SymmetricMatrix__vval','_SymmetricMatrix__vsubj','_SymmetricMatrix__vsubi','_SymmetricMatrix__uval','_SymmetricMatrix__usubj','_SymmetricMatrix__usubi','_SymmetricMatrix__d1','_SymmetricMatrix__d0']
  def sub(self,*args):
    if False: pass
    elif mosek_fusion_SymmetricMatrix._match_sub_Lmosek_4fusion_4SymmetricMatrix_2(*args): # mosek.fusion.SymmetricMatrix
      return self._sub_Lmosek_4fusion_4SymmetricMatrix_2(*args)
    elif mosek_fusion_SymmetricMatrix._match_alt_sub_Lmosek_4fusion_4SymmetricMatrix_2(*args): # mosek.fusion.SymmetricMatrix
      return self._sub_alt_Lmosek_4fusion_4SymmetricMatrix_2(*args)
    else:
      raise ValueError('Invalid argument list sub('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymmetricMatrix.sub(mosek.fusion.SymmetricMatrix)')
  @staticmethod
  def antiDiag(*args):
    if False: pass
    elif mosek_fusion_SymmetricMatrix._match_antiDiag__3D(*args): # []double
      return mosek_fusion_SymmetricMatrix._antiDiag__3D(*args)
    elif mosek_fusion_SymmetricMatrix._match_alt_antiDiag__3D(*args): # []double
      return mosek_fusion_SymmetricMatrix._antiDiag_alt__3D(*args)
    else:
      raise ValueError('Invalid argument list antiDiag('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymmetricMatrix.antiDiag(array(double,ndim=1))')
  def getdim(self,*args):
    if False: pass
    elif mosek_fusion_SymmetricMatrix._match_getdim_(*args): # 
      return self._getdim_(*args)
    elif mosek_fusion_SymmetricMatrix._match_alt_getdim_(*args): # 
      return self._getdim_alt_(*args)
    else:
      raise ValueError('Invalid argument list getdim('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymmetricMatrix.getdim()')
  @staticmethod
  def rankOne(*args):
    if False: pass
    elif mosek_fusion_SymmetricMatrix._match_rankOne__3D(*args): # []double
      return mosek_fusion_SymmetricMatrix._rankOne__3D(*args)
    elif mosek_fusion_SymmetricMatrix._match_alt_rankOne__3D(*args): # []double
      return mosek_fusion_SymmetricMatrix._rankOne_alt__3D(*args)
    elif mosek_fusion_SymmetricMatrix._match_rankOne_I_3I_3D(*args): # int32,[]int32,[]double
      return mosek_fusion_SymmetricMatrix._rankOne_I_3I_3D(*args)
    elif mosek_fusion_SymmetricMatrix._match_alt_rankOne_I_3I_3D(*args): # int32,[]int32,[]double
      return mosek_fusion_SymmetricMatrix._rankOne_alt_I_3I_3D(*args)
    else:
      raise ValueError('Invalid argument list rankOne('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymmetricMatrix.rankOne(array(double,ndim=1))\n\tmosek.fusion.SymmetricMatrix.rankOne(int32,array(int32,ndim=1),array(double,ndim=1))')
  def add(self,*args):
    if False: pass
    elif mosek_fusion_SymmetricMatrix._match_add_Lmosek_4fusion_4SymmetricMatrix_2(*args): # mosek.fusion.SymmetricMatrix
      return self._add_Lmosek_4fusion_4SymmetricMatrix_2(*args)
    elif mosek_fusion_SymmetricMatrix._match_alt_add_Lmosek_4fusion_4SymmetricMatrix_2(*args): # mosek.fusion.SymmetricMatrix
      return self._add_alt_Lmosek_4fusion_4SymmetricMatrix_2(*args)
    else:
      raise ValueError('Invalid argument list add('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymmetricMatrix.add(mosek.fusion.SymmetricMatrix)')
  def mul(self,*args):
    if False: pass
    elif mosek_fusion_SymmetricMatrix._match_mul_D(*args): # double
      return self._mul_D(*args)
    elif mosek_fusion_SymmetricMatrix._match_alt_mul_D(*args): # double
      return self._mul_alt_D(*args)
    else:
      raise ValueError('Invalid argument list mul('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymmetricMatrix.mul(double)')
  @staticmethod
  def diag(*args):
    if False: pass
    elif mosek_fusion_SymmetricMatrix._match_diag__3D(*args): # []double
      return mosek_fusion_SymmetricMatrix._diag__3D(*args)
    elif mosek_fusion_SymmetricMatrix._match_alt_diag__3D(*args): # []double
      return mosek_fusion_SymmetricMatrix._diag_alt__3D(*args)
    else:
      raise ValueError('Invalid argument list diag('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymmetricMatrix.diag(array(double,ndim=1))')
  def __repr__(self): return 'mosek.fusion.SymmetricMatrix'
  @staticmethod
  def _ctor_II_3I_3I_3D_3I_3I_3DD(dim0,dim1,usubi,usubj,uval,vsubi,vsubj,vval,scale):
    o = SymmetricMatrix.__new__(SymmetricMatrix)
    o._ctor_init_II_3I_3I_3D_3I_3I_3DD(dim0,dim1,usubi,usubj,uval,vsubi,vsubj,vval,scale)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3D_3I_3I_3DD(*args):
    if len(args) != 9: return False
    dim0,dim1,usubi,usubj,uval,vsubi,vsubj,vval,scale, = args
    return (__arg_match_I__(dim0) and __arg_match_I__(dim1) and __arg_match__3I__(usubi) and __arg_match__3I__(usubj) and __arg_match__3D__(uval) and __arg_match__3I__(vsubi) and __arg_match__3I__(vsubj) and __arg_match__3D__(vval) and __arg_match_D__(scale))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3D_3I_3I_3DD(*args):
    if len(args) != 9: return False
    dim0,dim1,usubi,usubj,uval,vsubi,vsubj,vval,scale, = args
    return (__arg_alt_match_I__(dim0) and __arg_alt_match_I__(dim1) and __arg_alt_match__3I__(usubi) and __arg_alt_match__3I__(usubj) and __arg_alt_match__3D__(uval) and __arg_alt_match__3I__(vsubi) and __arg_alt_match__3I__(vsubj) and __arg_alt_match__3D__(vval) and __arg_alt_match_D__(scale))
  def _ctor_alt_init_II_3I_3I_3D_3I_3I_3DD(self,dim0,dim1,usubi,usubj,uval,vsubi,vsubj,vval,scale):
    self._ctor_init_II_3I_3I_3D_3I_3I_3DD(numpy.int32(dim0),numpy.int32(dim1),numpy.array(usubi,dtype=numpy.dtype(numpy.int32)),numpy.array(usubj,dtype=numpy.dtype(numpy.int32)),numpy.array(uval,dtype=numpy.dtype(numpy.float64)),numpy.array(vsubi,dtype=numpy.dtype(numpy.int32)),numpy.array(vsubj,dtype=numpy.dtype(numpy.int32)),numpy.array(vval,dtype=numpy.dtype(numpy.float64)),numpy.float64(scale))
  def _ctor_init_II_3I_3I_3D_3I_3I_3DD(self,dim0,dim1,usubi,usubj,uval,vsubi,vsubj,vval,scale):
   object.__init__(self)
   (self.__d0) = dim0
   (self.__d1) = dim1
   (self.__usubi) = usubi
   (self.__usubj) = usubj
   (self.__uval) = uval
   (self.__vsubi) = vsubi
   (self.__vsubj) = vsubj
   (self.__vval) = vval
   (self.__scale) = scale
   self.__nnz = (- 1)
  @staticmethod
  def _match_rankOne_I_3I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match__3I__(_1) and __arg_match__3D__(_2))
  @staticmethod
  def _match_alt_rankOne_I_3I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3D__(_2))
  @staticmethod
  def _rankOne_alt_I_3I_3D(_t__0,_t__1,_t__2):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_SymmetricMatrix._rankOne_I_3I_3D(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _rankOne_I_3I_3D(_0,_1,_2):
   if (int((_1).shape[0])!=int((_2).shape[0])):
    raise mosek_fusion_LengthError._ctor_S("Mismatching array lengths")
   for _3 in range(0,int((_1).shape[0])):
    if ((_1[_3] < 0) or (_1[_3] >= _0)):
     raise mosek_fusion_LengthError._ctor_S("Invalid index in argument 'sub'")
   _4=numpy.array([_1[_5] for _5 in range(0,int((_1).shape[0]))], dtype=numpy.dtype(numpy.int32))
   _6=numpy.array([1 for _7 in range(0,int((_1).shape[0]))], dtype=numpy.dtype(numpy.int32))
   _8=numpy.array([_2[_9] for _9 in range(0,int((_2).shape[0]))], dtype=numpy.dtype(numpy.float64))
   return (mosek_fusion_SymmetricMatrix._ctor_II_3I_3I_3D_3I_3I_3DD(_0,1,_4,_6,_8,_4,_6,_8,1.0))
  @staticmethod
  def _match_rankOne__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_rankOne__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  @staticmethod
  def _rankOne_alt__3D(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_SymmetricMatrix._rankOne__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _rankOne__3D(_0):
   _1=int((_0).shape[0])
   _2=numpy.array([_3 for _3 in range(0,_1)], dtype=numpy.dtype(numpy.int32))
   _4=numpy.array([1 for _5 in range(0,_1)], dtype=numpy.dtype(numpy.int32))
   _6=numpy.array([_0[_7] for _7 in range(0,_1)], dtype=numpy.dtype(numpy.float64))
   return (mosek_fusion_SymmetricMatrix._ctor_II_3I_3I_3D_3I_3I_3DD(_1,1,_2,_4,_6,_2,_4,_6,1.0))
  @staticmethod
  def _match_antiDiag__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_antiDiag__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  @staticmethod
  def _antiDiag_alt__3D(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_SymmetricMatrix._antiDiag__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _antiDiag__3D(_0):
   _1=int((_0).shape[0])
   _2=numpy.array([_3 for _3 in range(0,_1)], dtype=numpy.dtype(numpy.int32))
   return (mosek_fusion_SymmetricMatrix._ctor_II_3I_3I_3D_3I_3I_3DD(_1,_1,_2,numpy.array([(_1 - _4) for _4 in range(0,_1)], dtype=numpy.dtype(numpy.int32)),numpy.array([_0[_5] for _5 in range(0,_1)], dtype=numpy.dtype(numpy.float64)),_2,_2,numpy.array([1.0 for _6 in range(0,_1)], dtype=numpy.dtype(numpy.float64)),1.0))
  @staticmethod
  def _match_diag__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_diag__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  @staticmethod
  def _diag_alt__3D(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_SymmetricMatrix._diag__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _diag__3D(_0):
   _1=int((_0).shape[0])
   _2=numpy.array([_3 for _3 in range(0,_1)], dtype=numpy.dtype(numpy.int32))
   return (mosek_fusion_SymmetricMatrix._ctor_II_3I_3I_3D_3I_3I_3DD(_1,_1,_2,_2,numpy.array([_0[_4] for _4 in range(0,_1)], dtype=numpy.dtype(numpy.float64)),_2,_2,numpy.array([1.0 for _5 in range(0,_1)], dtype=numpy.dtype(numpy.float64)),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4SymmetricMatrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4SymmetricMatrix_2__(_0))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4SymmetricMatrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4SymmetricMatrix_2__(_0))
  def _add_alt_Lmosek_4fusion_4SymmetricMatrix_2(self,_t__0):
    return self._add_Lmosek_4fusion_4SymmetricMatrix_2(_0)
  def _add_Lmosek_4fusion_4SymmetricMatrix_2(self,_0):
   _1=self._getdim_()
   if (_0._getdim_()!=_1):
    raise mosek_fusion_DimensionError._ctor_S("Mismatching dimensions")
   _2=int((self.__usubi).shape[0])
   _3=int(((_0.__usubi)).shape[0])
   _4=(_2 + _3)
   _5=int((self.__vsubi).shape[0])
   _6=int(((_0.__vsubi)).shape[0])
   _7=(_5 + _6)
   _8=numpy.zeros((_4,), dtype=numpy.dtype(numpy.int32))
   _9=numpy.zeros((_4,), dtype=numpy.dtype(numpy.int32))
   _10=numpy.zeros((_4,), dtype=numpy.dtype(numpy.float64))
   _11=numpy.zeros((_7,), dtype=numpy.dtype(numpy.int32))
   _12=numpy.zeros((_7,), dtype=numpy.dtype(numpy.int32))
   _13=numpy.zeros((_7,), dtype=numpy.dtype(numpy.float64))
   mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.__usubi,0,_8,0,_2)
   mosek.fusion.Utils.Tools._arraycopy__3II_3III((_0.__usubi),0,_8,_2,_3)
   mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.__usubj,0,_9,0,_2)
   for _14 in range(0,_3):
    _9[(_14 + _2)] = ((_0.__usubj)[_14] + self.__d1)
   fragments._c_closure_301(_10,self.__scale,_2,self.__uval) # src/fusion/SymmetricMatrix.monty:101:9-104:61
   if (((_0.__scale) > 1.0) or ((_0.__scale) < 1.0)):
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII((_0.__uval),0,_10,_2,_3)
   else:
    for _15 in range(0,_3):
     _10[(_15 + _2)] = ((_0.__scale) * (_0.__uval)[_15])
   mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.__usubi,0,_8,0,_2)
   for _16 in range(0,_6):
    _11[(_16 + _5)] = ((_0.__vsubi)[_16] + (_0.__d1))
   mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.__vsubj,0,_12,0,_5)
   mosek.fusion.Utils.Tools._arraycopy__3II_3III((_0.__vsubj),_5,_12,_5,_6)
   fragments._c_closure_302(_13,self.__scale,_5,self.__vval) # src/fusion/SymmetricMatrix.monty:119:9-122:61
   if (((_0.__scale) > 1.0) or ((_0.__scale) < 1.0)):
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII((_0.__vval),0,_13,_5,_6)
   else:
    for _17 in range(0,_6):
     _13[(_17 + _5)] = ((_0.__scale) * (_0.__vval)[_17])
   return (mosek_fusion_SymmetricMatrix._ctor_II_3I_3I_3D_3I_3I_3DD(self.__d0,(self.__d1 + (_0.__d1)),_8,_9,_10,_11,_12,_13,1.0))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4SymmetricMatrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4SymmetricMatrix_2__(_0))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4SymmetricMatrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4SymmetricMatrix_2__(_0))
  def _sub_alt_Lmosek_4fusion_4SymmetricMatrix_2(self,_t__0):
    return self._sub_Lmosek_4fusion_4SymmetricMatrix_2(_0)
  def _sub_Lmosek_4fusion_4SymmetricMatrix_2(self,_0):
   return (self._add_Lmosek_4fusion_4SymmetricMatrix_2(_0._mul_D((- 1.0))))
  @staticmethod
  def _match_mul_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_D__(_0))
  @staticmethod
  def _match_alt_mul_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_D__(_0))
  def _mul_alt_D(self,_t__0):
    return self._mul_D(numpy.float64(__0))
  def _mul_D(self,_0):
   return (mosek_fusion_SymmetricMatrix._ctor_II_3I_3I_3D_3I_3I_3DD(self.__d0,self.__d1,self.__usubi,self.__usubj,self.__uval,self.__vsubi,self.__vsubj,self.__vval,(self.__scale * _0)))
  @staticmethod
  def _match_getdim_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getdim_(*args):
    if len(args) != 0: return False
    return True
  def _getdim_alt_(self,):
    return self._getdim_()
  def _getdim_(self,):
   return numpy.int32(self.__d0)
 return SymmetricMatrix
mosek_fusion_SymmetricMatrix=__mk_mosek_fusion_SymmetricMatrix()
del __mk_mosek_fusion_SymmetricMatrix
#BEFORE CLASS
def __mk_mosek_fusion_NDSparseArray():
 class NDSparseArray(object):
  __slots__ = ['_cof','_inst','_dims','_size']
  @staticmethod
  def make(*args):
    if False: pass
    elif mosek_fusion_NDSparseArray._match_make_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_NDSparseArray._make_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_NDSparseArray._match_alt_make_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_NDSparseArray._make_alt_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_NDSparseArray._match_make__3I_3J_3D(*args): # []int32,[]int64,[]double
      return mosek_fusion_NDSparseArray._make__3I_3J_3D(*args)
    elif mosek_fusion_NDSparseArray._match_alt_make__3I_3J_3D(*args): # []int32,[]int64,[]double
      return mosek_fusion_NDSparseArray._make_alt__3I_3J_3D(*args)
    elif mosek_fusion_NDSparseArray._match_make__3I_3_5I_3D(*args): # []int32,[,]int32,[]double
      return mosek_fusion_NDSparseArray._make__3I_3_5I_3D(*args)
    elif mosek_fusion_NDSparseArray._match_alt_make__3I_3_5I_3D(*args): # []int32,[,]int32,[]double
      return mosek_fusion_NDSparseArray._make_alt__3I_3_5I_3D(*args)
    else:
      raise ValueError('Invalid argument list make('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NDSparseArray.make(mosek.fusion.Matrix)\n\tmosek.fusion.NDSparseArray.make(array(int32,ndim=1),array(int64,ndim=1),array(double,ndim=1))\n\tmosek.fusion.NDSparseArray.make(array(int32,ndim=1),array(int32,ndim=2),array(double,ndim=1))')
  def __repr__(self): return 'mosek.fusion.NDSparseArray'
  @staticmethod
  def _ctor__3I_3_5I_3D(dims_,sub,cof_):
    o = NDSparseArray.__new__(NDSparseArray)
    o._ctor_init__3I_3_5I_3D(dims_,sub,cof_)
    return o
  @staticmethod
  def __match_ctor__3I_3_5I_3D(*args):
    if len(args) != 3: return False
    dims_,sub,cof_, = args
    return (__arg_match__3I__(dims_) and __arg_match__3_5I__(sub) and __arg_match__3D__(cof_))
  @staticmethod
  def __match_alt_ctor__3I_3_5I_3D(*args):
    if len(args) != 3: return False
    dims_,sub,cof_, = args
    return (__arg_alt_match__3I__(dims_) and __arg_alt_match__3_5I__(sub) and __arg_alt_match__3D__(cof_))
  def _ctor_alt_init__3I_3_5I_3D(self,dims_,sub,cof_):
    self._ctor_init__3I_3_5I_3D(numpy.array(dims_,dtype=numpy.dtype(numpy.int32)),numpy.array(sub,dtype=numpy.dtype(numpy.int32)),numpy.array(cof_,dtype=numpy.dtype(numpy.float64)))
  def _ctor_init__3I_3_5I_3D(self,dims_,sub,cof_):
   object.__init__(self)
   _0=numpy.zeros((int((sub).shape[0]),), dtype=numpy.dtype(numpy.int64))
   self._size = 1
   self._size = fragments._c_closure_303(dims_,self._size) # src/fusion/Matrix.mbi:1053:20-71
   self._size = numpy.int64(self._size) # postprocess
   _1=int((dims_).shape[0])
   if (int((sub).shape[0])!=int((cof_).shape[0])):
    raise mosek_fusion_LengthError._ctor_S("Mismatching data array length")
   if (int((sub).shape[1])!=_1):
    raise mosek_fusion_IndexError._ctor_S("An index key in sub has wrong length")
   for _2 in range(0,int((sub).shape[0])):
    for _3 in range(0,int((sub).shape[1])):
     if ((sub[_2,_3] < 0) or (sub[_2,_3] >= dims_[_3])):
      raise mosek_fusion_IndexError._ctor_S("An index in sub is out of bounds")
   for _4 in range(0,int((sub).shape[0])):
    _5=0
    for _6 in range(0,int((sub).shape[1])):
     _5 = ((_5 * dims_[((_1 - _6) - 1)]) + sub[_4,_6])
    _0[_4] = _5
   self._dims = mosek.fusion.Utils.Tools._arraycopy__3I(dims_)
   _7=True
   _7 = fragments._c_closure_304(_0,_7) # src/fusion/Matrix.mbi:1075:9-84
   if _7:
    _8=1
    _8 = fragments._c_closure_305(_0,_8) # src/fusion/Matrix.mbi:1080:11-1082:25
    _8 = numpy.int32(_8) # postprocess
    if (_8==int((_0).shape[0])):
     self._inst = mosek.fusion.Utils.Tools._arraycopy__3J(_0)
     self._cof = mosek.fusion.Utils.Tools._arraycopy__3D(cof_)
    else:
     self._inst = numpy.zeros((_8,), dtype=numpy.dtype(numpy.int64))
     self._inst[0] = _0[0]
     self._cof = numpy.zeros((_8,), dtype=numpy.dtype(numpy.float64))
     self._cof[0] = cof_[0]
     _9=0
     _9 = fragments._c_closure_306(self._cof,cof_,self._inst,_0,_9) # src/fusion/Matrix.mbi:1093:13-1099:43
     _9 = numpy.int32(_9) # postprocess
   else:
    _10=mosek.fusion.Utils.Tools._range_J(long((_0).shape[0]))
    mosek.fusion.CommonTools._argQsort__3J_3J_3JJJ(_10,_0,None,0,long((_0).shape[0]))
    _11=1
    _11 = fragments._c_closure_307(_0,_11,_10) # src/fusion/Matrix.mbi:1107:11-1109:25
    _11 = numpy.int32(_11) # postprocess
    self._inst = numpy.zeros((_11,), dtype=numpy.dtype(numpy.int64))
    self._inst[0] = _0[_10[0]]
    self._cof = numpy.zeros((_11,), dtype=numpy.dtype(numpy.float64))
    self._cof[0] = cof_[_10[0]]
    _12=0
    _12 = fragments._c_closure_308(self._cof,cof_,self._inst,_0,_12,_10) # src/fusion/Matrix.mbi:1114:11-1120:47
    _12 = numpy.int32(_12) # postprocess
  @staticmethod
  def _ctor__3I_3J_3D(dims_,inst_,cof_):
    o = NDSparseArray.__new__(NDSparseArray)
    o._ctor_init__3I_3J_3D(dims_,inst_,cof_)
    return o
  @staticmethod
  def __match_ctor__3I_3J_3D(*args):
    if len(args) != 3: return False
    dims_,inst_,cof_, = args
    return (__arg_match__3I__(dims_) and __arg_match__3J__(inst_) and __arg_match__3D__(cof_))
  @staticmethod
  def __match_alt_ctor__3I_3J_3D(*args):
    if len(args) != 3: return False
    dims_,inst_,cof_, = args
    return (__arg_alt_match__3I__(dims_) and __arg_alt_match__3J__(inst_) and __arg_alt_match__3D__(cof_))
  def _ctor_alt_init__3I_3J_3D(self,dims_,inst_,cof_):
    self._ctor_init__3I_3J_3D(numpy.array(dims_,dtype=numpy.dtype(numpy.int32)),numpy.array(inst_,dtype=numpy.dtype(numpy.int64)),numpy.array(cof_,dtype=numpy.dtype(numpy.float64)))
  def _ctor_init__3I_3J_3D(self,dims_,inst_,cof_):
   object.__init__(self)
   self._size = 1
   self._size = fragments._c_closure_309(dims_,self._size) # src/fusion/Matrix.mbi:991:20-71
   self._size = numpy.int64(self._size) # postprocess
   if (int((inst_).shape[0])!=int((cof_).shape[0])):
    raise mosek_fusion_LengthError._ctor_S("Mismatching data array length")
   for _0 in range(0,int((inst_).shape[0])):
    if ((inst_[_0] < 0) or (inst_[_0] >= self._size)):
     raise mosek_fusion_IndexError._ctor_S("An index in inst is out of bounds")
   self._dims = mosek.fusion.Utils.Tools._arraycopy__3I(dims_)
   _1=True
   _1 = fragments._c_closure_310(inst_,_1) # src/fusion/Matrix.mbi:1000:9-84
   if _1:
    _2=1
    _2 = fragments._c_closure_311(inst_,_2) # src/fusion/Matrix.mbi:1005:11-1007:25
    _2 = numpy.int32(_2) # postprocess
    if (_2==int((inst_).shape[0])):
     self._inst = mosek.fusion.Utils.Tools._arraycopy__3J(inst_)
     self._cof = mosek.fusion.Utils.Tools._arraycopy__3D(cof_)
    else:
     self._inst = numpy.zeros((_2,), dtype=numpy.dtype(numpy.int64))
     self._inst[0] = inst_[0]
     self._cof = numpy.zeros((_2,), dtype=numpy.dtype(numpy.float64))
     self._cof[0] = cof_[0]
     _3=0
     _3 = fragments._c_closure_312(self._cof,cof_,self._inst,inst_,_3) # src/fusion/Matrix.mbi:1018:13-1024:43
     _3 = numpy.int32(_3) # postprocess
   else:
    _4=mosek.fusion.Utils.Tools._range_J(long((inst_).shape[0]))
    mosek.fusion.CommonTools._argQsort__3J_3J_3JJJ(_4,inst_,None,0,long((inst_).shape[0]))
    _5=1
    _5 = fragments._c_closure_313(inst_,_5,_4) # src/fusion/Matrix.mbi:1032:11-1034:25
    _5 = numpy.int32(_5) # postprocess
    self._inst = numpy.zeros((_5,), dtype=numpy.dtype(numpy.int64))
    self._inst[0] = inst_[_4[0]]
    self._cof = numpy.zeros((_5,), dtype=numpy.dtype(numpy.float64))
    self._cof[0] = cof_[_4[0]]
    _6=0
    _6 = fragments._c_closure_314(self._cof,cof_,self._inst,inst_,_6,_4) # src/fusion/Matrix.mbi:1039:11-1045:47
    _6 = numpy.int32(_6) # postprocess
  @staticmethod
  def _ctor_Lmosek_4fusion_4Matrix_2(m):
    o = NDSparseArray.__new__(NDSparseArray)
    o._ctor_init_Lmosek_4fusion_4Matrix_2(m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    m, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    m, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4Matrix_2(self,m):
    self._ctor_init_Lmosek_4fusion_4Matrix_2(m)
  def _ctor_init_Lmosek_4fusion_4Matrix_2(self,m):
   object.__init__(self)
   _0=m._numNonzeros_()
   _1=m._numRows_()
   _2=m._numColumns_()
   _3=numpy.zeros((_0,), dtype=numpy.dtype(numpy.int32))
   _4=numpy.zeros((_0,), dtype=numpy.dtype(numpy.int32))
   _5=numpy.zeros((_0,), dtype=numpy.dtype(numpy.float64))
   m._getDataAsTriplets__3I_3I_3D(_3,_4,_5)
   self._size = (numpy.int64(m._numRows_()) * numpy.int64(m._numColumns_()))
   self._dims = numpy.array([_1,_2], dtype=numpy.dtype(numpy.int32))
   self._inst = numpy.array([((numpy.int64(_3[_6]) * _2) + numpy.int64(_4[_6])) for _6 in range(0,_0)], dtype=numpy.dtype(numpy.int64))
   self._cof = _5
  @staticmethod
  def _match_make_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _match_alt_make_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _make_alt_Lmosek_4fusion_4Matrix_2(_t__0):
    return mosek_fusion_NDSparseArray._make_Lmosek_4fusion_4Matrix_2(_0)
  @staticmethod
  def _make_Lmosek_4fusion_4Matrix_2(_0):
   return (mosek_fusion_NDSparseArray._ctor_Lmosek_4fusion_4Matrix_2(_0))
  @staticmethod
  def _match_make__3I_3J_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match__3J__(_1) and __arg_match__3D__(_2))
  @staticmethod
  def _match_alt_make__3I_3J_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match__3D__(_2))
  @staticmethod
  def _make_alt__3I_3J_3D(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_NDSparseArray._make__3I_3J_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _make__3I_3J_3D(_0,_1,_2):
   return (mosek_fusion_NDSparseArray._ctor__3I_3J_3D(_0,_1,_2))
  @staticmethod
  def _match_make__3I_3_5I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match__3_5I__(_1) and __arg_match__3D__(_2))
  @staticmethod
  def _match_alt_make__3I_3_5I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3_5I__(_1) and __arg_alt_match__3D__(_2))
  @staticmethod
  def _make_alt__3I_3_5I_3D(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_NDSparseArray._make__3I_3_5I_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _make__3I_3_5I_3D(_0,_1,_2):
   return (mosek_fusion_NDSparseArray._ctor__3I_3_5I_3D(_0,_1,_2))
 return NDSparseArray
mosek_fusion_NDSparseArray=__mk_mosek_fusion_NDSparseArray()
del __mk_mosek_fusion_NDSparseArray
#BEFORE CLASS
def __mk_mosek_fusion_Matrix():
 class Matrix(object):
  __slots__ = ['_dimj','_dimi']
  def transpose(self,*args):
    if False: pass
    elif mosek_fusion_Matrix._match_transpose_(*args): # 
      return self._transpose_(*args)
    elif mosek_fusion_Matrix._match_alt_transpose_(*args): # 
      return self._transpose_alt_(*args)
    else:
      raise ValueError('Invalid argument list transpose('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.transpose()')
  @staticmethod
  def eye(*args):
    if False: pass
    elif mosek_fusion_Matrix._match_eye_I(*args): # int32
      return mosek_fusion_Matrix._eye_I(*args)
    elif mosek_fusion_Matrix._match_alt_eye_I(*args): # int32
      return mosek_fusion_Matrix._eye_alt_I(*args)
    else:
      raise ValueError('Invalid argument list eye('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.eye(int32)')
  @staticmethod
  def diag(*args):
    if False: pass
    elif mosek_fusion_Matrix._match_diag__3D(*args): # []double
      return mosek_fusion_Matrix._diag__3D(*args)
    elif mosek_fusion_Matrix._match_alt_diag__3D(*args): # []double
      return mosek_fusion_Matrix._diag_alt__3D(*args)
    elif mosek_fusion_Matrix._match_diag__3Lmosek_4fusion_4Matrix_2(*args): # []mosek.fusion.Matrix
      return mosek_fusion_Matrix._diag__3Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Matrix._match_alt_diag__3Lmosek_4fusion_4Matrix_2(*args): # []mosek.fusion.Matrix
      return mosek_fusion_Matrix._diag_alt__3Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Matrix._match_diag__3DI(*args): # []double,int32
      return mosek_fusion_Matrix._diag__3DI(*args)
    elif mosek_fusion_Matrix._match_alt_diag__3DI(*args): # []double,int32
      return mosek_fusion_Matrix._diag_alt__3DI(*args)
    elif mosek_fusion_Matrix._match_diag_ILmosek_4fusion_4Matrix_2(*args): # int32,mosek.fusion.Matrix
      return mosek_fusion_Matrix._diag_ILmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Matrix._match_alt_diag_ILmosek_4fusion_4Matrix_2(*args): # int32,mosek.fusion.Matrix
      return mosek_fusion_Matrix._diag_alt_ILmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Matrix._match_diag_ID(*args): # int32,double
      return mosek_fusion_Matrix._diag_ID(*args)
    elif mosek_fusion_Matrix._match_alt_diag_ID(*args): # int32,double
      return mosek_fusion_Matrix._diag_alt_ID(*args)
    elif mosek_fusion_Matrix._match_diag_IDI(*args): # int32,double,int32
      return mosek_fusion_Matrix._diag_IDI(*args)
    elif mosek_fusion_Matrix._match_alt_diag_IDI(*args): # int32,double,int32
      return mosek_fusion_Matrix._diag_alt_IDI(*args)
    else:
      raise ValueError('Invalid argument list diag('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.diag(array(double,ndim=1))\n\tmosek.fusion.Matrix.diag(array(mosek.fusion.Matrix,ndim=1))\n\tmosek.fusion.Matrix.diag(array(double,ndim=1),int32)\n\tmosek.fusion.Matrix.diag(int32,mosek.fusion.Matrix)\n\tmosek.fusion.Matrix.diag(int32,double)\n\tmosek.fusion.Matrix.diag(int32,double,int32)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_Matrix._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_Matrix._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.toString()')
  def getDataAsArray(self,*args):
    if False: pass
    elif mosek_fusion_Matrix._match_getDataAsArray_(*args): # 
      return self._getDataAsArray_(*args)
    elif mosek_fusion_Matrix._match_alt_getDataAsArray_(*args): # 
      return self._getDataAsArray_alt_(*args)
    else:
      raise ValueError('Invalid argument list getDataAsArray('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.getDataAsArray()')
  def getDataAsTriplets(self,*args):
    if False: pass
    elif mosek_fusion_Matrix._match_getDataAsTriplets__3I_3I_3D(*args): # []int32,[]int32,[]double
      return self._getDataAsTriplets__3I_3I_3D(*args)
    elif mosek_fusion_Matrix._match_alt_getDataAsTriplets__3I_3I_3D(*args): # []int32,[]int32,[]double
      return self._getDataAsTriplets_alt__3I_3I_3D(*args)
    else:
      raise ValueError('Invalid argument list getDataAsTriplets('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.getDataAsTriplets(array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1))')
  @staticmethod
  def dense(*args):
    if False: pass
    elif mosek_fusion_Matrix._match_dense__3_5D(*args): # [,]double
      return mosek_fusion_Matrix._dense__3_5D(*args)
    elif mosek_fusion_Matrix._match_alt_dense__3_5D(*args): # [,]double
      return mosek_fusion_Matrix._dense_alt__3_5D(*args)
    elif mosek_fusion_Matrix._match_dense_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_Matrix._dense_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Matrix._match_alt_dense_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_Matrix._dense_alt_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Matrix._match_dense_IID(*args): # int32,int32,double
      return mosek_fusion_Matrix._dense_IID(*args)
    elif mosek_fusion_Matrix._match_alt_dense_IID(*args): # int32,int32,double
      return mosek_fusion_Matrix._dense_alt_IID(*args)
    elif mosek_fusion_Matrix._match_dense_II_3D(*args): # int32,int32,[]double
      return mosek_fusion_Matrix._dense_II_3D(*args)
    elif mosek_fusion_Matrix._match_alt_dense_II_3D(*args): # int32,int32,[]double
      return mosek_fusion_Matrix._dense_alt_II_3D(*args)
    else:
      raise ValueError('Invalid argument list dense('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.dense(array(double,ndim=2))\n\tmosek.fusion.Matrix.dense(mosek.fusion.Matrix)\n\tmosek.fusion.Matrix.dense(int32,int32,double)\n\tmosek.fusion.Matrix.dense(int32,int32,array(double,ndim=1))')
  @staticmethod
  def antidiag(*args):
    if False: pass
    elif mosek_fusion_Matrix._match_antidiag__3D(*args): # []double
      return mosek_fusion_Matrix._antidiag__3D(*args)
    elif mosek_fusion_Matrix._match_alt_antidiag__3D(*args): # []double
      return mosek_fusion_Matrix._antidiag_alt__3D(*args)
    elif mosek_fusion_Matrix._match_antidiag__3DI(*args): # []double,int32
      return mosek_fusion_Matrix._antidiag__3DI(*args)
    elif mosek_fusion_Matrix._match_alt_antidiag__3DI(*args): # []double,int32
      return mosek_fusion_Matrix._antidiag_alt__3DI(*args)
    elif mosek_fusion_Matrix._match_antidiag_ID(*args): # int32,double
      return mosek_fusion_Matrix._antidiag_ID(*args)
    elif mosek_fusion_Matrix._match_alt_antidiag_ID(*args): # int32,double
      return mosek_fusion_Matrix._antidiag_alt_ID(*args)
    elif mosek_fusion_Matrix._match_antidiag_IDI(*args): # int32,double,int32
      return mosek_fusion_Matrix._antidiag_IDI(*args)
    elif mosek_fusion_Matrix._match_alt_antidiag_IDI(*args): # int32,double,int32
      return mosek_fusion_Matrix._antidiag_alt_IDI(*args)
    else:
      raise ValueError('Invalid argument list antidiag('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.antidiag(array(double,ndim=1))\n\tmosek.fusion.Matrix.antidiag(array(double,ndim=1),int32)\n\tmosek.fusion.Matrix.antidiag(int32,double)\n\tmosek.fusion.Matrix.antidiag(int32,double,int32)')
  def get(self,*args):
    if False: pass
    elif mosek_fusion_Matrix._match_get_II(*args): # int32,int32
      return self._get_II(*args)
    elif mosek_fusion_Matrix._match_alt_get_II(*args): # int32,int32
      return self._get_alt_II(*args)
    else:
      raise ValueError('Invalid argument list get('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.get(int32,int32)')
  def numRows(self,*args):
    if False: pass
    elif mosek_fusion_Matrix._match_numRows_(*args): # 
      return self._numRows_(*args)
    elif mosek_fusion_Matrix._match_alt_numRows_(*args): # 
      return self._numRows_alt_(*args)
    else:
      raise ValueError('Invalid argument list numRows('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.numRows()')
  def isSparse(self,*args):
    if False: pass
    elif mosek_fusion_Matrix._match_isSparse_(*args): # 
      return self._isSparse_(*args)
    elif mosek_fusion_Matrix._match_alt_isSparse_(*args): # 
      return self._isSparse_alt_(*args)
    else:
      raise ValueError('Invalid argument list isSparse('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.isSparse()')
  def numNonzeros(self,*args):
    if False: pass
    elif mosek_fusion_Matrix._match_numNonzeros_(*args): # 
      return self._numNonzeros_(*args)
    elif mosek_fusion_Matrix._match_alt_numNonzeros_(*args): # 
      return self._numNonzeros_alt_(*args)
    else:
      raise ValueError('Invalid argument list numNonzeros('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.numNonzeros()')
  @staticmethod
  def ones(*args):
    if False: pass
    elif mosek_fusion_Matrix._match_ones_II(*args): # int32,int32
      return mosek_fusion_Matrix._ones_II(*args)
    elif mosek_fusion_Matrix._match_alt_ones_II(*args): # int32,int32
      return mosek_fusion_Matrix._ones_alt_II(*args)
    else:
      raise ValueError('Invalid argument list ones('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.ones(int32,int32)')
  def numColumns(self,*args):
    if False: pass
    elif mosek_fusion_Matrix._match_numColumns_(*args): # 
      return self._numColumns_(*args)
    elif mosek_fusion_Matrix._match_alt_numColumns_(*args): # 
      return self._numColumns_alt_(*args)
    else:
      raise ValueError('Invalid argument list numColumns('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.numColumns()')
  @staticmethod
  def sparse(*args):
    if False: pass
    elif mosek_fusion_Matrix._match_sparse__3_5D(*args): # [,]double
      return mosek_fusion_Matrix._sparse__3_5D(*args)
    elif mosek_fusion_Matrix._match_alt_sparse__3_5D(*args): # [,]double
      return mosek_fusion_Matrix._sparse_alt__3_5D(*args)
    elif mosek_fusion_Matrix._match_sparse__3_3Lmosek_4fusion_4Matrix_2(*args): # [][]mosek.fusion.Matrix
      return mosek_fusion_Matrix._sparse__3_3Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Matrix._match_alt_sparse__3_3Lmosek_4fusion_4Matrix_2(*args): # [][]mosek.fusion.Matrix
      return mosek_fusion_Matrix._sparse_alt__3_3Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Matrix._match_sparse_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_Matrix._sparse_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Matrix._match_alt_sparse_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_Matrix._sparse_alt_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Matrix._match_sparse_II(*args): # int32,int32
      return mosek_fusion_Matrix._sparse_II(*args)
    elif mosek_fusion_Matrix._match_alt_sparse_II(*args): # int32,int32
      return mosek_fusion_Matrix._sparse_alt_II(*args)
    elif mosek_fusion_Matrix._match_sparse__3I_3I_3D(*args): # []int32,[]int32,[]double
      return mosek_fusion_Matrix._sparse__3I_3I_3D(*args)
    elif mosek_fusion_Matrix._match_alt_sparse__3I_3I_3D(*args): # []int32,[]int32,[]double
      return mosek_fusion_Matrix._sparse_alt__3I_3I_3D(*args)
    elif mosek_fusion_Matrix._match_sparse__3I_3ID(*args): # []int32,[]int32,double
      return mosek_fusion_Matrix._sparse__3I_3ID(*args)
    elif mosek_fusion_Matrix._match_alt_sparse__3I_3ID(*args): # []int32,[]int32,double
      return mosek_fusion_Matrix._sparse_alt__3I_3ID(*args)
    elif mosek_fusion_Matrix._match_sparse_II_3I_3ID(*args): # int32,int32,[]int32,[]int32,double
      return mosek_fusion_Matrix._sparse_II_3I_3ID(*args)
    elif mosek_fusion_Matrix._match_alt_sparse_II_3I_3ID(*args): # int32,int32,[]int32,[]int32,double
      return mosek_fusion_Matrix._sparse_alt_II_3I_3ID(*args)
    elif mosek_fusion_Matrix._match_sparse_II_3I_3I_3D(*args): # int32,int32,[]int32,[]int32,[]double
      return mosek_fusion_Matrix._sparse_II_3I_3I_3D(*args)
    elif mosek_fusion_Matrix._match_alt_sparse_II_3I_3I_3D(*args): # int32,int32,[]int32,[]int32,[]double
      return mosek_fusion_Matrix._sparse_alt_II_3I_3I_3D(*args)
    else:
      raise ValueError('Invalid argument list sparse('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.sparse(array(double,ndim=2))\n\tmosek.fusion.Matrix.sparse(array(array(mosek.fusion.Matrix,ndim=1),ndim=1))\n\tmosek.fusion.Matrix.sparse(mosek.fusion.Matrix)\n\tmosek.fusion.Matrix.sparse(int32,int32)\n\tmosek.fusion.Matrix.sparse(array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1))\n\tmosek.fusion.Matrix.sparse(array(int32,ndim=1),array(int32,ndim=1),double)\n\tmosek.fusion.Matrix.sparse(int32,int32,array(int32,ndim=1),array(int32,ndim=1),double)\n\tmosek.fusion.Matrix.sparse(int32,int32,array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1))')
  def __repr__(self): return 'mosek.fusion.Matrix'
  @staticmethod
  def _ctor_II(di,dj):
    o = Matrix.__new__(Matrix)
    o._ctor_init_II(di,dj)
    return o
  @staticmethod
  def __match_ctor_II(*args):
    if len(args) != 2: return False
    di,dj, = args
    return (__arg_match_I__(di) and __arg_match_I__(dj))
  @staticmethod
  def __match_alt_ctor_II(*args):
    if len(args) != 2: return False
    di,dj, = args
    return (__arg_alt_match_I__(di) and __arg_alt_match_I__(dj))
  def _ctor_alt_init_II(self,di,dj):
    self._ctor_init_II(numpy.int32(di),numpy.int32(dj))
  def _ctor_init_II(self,di,dj):
   object.__init__(self)
   if ((di < 0) or (dj < 0)):
    raise mosek_fusion_DimensionError._ctor_S("Invalid dimensions")
   self._dimi = di
   self._dimj = dj
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return ("")
  def _switchDims_alt_(self,):
    return self._switchDims_()
  def _switchDims_(self,):
   _0=self._dimi
   self._dimi = self._dimj
   self._dimj = _0
  @staticmethod
  def _match_diag_ILmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_diag_ILmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _diag_alt_ILmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Matrix._diag_ILmosek_4fusion_4Matrix_2(numpy.int32(__0),_1)
  @staticmethod
  def _diag_ILmosek_4fusion_4Matrix_2(_0,_1):
   return (mosek.fusion.Matrix._diag__3Lmosek_4fusion_4Matrix_2(numpy.array([_1 for _2 in range(0,_0)], dtype=numpy.dtype(object))))
  @staticmethod
  def _match_diag__3Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _match_alt_diag__3Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _diag_alt__3Lmosek_4fusion_4Matrix_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Matrix._diag__3Lmosek_4fusion_4Matrix_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _diag__3Lmosek_4fusion_4Matrix_2(_0):
   _1=_0
   _2=0
   _3=0
   _4=0
   for _5 in range(0,int((_0).shape[0])):
    _3 = (_3 + (_0[_5]._dimi))
    _4 = (_4 + (_0[_5]._dimj))
    _2 = (_2 + _0[_5]._numNonzeros_())
   _6=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int32))
   _7=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int32))
   _8=numpy.zeros((_2,), dtype=numpy.dtype(numpy.float64))
   _9=0
   _10=0
   _11=0
   for _12 in range(0,int((_0).shape[0])):
    _13=_0[_12]._numNonzeros_()
    _14=numpy.zeros((_13,), dtype=numpy.dtype(numpy.int32))
    _15=numpy.zeros((_13,), dtype=numpy.dtype(numpy.int32))
    _16=numpy.zeros((_13,), dtype=numpy.dtype(numpy.float64))
    _0[_12]._getDataAsTriplets__3I_3I_3D(_14,_15,_16)
    mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ(_16,0,_8,_11,_13)
    fragments._c_closure_315(_13,_11,_14,_9,_10,_6,_7) # src/fusion/Matrix.mbi:525:13-529:14
    _11 = (_11 + _13)
    _9 = (_9 + (_0[_12]._dimi))
    _10 = (_10 + (_0[_12]._dimj))
   return (mosek_fusion_SparseMatrix._ctor_II_3I_3I_3D(_3,_4,_6,_7,_8))
  @staticmethod
  def _match_antidiag_IDI(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_D__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_antidiag_IDI(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _antidiag_alt_IDI(_t__0,_t__1,_t__2):
    return mosek_fusion_Matrix._antidiag_IDI(numpy.int32(__0),numpy.float64(__1),numpy.int32(__2))
  @staticmethod
  def _antidiag_IDI(_0,_1,_2):
   if ((_2 < _0) and (_2 >= 0)):
    return (mosek.fusion.Matrix._antidiag__3DI(mosek.fusion.Utils.Tools._makevector_DI(_1,(_0 - _2)),_2))
   elif ((_2 > (- _0)) and (_2 < 0)):
    return (mosek.fusion.Matrix._antidiag__3DI(mosek.fusion.Utils.Tools._makevector_DI(_1,(_0 + _2)),_2))
   else:
    raise mosek_fusion_DimensionError._ctor_S("Diagonal index out of bounds")
  @staticmethod
  def _match_antidiag_ID(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_antidiag_ID(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _antidiag_alt_ID(_t__0,_t__1):
    return mosek_fusion_Matrix._antidiag_ID(numpy.int32(__0),numpy.float64(__1))
  @staticmethod
  def _antidiag_ID(_0,_1):
   return (mosek.fusion.Matrix._antidiag__3DI(mosek.fusion.Utils.Tools._makevector_DI(_1,_0),0))
  @staticmethod
  def _match_diag_IDI(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_D__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_diag_IDI(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _diag_alt_IDI(_t__0,_t__1,_t__2):
    return mosek_fusion_Matrix._diag_IDI(numpy.int32(__0),numpy.float64(__1),numpy.int32(__2))
  @staticmethod
  def _diag_IDI(_0,_1,_2):
   if ((_2 < _0) and (_2 >= 0)):
    return (mosek.fusion.Matrix._diag__3DI(mosek.fusion.Utils.Tools._makevector_DI(_1,(_0 - _2)),_2))
   elif ((_2 > (- _0)) and (_2 < 0)):
    return (mosek.fusion.Matrix._diag__3DI(mosek.fusion.Utils.Tools._makevector_DI(_1,(_0 + _2)),_2))
   else:
    raise mosek_fusion_DimensionError._ctor_S("Diagonal index out of bounds")
  @staticmethod
  def _match_diag_ID(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_diag_ID(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _diag_alt_ID(_t__0,_t__1):
    return mosek_fusion_Matrix._diag_ID(numpy.int32(__0),numpy.float64(__1))
  @staticmethod
  def _diag_ID(_0,_1):
   return (mosek.fusion.Matrix._diag__3DI(mosek.fusion.Utils.Tools._makevector_DI(_1,_0),0))
  @staticmethod
  def _match_antidiag__3DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_antidiag__3DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _antidiag_alt__3DI(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_Matrix._antidiag__3DI(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _antidiag__3DI(_0,_1):
   _2=(_1 if ((_1 > 0) ) else (- _1))
   _3=(int((_0).shape[0]) + _2)
   _4=int((_0).shape[0])
   if (_1 >= 0):
    _5=mosek.fusion.Utils.Tools._range_II(_1,(_4 + _1))
    _6=numpy.array([((_4 + _1) - _7) for _7 in range(1,(_4 + 1))], dtype=numpy.dtype(numpy.int32))
    return (mosek_fusion_SparseMatrix._ctor_II_3I_3I_3D(_3,_3,_5,_6,_0))
   else:
    _8=mosek.fusion.Utils.Tools._range_II(0,_4)
    _9=numpy.array([(_4 - _10) for _10 in range(1,(_4 + 1))], dtype=numpy.dtype(numpy.int32))
    return (mosek_fusion_SparseMatrix._ctor_II_3I_3I_3D(_3,_3,_8,_9,_0))
  @staticmethod
  def _match_antidiag__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_antidiag__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  @staticmethod
  def _antidiag_alt__3D(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Matrix._antidiag__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _antidiag__3D(_0):
   return (mosek.fusion.Matrix._antidiag__3DI(_0,0))
  @staticmethod
  def _match_diag__3DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_diag__3DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _diag_alt__3DI(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_Matrix._diag__3DI(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _diag__3DI(_0,_1):
   _2=(_1 if ((_1 > 0) ) else (- _1))
   _3=(int((_0).shape[0]) + _2)
   _4=int((_0).shape[0])
   if (_1 >= 0):
    _5=mosek.fusion.Utils.Tools._range_II(0,_4)
    _6=mosek.fusion.Utils.Tools._range_II(_2,(_4 + _2))
    return (mosek_fusion_SparseMatrix._ctor_II_3I_3I_3D(_3,_3,_5,_6,_0))
   else:
    _7=mosek.fusion.Utils.Tools._range_II(_2,(_4 + _2))
    _8=mosek.fusion.Utils.Tools._range_II(0,_4)
    return (mosek_fusion_SparseMatrix._ctor_II_3I_3I_3D(_3,_3,_7,_8,_0))
  @staticmethod
  def _match_diag__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_diag__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  @staticmethod
  def _diag_alt__3D(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Matrix._diag__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _diag__3D(_0):
   return (mosek.fusion.Matrix._diag__3DI(_0,0))
  @staticmethod
  def _match_ones_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_ones_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _ones_alt_II(_t__0,_t__1):
    return mosek_fusion_Matrix._ones_II(numpy.int32(__0),numpy.int32(__1))
  @staticmethod
  def _ones_II(_0,_1):
   return (mosek.fusion.Matrix._dense_IID(_0,_1,1.0))
  @staticmethod
  def _match_eye_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_eye_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _eye_alt_I(_t__0):
    return mosek_fusion_Matrix._eye_I(numpy.int32(__0))
  @staticmethod
  def _eye_I(_0):
   return (mosek.fusion.Matrix._diag__3D(numpy.array([1.0 for _1 in range(0,_0)], dtype=numpy.dtype(numpy.float64))))
  @staticmethod
  def _match_dense_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _match_alt_dense_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _dense_alt_Lmosek_4fusion_4Matrix_2(_t__0):
    return mosek_fusion_Matrix._dense_Lmosek_4fusion_4Matrix_2(_0)
  @staticmethod
  def _dense_Lmosek_4fusion_4Matrix_2(_0):
   return (mosek_fusion_DenseMatrix._ctor_Lmosek_4fusion_4Matrix_2(_0))
  @staticmethod
  def _match_dense_IID(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_dense_IID(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _dense_alt_IID(_t__0,_t__1,_t__2):
    return mosek_fusion_Matrix._dense_IID(numpy.int32(__0),numpy.int32(__1),numpy.float64(__2))
  @staticmethod
  def _dense_IID(_0,_1,_2):
   return (mosek_fusion_DenseMatrix._ctor_IID(_0,_1,_2))
  @staticmethod
  def _match_dense_II_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match__3D__(_2))
  @staticmethod
  def _match_alt_dense_II_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match__3D__(_2))
  @staticmethod
  def _dense_alt_II_3D(_t__0,_t__1,_t__2):
   _0=numpy.int32(_t__0)
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Matrix._dense_II_3D(_0,_1,_2)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _dense_II_3D(_0,_1,_2):
   return (mosek_fusion_DenseMatrix._ctor_II_3D(_0,_1,_2))
  @staticmethod
  def _match_dense__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5D__(_0))
  @staticmethod
  def _match_alt_dense__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5D__(_0))
  @staticmethod
  def _dense_alt__3_5D(_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Matrix._dense__3_5D(_0)
   return _1
  @staticmethod
  def _dense__3_5D(_0):
   return (mosek_fusion_DenseMatrix._ctor__3_5D(_0))
  @staticmethod
  def _match_sparse_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _match_alt_sparse_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _sparse_alt_Lmosek_4fusion_4Matrix_2(_t__0):
    return mosek_fusion_Matrix._sparse_Lmosek_4fusion_4Matrix_2(_0)
  @staticmethod
  def _sparse_Lmosek_4fusion_4Matrix_2(_0):
   _1=numpy.zeros((_0._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
   _2=numpy.zeros((_0._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
   _3=numpy.zeros((_0._numNonzeros_(),), dtype=numpy.dtype(numpy.float64))
   _0._getDataAsTriplets__3I_3I_3D(_1,_2,_3)
   return (mosek_fusion_SparseMatrix._ctor_II_3I_3I_3D(_0._numRows_(),_0._numColumns_(),_1,_2,_3))
  @staticmethod
  def _match_sparse__3_3Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_3Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _match_alt_sparse__3_3Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_3Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _sparse_alt__3_3Lmosek_4fusion_4Matrix_2(_t__0):
   _0=_monty.makeJaggedArray(_t__0,(1,1),numpy.dtype(object))
   _1 = mosek_fusion_Matrix._sparse__3_3Lmosek_4fusion_4Matrix_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _sparse__3_3Lmosek_4fusion_4Matrix_2(_0):
   _1=int((_0).shape[0])
   _2=int((_0[0]).shape[0])
   _3=numpy.zeros((_1,), dtype=numpy.dtype(numpy.int32))
   _4=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int32))
   _5=0
   _6=0
   _7=0
   while (_7 < _1):
    _8=0
    while (_8 < _2):
     _9=_0[_7][_8]
     if (_9 is not None):
      if (_4[_8]==0):
       _4[_8] = (_9._dimj)
      elif (_4[_8]!=(_9._dimj)):
       raise mosek_fusion_SparseFormatError._ctor_S("Sparse matrix construction blocks are not aligned")
      if (_3[_7]==0):
       _3[_7] = (_9._dimi)
      elif (_3[_7]!=(_9._dimi)):
       raise mosek_fusion_SparseFormatError._ctor_S("Sparse matrix construction blocks are not aligned")
      _5 = (_5 + _9._numNonzeros_())
     _6 += 1
     _8 += 1
    _7 += 1
   _10=numpy.zeros((_5,), dtype=numpy.dtype(numpy.float64))
   _11=numpy.zeros((_5,), dtype=numpy.dtype(numpy.int32))
   _12=numpy.zeros((_5,), dtype=numpy.dtype(numpy.int32))
   _13=0
   _14=0
   _15=0
   while (_15 < _1):
    _16=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int32))
    _17=0
    while (_17 < _3[_15]):
     _18=0
     _19=0
     while (_19 < _2):
      _20=_0[_15][_19]
      if (_20 is not None):
       _22=_20
       if   isinstance(_22,mosek_fusion_DenseMatrix):
        m=_22
        _22=_16[_19]
        _23=0
        while (_23 < (m._dimj)):
         _10[_13] = (m._data)[_22]
         _11[_13] = (_14 + _17)
         _12[_13] = (_18 + _23)
         _22 += 1
         _13 += 1
         _23 += 1
        _16[_19] = _22
       elif isinstance(_22,mosek_fusion_SparseMatrix):
        _24=_22
        _25 = _16[_19]
        while ((_25 < (_24._nnz)) and ((_24._subi)[_25]==_17)):
         _10[_13] = (_24._val)[_25]
         _12[_13] = ((_24._subj)[_25] + _18)
         _11[_13] = (_14 + _17)
         _13 += 1
         _25 += 1
        _16[_19] = _25
       else:
        m=_22
        raise mosek_fusion_MatrixError._ctor_S("Unknown matrix type.")
      _18 = (_18 + _4[_19])
      _19 += 1
     _17 += 1
    _14 = (_14 + _3[_15])
    _15 += 1
   _26=0
   _27=0
   _26 = fragments._c_closure_316(_26,_3,_1) # src/fusion/Matrix.mbi:351:9-354:10
   _26 = numpy.int32(_26) # postprocess
   _27 = fragments._c_closure_317(_27,_4,_2) # src/fusion/Matrix.mbi:355:9-358:10
   _27 = numpy.int32(_27) # postprocess
   return (mosek_fusion_SparseMatrix._ctor_II_3I_3I_3D(_26,_27,_11,_12,_10))
  @staticmethod
  def _match_sparse__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5D__(_0))
  @staticmethod
  def _match_alt_sparse__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5D__(_0))
  @staticmethod
  def _sparse_alt__3_5D(_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Matrix._sparse__3_5D(_0)
   return _1
  @staticmethod
  def _sparse__3_5D(_0):
   _1=int((_0).shape[0])
   _2=int((_0).shape[1])
   _3=numpy.int64((_1 * _2))
   _4=numpy.array([_5 for _5 in range(0,_1) for _6 in range(0,_2)], dtype=numpy.dtype(numpy.int32))
   _7=numpy.array([_9 for _8 in range(0,_1) for _9 in range(0,_2)], dtype=numpy.dtype(numpy.int32))
   _10=numpy.array([_0[_11,_12] for _11 in range(0,_1) for _12 in range(0,_2)], dtype=numpy.dtype(numpy.float64))
   return (mosek_fusion_SparseMatrix._ctor_II_3I_3I_3D(_1,_2,_4,_7,_10))
  @staticmethod
  def _match_sparse_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_sparse_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _sparse_alt_II(_t__0,_t__1):
    return mosek_fusion_Matrix._sparse_II(numpy.int32(__0),numpy.int32(__1))
  @staticmethod
  def _sparse_II(_0,_1):
   return (mosek_fusion_SparseMatrix._ctor_II_3I_3I_3DJ(_0,_1,numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),numpy.zeros((0,), dtype=numpy.dtype(numpy.float64)),0))
  @staticmethod
  def _match_sparse_II_3I_3ID(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match__3I__(_2) and __arg_match__3I__(_3) and __arg_match_D__(_4))
  @staticmethod
  def _match_alt_sparse_II_3I_3ID(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match__3I__(_3) and __arg_alt_match_D__(_4))
  @staticmethod
  def _sparse_alt_II_3I_3ID(_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int32(_t__0)
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.float64(_t__4)
   _1 = mosek_fusion_Matrix._sparse_II_3I_3ID(_0,_1,_2,_3,_4)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _sparse_II_3I_3ID(_0,_1,_2,_3,_4):
   _5=0
   if (_2 is not None):
    _5 = int((_2).shape[0])
   elif (_3 is not None):
    _5 = int((_3).shape[0])
   return (mosek.fusion.Matrix._sparse_II_3I_3I_3D(_0,_1,_2,_3,mosek.fusion.Utils.Tools._makevector_DI(_4,_5)))
  @staticmethod
  def _match_sparse__3I_3ID(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_sparse__3I_3ID(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _sparse_alt__3I_3ID(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.float64(_t__2)
   _1 = mosek_fusion_Matrix._sparse__3I_3ID(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _sparse__3I_3ID(_0,_1,_2):
   _3=0
   _4=0
   _5=int((_0).shape[0])
   if (_5 > int((_1).shape[0])):
    _5 = int((_1).shape[0])
   _3,_4 = fragments._c_closure_318(_3,_4,_5,_0,_1) # src/fusion/Matrix.mbi:179:9-183:10
   _3 = numpy.int32(_3) # postprocess
   _4 = numpy.int32(_4) # postprocess
   return (mosek.fusion.Matrix._sparse_II_3I_3ID((_3 + 1),(_4 + 1),_0,_1,_2))
  @staticmethod
  def _match_sparse__3I_3I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match__3D__(_2))
  @staticmethod
  def _match_alt_sparse__3I_3I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3D__(_2))
  @staticmethod
  def _sparse_alt__3I_3I_3D(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Matrix._sparse__3I_3I_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _sparse__3I_3I_3D(_0,_1,_2):
   _3=0
   _4=0
   _5=int((_0).shape[0])
   if (_5 > int((_1).shape[0])):
    _5 = int((_1).shape[0])
   if (_5 > int((_2).shape[0])):
    _5 = int((_2).shape[0])
   _3,_4 = fragments._c_closure_319(_3,_4,_5,_0,_1) # src/fusion/Matrix.mbi:161:9-165:10
   _3 = numpy.int32(_3) # postprocess
   _4 = numpy.int32(_4) # postprocess
   return (mosek.fusion.Matrix._sparse_II_3I_3I_3D((_3 + 1),(_4 + 1),_0,_1,_2))
  @staticmethod
  def _match_sparse_II_3I_3I_3D(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match__3I__(_2) and __arg_match__3I__(_3) and __arg_match__3D__(_4))
  @staticmethod
  def _match_alt_sparse_II_3I_3I_3D(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match__3I__(_3) and __arg_alt_match__3D__(_4))
  @staticmethod
  def _sparse_alt_II_3I_3I_3D(_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int32(_t__0)
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Matrix._sparse_II_3I_3I_3D(_0,_1,_2,_3,_4)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _sparse_II_3I_3I_3D(_0,_1,_2,_3,_4):
   _5=(_2 if ((_2 is not None) ) else numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)))
   _6=(_3 if ((_3 is not None) ) else numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)))
   _7=(_4 if ((_4 is not None) ) else numpy.zeros((0,), dtype=numpy.dtype(numpy.float64)))
   _8=long((_5).shape[0])
   if ((long((_6).shape[0])!=_8) or (long((_7).shape[0])!=_8)):
    raise mosek_fusion_SparseFormatError._ctor_S("Arrays defining sparse data have different lengths")
   return (mosek_fusion_SparseMatrix._ctor_II_3I_3I_3DJ(_0,_1,_5,_6,_7,_8))
  @staticmethod
  def _match_get_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_get_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _get_alt_II(self,_t__0,_t__1):
    return self._get_II(numpy.int32(__0),numpy.int32(__1))
  def _get_II(self,_0,_1):
   pass
  @staticmethod
  def _match_isSparse_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_isSparse_(*args):
    if len(args) != 0: return False
    return True
  def _isSparse_alt_(self,):
    return self._isSparse_()
  def _isSparse_(self,):
   pass
  @staticmethod
  def _match_getDataAsArray_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getDataAsArray_(*args):
    if len(args) != 0: return False
    return True
  def _getDataAsArray_alt_(self,):
    return self._getDataAsArray_()
  def _getDataAsArray_(self,):
   pass
  @staticmethod
  def _match_getDataAsTriplets__3I_3I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match__3D__(_2))
  @staticmethod
  def _match_alt_getDataAsTriplets__3I_3I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3D__(_2))
  def _getDataAsTriplets_alt__3I_3I_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._getDataAsTriplets__3I_3I_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _getDataAsTriplets__3I_3I_3D(self,_0,_1,_2):
   pass
  @staticmethod
  def _match_transpose_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_transpose_(*args):
    if len(args) != 0: return False
    return True
  def _transpose_alt_(self,):
    return self._transpose_()
  def _transpose_(self,):
   pass
  @staticmethod
  def _match_numNonzeros_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_numNonzeros_(*args):
    if len(args) != 0: return False
    return True
  def _numNonzeros_alt_(self,):
    return self._numNonzeros_()
  def _numNonzeros_(self,):
   pass
  @staticmethod
  def _match_numColumns_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_numColumns_(*args):
    if len(args) != 0: return False
    return True
  def _numColumns_alt_(self,):
    return self._numColumns_()
  def _numColumns_(self,):
   return numpy.int32(self._dimj)
  @staticmethod
  def _match_numRows_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_numRows_(*args):
    if len(args) != 0: return False
    return True
  def _numRows_alt_(self,):
    return self._numRows_()
  def _numRows_(self,):
   return numpy.int32(self._dimi)
 return Matrix
mosek_fusion_Matrix=__mk_mosek_fusion_Matrix()
del __mk_mosek_fusion_Matrix
#BEFORE CLASS
def __mk_mosek_fusion_DenseMatrix():
 class DenseMatrix(mosek_fusion_Matrix):
  __slots__ = ['_nnz','_data']
  def get(self,*args):
    if False: pass
    elif mosek_fusion_DenseMatrix._match_get_II(*args): # int32,int32
      return self._get_II(*args)
    elif mosek_fusion_DenseMatrix._match_alt_get_II(*args): # int32,int32
      return self._get_alt_II(*args)
    else:
      raise ValueError('Invalid argument list get('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.DenseMatrix.get(int32,int32)')
  def isSparse(self,*args):
    if False: pass
    elif mosek_fusion_DenseMatrix._match_isSparse_(*args): # 
      return self._isSparse_(*args)
    elif mosek_fusion_DenseMatrix._match_alt_isSparse_(*args): # 
      return self._isSparse_alt_(*args)
    else:
      raise ValueError('Invalid argument list isSparse('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.DenseMatrix.isSparse()')
  def getDataAsArray(self,*args):
    if False: pass
    elif mosek_fusion_DenseMatrix._match_getDataAsArray_(*args): # 
      return self._getDataAsArray_(*args)
    elif mosek_fusion_DenseMatrix._match_alt_getDataAsArray_(*args): # 
      return self._getDataAsArray_alt_(*args)
    else:
      raise ValueError('Invalid argument list getDataAsArray('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.DenseMatrix.getDataAsArray()')
  def numNonzeros(self,*args):
    if False: pass
    elif mosek_fusion_DenseMatrix._match_numNonzeros_(*args): # 
      return self._numNonzeros_(*args)
    elif mosek_fusion_DenseMatrix._match_alt_numNonzeros_(*args): # 
      return self._numNonzeros_alt_(*args)
    else:
      raise ValueError('Invalid argument list numNonzeros('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.DenseMatrix.numNonzeros()')
  def getDataAsTriplets(self,*args):
    if False: pass
    elif mosek_fusion_DenseMatrix._match_getDataAsTriplets__3I_3I_3D(*args): # []int32,[]int32,[]double
      return self._getDataAsTriplets__3I_3I_3D(*args)
    elif mosek_fusion_DenseMatrix._match_alt_getDataAsTriplets__3I_3I_3D(*args): # []int32,[]int32,[]double
      return self._getDataAsTriplets_alt__3I_3I_3D(*args)
    else:
      raise ValueError('Invalid argument list getDataAsTriplets('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.DenseMatrix.getDataAsTriplets(array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1))')
  def transpose(self,*args):
    if False: pass
    elif mosek_fusion_DenseMatrix._match_transpose_(*args): # 
      return self._transpose_(*args)
    elif mosek_fusion_DenseMatrix._match_alt_transpose_(*args): # 
      return self._transpose_alt_(*args)
    else:
      raise ValueError('Invalid argument list transpose('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.DenseMatrix.transpose()')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_DenseMatrix._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_DenseMatrix._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.DenseMatrix.toString()')
  def __repr__(self): return 'mosek.fusion.DenseMatrix'
  @staticmethod
  def _ctor_II_3D(dimi_,dimj_,cof):
    o = DenseMatrix.__new__(DenseMatrix)
    o._ctor_init_II_3D(dimi_,dimj_,cof)
    return o
  @staticmethod
  def __match_ctor_II_3D(*args):
    if len(args) != 3: return False
    dimi_,dimj_,cof, = args
    return (__arg_match_I__(dimi_) and __arg_match_I__(dimj_) and __arg_match__3D__(cof))
  @staticmethod
  def __match_alt_ctor_II_3D(*args):
    if len(args) != 3: return False
    dimi_,dimj_,cof, = args
    return (__arg_alt_match_I__(dimi_) and __arg_alt_match_I__(dimj_) and __arg_alt_match__3D__(cof))
  def _ctor_alt_init_II_3D(self,dimi_,dimj_,cof):
    self._ctor_init_II_3D(numpy.int32(dimi_),numpy.int32(dimj_),numpy.array(cof,dtype=numpy.dtype(numpy.float64)))
  def _ctor_init_II_3D(self,dimi_,dimj_,cof):
   mosek_fusion_Matrix._ctor_init_II(self,dimi_,dimj_)
   self._nnz = numpy.int64((dimi_ * dimj_))
   self._data = numpy.zeros(((dimi_ * dimj_),), dtype=numpy.dtype(numpy.float64))
   mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(cof,0,self._data,0,(dimi_ * dimj_))
  @staticmethod
  def _ctor_Lmosek_4fusion_4Matrix_2(m_):
    o = DenseMatrix.__new__(DenseMatrix)
    o._ctor_init_Lmosek_4fusion_4Matrix_2(m_)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    m_, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(m_))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    m_, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(m_))
  def _ctor_alt_init_Lmosek_4fusion_4Matrix_2(self,m_):
    self._ctor_init_Lmosek_4fusion_4Matrix_2(m_)
  def _ctor_init_Lmosek_4fusion_4Matrix_2(self,m_):
   mosek_fusion_Matrix._ctor_init_II(self,(m_._dimi),(m_._dimj))
   _1=m_
   if   isinstance(_1,mosek_fusion_DenseMatrix):
    m=_1
    self._data = mosek.fusion.Utils.Tools._arraycopy__3D((m._data))
   elif isinstance(_1,mosek_fusion_SparseMatrix):
    _1=_1
    self._data = mosek.fusion.Utils.Tools._zeros_I(((_1._dimi) * (_1._dimj)))
    for _2 in range(0,(_1._nnz)):
     self._data[(((_1._subi)[_2] * self._dimj) + (_1._subj)[_2])] = (_1._val)[_2]
   else:
    m=_1
    raise mosek_fusion_MatrixError._ctor_S("Unknown matrix type.")
   self._nnz = numpy.int64((self._dimi * self._dimj))
  @staticmethod
  def _ctor__3_5D(d):
    o = DenseMatrix.__new__(DenseMatrix)
    o._ctor_init__3_5D(d)
    return o
  @staticmethod
  def __match_ctor__3_5D(*args):
    if len(args) != 1: return False
    d, = args
    return (__arg_match__3_5D__(d))
  @staticmethod
  def __match_alt_ctor__3_5D(*args):
    if len(args) != 1: return False
    d, = args
    return (__arg_alt_match__3_5D__(d))
  def _ctor_alt_init__3_5D(self,d):
    self._ctor_init__3_5D(numpy.array(d,dtype=numpy.dtype(numpy.float64)))
  def _ctor_init__3_5D(self,d):
   mosek_fusion_Matrix._ctor_init_II(self,int((d).shape[0]),int((d).shape[1]))
   self._data = numpy.array([d[_0,_1] for _0 in range(0,self._dimi) for _1 in range(0,self._dimj)], dtype=numpy.dtype(numpy.float64))
   self._nnz = numpy.int64((self._dimi * self._dimj))
  @staticmethod
  def _ctor_IID(dimi_,dimj_,value_):
    o = DenseMatrix.__new__(DenseMatrix)
    o._ctor_init_IID(dimi_,dimj_,value_)
    return o
  @staticmethod
  def __match_ctor_IID(*args):
    if len(args) != 3: return False
    dimi_,dimj_,value_, = args
    return (__arg_match_I__(dimi_) and __arg_match_I__(dimj_) and __arg_match_D__(value_))
  @staticmethod
  def __match_alt_ctor_IID(*args):
    if len(args) != 3: return False
    dimi_,dimj_,value_, = args
    return (__arg_alt_match_I__(dimi_) and __arg_alt_match_I__(dimj_) and __arg_alt_match_D__(value_))
  def _ctor_alt_init_IID(self,dimi_,dimj_,value_):
    self._ctor_init_IID(numpy.int32(dimi_),numpy.int32(dimj_),numpy.float64(value_))
  def _ctor_init_IID(self,dimi_,dimj_,value_):
   mosek_fusion_Matrix._ctor_init_II(self,dimi_,dimj_)
   self._data = numpy.array([value_ for _0 in range(0,dimi_) for _1 in range(0,dimj_)], dtype=numpy.dtype(numpy.float64))
   self._nnz = numpy.int64((dimi_ * dimj_))
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("DenseMatrix(")
   _0._a_I(self._dimi)
   _0._a_S(",")
   _0._a_I(self._dimj)
   _0._a_S(": ")
   _1=0
   _2=0
   while (_2 < self._dimi):
    if (_2 > 0):
     _0._a_S(",")
    _0._a_S("[ ")
    _0._a_D(self._data[_1])
    _1 += 1
    _3=1
    while (_3 < self._dimj):
     _0._a_S(",")
     _0._a_D(self._data[_1])
     _1 += 1
     _3 += 1
    _0._a_S(" ]")
    _2 += 1
   _0._a_S(")")
   return (_0._toString_())
  @staticmethod
  def _match_transpose_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_transpose_(*args):
    if len(args) != 0: return False
    return True
  def _transpose_alt_(self,):
    return self._transpose_()
  def _transpose_(self,):
   _0=numpy.zeros(((self._dimi * self._dimj),), dtype=numpy.dtype(numpy.float64))
   _1=0
   _2=self._dimi
   _1 = fragments._c_closure_320(self._data,self._dimi,self._dimj,_0,_1,_2) # src/fusion/Matrix.mbi:911:9-921:10
   _1 = numpy.int32(_1) # postprocess
   return (mosek_fusion_DenseMatrix._ctor_II_3D(self._dimj,self._dimi,_0))
  @staticmethod
  def _match_isSparse_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_isSparse_(*args):
    if len(args) != 0: return False
    return True
  def _isSparse_alt_(self,):
    return self._isSparse_()
  def _isSparse_(self,):
   return (False)
  @staticmethod
  def _match_getDataAsArray_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getDataAsArray_(*args):
    if len(args) != 0: return False
    return True
  def _getDataAsArray_alt_(self,):
    return self._getDataAsArray_()
  def _getDataAsArray_(self,):
   return (mosek.fusion.Utils.Tools._arraycopy__3D(self._data))
  @staticmethod
  def _match_getDataAsTriplets__3I_3I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match__3D__(_2))
  @staticmethod
  def _match_alt_getDataAsTriplets__3I_3I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3D__(_2))
  def _getDataAsTriplets_alt__3I_3I_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._getDataAsTriplets__3I_3I_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _getDataAsTriplets__3I_3I_3D(self,_0,_1,_2):
   if ((int((_0).shape[0]) < self._nnz) or ((int((_1).shape[0]) < self._nnz) or (int((_2).shape[0]) < self._nnz))):
    raise mosek_fusion_LengthError._ctor_S("Output arrays are not long enough.")
   mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self._data,0,_2,0,int((self._data).shape[0]))
   _3=0
   _3 = fragments._c_closure_321(self._dimi,self._dimj,_3,_0,_1) # src/fusion/Matrix.mbi:811:9-819:10
   _3 = numpy.int32(_3) # postprocess
  @staticmethod
  def _match_get_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_get_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _get_alt_II(self,_t__0,_t__1):
    return self._get_II(numpy.int32(__0),numpy.int32(__1))
  def _get_II(self,_0,_1):
   return numpy.float64(self._data[((_0 * self._dimj) + _1)])
  @staticmethod
  def _match_numNonzeros_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_numNonzeros_(*args):
    if len(args) != 0: return False
    return True
  def _numNonzeros_alt_(self,):
    return self._numNonzeros_()
  def _numNonzeros_(self,):
   return numpy.int64(numpy.int64((self._dimi * self._dimj)))
 return DenseMatrix
mosek_fusion_DenseMatrix=__mk_mosek_fusion_DenseMatrix()
del __mk_mosek_fusion_DenseMatrix
#BEFORE CLASS
def __mk_mosek_fusion_SparseMatrix():
 class SparseMatrix(mosek_fusion_Matrix):
  __slots__ = ['_nnz','_val','_subj','_subi']
  def isSparse(self,*args):
    if False: pass
    elif mosek_fusion_SparseMatrix._match_isSparse_(*args): # 
      return self._isSparse_(*args)
    elif mosek_fusion_SparseMatrix._match_alt_isSparse_(*args): # 
      return self._isSparse_alt_(*args)
    else:
      raise ValueError('Invalid argument list isSparse('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SparseMatrix.isSparse()')
  def getDataAsArray(self,*args):
    if False: pass
    elif mosek_fusion_SparseMatrix._match_getDataAsArray_(*args): # 
      return self._getDataAsArray_(*args)
    elif mosek_fusion_SparseMatrix._match_alt_getDataAsArray_(*args): # 
      return self._getDataAsArray_alt_(*args)
    else:
      raise ValueError('Invalid argument list getDataAsArray('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SparseMatrix.getDataAsArray()')
  def get(self,*args):
    if False: pass
    elif mosek_fusion_SparseMatrix._match_get_II(*args): # int32,int32
      return self._get_II(*args)
    elif mosek_fusion_SparseMatrix._match_alt_get_II(*args): # int32,int32
      return self._get_alt_II(*args)
    else:
      raise ValueError('Invalid argument list get('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SparseMatrix.get(int32,int32)')
  def getDataAsTriplets(self,*args):
    if False: pass
    elif mosek_fusion_SparseMatrix._match_getDataAsTriplets__3I_3I_3D(*args): # []int32,[]int32,[]double
      return self._getDataAsTriplets__3I_3I_3D(*args)
    elif mosek_fusion_SparseMatrix._match_alt_getDataAsTriplets__3I_3I_3D(*args): # []int32,[]int32,[]double
      return self._getDataAsTriplets_alt__3I_3I_3D(*args)
    else:
      raise ValueError('Invalid argument list getDataAsTriplets('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SparseMatrix.getDataAsTriplets(array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1))')
  def numNonzeros(self,*args):
    if False: pass
    elif mosek_fusion_SparseMatrix._match_numNonzeros_(*args): # 
      return self._numNonzeros_(*args)
    elif mosek_fusion_SparseMatrix._match_alt_numNonzeros_(*args): # 
      return self._numNonzeros_alt_(*args)
    else:
      raise ValueError('Invalid argument list numNonzeros('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SparseMatrix.numNonzeros()')
  def transpose(self,*args):
    if False: pass
    elif mosek_fusion_SparseMatrix._match_transpose_(*args): # 
      return self._transpose_(*args)
    elif mosek_fusion_SparseMatrix._match_alt_transpose_(*args): # 
      return self._transpose_alt_(*args)
    else:
      raise ValueError('Invalid argument list transpose('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SparseMatrix.transpose()')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_SparseMatrix._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_SparseMatrix._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SparseMatrix.toString()')
  def __repr__(self): return 'mosek.fusion.SparseMatrix'
  @staticmethod
  def _ctor_II_3I_3I_3DJ(dimi_,dimj_,subi_,subj_,val_,nelm):
    o = SparseMatrix.__new__(SparseMatrix)
    o._ctor_init_II_3I_3I_3DJ(dimi_,dimj_,subi_,subj_,val_,nelm)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3DJ(*args):
    if len(args) != 6: return False
    dimi_,dimj_,subi_,subj_,val_,nelm, = args
    return (__arg_match_I__(dimi_) and __arg_match_I__(dimj_) and __arg_match__3I__(subi_) and __arg_match__3I__(subj_) and __arg_match__3D__(val_) and __arg_match_J__(nelm))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3DJ(*args):
    if len(args) != 6: return False
    dimi_,dimj_,subi_,subj_,val_,nelm, = args
    return (__arg_alt_match_I__(dimi_) and __arg_alt_match_I__(dimj_) and __arg_alt_match__3I__(subi_) and __arg_alt_match__3I__(subj_) and __arg_alt_match__3D__(val_) and __arg_alt_match_J__(nelm))
  def _ctor_alt_init_II_3I_3I_3DJ(self,dimi_,dimj_,subi_,subj_,val_,nelm):
    self._ctor_init_II_3I_3I_3DJ(numpy.int32(dimi_),numpy.int32(dimj_),numpy.array(subi_,dtype=numpy.dtype(numpy.int32)),numpy.array(subj_,dtype=numpy.dtype(numpy.int32)),numpy.array(val_,dtype=numpy.dtype(numpy.float64)),numpy.int64(nelm))
  def _ctor_init_II_3I_3I_3DJ(self,dimi_,dimj_,subi_,subj_,val_,nelm):
   mosek_fusion_Matrix._ctor_init_II(self,dimi_,dimj_)
   if (nelm > 0):
    if ((int((subi_).shape[0]) < nelm) or ((int((subj_).shape[0]) < nelm) or (int((val_).shape[0]) < nelm))):
     raise mosek_fusion_SparseFormatError._ctor_S("Mismatching arrays in sparse data.")
    for _0 in range(0,nelm):
     if ((subi_[_0] < 0) or ((subi_[_0] >= self._dimi) or ((subj_[_0] < 0) or (subj_[_0] >= self._dimj)))):
      raise mosek_fusion_SparseFormatError._ctor_S("Subscript out of bounds.")
    _1=numpy.zeros((1,), dtype=numpy.dtype(object))
    _2=numpy.zeros((1,), dtype=numpy.dtype(object))
    _3=numpy.zeros((1,), dtype=numpy.dtype(object))
    mosek.fusion.CommonTools._tripletSort__3I_3I_3D_3_3I_3_3I_3_3DJII(subi_,subj_,val_,_1,_2,_3,nelm,self._dimi,self._dimj)
    self._subi = _1[0]
    self._subj = _2[0]
    self._val = _3[0]
    self._nnz = long((self._val).shape[0])
   else:
    self._subi = numpy.zeros((0,), dtype=numpy.dtype(numpy.int32))
    self._subj = numpy.zeros((0,), dtype=numpy.dtype(numpy.int32))
    self._val = numpy.zeros((0,), dtype=numpy.dtype(numpy.float64))
    self._nnz = 0
  @staticmethod
  def _ctor_II_3I_3I_3D(dimi_,dimj_,subi_,subj_,val_):
    o = SparseMatrix.__new__(SparseMatrix)
    o._ctor_init_II_3I_3I_3D(dimi_,dimj_,subi_,subj_,val_)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3D(*args):
    if len(args) != 5: return False
    dimi_,dimj_,subi_,subj_,val_, = args
    return (__arg_match_I__(dimi_) and __arg_match_I__(dimj_) and __arg_match__3I__(subi_) and __arg_match__3I__(subj_) and __arg_match__3D__(val_))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3D(*args):
    if len(args) != 5: return False
    dimi_,dimj_,subi_,subj_,val_, = args
    return (__arg_alt_match_I__(dimi_) and __arg_alt_match_I__(dimj_) and __arg_alt_match__3I__(subi_) and __arg_alt_match__3I__(subj_) and __arg_alt_match__3D__(val_))
  def _ctor_alt_init_II_3I_3I_3D(self,dimi_,dimj_,subi_,subj_,val_):
    self._ctor_init_II_3I_3I_3D(numpy.int32(dimi_),numpy.int32(dimj_),numpy.array(subi_,dtype=numpy.dtype(numpy.int32)),numpy.array(subj_,dtype=numpy.dtype(numpy.int32)),numpy.array(val_,dtype=numpy.dtype(numpy.float64)))
  def _ctor_init_II_3I_3I_3D(self,dimi_,dimj_,subi_,subj_,val_):
   mosek_fusion_Matrix._ctor_init_II(self,dimi_,dimj_)
   _0=0
   _0 = fragments._c_closure_322(_0,val_) # src/fusion/Matrix.mbi:615:20-89
   _0 = numpy.int32(_0) # postprocess
   if ((_0 > 0) and (_0 < int((subi_).shape[0]))):
    self._subi = numpy.zeros((_0,), dtype=numpy.dtype(numpy.int32))
    self._subj = numpy.zeros((_0,), dtype=numpy.dtype(numpy.int32))
    self._val = numpy.zeros((_0,), dtype=numpy.dtype(numpy.float64))
    self._nnz = _0
    _1=0
    _1 = fragments._c_closure_323(_1,self._subi,subi_,self._subj,subj_,self._val,val_) # src/fusion/Matrix.mbi:624:11-631:14
    _1 = numpy.int32(_1) # postprocess
   else:
    self._subi = subi_
    self._subj = subj_
    self._val = val_
    if (subi_ is None):
     self._nnz = 0
    else:
     self._nnz = long((self._subi).shape[0])
  def _formPtrb_alt_(self,):
    return self._formPtrb_()
  def _formPtrb_(self,):
   _0=numpy.zeros(((self._dimi + 1),), dtype=numpy.dtype(numpy.int64))
   _1=0
   _1 = fragments._c_closure_324(self._dimi,self._nnz,_1,_0,self._subi) # src/fusion/Matrix.mbi:764:9-770:10
   _1 = numpy.int64(_1) # postprocess
   _0[self._dimi] = _1
   return (_0)
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("SparseMatrix(")._a_I(self._dimi)._a_S(",")._a_I(self._dimj)._a_S(", [")
   if ((self._subi is not None) and (int((self._subi).shape[0]) > 0)):
    _0._a_S("(")._a_I(self._subi[0])._a_S(",")._a_I(self._subj[0])._a_S(",")._a_D(self._val[0])._a_S(")")
    for _1 in range(1,int((self._subi).shape[0])):
     _0._a_S(",(")._a_I(self._subi[_1])._a_S(",")._a_I(self._subj[_1])._a_S(",")._a_D(self._val[_1])._a_S(")")
   _0._a_S(" ])")
   return (_0._toString_())
  @staticmethod
  def _match_numNonzeros_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_numNonzeros_(*args):
    if len(args) != 0: return False
    return True
  def _numNonzeros_alt_(self,):
    return self._numNonzeros_()
  def _numNonzeros_(self,):
   return numpy.int64(self._nnz)
  @staticmethod
  def _match_transpose_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_transpose_(*args):
    if len(args) != 0: return False
    return True
  def _transpose_alt_(self,):
    return self._transpose_()
  def _transpose_(self,):
   return (mosek.fusion.Matrix._sparse_II_3I_3I_3D(self._dimj,self._dimi,self._subj,self._subi,self._val))
  @staticmethod
  def _match_isSparse_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_isSparse_(*args):
    if len(args) != 0: return False
    return True
  def _isSparse_alt_(self,):
    return self._isSparse_()
  def _isSparse_(self,):
   return (True)
  @staticmethod
  def _match_getDataAsArray_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getDataAsArray_(*args):
    if len(args) != 0: return False
    return True
  def _getDataAsArray_alt_(self,):
    return self._getDataAsArray_()
  def _getDataAsArray_(self,):
   _0=numpy.zeros(((self._dimi * self._dimj),), dtype=numpy.dtype(numpy.float64))
   fragments._c_closure_325(self._dimj,_0,self._subi,self._subj,self._val) # src/fusion/Matrix.mbi:725:9-726:46
   return (_0)
  @staticmethod
  def _match_getDataAsTriplets__3I_3I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match__3D__(_2))
  @staticmethod
  def _match_alt_getDataAsTriplets__3I_3I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3D__(_2))
  def _getDataAsTriplets_alt__3I_3I_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._getDataAsTriplets__3I_3I_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _getDataAsTriplets__3I_3I_3D(self,_0,_1,_2):
   if ((long((_0).shape[0]) < self._nnz) or ((long((_1).shape[0]) < self._nnz) or (long((_2).shape[0]) < self._nnz))):
    raise mosek_fusion_LengthError._ctor_S("Output arrays are not long enough.")
   if ((self._subi is not None) and (int((self._subi).shape[0]) > 0)):
    mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(self._subi,0,_0,0,self._nnz)
    mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(self._subj,0,_1,0,self._nnz)
    mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ(self._val,0,_2,0,self._nnz)
  @staticmethod
  def _match_get_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_get_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _get_alt_II(self,_t__0,_t__1):
    return self._get_II(numpy.int32(__0),numpy.int32(__1))
  def _get_II(self,_0,_1):
   if ((_0 < 0) or ((_0 >= self._dimi) or ((_1 < 0) or (_1 >= self._dimj)))):
    raise mosek_fusion_IndexError._ctor_S("Index out if bounds")
   _2=0
   _3=int((self._subi).shape[0])
   while ((_3 - _2) > 1):
    _4=((_2 + _3) // 2)
    if ((self._subi[_4] < _0) or ((self._subi[_4]==_0) and (self._subj[_4] < _1))):
     _2 = _4
    elif ((self._subi[_4] > _0) or ((self._subi[_4]==_0) and (self._subj[_4] > _1))):
     _3 = _4
    else:
     return numpy.float64(self._val[_4])
   if ((self._subi[_2]==_0) and (self._subj[_2]==_1)):
    return numpy.float64(self._val[_2])
   else:
    return numpy.float64(0.0)
 return SparseMatrix
mosek_fusion_SparseMatrix=__mk_mosek_fusion_SparseMatrix()
del __mk_mosek_fusion_SparseMatrix
#BEFORE CLASS
def __mk_mosek_fusion_Parameters():
 class Parameters(object):
  @staticmethod
  def setParameter(*args):
    if False: pass
    elif mosek_fusion_Parameters._match_setParameter_Lmosek_4fusion_4Model_2SS(*args): # mosek.fusion.Model,string,string
      return mosek_fusion_Parameters._setParameter_Lmosek_4fusion_4Model_2SS(*args)
    elif mosek_fusion_Parameters._match_alt_setParameter_Lmosek_4fusion_4Model_2SS(*args): # mosek.fusion.Model,string,string
      return mosek_fusion_Parameters._setParameter_alt_Lmosek_4fusion_4Model_2SS(*args)
    elif mosek_fusion_Parameters._match_setParameter_Lmosek_4fusion_4Model_2SI(*args): # mosek.fusion.Model,string,int32
      return mosek_fusion_Parameters._setParameter_Lmosek_4fusion_4Model_2SI(*args)
    elif mosek_fusion_Parameters._match_alt_setParameter_Lmosek_4fusion_4Model_2SI(*args): # mosek.fusion.Model,string,int32
      return mosek_fusion_Parameters._setParameter_alt_Lmosek_4fusion_4Model_2SI(*args)
    elif mosek_fusion_Parameters._match_setParameter_Lmosek_4fusion_4Model_2SD(*args): # mosek.fusion.Model,string,double
      return mosek_fusion_Parameters._setParameter_Lmosek_4fusion_4Model_2SD(*args)
    elif mosek_fusion_Parameters._match_alt_setParameter_Lmosek_4fusion_4Model_2SD(*args): # mosek.fusion.Model,string,double
      return mosek_fusion_Parameters._setParameter_alt_Lmosek_4fusion_4Model_2SD(*args)
    else:
      raise ValueError('Invalid argument list setParameter('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Parameters.setParameter(mosek.fusion.Model,string,string)\n\tmosek.fusion.Parameters.setParameter(mosek.fusion.Model,string,int32)\n\tmosek.fusion.Parameters.setParameter(mosek.fusion.Model,string,double)')
  def __repr__(self): return 'mosek.fusion.Parameters'
  @staticmethod
  def _match_setParameter_Lmosek_4fusion_4Model_2SD(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(_0) and __arg_match_S__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_setParameter_Lmosek_4fusion_4Model_2SD(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(_0) and __arg_alt_match_S__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _setParameter_alt_Lmosek_4fusion_4Model_2SD(_t__0,_t__1,_t__2):
    return mosek_fusion_Parameters._setParameter_Lmosek_4fusion_4Model_2SD(_0,_1,numpy.float64(__2))
  @staticmethod
  def _setParameter_Lmosek_4fusion_4Model_2SD(_0,_1,_2):
   if False:
    pass
   elif (_1=="autoUpdateSolInfo"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (autoUpdateSolInfo)")
   elif (_1=="removeUnusedSolutions"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (removeUnusedSolutions)")
   if (_1=="numThreads"):
    if ((_2 - numpy.int32(_2))==0.0):
     _3=_2
     if (0 <= _3):
      _0._task_1put_1param_SD("MSK_IPAR_NUM_THREADS",_3)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (numThreads)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (numThreads)")
   elif (_1=="intpntMultiThread"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMultiThread)")
   if (_1=="mtSpincount"):
    if ((_2 - numpy.int32(_2))==0.0):
     _4=_2
     if ((0 <= _4) and (_4 <= 1000000000)):
      _0._task_1put_1param_SD("MSK_IPAR_MT_SPINCOUNT",_4)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mtSpincount)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mtSpincount)")
   elif (_1=="optimizer"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (optimizer)")
   if (_1=="biMaxIterations"):
    if ((_2 - numpy.int32(_2))==0.0):
     _5=_2
     if (0 <= _5):
      _0._task_1put_1param_SD("MSK_IPAR_BI_MAX_ITERATIONS",_5)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biMaxIterations)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biMaxIterations)")
   if (_1=="licenseTrhExpiryWrn"):
    if ((_2 - numpy.int32(_2))==0.0):
     _6=_2
     if (0 <= _6):
      _0._task_1put_1param_SD("MSK_IPAR_LICENSE_TRH_EXPIRY_WRN",_6)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseTrhExpiryWrn)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseTrhExpiryWrn)")
   if (_1=="logCutSecondOpt"):
    if ((_2 - numpy.int32(_2))==0.0):
     _7=_2
     if (0 <= _7):
      _0._task_1put_1param_SD("MSK_IPAR_LOG_CUT_SECOND_OPT",_7)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logCutSecondOpt)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logCutSecondOpt)")
   if (_1=="logAnaPro"):
    if ((_2 - numpy.int32(_2))==0.0):
     _8=_2
     if (0 <= _8):
      _0._task_1put_1param_SD("MSK_IPAR_LOG_ANA_PRO",_8)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logAnaPro)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logAnaPro)")
   if (_1=="logResponse"):
    if ((_2 - numpy.int32(_2))==0.0):
     _9=_2
     if (0 <= _9):
      _0._task_1put_1param_SD("MSK_IPAR_LOG_RESPONSE",_9)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logResponse)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logResponse)")
   if (_1=="logBi"):
    if ((_2 - numpy.int32(_2))==0.0):
     _10=_2
     if (0 <= _10):
      _0._task_1put_1param_SD("MSK_IPAR_LOG_BI",_10)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logBi)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logBi)")
   if (_1=="logBiFreq"):
    if ((_2 - numpy.int32(_2))==0.0):
     _11=_2
     if (0 <= _11):
      _0._task_1put_1param_SD("MSK_IPAR_LOG_BI_FREQ",_11)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logBiFreq)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logBiFreq)")
   elif (_1=="biCleanOptimizer"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biCleanOptimizer)")
   elif (_1=="intpntStartingPoint"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntStartingPoint)")
   elif (_1=="intpntDiffStep"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntDiffStep)")
   elif (_1=="intpntScaling"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntScaling)")
   elif (_1=="intpntSolveForm"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntSolveForm)")
   if (_1=="logIntpnt"):
    if ((_2 - numpy.int32(_2))==0.0):
     _12=_2
     if (0 <= _12):
      _0._task_1put_1param_SD("MSK_IPAR_LOG_INTPNT",_12)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logIntpnt)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logIntpnt)")
   if (_1=="intpntMaxIterations"):
    if ((_2 - numpy.int32(_2))==0.0):
     _13=_2
     if (0 <= _13):
      _0._task_1put_1param_SD("MSK_IPAR_INTPNT_MAX_ITERATIONS",_13)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMaxIterations)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMaxIterations)")
   if (_1=="intpntOffColTrh"):
    if ((_2 - numpy.int32(_2))==0.0):
     _14=_2
     if (0 <= _14):
      _0._task_1put_1param_SD("MSK_IPAR_INTPNT_OFF_COL_TRH",_14)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOffColTrh)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOffColTrh)")
   elif (_1=="intpntOrderMethod"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOrderMethod)")
   elif (_1=="intpntBasis"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntBasis)")
   elif (_1=="biIgnoreMaxIter"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biIgnoreMaxIter)")
   elif (_1=="biIgnoreNumError"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biIgnoreNumError)")
   if (_1=="intpntMaxNumCor"):
    if ((_2 - numpy.int32(_2))==0.0):
     _15=_2
     if ((- 1) <= _15):
      _0._task_1put_1param_SD("MSK_IPAR_INTPNT_MAX_NUM_COR",_15)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMaxNumCor)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMaxNumCor)")
   elif (_1=="presolveUse"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveUse)")
   if (_1=="presolveLevel"):
    if ((_2 - numpy.int32(_2))==0.0):
     _16=_2
     if True:
      _0._task_1put_1param_SD("MSK_IPAR_PRESOLVE_LEVEL",_16)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLevel)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLevel)")
   if (_1=="logPresolve"):
    if ((_2 - numpy.int32(_2))==0.0):
     _17=_2
     if (0 <= _17):
      _0._task_1put_1param_SD("MSK_IPAR_LOG_PRESOLVE",_17)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logPresolve)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logPresolve)")
   elif (_1=="presolveLindepUse"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepUse)")
   if (_1=="presolveEliminatorMaxNumTries"):
    if ((_2 - numpy.int32(_2))==0.0):
     _18=_2
     if True:
      _0._task_1put_1param_SD("MSK_IPAR_PRESOLVE_ELIMINATOR_MAX_NUM_TRIES",_18)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveEliminatorMaxNumTries)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveEliminatorMaxNumTries)")
   if (_1=="presolveEliminatorMaxFill"):
    if ((_2 - numpy.int32(_2))==0.0):
     _19=_2
     if True:
      _0._task_1put_1param_SD("MSK_IPAR_PRESOLVE_ELIMINATOR_MAX_FILL",_19)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveEliminatorMaxFill)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveEliminatorMaxFill)")
   if (_1=="simPrimalCrash"):
    if ((_2 - numpy.int32(_2))==0.0):
     _20=_2
     if (0 <= _20):
      _0._task_1put_1param_SD("MSK_IPAR_SIM_PRIMAL_CRASH",_20)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalCrash)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalCrash)")
   if (_1=="logSim"):
    if ((_2 - numpy.int32(_2))==0.0):
     _21=_2
     if (0 <= _21):
      _0._task_1put_1param_SD("MSK_IPAR_LOG_SIM",_21)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSim)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSim)")
   if (_1=="logSimMinor"):
    if ((_2 - numpy.int32(_2))==0.0):
     _22=_2
     if (0 <= _22):
      _0._task_1put_1param_SD("MSK_IPAR_LOG_SIM_MINOR",_22)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSimMinor)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSimMinor)")
   if (_1=="logSimFreq"):
    if ((_2 - numpy.int32(_2))==0.0):
     _23=_2
     if (0 <= _23):
      _0._task_1put_1param_SD("MSK_IPAR_LOG_SIM_FREQ",_23)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSimFreq)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSimFreq)")
   if (_1=="simPrimalRestrictSelection"):
    if ((_2 - numpy.int32(_2))==0.0):
     _24=_2
     if ((0 <= _24) and (_24 <= 100)):
      _0._task_1put_1param_SD("MSK_IPAR_SIM_PRIMAL_RESTRICT_SELECTION",_24)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalRestrictSelection)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalRestrictSelection)")
   elif (_1=="simPrimalSelection"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalSelection)")
   if (_1=="simDualRestrictSelection"):
    if ((_2 - numpy.int32(_2))==0.0):
     _25=_2
     if ((0 <= _25) and (_25 <= 100)):
      _0._task_1put_1param_SD("MSK_IPAR_SIM_DUAL_RESTRICT_SELECTION",_25)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualRestrictSelection)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualRestrictSelection)")
   elif (_1=="simDualSelection"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualSelection)")
   if (_1=="simMaxIterations"):
    if ((_2 - numpy.int32(_2))==0.0):
     _26=_2
     if (0 <= _26):
      _0._task_1put_1param_SD("MSK_IPAR_SIM_MAX_ITERATIONS",_26)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simMaxIterations)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simMaxIterations)")
   elif (_1=="simHotstartLu"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simHotstartLu)")
   if (_1=="simRefactorFreq"):
    if ((_2 - numpy.int32(_2))==0.0):
     _27=_2
     if (0 <= _27):
      _0._task_1put_1param_SD("MSK_IPAR_SIM_REFACTOR_FREQ",_27)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simRefactorFreq)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simRefactorFreq)")
   elif (_1=="mioMode"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMode)")
   if (_1=="logMio"):
    if ((_2 - numpy.int32(_2))==0.0):
     _28=_2
     if (0 <= _28):
      _0._task_1put_1param_SD("MSK_IPAR_LOG_MIO",_28)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logMio)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logMio)")
   if (_1=="logMioFreq"):
    if ((_2 - numpy.int32(_2))==0.0):
     _29=_2
     if True:
      _0._task_1put_1param_SD("MSK_IPAR_LOG_MIO_FREQ",_29)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logMioFreq)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logMioFreq)")
   if (_1=="mioMaxNumRelaxs"):
    if ((_2 - numpy.int32(_2))==0.0):
     _30=_2
     if True:
      _0._task_1put_1param_SD("MSK_IPAR_MIO_MAX_NUM_RELAXS",_30)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumRelaxs)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumRelaxs)")
   if (_1=="mioMaxNumBranches"):
    if ((_2 - numpy.int32(_2))==0.0):
     _31=_2
     if True:
      _0._task_1put_1param_SD("MSK_IPAR_MIO_MAX_NUM_BRANCHES",_31)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumBranches)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumBranches)")
   if (_1=="mioMaxNumSolutions"):
    if ((_2 - numpy.int32(_2))==0.0):
     _32=_2
     if True:
      _0._task_1put_1param_SD("MSK_IPAR_MIO_MAX_NUM_SOLUTIONS",_32)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumSolutions)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumSolutions)")
   elif (_1=="mioNodeSelection"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioNodeSelection)")
   if (_1=="mioHeuristicLevel"):
    if ((_2 - numpy.int32(_2))==0.0):
     _33=_2
     if True:
      _0._task_1put_1param_SD("MSK_IPAR_MIO_HEURISTIC_LEVEL",_33)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioHeuristicLevel)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioHeuristicLevel)")
   if (_1=="mioProbingLevel"):
    if ((_2 - numpy.int32(_2))==0.0):
     _34=_2
     if (((- 1) <= _34) and (_34 <= 3)):
      _0._task_1put_1param_SD("MSK_IPAR_MIO_PROBING_LEVEL",_34)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioProbingLevel)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioProbingLevel)")
   if (_1=="mioCutSelectionLevel"):
    if ((_2 - numpy.int32(_2))==0.0):
     _35=_2
     if (((- 1) <= _35) and (_35 <= 1)):
      _0._task_1put_1param_SD("MSK_IPAR_MIO_CUT_SELECTION_LEVEL",_35)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutSelectionLevel)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutSelectionLevel)")
   if (_1=="mioVbDetectionLevel"):
    if ((_2 - numpy.int32(_2))==0.0):
     _36=_2
     if (((- 1) <= _36) and (_36 <= 2)):
      _0._task_1put_1param_SD("MSK_IPAR_MIO_VB_DETECTION_LEVEL",_36)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioVbDetectionLevel)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioVbDetectionLevel)")
   elif (_1=="mioBranchDir"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioBranchDir)")
   elif (_1=="mioRootOptimizer"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRootOptimizer)")
   elif (_1=="mioNodeOptimizer"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioNodeOptimizer)")
   elif (_1=="mioPerspectiveReformulate"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioPerspectiveReformulate)")
   elif (_1=="writeLpQuotedNames"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpQuotedNames)")
   if (_1=="writeLpLineWidth"):
    if ((_2 - numpy.int32(_2))==0.0):
     _37=_2
     if (40 <= _37):
      _0._task_1put_1param_SD("MSK_IPAR_WRITE_LP_LINE_WIDTH",_37)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpLineWidth)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpLineWidth)")
   if (_1=="writeLpTermsPerLine"):
    if ((_2 - numpy.int32(_2))==0.0):
     _38=_2
     if (0 <= _38):
      _0._task_1put_1param_SD("MSK_IPAR_WRITE_LP_TERMS_PER_LINE",_38)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpTermsPerLine)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpTermsPerLine)")
   elif (_1=="writeLpFullObj"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpFullObj)")
   if (_1=="logInfeasAna"):
    if ((_2 - numpy.int32(_2))==0.0):
     _39=_2
     if (0 <= _39):
      _0._task_1put_1param_SD("MSK_IPAR_LOG_INFEAS_ANA",_39)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logInfeasAna)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logInfeasAna)")
   elif (_1=="licenseWait"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseWait)")
   elif (_1=="licenseSuppressExpireWrns"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseSuppressExpireWrns)")
   if (_1=="licensePauseTime"):
    if ((_2 - numpy.int32(_2))==0.0):
     _40=_2
     if ((0 <= _40) and (_40 <= 1000000)):
      _0._task_1put_1param_SD("MSK_IPAR_LICENSE_PAUSE_TIME",_40)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licensePauseTime)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licensePauseTime)")
   elif (_1=="licenseDebug"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseDebug)")
   if (_1=="log"):
    if ((_2 - numpy.int32(_2))==0.0):
     _41=_2
     if (0 <= _41):
      _0._task_1put_1param_SD("MSK_IPAR_LOG",_41)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (log)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (log)")
   if (_1=="logExpand"):
    if ((_2 - numpy.int32(_2))==0.0):
     _42=_2
     if (0 <= _42):
      _0._task_1put_1param_SD("MSK_IPAR_LOG_EXPAND",_42)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logExpand)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logExpand)")
   if (_1=="logFile"):
    if ((_2 - numpy.int32(_2))==0.0):
     _43=_2
     if (0 <= _43):
      _0._task_1put_1param_SD("MSK_IPAR_LOG_FILE",_43)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logFile)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logFile)")
   if (_1=="logOrder"):
    if ((_2 - numpy.int32(_2))==0.0):
     _44=_2
     if (0 <= _44):
      _0._task_1put_1param_SD("MSK_IPAR_LOG_ORDER",_44)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logOrder)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logOrder)")
   elif (_1=="simScaling"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simScaling)")
   elif (_1=="simScalingMethod"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simScalingMethod)")
   if (_1=="simPrimalPhaseoneMethod"):
    if ((_2 - numpy.int32(_2))==0.0):
     _45=_2
     if ((0 <= _45) and (_45 <= 10)):
      _0._task_1put_1param_SD("MSK_IPAR_SIM_PRIMAL_PHASEONE_METHOD",_45)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalPhaseoneMethod)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalPhaseoneMethod)")
   if (_1=="simDualPhaseoneMethod"):
    if ((_2 - numpy.int32(_2))==0.0):
     _46=_2
     if ((0 <= _46) and (_46 <= 10)):
      _0._task_1put_1param_SD("MSK_IPAR_SIM_DUAL_PHASEONE_METHOD",_46)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualPhaseoneMethod)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualPhaseoneMethod)")
   if (_1=="simMaxNumSetbacks"):
    if ((_2 - numpy.int32(_2))==0.0):
     _47=_2
     if (0 <= _47):
      _0._task_1put_1param_SD("MSK_IPAR_SIM_MAX_NUM_SETBACKS",_47)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simMaxNumSetbacks)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simMaxNumSetbacks)")
   elif (_1=="simHotstart"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simHotstart)")
   elif (_1=="simBasisFactorUse"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simBasisFactorUse)")
   elif (_1=="simDegen"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDegen)")
   elif (_1=="simReformulation"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simReformulation)")
   elif (_1=="simExploitDupvec"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simExploitDupvec)")
   elif (_1=="simSaveLu"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSaveLu)")
   elif (_1=="simNonSingular"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simNonSingular)")
   if (_1=="simDualCrash"):
    if ((_2 - numpy.int32(_2))==0.0):
     _48=_2
     if (0 <= _48):
      _0._task_1put_1param_SD("MSK_IPAR_SIM_DUAL_CRASH",_48)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualCrash)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualCrash)")
   elif (_1=="infeasPreferPrimal"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (infeasPreferPrimal)")
   if (_1=="mioRootRepeatPresolveLevel"):
    if ((_2 - numpy.int32(_2))==0.0):
     _49=_2
     if (((- 1) <= _49) and (_49 <= 1)):
      _0._task_1put_1param_SD("MSK_IPAR_MIO_ROOT_REPEAT_PRESOLVE_LEVEL",_49)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRootRepeatPresolveLevel)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRootRepeatPresolveLevel)")
   elif (_1=="mioCutCmir"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutCmir)")
   elif (_1=="mioCutClique"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutClique)")
   elif (_1=="mioCutImpliedBound"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutImpliedBound)")
   elif (_1=="mioCutKnapsackCover"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutKnapsackCover)")
   elif (_1=="mioCutGmi"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutGmi)")
   elif (_1=="mioConstructSol"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioConstructSol)")
   if (_1=="presolveLindepRelWorkTrh"):
    if ((_2 - numpy.int32(_2))==0.0):
     _50=_2
     if True:
      _0._task_1put_1param_SD("MSK_IPAR_PRESOLVE_LINDEP_REL_WORK_TRH",_50)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepRelWorkTrh)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepRelWorkTrh)")
   if (_1=="presolveLindepAbsWorkTrh"):
    if ((_2 - numpy.int32(_2))==0.0):
     _51=_2
     if True:
      _0._task_1put_1param_SD("MSK_IPAR_PRESOLVE_LINDEP_ABS_WORK_TRH",_51)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepAbsWorkTrh)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepAbsWorkTrh)")
   elif (_1=="cacheLicense"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (cacheLicense)")
   elif (_1=="intpntRegularizationUse"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntRegularizationUse)")
   elif (_1=="simSolveForm"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSolveForm)")
   elif (_1=="simSwitchOptimizer"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSwitchOptimizer)")
   if (_1=="mioRinsMaxNodes"):
    if ((_2 - numpy.int32(_2))==0.0):
     _52=_2
     if ((- 1) <= _52):
      _0._task_1put_1param_SD("MSK_IPAR_MIO_RINS_MAX_NODES",_52)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRinsMaxNodes)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRinsMaxNodes)")
   if (_1=="optimizerMaxTime"):
    _53=_2
    if True:
     _0._task_1put_1param_SD("MSK_DPAR_OPTIMIZER_MAX_TIME",_53)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (optimizerMaxTime)")
   if (_1=="lowerObjCut"):
    _54=_2
    if True:
     _0._task_1put_1param_SD("MSK_DPAR_LOWER_OBJ_CUT",_54)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (lowerObjCut)")
   if (_1=="upperObjCut"):
    _55=_2
    if True:
     _0._task_1put_1param_SD("MSK_DPAR_UPPER_OBJ_CUT",_55)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (upperObjCut)")
   if (_1=="upperObjCutFiniteTrh"):
    _56=_2
    if True:
     _0._task_1put_1param_SD("MSK_DPAR_UPPER_OBJ_CUT_FINITE_TRH",_56)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (upperObjCutFiniteTrh)")
   if (_1=="lowerObjCutFiniteTrh"):
    _57=_2
    if True:
     _0._task_1put_1param_SD("MSK_DPAR_LOWER_OBJ_CUT_FINITE_TRH",_57)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (lowerObjCutFiniteTrh)")
   if (_1=="intpntTolRelGap"):
    _58=_2
    if (1.000000e-14 <= _58):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_REL_GAP",_58)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolRelGap)")
   if (_1=="intpntTolStepSize"):
    _59=_2
    if ((0.000000e+00 <= _59) and (_59 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_STEP_SIZE",_59)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolStepSize)")
   if (_1=="simLuTolRelPiv"):
    _60=_2
    if ((1.000000e-06 <= _60) and (_60 <= 9.999990e-01)):
     _0._task_1put_1param_SD("MSK_DPAR_SIM_LU_TOL_REL_PIV",_60)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simLuTolRelPiv)")
   if (_1=="intpntTolRelStep"):
    _61=_2
    if ((1.000000e-04 <= _61) and (_61 <= 9.999990e-01)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_REL_STEP",_61)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolRelStep)")
   if (_1=="intpntTolPath"):
    _62=_2
    if ((0.000000e+00 <= _62) and (_62 <= 9.999000e-01)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_PATH",_62)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPath)")
   if (_1=="intpntTolPfeas"):
    _63=_2
    if ((0.000000e+00 <= _63) and (_63 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_PFEAS",_63)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPfeas)")
   if (_1=="intpntTolDfeas"):
    _64=_2
    if ((0.000000e+00 <= _64) and (_64 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_DFEAS",_64)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolDfeas)")
   if (_1=="intpntTolMuRed"):
    _65=_2
    if ((0.000000e+00 <= _65) and (_65 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_MU_RED",_65)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolMuRed)")
   if (_1=="intpntTolInfeas"):
    _66=_2
    if ((0.000000e+00 <= _66) and (_66 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_INFEAS",_66)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolInfeas)")
   if (_1=="intpntCoTolRelGap"):
    _67=_2
    if ((0.000000e+00 <= _67) and (_67 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_REL_GAP",_67)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolRelGap)")
   if (_1=="intpntCoTolPfeas"):
    _68=_2
    if ((0.000000e+00 <= _68) and (_68 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_PFEAS",_68)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolPfeas)")
   if (_1=="intpntCoTolDfeas"):
    _69=_2
    if ((0.000000e+00 <= _69) and (_69 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_DFEAS",_69)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolDfeas)")
   if (_1=="intpntCoTolMuRed"):
    _70=_2
    if ((0.000000e+00 <= _70) and (_70 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_MU_RED",_70)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolMuRed)")
   if (_1=="intpntCoTolNearRel"):
    _71=_2
    if (1.000000e+00 <= _71):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_NEAR_REL",_71)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolNearRel)")
   if (_1=="intpntCoTolInfeas"):
    _72=_2
    if ((0.000000e+00 <= _72) and (_72 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_INFEAS",_72)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolInfeas)")
   if (_1=="intpntQoTolRelGap"):
    _73=_2
    if ((0.000000e+00 <= _73) and (_73 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_QO_TOL_REL_GAP",_73)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntQoTolRelGap)")
   if (_1=="intpntQoTolPfeas"):
    _74=_2
    if ((0.000000e+00 <= _74) and (_74 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_QO_TOL_PFEAS",_74)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntQoTolPfeas)")
   if (_1=="intpntQoTolDfeas"):
    _75=_2
    if ((0.000000e+00 <= _75) and (_75 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_QO_TOL_DFEAS",_75)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntQoTolDfeas)")
   if (_1=="intpntQoTolMuRed"):
    _76=_2
    if ((0.000000e+00 <= _76) and (_76 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_QO_TOL_MU_RED",_76)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntQoTolMuRed)")
   if (_1=="intpntQoTolNearRel"):
    _77=_2
    if (1.000000e+00 <= _77):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_QO_TOL_NEAR_REL",_77)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntQoTolNearRel)")
   if (_1=="intpntQoTolInfeas"):
    _78=_2
    if ((0.000000e+00 <= _78) and (_78 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_QO_TOL_INFEAS",_78)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntQoTolInfeas)")
   if (_1=="intpntTolPsafe"):
    _79=_2
    if (1.000000e-04 <= _79):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_PSAFE",_79)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPsafe)")
   if (_1=="intpntTolDsafe"):
    _80=_2
    if (1.000000e-04 <= _80):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_DSAFE",_80)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolDsafe)")
   if (_1=="mioMaxTime"):
    _81=_2
    if True:
     _0._task_1put_1param_SD("MSK_DPAR_MIO_MAX_TIME",_81)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxTime)")
   if (_1=="mioDisableTermTime"):
    _82=_2
    if True:
     _0._task_1put_1param_SD("MSK_DPAR_MIO_DISABLE_TERM_TIME",_82)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioDisableTermTime)")
   if (_1=="mioRelGapConst"):
    _83=_2
    if (1.000000e-15 <= _83):
     _0._task_1put_1param_SD("MSK_DPAR_MIO_REL_GAP_CONST",_83)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRelGapConst)")
   if (_1=="mioTolRelGap"):
    _84=_2
    if (0.000000e+00 <= _84):
     _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_REL_GAP",_84)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolRelGap)")
   if (_1=="mioNearTolRelGap"):
    _85=_2
    if (0.000000e+00 <= _85):
     _0._task_1put_1param_SD("MSK_DPAR_MIO_NEAR_TOL_REL_GAP",_85)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioNearTolRelGap)")
   if (_1=="mioTolAbsGap"):
    _86=_2
    if (0.000000e+00 <= _86):
     _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_ABS_GAP",_86)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolAbsGap)")
   if (_1=="mioNearTolAbsGap"):
    _87=_2
    if (0.000000e+00 <= _87):
     _0._task_1put_1param_SD("MSK_DPAR_MIO_NEAR_TOL_ABS_GAP",_87)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioNearTolAbsGap)")
   if (_1=="mioTolAbsRelaxInt"):
    _88=_2
    if (1.000000e-09 <= _88):
     _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_ABS_RELAX_INT",_88)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolAbsRelaxInt)")
   if (_1=="basisTolX"):
    _89=_2
    if (1.000000e-09 <= _89):
     _0._task_1put_1param_SD("MSK_DPAR_BASIS_TOL_X",_89)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisTolX)")
   if (_1=="basisTolS"):
    _90=_2
    if (1.000000e-09 <= _90):
     _0._task_1put_1param_SD("MSK_DPAR_BASIS_TOL_S",_90)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisTolS)")
   if (_1=="basisRelTolS"):
    _91=_2
    if (0.000000e+00 <= _91):
     _0._task_1put_1param_SD("MSK_DPAR_BASIS_REL_TOL_S",_91)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisRelTolS)")
   if (_1=="presolveTolX"):
    _92=_2
    if (0.000000e+00 <= _92):
     _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_X",_92)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolX)")
   if (_1=="presolveTolS"):
    _93=_2
    if (0.000000e+00 <= _93):
     _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_S",_93)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolS)")
   if (_1=="presolveTolAij"):
    _94=_2
    if (1.000000e-15 <= _94):
     _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_AIJ",_94)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolAij)")
   if (_1=="presolveTolAbsLindep"):
    _95=_2
    if (0.000000e+00 <= _95):
     _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_ABS_LINDEP",_95)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolAbsLindep)")
   if (_1=="presolveTolRelLindep"):
    _96=_2
    if (0.000000e+00 <= _96):
     _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_REL_LINDEP",_96)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolRelLindep)")
   if (_1=="simplexAbsTolPiv"):
    _97=_2
    if (1.000000e-12 <= _97):
     _0._task_1put_1param_SD("MSK_DPAR_SIMPLEX_ABS_TOL_PIV",_97)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simplexAbsTolPiv)")
   if (_1=="mioTolFeas"):
    _98=_2
    if ((1.000000e-09 <= _98) and (_98 <= 1.000000e-03)):
     _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_FEAS",_98)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolFeas)")
   if (_1=="anaSolInfeasTol"):
    _99=_2
    if (0.000000e+00 <= _99):
     _0._task_1put_1param_SD("MSK_DPAR_ANA_SOL_INFEAS_TOL",_99)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (anaSolInfeasTol)")
   if (_1=="mioTolRelDualBoundImprovement"):
    _100=_2
    if ((0.000000e+00 <= _100) and (_100 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_REL_DUAL_BOUND_IMPROVEMENT",_100)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolRelDualBoundImprovement)")
   raise mosek_fusion_ParameterError._ctor_S("Unknown parameter")
  @staticmethod
  def _match_setParameter_Lmosek_4fusion_4Model_2SI(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(_0) and __arg_match_S__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_setParameter_Lmosek_4fusion_4Model_2SI(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(_0) and __arg_alt_match_S__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _setParameter_alt_Lmosek_4fusion_4Model_2SI(_t__0,_t__1,_t__2):
    return mosek_fusion_Parameters._setParameter_Lmosek_4fusion_4Model_2SI(_0,_1,numpy.int32(__2))
  @staticmethod
  def _setParameter_Lmosek_4fusion_4Model_2SI(_0,_1,_2):
   if False:
    pass
   elif (_1=="autoUpdateSolInfo"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (autoUpdateSolInfo)")
   elif (_1=="removeUnusedSolutions"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (removeUnusedSolutions)")
   if (_1=="numThreads"):
    _3=_2
    if (0 <= _3):
     _0._task_1put_1param_SI("MSK_IPAR_NUM_THREADS",_3)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (numThreads)")
   elif (_1=="intpntMultiThread"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMultiThread)")
   if (_1=="mtSpincount"):
    _4=_2
    if ((0 <= _4) and (_4 <= 1000000000)):
     _0._task_1put_1param_SI("MSK_IPAR_MT_SPINCOUNT",_4)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mtSpincount)")
   elif (_1=="optimizer"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (optimizer)")
   if (_1=="biMaxIterations"):
    _5=_2
    if (0 <= _5):
     _0._task_1put_1param_SI("MSK_IPAR_BI_MAX_ITERATIONS",_5)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biMaxIterations)")
   if (_1=="licenseTrhExpiryWrn"):
    _6=_2
    if (0 <= _6):
     _0._task_1put_1param_SI("MSK_IPAR_LICENSE_TRH_EXPIRY_WRN",_6)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseTrhExpiryWrn)")
   if (_1=="logCutSecondOpt"):
    _7=_2
    if (0 <= _7):
     _0._task_1put_1param_SI("MSK_IPAR_LOG_CUT_SECOND_OPT",_7)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logCutSecondOpt)")
   if (_1=="logAnaPro"):
    _8=_2
    if (0 <= _8):
     _0._task_1put_1param_SI("MSK_IPAR_LOG_ANA_PRO",_8)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logAnaPro)")
   if (_1=="logResponse"):
    _9=_2
    if (0 <= _9):
     _0._task_1put_1param_SI("MSK_IPAR_LOG_RESPONSE",_9)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logResponse)")
   if (_1=="logBi"):
    _10=_2
    if (0 <= _10):
     _0._task_1put_1param_SI("MSK_IPAR_LOG_BI",_10)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logBi)")
   if (_1=="logBiFreq"):
    _11=_2
    if (0 <= _11):
     _0._task_1put_1param_SI("MSK_IPAR_LOG_BI_FREQ",_11)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logBiFreq)")
   elif (_1=="biCleanOptimizer"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biCleanOptimizer)")
   elif (_1=="intpntStartingPoint"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntStartingPoint)")
   elif (_1=="intpntDiffStep"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntDiffStep)")
   elif (_1=="intpntScaling"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntScaling)")
   elif (_1=="intpntSolveForm"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntSolveForm)")
   if (_1=="logIntpnt"):
    _12=_2
    if (0 <= _12):
     _0._task_1put_1param_SI("MSK_IPAR_LOG_INTPNT",_12)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logIntpnt)")
   if (_1=="intpntMaxIterations"):
    _13=_2
    if (0 <= _13):
     _0._task_1put_1param_SI("MSK_IPAR_INTPNT_MAX_ITERATIONS",_13)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMaxIterations)")
   if (_1=="intpntOffColTrh"):
    _14=_2
    if (0 <= _14):
     _0._task_1put_1param_SI("MSK_IPAR_INTPNT_OFF_COL_TRH",_14)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOffColTrh)")
   elif (_1=="intpntOrderMethod"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOrderMethod)")
   elif (_1=="intpntBasis"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntBasis)")
   elif (_1=="biIgnoreMaxIter"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biIgnoreMaxIter)")
   elif (_1=="biIgnoreNumError"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biIgnoreNumError)")
   if (_1=="intpntMaxNumCor"):
    _15=_2
    if ((- 1) <= _15):
     _0._task_1put_1param_SI("MSK_IPAR_INTPNT_MAX_NUM_COR",_15)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMaxNumCor)")
   elif (_1=="presolveUse"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveUse)")
   if (_1=="presolveLevel"):
    _16=_2
    if True:
     _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_LEVEL",_16)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLevel)")
   if (_1=="logPresolve"):
    _17=_2
    if (0 <= _17):
     _0._task_1put_1param_SI("MSK_IPAR_LOG_PRESOLVE",_17)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logPresolve)")
   elif (_1=="presolveLindepUse"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepUse)")
   if (_1=="presolveEliminatorMaxNumTries"):
    _18=_2
    if True:
     _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_ELIMINATOR_MAX_NUM_TRIES",_18)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveEliminatorMaxNumTries)")
   if (_1=="presolveEliminatorMaxFill"):
    _19=_2
    if True:
     _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_ELIMINATOR_MAX_FILL",_19)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveEliminatorMaxFill)")
   if (_1=="simPrimalCrash"):
    _20=_2
    if (0 <= _20):
     _0._task_1put_1param_SI("MSK_IPAR_SIM_PRIMAL_CRASH",_20)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalCrash)")
   if (_1=="logSim"):
    _21=_2
    if (0 <= _21):
     _0._task_1put_1param_SI("MSK_IPAR_LOG_SIM",_21)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSim)")
   if (_1=="logSimMinor"):
    _22=_2
    if (0 <= _22):
     _0._task_1put_1param_SI("MSK_IPAR_LOG_SIM_MINOR",_22)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSimMinor)")
   if (_1=="logSimFreq"):
    _23=_2
    if (0 <= _23):
     _0._task_1put_1param_SI("MSK_IPAR_LOG_SIM_FREQ",_23)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSimFreq)")
   if (_1=="simPrimalRestrictSelection"):
    _24=_2
    if ((0 <= _24) and (_24 <= 100)):
     _0._task_1put_1param_SI("MSK_IPAR_SIM_PRIMAL_RESTRICT_SELECTION",_24)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalRestrictSelection)")
   elif (_1=="simPrimalSelection"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalSelection)")
   if (_1=="simDualRestrictSelection"):
    _25=_2
    if ((0 <= _25) and (_25 <= 100)):
     _0._task_1put_1param_SI("MSK_IPAR_SIM_DUAL_RESTRICT_SELECTION",_25)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualRestrictSelection)")
   elif (_1=="simDualSelection"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualSelection)")
   if (_1=="simMaxIterations"):
    _26=_2
    if (0 <= _26):
     _0._task_1put_1param_SI("MSK_IPAR_SIM_MAX_ITERATIONS",_26)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simMaxIterations)")
   elif (_1=="simHotstartLu"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simHotstartLu)")
   if (_1=="simRefactorFreq"):
    _27=_2
    if (0 <= _27):
     _0._task_1put_1param_SI("MSK_IPAR_SIM_REFACTOR_FREQ",_27)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simRefactorFreq)")
   elif (_1=="mioMode"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMode)")
   if (_1=="logMio"):
    _28=_2
    if (0 <= _28):
     _0._task_1put_1param_SI("MSK_IPAR_LOG_MIO",_28)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logMio)")
   if (_1=="logMioFreq"):
    _29=_2
    if True:
     _0._task_1put_1param_SI("MSK_IPAR_LOG_MIO_FREQ",_29)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logMioFreq)")
   if (_1=="mioMaxNumRelaxs"):
    _30=_2
    if True:
     _0._task_1put_1param_SI("MSK_IPAR_MIO_MAX_NUM_RELAXS",_30)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumRelaxs)")
   if (_1=="mioMaxNumBranches"):
    _31=_2
    if True:
     _0._task_1put_1param_SI("MSK_IPAR_MIO_MAX_NUM_BRANCHES",_31)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumBranches)")
   if (_1=="mioMaxNumSolutions"):
    _32=_2
    if True:
     _0._task_1put_1param_SI("MSK_IPAR_MIO_MAX_NUM_SOLUTIONS",_32)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumSolutions)")
   elif (_1=="mioNodeSelection"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioNodeSelection)")
   if (_1=="mioHeuristicLevel"):
    _33=_2
    if True:
     _0._task_1put_1param_SI("MSK_IPAR_MIO_HEURISTIC_LEVEL",_33)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioHeuristicLevel)")
   if (_1=="mioProbingLevel"):
    _34=_2
    if (((- 1) <= _34) and (_34 <= 3)):
     _0._task_1put_1param_SI("MSK_IPAR_MIO_PROBING_LEVEL",_34)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioProbingLevel)")
   if (_1=="mioCutSelectionLevel"):
    _35=_2
    if (((- 1) <= _35) and (_35 <= 1)):
     _0._task_1put_1param_SI("MSK_IPAR_MIO_CUT_SELECTION_LEVEL",_35)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutSelectionLevel)")
   if (_1=="mioVbDetectionLevel"):
    _36=_2
    if (((- 1) <= _36) and (_36 <= 2)):
     _0._task_1put_1param_SI("MSK_IPAR_MIO_VB_DETECTION_LEVEL",_36)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioVbDetectionLevel)")
   elif (_1=="mioBranchDir"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioBranchDir)")
   elif (_1=="mioRootOptimizer"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRootOptimizer)")
   elif (_1=="mioNodeOptimizer"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioNodeOptimizer)")
   elif (_1=="mioPerspectiveReformulate"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioPerspectiveReformulate)")
   elif (_1=="writeLpQuotedNames"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpQuotedNames)")
   if (_1=="writeLpLineWidth"):
    _37=_2
    if (40 <= _37):
     _0._task_1put_1param_SI("MSK_IPAR_WRITE_LP_LINE_WIDTH",_37)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpLineWidth)")
   if (_1=="writeLpTermsPerLine"):
    _38=_2
    if (0 <= _38):
     _0._task_1put_1param_SI("MSK_IPAR_WRITE_LP_TERMS_PER_LINE",_38)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpTermsPerLine)")
   elif (_1=="writeLpFullObj"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpFullObj)")
   if (_1=="logInfeasAna"):
    _39=_2
    if (0 <= _39):
     _0._task_1put_1param_SI("MSK_IPAR_LOG_INFEAS_ANA",_39)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logInfeasAna)")
   elif (_1=="licenseWait"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseWait)")
   elif (_1=="licenseSuppressExpireWrns"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseSuppressExpireWrns)")
   if (_1=="licensePauseTime"):
    _40=_2
    if ((0 <= _40) and (_40 <= 1000000)):
     _0._task_1put_1param_SI("MSK_IPAR_LICENSE_PAUSE_TIME",_40)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licensePauseTime)")
   elif (_1=="licenseDebug"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseDebug)")
   if (_1=="log"):
    _41=_2
    if (0 <= _41):
     _0._task_1put_1param_SI("MSK_IPAR_LOG",_41)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (log)")
   if (_1=="logExpand"):
    _42=_2
    if (0 <= _42):
     _0._task_1put_1param_SI("MSK_IPAR_LOG_EXPAND",_42)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logExpand)")
   if (_1=="logFile"):
    _43=_2
    if (0 <= _43):
     _0._task_1put_1param_SI("MSK_IPAR_LOG_FILE",_43)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logFile)")
   if (_1=="logOrder"):
    _44=_2
    if (0 <= _44):
     _0._task_1put_1param_SI("MSK_IPAR_LOG_ORDER",_44)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logOrder)")
   elif (_1=="simScaling"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simScaling)")
   elif (_1=="simScalingMethod"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simScalingMethod)")
   if (_1=="simPrimalPhaseoneMethod"):
    _45=_2
    if ((0 <= _45) and (_45 <= 10)):
     _0._task_1put_1param_SI("MSK_IPAR_SIM_PRIMAL_PHASEONE_METHOD",_45)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalPhaseoneMethod)")
   if (_1=="simDualPhaseoneMethod"):
    _46=_2
    if ((0 <= _46) and (_46 <= 10)):
     _0._task_1put_1param_SI("MSK_IPAR_SIM_DUAL_PHASEONE_METHOD",_46)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualPhaseoneMethod)")
   if (_1=="simMaxNumSetbacks"):
    _47=_2
    if (0 <= _47):
     _0._task_1put_1param_SI("MSK_IPAR_SIM_MAX_NUM_SETBACKS",_47)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simMaxNumSetbacks)")
   elif (_1=="simHotstart"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simHotstart)")
   elif (_1=="simBasisFactorUse"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simBasisFactorUse)")
   elif (_1=="simDegen"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDegen)")
   elif (_1=="simReformulation"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simReformulation)")
   elif (_1=="simExploitDupvec"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simExploitDupvec)")
   elif (_1=="simSaveLu"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSaveLu)")
   elif (_1=="simNonSingular"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simNonSingular)")
   if (_1=="simDualCrash"):
    _48=_2
    if (0 <= _48):
     _0._task_1put_1param_SI("MSK_IPAR_SIM_DUAL_CRASH",_48)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualCrash)")
   elif (_1=="infeasPreferPrimal"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (infeasPreferPrimal)")
   if (_1=="mioRootRepeatPresolveLevel"):
    _49=_2
    if (((- 1) <= _49) and (_49 <= 1)):
     _0._task_1put_1param_SI("MSK_IPAR_MIO_ROOT_REPEAT_PRESOLVE_LEVEL",_49)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRootRepeatPresolveLevel)")
   elif (_1=="mioCutCmir"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutCmir)")
   elif (_1=="mioCutClique"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutClique)")
   elif (_1=="mioCutImpliedBound"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutImpliedBound)")
   elif (_1=="mioCutKnapsackCover"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutKnapsackCover)")
   elif (_1=="mioCutGmi"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutGmi)")
   elif (_1=="mioConstructSol"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioConstructSol)")
   if (_1=="presolveLindepRelWorkTrh"):
    _50=_2
    if True:
     _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_LINDEP_REL_WORK_TRH",_50)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepRelWorkTrh)")
   if (_1=="presolveLindepAbsWorkTrh"):
    _51=_2
    if True:
     _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_LINDEP_ABS_WORK_TRH",_51)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepAbsWorkTrh)")
   elif (_1=="cacheLicense"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (cacheLicense)")
   elif (_1=="intpntRegularizationUse"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntRegularizationUse)")
   elif (_1=="simSolveForm"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSolveForm)")
   elif (_1=="simSwitchOptimizer"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSwitchOptimizer)")
   if (_1=="mioRinsMaxNodes"):
    _52=_2
    if ((- 1) <= _52):
     _0._task_1put_1param_SI("MSK_IPAR_MIO_RINS_MAX_NODES",_52)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRinsMaxNodes)")
   if (_1=="optimizerMaxTime"):
    _53=numpy.float64(_2)
    if True:
     _0._task_1put_1param_SD("MSK_DPAR_OPTIMIZER_MAX_TIME",_53)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (optimizerMaxTime)")
   if (_1=="lowerObjCut"):
    _54=numpy.float64(_2)
    if True:
     _0._task_1put_1param_SD("MSK_DPAR_LOWER_OBJ_CUT",_54)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (lowerObjCut)")
   if (_1=="upperObjCut"):
    _55=numpy.float64(_2)
    if True:
     _0._task_1put_1param_SD("MSK_DPAR_UPPER_OBJ_CUT",_55)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (upperObjCut)")
   if (_1=="upperObjCutFiniteTrh"):
    _56=numpy.float64(_2)
    if True:
     _0._task_1put_1param_SD("MSK_DPAR_UPPER_OBJ_CUT_FINITE_TRH",_56)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (upperObjCutFiniteTrh)")
   if (_1=="lowerObjCutFiniteTrh"):
    _57=numpy.float64(_2)
    if True:
     _0._task_1put_1param_SD("MSK_DPAR_LOWER_OBJ_CUT_FINITE_TRH",_57)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (lowerObjCutFiniteTrh)")
   if (_1=="intpntTolRelGap"):
    _58=numpy.float64(_2)
    if (1.000000e-14 <= _58):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_REL_GAP",_58)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolRelGap)")
   if (_1=="intpntTolStepSize"):
    _59=numpy.float64(_2)
    if ((0.000000e+00 <= _59) and (_59 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_STEP_SIZE",_59)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolStepSize)")
   if (_1=="simLuTolRelPiv"):
    _60=numpy.float64(_2)
    if ((1.000000e-06 <= _60) and (_60 <= 9.999990e-01)):
     _0._task_1put_1param_SD("MSK_DPAR_SIM_LU_TOL_REL_PIV",_60)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simLuTolRelPiv)")
   if (_1=="intpntTolRelStep"):
    _61=numpy.float64(_2)
    if ((1.000000e-04 <= _61) and (_61 <= 9.999990e-01)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_REL_STEP",_61)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolRelStep)")
   if (_1=="intpntTolPath"):
    _62=numpy.float64(_2)
    if ((0.000000e+00 <= _62) and (_62 <= 9.999000e-01)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_PATH",_62)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPath)")
   if (_1=="intpntTolPfeas"):
    _63=numpy.float64(_2)
    if ((0.000000e+00 <= _63) and (_63 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_PFEAS",_63)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPfeas)")
   if (_1=="intpntTolDfeas"):
    _64=numpy.float64(_2)
    if ((0.000000e+00 <= _64) and (_64 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_DFEAS",_64)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolDfeas)")
   if (_1=="intpntTolMuRed"):
    _65=numpy.float64(_2)
    if ((0.000000e+00 <= _65) and (_65 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_MU_RED",_65)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolMuRed)")
   if (_1=="intpntTolInfeas"):
    _66=numpy.float64(_2)
    if ((0.000000e+00 <= _66) and (_66 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_INFEAS",_66)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolInfeas)")
   if (_1=="intpntCoTolRelGap"):
    _67=numpy.float64(_2)
    if ((0.000000e+00 <= _67) and (_67 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_REL_GAP",_67)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolRelGap)")
   if (_1=="intpntCoTolPfeas"):
    _68=numpy.float64(_2)
    if ((0.000000e+00 <= _68) and (_68 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_PFEAS",_68)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolPfeas)")
   if (_1=="intpntCoTolDfeas"):
    _69=numpy.float64(_2)
    if ((0.000000e+00 <= _69) and (_69 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_DFEAS",_69)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolDfeas)")
   if (_1=="intpntCoTolMuRed"):
    _70=numpy.float64(_2)
    if ((0.000000e+00 <= _70) and (_70 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_MU_RED",_70)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolMuRed)")
   if (_1=="intpntCoTolNearRel"):
    _71=numpy.float64(_2)
    if (1.000000e+00 <= _71):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_NEAR_REL",_71)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolNearRel)")
   if (_1=="intpntCoTolInfeas"):
    _72=numpy.float64(_2)
    if ((0.000000e+00 <= _72) and (_72 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_INFEAS",_72)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolInfeas)")
   if (_1=="intpntQoTolRelGap"):
    _73=numpy.float64(_2)
    if ((0.000000e+00 <= _73) and (_73 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_QO_TOL_REL_GAP",_73)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntQoTolRelGap)")
   if (_1=="intpntQoTolPfeas"):
    _74=numpy.float64(_2)
    if ((0.000000e+00 <= _74) and (_74 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_QO_TOL_PFEAS",_74)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntQoTolPfeas)")
   if (_1=="intpntQoTolDfeas"):
    _75=numpy.float64(_2)
    if ((0.000000e+00 <= _75) and (_75 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_QO_TOL_DFEAS",_75)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntQoTolDfeas)")
   if (_1=="intpntQoTolMuRed"):
    _76=numpy.float64(_2)
    if ((0.000000e+00 <= _76) and (_76 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_QO_TOL_MU_RED",_76)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntQoTolMuRed)")
   if (_1=="intpntQoTolNearRel"):
    _77=numpy.float64(_2)
    if (1.000000e+00 <= _77):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_QO_TOL_NEAR_REL",_77)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntQoTolNearRel)")
   if (_1=="intpntQoTolInfeas"):
    _78=numpy.float64(_2)
    if ((0.000000e+00 <= _78) and (_78 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_QO_TOL_INFEAS",_78)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntQoTolInfeas)")
   if (_1=="intpntTolPsafe"):
    _79=numpy.float64(_2)
    if (1.000000e-04 <= _79):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_PSAFE",_79)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPsafe)")
   if (_1=="intpntTolDsafe"):
    _80=numpy.float64(_2)
    if (1.000000e-04 <= _80):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_DSAFE",_80)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolDsafe)")
   if (_1=="mioMaxTime"):
    _81=numpy.float64(_2)
    if True:
     _0._task_1put_1param_SD("MSK_DPAR_MIO_MAX_TIME",_81)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxTime)")
   if (_1=="mioDisableTermTime"):
    _82=numpy.float64(_2)
    if True:
     _0._task_1put_1param_SD("MSK_DPAR_MIO_DISABLE_TERM_TIME",_82)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioDisableTermTime)")
   if (_1=="mioRelGapConst"):
    _83=numpy.float64(_2)
    if (1.000000e-15 <= _83):
     _0._task_1put_1param_SD("MSK_DPAR_MIO_REL_GAP_CONST",_83)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRelGapConst)")
   if (_1=="mioTolRelGap"):
    _84=numpy.float64(_2)
    if (0.000000e+00 <= _84):
     _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_REL_GAP",_84)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolRelGap)")
   if (_1=="mioNearTolRelGap"):
    _85=numpy.float64(_2)
    if (0.000000e+00 <= _85):
     _0._task_1put_1param_SD("MSK_DPAR_MIO_NEAR_TOL_REL_GAP",_85)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioNearTolRelGap)")
   if (_1=="mioTolAbsGap"):
    _86=numpy.float64(_2)
    if (0.000000e+00 <= _86):
     _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_ABS_GAP",_86)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolAbsGap)")
   if (_1=="mioNearTolAbsGap"):
    _87=numpy.float64(_2)
    if (0.000000e+00 <= _87):
     _0._task_1put_1param_SD("MSK_DPAR_MIO_NEAR_TOL_ABS_GAP",_87)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioNearTolAbsGap)")
   if (_1=="mioTolAbsRelaxInt"):
    _88=numpy.float64(_2)
    if (1.000000e-09 <= _88):
     _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_ABS_RELAX_INT",_88)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolAbsRelaxInt)")
   if (_1=="basisTolX"):
    _89=numpy.float64(_2)
    if (1.000000e-09 <= _89):
     _0._task_1put_1param_SD("MSK_DPAR_BASIS_TOL_X",_89)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisTolX)")
   if (_1=="basisTolS"):
    _90=numpy.float64(_2)
    if (1.000000e-09 <= _90):
     _0._task_1put_1param_SD("MSK_DPAR_BASIS_TOL_S",_90)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisTolS)")
   if (_1=="basisRelTolS"):
    _91=numpy.float64(_2)
    if (0.000000e+00 <= _91):
     _0._task_1put_1param_SD("MSK_DPAR_BASIS_REL_TOL_S",_91)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisRelTolS)")
   if (_1=="presolveTolX"):
    _92=numpy.float64(_2)
    if (0.000000e+00 <= _92):
     _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_X",_92)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolX)")
   if (_1=="presolveTolS"):
    _93=numpy.float64(_2)
    if (0.000000e+00 <= _93):
     _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_S",_93)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolS)")
   if (_1=="presolveTolAij"):
    _94=numpy.float64(_2)
    if (1.000000e-15 <= _94):
     _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_AIJ",_94)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolAij)")
   if (_1=="presolveTolAbsLindep"):
    _95=numpy.float64(_2)
    if (0.000000e+00 <= _95):
     _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_ABS_LINDEP",_95)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolAbsLindep)")
   if (_1=="presolveTolRelLindep"):
    _96=numpy.float64(_2)
    if (0.000000e+00 <= _96):
     _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_REL_LINDEP",_96)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolRelLindep)")
   if (_1=="simplexAbsTolPiv"):
    _97=numpy.float64(_2)
    if (1.000000e-12 <= _97):
     _0._task_1put_1param_SD("MSK_DPAR_SIMPLEX_ABS_TOL_PIV",_97)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simplexAbsTolPiv)")
   if (_1=="mioTolFeas"):
    _98=numpy.float64(_2)
    if ((1.000000e-09 <= _98) and (_98 <= 1.000000e-03)):
     _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_FEAS",_98)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolFeas)")
   if (_1=="anaSolInfeasTol"):
    _99=numpy.float64(_2)
    if (0.000000e+00 <= _99):
     _0._task_1put_1param_SD("MSK_DPAR_ANA_SOL_INFEAS_TOL",_99)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (anaSolInfeasTol)")
   if (_1=="mioTolRelDualBoundImprovement"):
    _100=numpy.float64(_2)
    if ((0.000000e+00 <= _100) and (_100 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_REL_DUAL_BOUND_IMPROVEMENT",_100)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolRelDualBoundImprovement)")
   raise mosek_fusion_ParameterError._ctor_S("Unknown parameter")
  @staticmethod
  def _match_setParameter_Lmosek_4fusion_4Model_2SS(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(_0) and __arg_match_S__(_1) and __arg_match_S__(_2))
  @staticmethod
  def _match_alt_setParameter_Lmosek_4fusion_4Model_2SS(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(_0) and __arg_alt_match_S__(_1) and __arg_alt_match_S__(_2))
  @staticmethod
  def _setParameter_alt_Lmosek_4fusion_4Model_2SS(_t__0,_t__1,_t__2):
    return mosek_fusion_Parameters._setParameter_Lmosek_4fusion_4Model_2SS(_0,_1,_2)
  @staticmethod
  def _setParameter_Lmosek_4fusion_4Model_2SS(_0,_1,_2):
   if False:
    pass
   if (_1=="autoUpdateSolInfo"):
    _3=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_3 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (autoUpdateSolInfo)")
    _0._task_1put_1param_SI("MSK_IPAR_AUTO_UPDATE_SOL_INFO",_3)
    return 
   if (_1=="removeUnusedSolutions"):
    _4=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_4 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (removeUnusedSolutions)")
    _0._task_1put_1param_SI("MSK_IPAR_REMOVE_UNUSED_SOLUTIONS",_4)
    return 
   if (_1=="numThreads"):
    try:
     _5=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _5):
      _0._task_1put_1param_SI("MSK_IPAR_NUM_THREADS",_5)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (numThreads)")
    except mosek_fusion_ValueConversionError, _6:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (numThreads)")
   if (_1=="intpntMultiThread"):
    _7=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_7 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMultiThread)")
    _0._task_1put_1param_SI("MSK_IPAR_INTPNT_MULTI_THREAD",_7)
    return 
   if (_1=="mtSpincount"):
    try:
     _8=mosek.fusion.Utils.Tools._toInt_S(_2)
     if ((0 <= _8) and (_8 <= 1000000000)):
      _0._task_1put_1param_SI("MSK_IPAR_MT_SPINCOUNT",_8)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mtSpincount)")
    except mosek_fusion_ValueConversionError, _9:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mtSpincount)")
   if (_1=="optimizer"):
    _10=mosek.fusion.Parameters.__string_1to_1optimizertype_1value_S(_2)
    if (_10 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (optimizer)")
    _0._task_1put_1param_SI("MSK_IPAR_OPTIMIZER",_10)
    return 
   if (_1=="biMaxIterations"):
    try:
     _11=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _11):
      _0._task_1put_1param_SI("MSK_IPAR_BI_MAX_ITERATIONS",_11)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biMaxIterations)")
    except mosek_fusion_ValueConversionError, _12:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biMaxIterations)")
   if (_1=="licenseTrhExpiryWrn"):
    try:
     _13=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _13):
      _0._task_1put_1param_SI("MSK_IPAR_LICENSE_TRH_EXPIRY_WRN",_13)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseTrhExpiryWrn)")
    except mosek_fusion_ValueConversionError, _14:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseTrhExpiryWrn)")
   if (_1=="logCutSecondOpt"):
    try:
     _15=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _15):
      _0._task_1put_1param_SI("MSK_IPAR_LOG_CUT_SECOND_OPT",_15)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logCutSecondOpt)")
    except mosek_fusion_ValueConversionError, _16:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logCutSecondOpt)")
   if (_1=="logAnaPro"):
    try:
     _17=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _17):
      _0._task_1put_1param_SI("MSK_IPAR_LOG_ANA_PRO",_17)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logAnaPro)")
    except mosek_fusion_ValueConversionError, _18:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logAnaPro)")
   if (_1=="logResponse"):
    try:
     _19=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _19):
      _0._task_1put_1param_SI("MSK_IPAR_LOG_RESPONSE",_19)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logResponse)")
    except mosek_fusion_ValueConversionError, _20:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logResponse)")
   if (_1=="logBi"):
    try:
     _21=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _21):
      _0._task_1put_1param_SI("MSK_IPAR_LOG_BI",_21)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logBi)")
    except mosek_fusion_ValueConversionError, _22:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logBi)")
   if (_1=="logBiFreq"):
    try:
     _23=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _23):
      _0._task_1put_1param_SI("MSK_IPAR_LOG_BI_FREQ",_23)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logBiFreq)")
    except mosek_fusion_ValueConversionError, _24:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logBiFreq)")
   if (_1=="biCleanOptimizer"):
    _25=mosek.fusion.Parameters.__string_1to_1optimizertype_1value_S(_2)
    if (_25 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biCleanOptimizer)")
    _0._task_1put_1param_SI("MSK_IPAR_BI_CLEAN_OPTIMIZER",_25)
    return 
   if (_1=="intpntStartingPoint"):
    _26=mosek.fusion.Parameters.__string_1to_1startpointtype_1value_S(_2)
    if (_26 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntStartingPoint)")
    _0._task_1put_1param_SI("MSK_IPAR_INTPNT_STARTING_POINT",_26)
    return 
   if (_1=="intpntDiffStep"):
    _27=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_27 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntDiffStep)")
    _0._task_1put_1param_SI("MSK_IPAR_INTPNT_DIFF_STEP",_27)
    return 
   if (_1=="intpntScaling"):
    _28=mosek.fusion.Parameters.__string_1to_1scalingtype_1value_S(_2)
    if (_28 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntScaling)")
    _0._task_1put_1param_SI("MSK_IPAR_INTPNT_SCALING",_28)
    return 
   if (_1=="intpntSolveForm"):
    _29=mosek.fusion.Parameters.__string_1to_1solveform_1value_S(_2)
    if (_29 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntSolveForm)")
    _0._task_1put_1param_SI("MSK_IPAR_INTPNT_SOLVE_FORM",_29)
    return 
   if (_1=="logIntpnt"):
    try:
     _30=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _30):
      _0._task_1put_1param_SI("MSK_IPAR_LOG_INTPNT",_30)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logIntpnt)")
    except mosek_fusion_ValueConversionError, _31:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logIntpnt)")
   if (_1=="intpntMaxIterations"):
    try:
     _32=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _32):
      _0._task_1put_1param_SI("MSK_IPAR_INTPNT_MAX_ITERATIONS",_32)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMaxIterations)")
    except mosek_fusion_ValueConversionError, _33:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMaxIterations)")
   if (_1=="intpntOffColTrh"):
    try:
     _34=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _34):
      _0._task_1put_1param_SI("MSK_IPAR_INTPNT_OFF_COL_TRH",_34)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOffColTrh)")
    except mosek_fusion_ValueConversionError, _35:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOffColTrh)")
   if (_1=="intpntOrderMethod"):
    _36=mosek.fusion.Parameters.__string_1to_1orderingtype_1value_S(_2)
    if (_36 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOrderMethod)")
    _0._task_1put_1param_SI("MSK_IPAR_INTPNT_ORDER_METHOD",_36)
    return 
   if (_1=="intpntBasis"):
    _37=mosek.fusion.Parameters.__string_1to_1basindtype_1value_S(_2)
    if (_37 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntBasis)")
    _0._task_1put_1param_SI("MSK_IPAR_INTPNT_BASIS",_37)
    return 
   if (_1=="biIgnoreMaxIter"):
    _38=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_38 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biIgnoreMaxIter)")
    _0._task_1put_1param_SI("MSK_IPAR_BI_IGNORE_MAX_ITER",_38)
    return 
   if (_1=="biIgnoreNumError"):
    _39=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_39 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biIgnoreNumError)")
    _0._task_1put_1param_SI("MSK_IPAR_BI_IGNORE_NUM_ERROR",_39)
    return 
   if (_1=="intpntMaxNumCor"):
    try:
     _40=mosek.fusion.Utils.Tools._toInt_S(_2)
     if ((- 1) <= _40):
      _0._task_1put_1param_SI("MSK_IPAR_INTPNT_MAX_NUM_COR",_40)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMaxNumCor)")
    except mosek_fusion_ValueConversionError, _41:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMaxNumCor)")
   if (_1=="presolveUse"):
    _42=mosek.fusion.Parameters.__string_1to_1presolvemode_1value_S(_2)
    if (_42 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveUse)")
    _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_USE",_42)
    return 
   if (_1=="presolveLevel"):
    try:
     _43=mosek.fusion.Utils.Tools._toInt_S(_2)
     if True:
      _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_LEVEL",_43)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLevel)")
    except mosek_fusion_ValueConversionError, _44:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLevel)")
   if (_1=="logPresolve"):
    try:
     _45=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _45):
      _0._task_1put_1param_SI("MSK_IPAR_LOG_PRESOLVE",_45)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logPresolve)")
    except mosek_fusion_ValueConversionError, _46:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logPresolve)")
   if (_1=="presolveLindepUse"):
    _47=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_47 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepUse)")
    _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_LINDEP_USE",_47)
    return 
   if (_1=="presolveEliminatorMaxNumTries"):
    try:
     _48=mosek.fusion.Utils.Tools._toInt_S(_2)
     if True:
      _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_ELIMINATOR_MAX_NUM_TRIES",_48)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveEliminatorMaxNumTries)")
    except mosek_fusion_ValueConversionError, _49:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveEliminatorMaxNumTries)")
   if (_1=="presolveEliminatorMaxFill"):
    try:
     _50=mosek.fusion.Utils.Tools._toInt_S(_2)
     if True:
      _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_ELIMINATOR_MAX_FILL",_50)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveEliminatorMaxFill)")
    except mosek_fusion_ValueConversionError, _51:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveEliminatorMaxFill)")
   if (_1=="simPrimalCrash"):
    try:
     _52=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _52):
      _0._task_1put_1param_SI("MSK_IPAR_SIM_PRIMAL_CRASH",_52)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalCrash)")
    except mosek_fusion_ValueConversionError, _53:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalCrash)")
   if (_1=="logSim"):
    try:
     _54=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _54):
      _0._task_1put_1param_SI("MSK_IPAR_LOG_SIM",_54)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSim)")
    except mosek_fusion_ValueConversionError, _55:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSim)")
   if (_1=="logSimMinor"):
    try:
     _56=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _56):
      _0._task_1put_1param_SI("MSK_IPAR_LOG_SIM_MINOR",_56)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSimMinor)")
    except mosek_fusion_ValueConversionError, _57:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSimMinor)")
   if (_1=="logSimFreq"):
    try:
     _58=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _58):
      _0._task_1put_1param_SI("MSK_IPAR_LOG_SIM_FREQ",_58)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSimFreq)")
    except mosek_fusion_ValueConversionError, _59:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSimFreq)")
   if (_1=="simPrimalRestrictSelection"):
    try:
     _60=mosek.fusion.Utils.Tools._toInt_S(_2)
     if ((0 <= _60) and (_60 <= 100)):
      _0._task_1put_1param_SI("MSK_IPAR_SIM_PRIMAL_RESTRICT_SELECTION",_60)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalRestrictSelection)")
    except mosek_fusion_ValueConversionError, _61:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalRestrictSelection)")
   if (_1=="simPrimalSelection"):
    _62=mosek.fusion.Parameters.__string_1to_1simseltype_1value_S(_2)
    if (_62 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalSelection)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_PRIMAL_SELECTION",_62)
    return 
   if (_1=="simDualRestrictSelection"):
    try:
     _63=mosek.fusion.Utils.Tools._toInt_S(_2)
     if ((0 <= _63) and (_63 <= 100)):
      _0._task_1put_1param_SI("MSK_IPAR_SIM_DUAL_RESTRICT_SELECTION",_63)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualRestrictSelection)")
    except mosek_fusion_ValueConversionError, _64:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualRestrictSelection)")
   if (_1=="simDualSelection"):
    _65=mosek.fusion.Parameters.__string_1to_1simseltype_1value_S(_2)
    if (_65 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualSelection)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_DUAL_SELECTION",_65)
    return 
   if (_1=="simMaxIterations"):
    try:
     _66=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _66):
      _0._task_1put_1param_SI("MSK_IPAR_SIM_MAX_ITERATIONS",_66)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simMaxIterations)")
    except mosek_fusion_ValueConversionError, _67:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simMaxIterations)")
   if (_1=="simHotstartLu"):
    _68=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_68 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simHotstartLu)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_HOTSTART_LU",_68)
    return 
   if (_1=="simRefactorFreq"):
    try:
     _69=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _69):
      _0._task_1put_1param_SI("MSK_IPAR_SIM_REFACTOR_FREQ",_69)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simRefactorFreq)")
    except mosek_fusion_ValueConversionError, _70:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simRefactorFreq)")
   if (_1=="mioMode"):
    _71=mosek.fusion.Parameters.__string_1to_1miomode_1value_S(_2)
    if (_71 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMode)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_MODE",_71)
    return 
   if (_1=="logMio"):
    try:
     _72=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _72):
      _0._task_1put_1param_SI("MSK_IPAR_LOG_MIO",_72)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logMio)")
    except mosek_fusion_ValueConversionError, _73:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logMio)")
   if (_1=="logMioFreq"):
    try:
     _74=mosek.fusion.Utils.Tools._toInt_S(_2)
     if True:
      _0._task_1put_1param_SI("MSK_IPAR_LOG_MIO_FREQ",_74)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logMioFreq)")
    except mosek_fusion_ValueConversionError, _75:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logMioFreq)")
   if (_1=="mioMaxNumRelaxs"):
    try:
     _76=mosek.fusion.Utils.Tools._toInt_S(_2)
     if True:
      _0._task_1put_1param_SI("MSK_IPAR_MIO_MAX_NUM_RELAXS",_76)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumRelaxs)")
    except mosek_fusion_ValueConversionError, _77:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumRelaxs)")
   if (_1=="mioMaxNumBranches"):
    try:
     _78=mosek.fusion.Utils.Tools._toInt_S(_2)
     if True:
      _0._task_1put_1param_SI("MSK_IPAR_MIO_MAX_NUM_BRANCHES",_78)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumBranches)")
    except mosek_fusion_ValueConversionError, _79:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumBranches)")
   if (_1=="mioMaxNumSolutions"):
    try:
     _80=mosek.fusion.Utils.Tools._toInt_S(_2)
     if True:
      _0._task_1put_1param_SI("MSK_IPAR_MIO_MAX_NUM_SOLUTIONS",_80)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumSolutions)")
    except mosek_fusion_ValueConversionError, _81:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumSolutions)")
   if (_1=="mioNodeSelection"):
    _82=mosek.fusion.Parameters.__string_1to_1mionodeseltype_1value_S(_2)
    if (_82 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioNodeSelection)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_NODE_SELECTION",_82)
    return 
   if (_1=="mioHeuristicLevel"):
    try:
     _83=mosek.fusion.Utils.Tools._toInt_S(_2)
     if True:
      _0._task_1put_1param_SI("MSK_IPAR_MIO_HEURISTIC_LEVEL",_83)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioHeuristicLevel)")
    except mosek_fusion_ValueConversionError, _84:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioHeuristicLevel)")
   if (_1=="mioProbingLevel"):
    try:
     _85=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (((- 1) <= _85) and (_85 <= 3)):
      _0._task_1put_1param_SI("MSK_IPAR_MIO_PROBING_LEVEL",_85)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioProbingLevel)")
    except mosek_fusion_ValueConversionError, _86:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioProbingLevel)")
   if (_1=="mioCutSelectionLevel"):
    try:
     _87=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (((- 1) <= _87) and (_87 <= 1)):
      _0._task_1put_1param_SI("MSK_IPAR_MIO_CUT_SELECTION_LEVEL",_87)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutSelectionLevel)")
    except mosek_fusion_ValueConversionError, _88:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutSelectionLevel)")
   if (_1=="mioVbDetectionLevel"):
    try:
     _89=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (((- 1) <= _89) and (_89 <= 2)):
      _0._task_1put_1param_SI("MSK_IPAR_MIO_VB_DETECTION_LEVEL",_89)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioVbDetectionLevel)")
    except mosek_fusion_ValueConversionError, _90:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioVbDetectionLevel)")
   if (_1=="mioBranchDir"):
    _91=mosek.fusion.Parameters.__string_1to_1branchdir_1value_S(_2)
    if (_91 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioBranchDir)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_BRANCH_DIR",_91)
    return 
   if (_1=="mioRootOptimizer"):
    _92=mosek.fusion.Parameters.__string_1to_1optimizertype_1value_S(_2)
    if (_92 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRootOptimizer)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_ROOT_OPTIMIZER",_92)
    return 
   if (_1=="mioNodeOptimizer"):
    _93=mosek.fusion.Parameters.__string_1to_1optimizertype_1value_S(_2)
    if (_93 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioNodeOptimizer)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_NODE_OPTIMIZER",_93)
    return 
   if (_1=="mioPerspectiveReformulate"):
    _94=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_94 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioPerspectiveReformulate)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_PERSPECTIVE_REFORMULATE",_94)
    return 
   if (_1=="writeLpQuotedNames"):
    _95=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_95 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpQuotedNames)")
    _0._task_1put_1param_SI("MSK_IPAR_WRITE_LP_QUOTED_NAMES",_95)
    return 
   if (_1=="writeLpLineWidth"):
    try:
     _96=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (40 <= _96):
      _0._task_1put_1param_SI("MSK_IPAR_WRITE_LP_LINE_WIDTH",_96)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpLineWidth)")
    except mosek_fusion_ValueConversionError, _97:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpLineWidth)")
   if (_1=="writeLpTermsPerLine"):
    try:
     _98=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _98):
      _0._task_1put_1param_SI("MSK_IPAR_WRITE_LP_TERMS_PER_LINE",_98)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpTermsPerLine)")
    except mosek_fusion_ValueConversionError, _99:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpTermsPerLine)")
   if (_1=="writeLpFullObj"):
    _100=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_100 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpFullObj)")
    _0._task_1put_1param_SI("MSK_IPAR_WRITE_LP_FULL_OBJ",_100)
    return 
   if (_1=="logInfeasAna"):
    try:
     _101=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _101):
      _0._task_1put_1param_SI("MSK_IPAR_LOG_INFEAS_ANA",_101)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logInfeasAna)")
    except mosek_fusion_ValueConversionError, _102:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logInfeasAna)")
   if (_1=="licenseWait"):
    _103=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_103 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseWait)")
    _0._task_1put_1param_SI("MSK_IPAR_LICENSE_WAIT",_103)
    return 
   if (_1=="licenseSuppressExpireWrns"):
    _104=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_104 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseSuppressExpireWrns)")
    _0._task_1put_1param_SI("MSK_IPAR_LICENSE_SUPPRESS_EXPIRE_WRNS",_104)
    return 
   if (_1=="licensePauseTime"):
    try:
     _105=mosek.fusion.Utils.Tools._toInt_S(_2)
     if ((0 <= _105) and (_105 <= 1000000)):
      _0._task_1put_1param_SI("MSK_IPAR_LICENSE_PAUSE_TIME",_105)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licensePauseTime)")
    except mosek_fusion_ValueConversionError, _106:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licensePauseTime)")
   if (_1=="licenseDebug"):
    _107=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_107 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseDebug)")
    _0._task_1put_1param_SI("MSK_IPAR_LICENSE_DEBUG",_107)
    return 
   if (_1=="log"):
    try:
     _108=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _108):
      _0._task_1put_1param_SI("MSK_IPAR_LOG",_108)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (log)")
    except mosek_fusion_ValueConversionError, _109:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (log)")
   if (_1=="logExpand"):
    try:
     _110=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _110):
      _0._task_1put_1param_SI("MSK_IPAR_LOG_EXPAND",_110)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logExpand)")
    except mosek_fusion_ValueConversionError, _111:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logExpand)")
   if (_1=="logFile"):
    try:
     _112=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _112):
      _0._task_1put_1param_SI("MSK_IPAR_LOG_FILE",_112)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logFile)")
    except mosek_fusion_ValueConversionError, _113:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logFile)")
   if (_1=="logOrder"):
    try:
     _114=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _114):
      _0._task_1put_1param_SI("MSK_IPAR_LOG_ORDER",_114)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logOrder)")
    except mosek_fusion_ValueConversionError, _115:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logOrder)")
   if (_1=="simScaling"):
    _116=mosek.fusion.Parameters.__string_1to_1scalingtype_1value_S(_2)
    if (_116 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simScaling)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_SCALING",_116)
    return 
   if (_1=="simScalingMethod"):
    _117=mosek.fusion.Parameters.__string_1to_1scalingmethod_1value_S(_2)
    if (_117 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simScalingMethod)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_SCALING_METHOD",_117)
    return 
   if (_1=="simPrimalPhaseoneMethod"):
    try:
     _118=mosek.fusion.Utils.Tools._toInt_S(_2)
     if ((0 <= _118) and (_118 <= 10)):
      _0._task_1put_1param_SI("MSK_IPAR_SIM_PRIMAL_PHASEONE_METHOD",_118)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalPhaseoneMethod)")
    except mosek_fusion_ValueConversionError, _119:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalPhaseoneMethod)")
   if (_1=="simDualPhaseoneMethod"):
    try:
     _120=mosek.fusion.Utils.Tools._toInt_S(_2)
     if ((0 <= _120) and (_120 <= 10)):
      _0._task_1put_1param_SI("MSK_IPAR_SIM_DUAL_PHASEONE_METHOD",_120)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualPhaseoneMethod)")
    except mosek_fusion_ValueConversionError, _121:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualPhaseoneMethod)")
   if (_1=="simMaxNumSetbacks"):
    try:
     _122=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _122):
      _0._task_1put_1param_SI("MSK_IPAR_SIM_MAX_NUM_SETBACKS",_122)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simMaxNumSetbacks)")
    except mosek_fusion_ValueConversionError, _123:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simMaxNumSetbacks)")
   if (_1=="simHotstart"):
    _124=mosek.fusion.Parameters.__string_1to_1simhotstart_1value_S(_2)
    if (_124 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simHotstart)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_HOTSTART",_124)
    return 
   if (_1=="simBasisFactorUse"):
    _125=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_125 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simBasisFactorUse)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_BASIS_FACTOR_USE",_125)
    return 
   if (_1=="simDegen"):
    _126=mosek.fusion.Parameters.__string_1to_1simdegen_1value_S(_2)
    if (_126 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDegen)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_DEGEN",_126)
    return 
   if (_1=="simReformulation"):
    _127=mosek.fusion.Parameters.__string_1to_1simreform_1value_S(_2)
    if (_127 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simReformulation)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_REFORMULATION",_127)
    return 
   if (_1=="simExploitDupvec"):
    _128=mosek.fusion.Parameters.__string_1to_1simdupvec_1value_S(_2)
    if (_128 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simExploitDupvec)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_EXPLOIT_DUPVEC",_128)
    return 
   if (_1=="simSaveLu"):
    _129=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_129 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSaveLu)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_SAVE_LU",_129)
    return 
   if (_1=="simNonSingular"):
    _130=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_130 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simNonSingular)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_NON_SINGULAR",_130)
    return 
   if (_1=="simDualCrash"):
    try:
     _131=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _131):
      _0._task_1put_1param_SI("MSK_IPAR_SIM_DUAL_CRASH",_131)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualCrash)")
    except mosek_fusion_ValueConversionError, _132:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualCrash)")
   if (_1=="infeasPreferPrimal"):
    _133=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_133 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (infeasPreferPrimal)")
    _0._task_1put_1param_SI("MSK_IPAR_INFEAS_PREFER_PRIMAL",_133)
    return 
   if (_1=="mioRootRepeatPresolveLevel"):
    try:
     _134=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (((- 1) <= _134) and (_134 <= 1)):
      _0._task_1put_1param_SI("MSK_IPAR_MIO_ROOT_REPEAT_PRESOLVE_LEVEL",_134)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRootRepeatPresolveLevel)")
    except mosek_fusion_ValueConversionError, _135:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRootRepeatPresolveLevel)")
   if (_1=="mioCutCmir"):
    _136=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_136 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutCmir)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_CUT_CMIR",_136)
    return 
   if (_1=="mioCutClique"):
    _137=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_137 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutClique)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_CUT_CLIQUE",_137)
    return 
   if (_1=="mioCutImpliedBound"):
    _138=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_138 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutImpliedBound)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_CUT_IMPLIED_BOUND",_138)
    return 
   if (_1=="mioCutKnapsackCover"):
    _139=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_139 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutKnapsackCover)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_CUT_KNAPSACK_COVER",_139)
    return 
   if (_1=="mioCutGmi"):
    _140=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_140 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutGmi)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_CUT_GMI",_140)
    return 
   if (_1=="mioConstructSol"):
    _141=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_141 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioConstructSol)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_CONSTRUCT_SOL",_141)
    return 
   if (_1=="presolveLindepRelWorkTrh"):
    try:
     _142=mosek.fusion.Utils.Tools._toInt_S(_2)
     if True:
      _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_LINDEP_REL_WORK_TRH",_142)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepRelWorkTrh)")
    except mosek_fusion_ValueConversionError, _143:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepRelWorkTrh)")
   if (_1=="presolveLindepAbsWorkTrh"):
    try:
     _144=mosek.fusion.Utils.Tools._toInt_S(_2)
     if True:
      _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_LINDEP_ABS_WORK_TRH",_144)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepAbsWorkTrh)")
    except mosek_fusion_ValueConversionError, _145:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepAbsWorkTrh)")
   if (_1=="cacheLicense"):
    _146=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_146 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (cacheLicense)")
    _0._task_1put_1param_SI("MSK_IPAR_CACHE_LICENSE",_146)
    return 
   if (_1=="intpntRegularizationUse"):
    _147=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_147 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntRegularizationUse)")
    _0._task_1put_1param_SI("MSK_IPAR_INTPNT_REGULARIZATION_USE",_147)
    return 
   if (_1=="simSolveForm"):
    _148=mosek.fusion.Parameters.__string_1to_1solveform_1value_S(_2)
    if (_148 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSolveForm)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_SOLVE_FORM",_148)
    return 
   if (_1=="simSwitchOptimizer"):
    _149=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_149 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSwitchOptimizer)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_SWITCH_OPTIMIZER",_149)
    return 
   if (_1=="mioRinsMaxNodes"):
    try:
     _150=mosek.fusion.Utils.Tools._toInt_S(_2)
     if ((- 1) <= _150):
      _0._task_1put_1param_SI("MSK_IPAR_MIO_RINS_MAX_NODES",_150)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRinsMaxNodes)")
    except mosek_fusion_ValueConversionError, _151:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRinsMaxNodes)")
   if (_1=="optimizerMaxTime"):
    try:
     _152=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if True:
      _0._task_1put_1param_SD("MSK_DPAR_OPTIMIZER_MAX_TIME",_152)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (optimizerMaxTime)")
    except mosek_fusion_ValueConversionError, _153:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (optimizerMaxTime)")
   if (_1=="lowerObjCut"):
    try:
     _154=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if True:
      _0._task_1put_1param_SD("MSK_DPAR_LOWER_OBJ_CUT",_154)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (lowerObjCut)")
    except mosek_fusion_ValueConversionError, _155:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (lowerObjCut)")
   if (_1=="upperObjCut"):
    try:
     _156=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if True:
      _0._task_1put_1param_SD("MSK_DPAR_UPPER_OBJ_CUT",_156)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (upperObjCut)")
    except mosek_fusion_ValueConversionError, _157:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (upperObjCut)")
   if (_1=="upperObjCutFiniteTrh"):
    try:
     _158=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if True:
      _0._task_1put_1param_SD("MSK_DPAR_UPPER_OBJ_CUT_FINITE_TRH",_158)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (upperObjCutFiniteTrh)")
    except mosek_fusion_ValueConversionError, _159:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (upperObjCutFiniteTrh)")
   if (_1=="lowerObjCutFiniteTrh"):
    try:
     _160=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if True:
      _0._task_1put_1param_SD("MSK_DPAR_LOWER_OBJ_CUT_FINITE_TRH",_160)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (lowerObjCutFiniteTrh)")
    except mosek_fusion_ValueConversionError, _161:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (lowerObjCutFiniteTrh)")
   if (_1=="intpntTolRelGap"):
    try:
     _162=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (1.000000e-14 <= _162):
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_REL_GAP",_162)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolRelGap)")
    except mosek_fusion_ValueConversionError, _163:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolRelGap)")
   if (_1=="intpntTolStepSize"):
    try:
     _164=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _164) and (_164 <= 1.000000e+00)):
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_STEP_SIZE",_164)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolStepSize)")
    except mosek_fusion_ValueConversionError, _165:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolStepSize)")
   if (_1=="simLuTolRelPiv"):
    try:
     _166=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((1.000000e-06 <= _166) and (_166 <= 9.999990e-01)):
      _0._task_1put_1param_SD("MSK_DPAR_SIM_LU_TOL_REL_PIV",_166)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simLuTolRelPiv)")
    except mosek_fusion_ValueConversionError, _167:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simLuTolRelPiv)")
   if (_1=="intpntTolRelStep"):
    try:
     _168=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((1.000000e-04 <= _168) and (_168 <= 9.999990e-01)):
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_REL_STEP",_168)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolRelStep)")
    except mosek_fusion_ValueConversionError, _169:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolRelStep)")
   if (_1=="intpntTolPath"):
    try:
     _170=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _170) and (_170 <= 9.999000e-01)):
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_PATH",_170)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPath)")
    except mosek_fusion_ValueConversionError, _171:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPath)")
   if (_1=="intpntTolPfeas"):
    try:
     _172=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _172) and (_172 <= 1.000000e+00)):
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_PFEAS",_172)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPfeas)")
    except mosek_fusion_ValueConversionError, _173:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPfeas)")
   if (_1=="intpntTolDfeas"):
    try:
     _174=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _174) and (_174 <= 1.000000e+00)):
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_DFEAS",_174)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolDfeas)")
    except mosek_fusion_ValueConversionError, _175:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolDfeas)")
   if (_1=="intpntTolMuRed"):
    try:
     _176=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _176) and (_176 <= 1.000000e+00)):
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_MU_RED",_176)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolMuRed)")
    except mosek_fusion_ValueConversionError, _177:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolMuRed)")
   if (_1=="intpntTolInfeas"):
    try:
     _178=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _178) and (_178 <= 1.000000e+00)):
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_INFEAS",_178)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolInfeas)")
    except mosek_fusion_ValueConversionError, _179:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolInfeas)")
   if (_1=="intpntCoTolRelGap"):
    try:
     _180=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _180) and (_180 <= 1.000000e+00)):
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_REL_GAP",_180)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolRelGap)")
    except mosek_fusion_ValueConversionError, _181:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolRelGap)")
   if (_1=="intpntCoTolPfeas"):
    try:
     _182=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _182) and (_182 <= 1.000000e+00)):
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_PFEAS",_182)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolPfeas)")
    except mosek_fusion_ValueConversionError, _183:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolPfeas)")
   if (_1=="intpntCoTolDfeas"):
    try:
     _184=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _184) and (_184 <= 1.000000e+00)):
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_DFEAS",_184)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolDfeas)")
    except mosek_fusion_ValueConversionError, _185:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolDfeas)")
   if (_1=="intpntCoTolMuRed"):
    try:
     _186=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _186) and (_186 <= 1.000000e+00)):
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_MU_RED",_186)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolMuRed)")
    except mosek_fusion_ValueConversionError, _187:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolMuRed)")
   if (_1=="intpntCoTolNearRel"):
    try:
     _188=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (1.000000e+00 <= _188):
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_NEAR_REL",_188)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolNearRel)")
    except mosek_fusion_ValueConversionError, _189:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolNearRel)")
   if (_1=="intpntCoTolInfeas"):
    try:
     _190=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _190) and (_190 <= 1.000000e+00)):
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_INFEAS",_190)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolInfeas)")
    except mosek_fusion_ValueConversionError, _191:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolInfeas)")
   if (_1=="intpntQoTolRelGap"):
    try:
     _192=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _192) and (_192 <= 1.000000e+00)):
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_QO_TOL_REL_GAP",_192)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntQoTolRelGap)")
    except mosek_fusion_ValueConversionError, _193:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntQoTolRelGap)")
   if (_1=="intpntQoTolPfeas"):
    try:
     _194=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _194) and (_194 <= 1.000000e+00)):
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_QO_TOL_PFEAS",_194)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntQoTolPfeas)")
    except mosek_fusion_ValueConversionError, _195:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntQoTolPfeas)")
   if (_1=="intpntQoTolDfeas"):
    try:
     _196=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _196) and (_196 <= 1.000000e+00)):
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_QO_TOL_DFEAS",_196)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntQoTolDfeas)")
    except mosek_fusion_ValueConversionError, _197:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntQoTolDfeas)")
   if (_1=="intpntQoTolMuRed"):
    try:
     _198=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _198) and (_198 <= 1.000000e+00)):
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_QO_TOL_MU_RED",_198)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntQoTolMuRed)")
    except mosek_fusion_ValueConversionError, _199:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntQoTolMuRed)")
   if (_1=="intpntQoTolNearRel"):
    try:
     _200=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (1.000000e+00 <= _200):
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_QO_TOL_NEAR_REL",_200)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntQoTolNearRel)")
    except mosek_fusion_ValueConversionError, _201:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntQoTolNearRel)")
   if (_1=="intpntQoTolInfeas"):
    try:
     _202=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _202) and (_202 <= 1.000000e+00)):
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_QO_TOL_INFEAS",_202)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntQoTolInfeas)")
    except mosek_fusion_ValueConversionError, _203:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntQoTolInfeas)")
   if (_1=="intpntTolPsafe"):
    try:
     _204=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (1.000000e-04 <= _204):
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_PSAFE",_204)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPsafe)")
    except mosek_fusion_ValueConversionError, _205:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPsafe)")
   if (_1=="intpntTolDsafe"):
    try:
     _206=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (1.000000e-04 <= _206):
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_DSAFE",_206)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolDsafe)")
    except mosek_fusion_ValueConversionError, _207:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolDsafe)")
   if (_1=="mioMaxTime"):
    try:
     _208=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if True:
      _0._task_1put_1param_SD("MSK_DPAR_MIO_MAX_TIME",_208)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxTime)")
    except mosek_fusion_ValueConversionError, _209:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxTime)")
   if (_1=="mioDisableTermTime"):
    try:
     _210=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if True:
      _0._task_1put_1param_SD("MSK_DPAR_MIO_DISABLE_TERM_TIME",_210)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioDisableTermTime)")
    except mosek_fusion_ValueConversionError, _211:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioDisableTermTime)")
   if (_1=="mioRelGapConst"):
    try:
     _212=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (1.000000e-15 <= _212):
      _0._task_1put_1param_SD("MSK_DPAR_MIO_REL_GAP_CONST",_212)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRelGapConst)")
    except mosek_fusion_ValueConversionError, _213:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRelGapConst)")
   if (_1=="mioTolRelGap"):
    try:
     _214=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (0.000000e+00 <= _214):
      _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_REL_GAP",_214)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolRelGap)")
    except mosek_fusion_ValueConversionError, _215:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolRelGap)")
   if (_1=="mioNearTolRelGap"):
    try:
     _216=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (0.000000e+00 <= _216):
      _0._task_1put_1param_SD("MSK_DPAR_MIO_NEAR_TOL_REL_GAP",_216)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioNearTolRelGap)")
    except mosek_fusion_ValueConversionError, _217:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioNearTolRelGap)")
   if (_1=="mioTolAbsGap"):
    try:
     _218=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (0.000000e+00 <= _218):
      _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_ABS_GAP",_218)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolAbsGap)")
    except mosek_fusion_ValueConversionError, _219:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolAbsGap)")
   if (_1=="mioNearTolAbsGap"):
    try:
     _220=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (0.000000e+00 <= _220):
      _0._task_1put_1param_SD("MSK_DPAR_MIO_NEAR_TOL_ABS_GAP",_220)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioNearTolAbsGap)")
    except mosek_fusion_ValueConversionError, _221:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioNearTolAbsGap)")
   if (_1=="mioTolAbsRelaxInt"):
    try:
     _222=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (1.000000e-09 <= _222):
      _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_ABS_RELAX_INT",_222)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolAbsRelaxInt)")
    except mosek_fusion_ValueConversionError, _223:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolAbsRelaxInt)")
   if (_1=="basisTolX"):
    try:
     _224=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (1.000000e-09 <= _224):
      _0._task_1put_1param_SD("MSK_DPAR_BASIS_TOL_X",_224)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisTolX)")
    except mosek_fusion_ValueConversionError, _225:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisTolX)")
   if (_1=="basisTolS"):
    try:
     _226=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (1.000000e-09 <= _226):
      _0._task_1put_1param_SD("MSK_DPAR_BASIS_TOL_S",_226)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisTolS)")
    except mosek_fusion_ValueConversionError, _227:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisTolS)")
   if (_1=="basisRelTolS"):
    try:
     _228=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (0.000000e+00 <= _228):
      _0._task_1put_1param_SD("MSK_DPAR_BASIS_REL_TOL_S",_228)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisRelTolS)")
    except mosek_fusion_ValueConversionError, _229:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisRelTolS)")
   if (_1=="presolveTolX"):
    try:
     _230=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (0.000000e+00 <= _230):
      _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_X",_230)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolX)")
    except mosek_fusion_ValueConversionError, _231:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolX)")
   if (_1=="presolveTolS"):
    try:
     _232=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (0.000000e+00 <= _232):
      _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_S",_232)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolS)")
    except mosek_fusion_ValueConversionError, _233:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolS)")
   if (_1=="presolveTolAij"):
    try:
     _234=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (1.000000e-15 <= _234):
      _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_AIJ",_234)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolAij)")
    except mosek_fusion_ValueConversionError, _235:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolAij)")
   if (_1=="presolveTolAbsLindep"):
    try:
     _236=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (0.000000e+00 <= _236):
      _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_ABS_LINDEP",_236)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolAbsLindep)")
    except mosek_fusion_ValueConversionError, _237:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolAbsLindep)")
   if (_1=="presolveTolRelLindep"):
    try:
     _238=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (0.000000e+00 <= _238):
      _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_REL_LINDEP",_238)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolRelLindep)")
    except mosek_fusion_ValueConversionError, _239:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolRelLindep)")
   if (_1=="simplexAbsTolPiv"):
    try:
     _240=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (1.000000e-12 <= _240):
      _0._task_1put_1param_SD("MSK_DPAR_SIMPLEX_ABS_TOL_PIV",_240)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simplexAbsTolPiv)")
    except mosek_fusion_ValueConversionError, _241:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simplexAbsTolPiv)")
   if (_1=="mioTolFeas"):
    try:
     _242=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((1.000000e-09 <= _242) and (_242 <= 1.000000e-03)):
      _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_FEAS",_242)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolFeas)")
    except mosek_fusion_ValueConversionError, _243:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolFeas)")
   if (_1=="anaSolInfeasTol"):
    try:
     _244=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (0.000000e+00 <= _244):
      _0._task_1put_1param_SD("MSK_DPAR_ANA_SOL_INFEAS_TOL",_244)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (anaSolInfeasTol)")
    except mosek_fusion_ValueConversionError, _245:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (anaSolInfeasTol)")
   if (_1=="mioTolRelDualBoundImprovement"):
    try:
     _246=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _246) and (_246 <= 1.000000e+00)):
      _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_REL_DUAL_BOUND_IMPROVEMENT",_246)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolRelDualBoundImprovement)")
    except mosek_fusion_ValueConversionError, _247:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolRelDualBoundImprovement)")
   raise mosek_fusion_ParameterError._ctor_S("Unknown parameter")
  @staticmethod
  def __string_1to_1miocontsoltype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1miocontsoltype_1value_S(_0)
  @staticmethod
  def __string_1to_1miocontsoltype_1value_S(_0):
   if (_0=="none"):
    return numpy.int32(0)
   if (_0=="root"):
    return numpy.int32(1)
   if (_0=="itg"):
    return numpy.int32(2)
   if (_0=="itgRel"):
    return numpy.int32(3)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1internal_1dinf_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1internal_1dinf_1value_S(_0)
  @staticmethod
  def __string_1to_1internal_1dinf_1value_S(_0):
   if (_0=="sensitivityPrimalTime"):
    return numpy.int32(79)
   if (_0=="sensitivityDualTime"):
    return numpy.int32(78)
   if (_0=="intpntCompGap"):
    return numpy.int32(11)
   if (_0=="intpntGfeas"):
    return numpy.int32(57)
   if (_0=="intpntMu"):
    return numpy.int32(64)
   if (_0=="intpntInitIterTime"):
    return numpy.int32(59)
   if (_0=="intpntFactorTime"):
    return numpy.int32(55)
   if (_0=="intpntInitSearchTime"):
    return numpy.int32(60)
   if (_0=="intpntFormSearchTime"):
    return numpy.int32(56)
   if (_0=="intpntUpdateTime"):
    return numpy.int32(68)
   if (_0=="intpntFactorSetupTime"):
    return numpy.int32(52)
   if (_0=="intpntFactorSchurTime"):
    return numpy.int32(46)
   if (_0=="intpntFactorHatSchurTime"):
    return numpy.int32(31)
   if (_0=="intpntFactorHatSchurPushTime"):
    return numpy.int32(30)
   if (_0=="intpntFactorHatSchurPullTime"):
    return numpy.int32(28)
   if (_0=="intpntFactorBarSchurTime"):
    return numpy.int32(15)
   if (_0=="intpntFactorBarSchurDeTabTime"):
    return numpy.int32(12)
   if (_0=="intpntFactorBarSchurSpTabTime"):
    return numpy.int32(14)
   if (_0=="intpntFactorSparseLTime"):
    return numpy.int32(54)
   if (_0=="intpntFactorDenseLTime"):
    return numpy.int32(20)
   if (_0=="intpntFactorHataTime"):
    return numpy.int32(34)
   if (_0=="intpntFactorHataSolveTime"):
    return numpy.int32(33)
   if (_0=="intpntFactorHatvTime"):
    return numpy.int32(41)
   if (_0=="intpntFactorHatathataTime"):
    return numpy.int32(36)
   if (_0=="intpntFactorHatvthatvTime"):
    return numpy.int32(43)
   if (_0=="intpntFactorDotlInitTime"):
    return numpy.int32(24)
   if (_0=="intpntFactorDotlFactorTime"):
    return numpy.int32(23)
   if (_0=="intpntFactorHatldInitTime"):
    return numpy.int32(39)
   if (_0=="intpntFactorHatldFactorTime"):
    return numpy.int32(38)
   if (_0=="intpntFactorDenseTime"):
    return numpy.int32(21)
   if (_0=="intpntIterNonCorrectorFlops"):
    return numpy.int32(61)
   if (_0=="intpntIterOneCorrectorFlops"):
    return numpy.int32(62)
   if (_0=="intpntSolveTime"):
    return numpy.int32(67)
   if (_0=="intpntIterRefTime"):
    return numpy.int32(63)
   if (_0=="intpntSolveSparseLTime"):
    return numpy.int32(66)
   if (_0=="intpntSolveDenseLTime"):
    return numpy.int32(65)
   if (_0=="intpntFactorSetupFlops"):
    return numpy.int32(48)
   if (_0=="intpntFactorSetupHatSchurFlops"):
    return numpy.int32(50)
   if (_0=="intpntFactorSchurFlops"):
    return numpy.int32(45)
   if (_0=="intpntFactorHatSchurFlops"):
    return numpy.int32(26)
   if (_0=="intpntFactorHatSchurPushFlops"):
    return numpy.int32(29)
   if (_0=="intpntFactorHatSchurPullFlops"):
    return numpy.int32(27)
   if (_0=="intpntFactorBarSchurFlops"):
    return numpy.int32(13)
   if (_0=="intpntFactorSparseLFlops"):
    return numpy.int32(53)
   if (_0=="intpntFactorMlOrderSparseLFlops"):
    return numpy.int32(44)
   if (_0=="intpntFactorGpOrderSparseLFlops"):
    return numpy.int32(25)
   if (_0=="intpntFactorDenseLFlops"):
    return numpy.int32(19)
   if (_0=="intpntFactorBvFlops"):
    return numpy.int32(16)
   if (_0=="intpntFactorBvtbvFlops"):
    return numpy.int32(17)
   if (_0=="intpntFactorHataFlops"):
    return numpy.int32(32)
   if (_0=="intpntFactorHatvFlops"):
    return numpy.int32(40)
   if (_0=="intpntFactorDenseFlops"):
    return numpy.int32(18)
   if (_0=="intpntFactorHatathataFlops"):
    return numpy.int32(35)
   if (_0=="intpntFactorHatvthatvFlops"):
    return numpy.int32(42)
   if (_0=="intpntFactorDotlFactorFlops"):
    return numpy.int32(22)
   if (_0=="intpntFactorHatldFactorFlops"):
    return numpy.int32(37)
   if (_0=="presolveAcoltTime"):
    return numpy.int32(69)
   if (_0=="presolveSetupTime"):
    return numpy.int32(74)
   if (_0=="presolveCheckproTime"):
    return numpy.int32(70)
   if (_0=="presolveDupconTime"):
    return numpy.int32(71)
   if (_0=="presolveDupvarTime"):
    return numpy.int32(72)
   if (_0=="presolveFinalTime"):
    return numpy.int32(73)
   if (_0=="presolveSubDomvarTime"):
    return numpy.int32(75)
   if (_0=="presolveSubRelaxTime"):
    return numpy.int32(76)
   if (_0=="primalSimplexInftime"):
    return numpy.int32(77)
   if (_0=="dualSimplexInftime"):
    return numpy.int32(10)
   if (_0=="intpntGpOrderSavedFlops"):
    return numpy.int32(58)
   if (_0=="intpntFactorSetupDetectDenseTime"):
    return numpy.int32(47)
   if (_0=="intpntFactorSetupMlOrderTime"):
    return numpy.int32(51)
   if (_0=="intpntFactorSetupGpOrderTime"):
    return numpy.int32(49)
   if (_0=="biCrashTime"):
    return numpy.int32(1)
   if (_0=="biCrashLuTime"):
    return numpy.int32(0)
   if (_0=="biFactorTime"):
    return numpy.int32(5)
   if (_0=="biFactorWork"):
    return numpy.int32(6)
   if (_0=="biPrimalDone"):
    return numpy.int32(7)
   if (_0=="biDualDone"):
    return numpy.int32(2)
   if (_0=="simPrimalObj"):
    return numpy.int32(83)
   if (_0=="simPrimalFeas"):
    return numpy.int32(82)
   if (_0=="simDualObj"):
    return numpy.int32(81)
   if (_0=="simDualFeas"):
    return numpy.int32(80)
   if (_0=="biPrimalObj"):
    return numpy.int32(9)
   if (_0=="biDualObj"):
    return numpy.int32(4)
   if (_0=="biPrimalFeas"):
    return numpy.int32(8)
   if (_0=="biDualFeas"):
    return numpy.int32(3)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1presolvemode_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1presolvemode_1value_S(_0)
  @staticmethod
  def __string_1to_1presolvemode_1value_S(_0):
   if (_0=="off"):
    return numpy.int32(0)
   if (_0=="on"):
    return numpy.int32(1)
   if (_0=="free"):
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1optimizertype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1optimizertype_1value_S(_0)
  @staticmethod
  def __string_1to_1optimizertype_1value_S(_0):
   if (_0=="free"):
    return numpy.int32(2)
   if (_0=="intpnt"):
    return numpy.int32(4)
   if (_0=="conic"):
    return numpy.int32(0)
   if (_0=="primalSimplex"):
    return numpy.int32(6)
   if (_0=="dualSimplex"):
    return numpy.int32(1)
   if (_0=="freeSimplex"):
    return numpy.int32(3)
   if (_0=="mixedInt"):
    return numpy.int32(5)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1stakey_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1stakey_1value_S(_0)
  @staticmethod
  def __string_1to_1stakey_1value_S(_0):
   if (_0=="unk"):
    return numpy.int32(0)
   if (_0=="bas"):
    return numpy.int32(1)
   if (_0=="supbas"):
    return numpy.int32(2)
   if (_0=="low"):
    return numpy.int32(3)
   if (_0=="upr"):
    return numpy.int32(4)
   if (_0=="fix"):
    return numpy.int32(5)
   if (_0=="inf"):
    return numpy.int32(6)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1iinfitem_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1iinfitem_1value_S(_0)
  @staticmethod
  def __string_1to_1iinfitem_1value_S(_0):
   if (_0=="anaProNumCon"):
    return numpy.int32(0)
   if (_0=="anaProNumConLo"):
    return numpy.int32(3)
   if (_0=="anaProNumConUp"):
    return numpy.int32(5)
   if (_0=="anaProNumConRa"):
    return numpy.int32(4)
   if (_0=="anaProNumConEq"):
    return numpy.int32(1)
   if (_0=="anaProNumConFr"):
    return numpy.int32(2)
   if (_0=="anaProNumVar"):
    return numpy.int32(6)
   if (_0=="anaProNumVarLo"):
    return numpy.int32(12)
   if (_0=="anaProNumVarUp"):
    return numpy.int32(14)
   if (_0=="anaProNumVarRa"):
    return numpy.int32(13)
   if (_0=="anaProNumVarEq"):
    return numpy.int32(9)
   if (_0=="anaProNumVarFr"):
    return numpy.int32(10)
   if (_0=="anaProNumVarCont"):
    return numpy.int32(8)
   if (_0=="anaProNumVarBin"):
    return numpy.int32(7)
   if (_0=="anaProNumVarInt"):
    return numpy.int32(11)
   if (_0=="optimizeResponse"):
    return numpy.int32(51)
   if (_0=="intpntIter"):
    return numpy.int32(16)
   if (_0=="intpntFactorDimDense"):
    return numpy.int32(15)
   if (_0=="intpntSolveDual"):
    return numpy.int32(18)
   if (_0=="mioNodeDepth"):
    return numpy.int32(26)
   if (_0=="mioNumcon"):
    return numpy.int32(37)
   if (_0=="mioNumvar"):
    return numpy.int32(39)
   if (_0=="mioNumint"):
    return numpy.int32(38)
   if (_0=="mioPresolvedNumcont"):
    return numpy.int32(43)
   if (_0=="mioPresolvedNumbin"):
    return numpy.int32(41)
   if (_0=="mioPresolvedNumcon"):
    return numpy.int32(42)
   if (_0=="mioPresolvedNumvar"):
    return numpy.int32(45)
   if (_0=="mioPresolvedNumint"):
    return numpy.int32(44)
   if (_0=="mioCliqueTableSize"):
    return numpy.int32(20)
   if (_0=="mioConstructSolution"):
    return numpy.int32(22)
   if (_0=="mioConstructNumRoundings"):
    return numpy.int32(21)
   if (_0=="mioNumIntSolutions"):
    return numpy.int32(33)
   if (_0=="mioObjBoundDefined"):
    return numpy.int32(40)
   if (_0=="mioNumActiveNodes"):
    return numpy.int32(27)
   if (_0=="mioNumRelax"):
    return numpy.int32(35)
   if (_0=="mioNumBranch"):
    return numpy.int32(28)
   if (_0=="mioTotalNumCuts"):
    return numpy.int32(47)
   if (_0=="mioNumCmirCuts"):
    return numpy.int32(30)
   if (_0=="mioNumCliqueCuts"):
    return numpy.int32(29)
   if (_0=="mioNumImpliedBoundCuts"):
    return numpy.int32(32)
   if (_0=="mioNumKnapsackCoverCuts"):
    return numpy.int32(34)
   if (_0=="mioNumGomoryCuts"):
    return numpy.int32(31)
   if (_0=="mioNumRepeatedPresolve"):
    return numpy.int32(36)
   if (_0=="mioInitialSolution"):
    return numpy.int32(23)
   if (_0=="mioUserObjCut"):
    return numpy.int32(48)
   if (_0=="mioRelgapSatisfied"):
    return numpy.int32(46)
   if (_0=="mioAbsgapSatisfied"):
    return numpy.int32(19)
   if (_0=="mioNearRelgapSatisfied"):
    return numpy.int32(25)
   if (_0=="mioNearAbsgapSatisfied"):
    return numpy.int32(24)
   if (_0=="rdProtype"):
    return numpy.int32(58)
   if (_0=="rdNumcon"):
    return numpy.int32(53)
   if (_0=="rdNumvar"):
    return numpy.int32(57)
   if (_0=="rdNumbarvar"):
    return numpy.int32(52)
   if (_0=="rdNumintvar"):
    return numpy.int32(55)
   if (_0=="rdNumq"):
    return numpy.int32(56)
   if (_0=="simDualDegIter"):
    return numpy.int32(59)
   if (_0=="simDualInfIter"):
    return numpy.int32(62)
   if (_0=="simDualHotstartLu"):
    return numpy.int32(61)
   if (_0=="simPrimalIter"):
    return numpy.int32(70)
   if (_0=="simDualIter"):
    return numpy.int32(63)
   if (_0=="intpntNumThreads"):
    return numpy.int32(17)
   if (_0=="simPrimalInfIter"):
    return numpy.int32(69)
   if (_0=="simPrimalDegIter"):
    return numpy.int32(66)
   if (_0=="simPrimalHotstart"):
    return numpy.int32(67)
   if (_0=="simPrimalHotstartLu"):
    return numpy.int32(68)
   if (_0=="simDualHotstart"):
    return numpy.int32(60)
   if (_0=="solItrProsta"):
    return numpy.int32(76)
   if (_0=="solItrSolsta"):
    return numpy.int32(77)
   if (_0=="solBasProsta"):
    return numpy.int32(72)
   if (_0=="solBasSolsta"):
    return numpy.int32(73)
   if (_0=="solItgProsta"):
    return numpy.int32(74)
   if (_0=="solItgSolsta"):
    return numpy.int32(75)
   if (_0=="simNumcon"):
    return numpy.int32(64)
   if (_0=="simNumvar"):
    return numpy.int32(65)
   if (_0=="optNumcon"):
    return numpy.int32(49)
   if (_0=="optNumvar"):
    return numpy.int32(50)
   if (_0=="stoNumARealloc"):
    return numpy.int32(78)
   if (_0=="rdNumcone"):
    return numpy.int32(54)
   if (_0=="simSolveDual"):
    return numpy.int32(71)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1simreform_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1simreform_1value_S(_0)
  @staticmethod
  def __string_1to_1simreform_1value_S(_0):
   if (_0=="on"):
    return numpy.int32(1)
   if (_0=="off"):
    return numpy.int32(0)
   if (_0=="free"):
    return numpy.int32(2)
   if (_0=="aggressive"):
    return numpy.int32(3)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1value_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1value_1value_S(_0)
  @staticmethod
  def __string_1to_1value_1value_S(_0):
   if (_0=="maxStrLen"):
    return numpy.int32(1024)
   if (_0=="licenseBufferLength"):
    return numpy.int32(21)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1scalingmethod_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1scalingmethod_1value_S(_0)
  @staticmethod
  def __string_1to_1scalingmethod_1value_S(_0):
   if (_0=="pow2"):
    return numpy.int32(0)
   if (_0=="free"):
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1soltype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1soltype_1value_S(_0)
  @staticmethod
  def __string_1to_1soltype_1value_S(_0):
   if (_0=="bas"):
    return numpy.int32(1)
   if (_0=="itr"):
    return numpy.int32(0)
   if (_0=="itg"):
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1startpointtype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1startpointtype_1value_S(_0)
  @staticmethod
  def __string_1to_1startpointtype_1value_S(_0):
   if (_0=="free"):
    return numpy.int32(0)
   if (_0=="guess"):
    return numpy.int32(1)
   if (_0=="constant"):
    return numpy.int32(2)
   if (_0=="satisfyBounds"):
    return numpy.int32(3)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1language_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1language_1value_S(_0)
  @staticmethod
  def __string_1to_1language_1value_S(_0):
   if (_0=="eng"):
    return numpy.int32(0)
   if (_0=="dan"):
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1checkconvexitytype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1checkconvexitytype_1value_S(_0)
  @staticmethod
  def __string_1to_1checkconvexitytype_1value_S(_0):
   if (_0=="none"):
    return numpy.int32(0)
   if (_0=="simple"):
    return numpy.int32(1)
   if (_0=="full"):
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1variabletype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1variabletype_1value_S(_0)
  @staticmethod
  def __string_1to_1variabletype_1value_S(_0):
   if (_0=="typeCont"):
    return numpy.int32(0)
   if (_0=="typeInt"):
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1mpsformat_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1mpsformat_1value_S(_0)
  @staticmethod
  def __string_1to_1mpsformat_1value_S(_0):
   if (_0=="strict"):
    return numpy.int32(0)
   if (_0=="relaxed"):
    return numpy.int32(1)
   if (_0=="free"):
    return numpy.int32(2)
   if (_0=="cplex"):
    return numpy.int32(3)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1nametype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1nametype_1value_S(_0)
  @staticmethod
  def __string_1to_1nametype_1value_S(_0):
   if (_0=="gen"):
    return numpy.int32(0)
   if (_0=="mps"):
    return numpy.int32(1)
   if (_0=="lp"):
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1compresstype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1compresstype_1value_S(_0)
  @staticmethod
  def __string_1to_1compresstype_1value_S(_0):
   if (_0=="none"):
    return numpy.int32(0)
   if (_0=="free"):
    return numpy.int32(1)
   if (_0=="gzip"):
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1simdupvec_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1simdupvec_1value_S(_0)
  @staticmethod
  def __string_1to_1simdupvec_1value_S(_0):
   if (_0=="on"):
    return numpy.int32(1)
   if (_0=="off"):
    return numpy.int32(0)
   if (_0=="free"):
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1dparam_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1dparam_1value_S(_0)
  @staticmethod
  def __string_1to_1dparam_1value_S(_0):
   if (_0=="dataTolCjLarge"):
    return numpy.int32(14)
   if (_0=="dataTolCHuge"):
    return numpy.int32(13)
   if (_0=="dataTolAij"):
    return numpy.int32(8)
   if (_0=="dataTolAijLarge"):
    return numpy.int32(10)
   if (_0=="dataTolAijHuge"):
    return numpy.int32(9)
   if (_0=="dataSymMatTol"):
    return numpy.int32(5)
   if (_0=="dataSymMatTolLarge"):
    return numpy.int32(7)
   if (_0=="dataSymMatTolHuge"):
    return numpy.int32(6)
   if (_0=="dataTolBoundInf"):
    return numpy.int32(11)
   if (_0=="dataTolBoundWrn"):
    return numpy.int32(12)
   if (_0=="dataTolQij"):
    return numpy.int32(15)
   if (_0=="dataTolX"):
    return numpy.int32(16)
   if (_0=="semidefiniteTolApprox"):
    return numpy.int32(65)
   if (_0=="optimizerMaxTime"):
    return numpy.int32(58)
   if (_0=="lowerObjCut"):
    return numpy.int32(46)
   if (_0=="upperObjCut"):
    return numpy.int32(68)
   if (_0=="upperObjCutFiniteTrh"):
    return numpy.int32(69)
   if (_0=="lowerObjCutFiniteTrh"):
    return numpy.int32(47)
   if (_0=="intpntTolRelGap"):
    return numpy.int32(43)
   if (_0=="intpntNlTolRelGap"):
    return numpy.int32(28)
   if (_0=="intpntTolStepSize"):
    return numpy.int32(45)
   if (_0=="simLuTolRelPiv"):
    return numpy.int32(66)
   if (_0=="intpntTolRelStep"):
    return numpy.int32(44)
   if (_0=="intpntNlTolRelStep"):
    return numpy.int32(29)
   if (_0=="intpntNlMeritBal"):
    return numpy.int32(23)
   if (_0=="intpntTolPath"):
    return numpy.int32(40)
   if (_0=="intpntTolPfeas"):
    return numpy.int32(41)
   if (_0=="intpntTolDfeas"):
    return numpy.int32(36)
   if (_0=="intpntTolMuRed"):
    return numpy.int32(39)
   if (_0=="intpntNlTolPfeas"):
    return numpy.int32(27)
   if (_0=="intpntNlTolDfeas"):
    return numpy.int32(24)
   if (_0=="intpntNlTolMuRed"):
    return numpy.int32(25)
   if (_0=="intpntNlTolNearRel"):
    return numpy.int32(26)
   if (_0=="intpntTolInfeas"):
    return numpy.int32(38)
   if (_0=="intpntCoTolRelGap"):
    return numpy.int32(22)
   if (_0=="intpntCoTolPfeas"):
    return numpy.int32(21)
   if (_0=="intpntCoTolDfeas"):
    return numpy.int32(17)
   if (_0=="intpntCoTolMuRed"):
    return numpy.int32(19)
   if (_0=="intpntCoTolNearRel"):
    return numpy.int32(20)
   if (_0=="intpntCoTolInfeas"):
    return numpy.int32(18)
   if (_0=="intpntQoTolRelGap"):
    return numpy.int32(35)
   if (_0=="intpntQoTolPfeas"):
    return numpy.int32(34)
   if (_0=="intpntQoTolDfeas"):
    return numpy.int32(30)
   if (_0=="intpntQoTolMuRed"):
    return numpy.int32(32)
   if (_0=="intpntQoTolNearRel"):
    return numpy.int32(33)
   if (_0=="intpntQoTolInfeas"):
    return numpy.int32(31)
   if (_0=="intpntTolPsafe"):
    return numpy.int32(42)
   if (_0=="intpntTolDsafe"):
    return numpy.int32(37)
   if (_0=="mioMaxTime"):
    return numpy.int32(49)
   if (_0=="mioDisableTermTime"):
    return numpy.int32(48)
   if (_0=="mioRelGapConst"):
    return numpy.int32(52)
   if (_0=="mioTolRelGap"):
    return numpy.int32(57)
   if (_0=="mioNearTolRelGap"):
    return numpy.int32(51)
   if (_0=="mioTolAbsGap"):
    return numpy.int32(53)
   if (_0=="mioNearTolAbsGap"):
    return numpy.int32(50)
   if (_0=="mioTolAbsRelaxInt"):
    return numpy.int32(54)
   if (_0=="basisTolX"):
    return numpy.int32(3)
   if (_0=="basisTolS"):
    return numpy.int32(2)
   if (_0=="basisRelTolS"):
    return numpy.int32(1)
   if (_0=="presolveTolX"):
    return numpy.int32(63)
   if (_0=="presolveTolS"):
    return numpy.int32(62)
   if (_0=="presolveTolAij"):
    return numpy.int32(60)
   if (_0=="presolveTolAbsLindep"):
    return numpy.int32(59)
   if (_0=="presolveTolRelLindep"):
    return numpy.int32(61)
   if (_0=="simplexAbsTolPiv"):
    return numpy.int32(67)
   if (_0=="mioTolFeas"):
    return numpy.int32(55)
   if (_0=="anaSolInfeasTol"):
    return numpy.int32(0)
   if (_0=="checkConvexityRelTol"):
    return numpy.int32(4)
   if (_0=="qcqoReformulateRelDropTol"):
    return numpy.int32(64)
   if (_0=="mioTolRelDualBoundImprovement"):
    return numpy.int32(56)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1inftype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1inftype_1value_S(_0)
  @staticmethod
  def __string_1to_1inftype_1value_S(_0):
   if (_0=="douType"):
    return numpy.int32(0)
   if (_0=="intType"):
    return numpy.int32(1)
   if (_0=="lintType"):
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1problemtype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1problemtype_1value_S(_0)
  @staticmethod
  def __string_1to_1problemtype_1value_S(_0):
   if (_0=="lo"):
    return numpy.int32(0)
   if (_0=="qo"):
    return numpy.int32(1)
   if (_0=="qcqo"):
    return numpy.int32(2)
   if (_0=="geco"):
    return numpy.int32(3)
   if (_0=="conic"):
    return numpy.int32(4)
   if (_0=="mixed"):
    return numpy.int32(5)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1orderingtype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1orderingtype_1value_S(_0)
  @staticmethod
  def __string_1to_1orderingtype_1value_S(_0):
   if (_0=="free"):
    return numpy.int32(0)
   if (_0=="appminloc"):
    return numpy.int32(1)
   if (_0=="experimental"):
    return numpy.int32(2)
   if (_0=="tryGraphpar"):
    return numpy.int32(3)
   if (_0=="forceGraphpar"):
    return numpy.int32(4)
   if (_0=="none"):
    return numpy.int32(5)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1dataformat_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1dataformat_1value_S(_0)
  @staticmethod
  def __string_1to_1dataformat_1value_S(_0):
   if (_0=="extension"):
    return numpy.int32(0)
   if (_0=="mps"):
    return numpy.int32(1)
   if (_0=="lp"):
    return numpy.int32(2)
   if (_0=="op"):
    return numpy.int32(3)
   if (_0=="xml"):
    return numpy.int32(4)
   if (_0=="freeMps"):
    return numpy.int32(5)
   if (_0=="task"):
    return numpy.int32(6)
   if (_0=="cb"):
    return numpy.int32(7)
   if (_0=="jsonTask"):
    return numpy.int32(8)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1simdegen_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1simdegen_1value_S(_0)
  @staticmethod
  def __string_1to_1simdegen_1value_S(_0):
   if (_0=="none"):
    return numpy.int32(0)
   if (_0=="free"):
    return numpy.int32(1)
   if (_0=="aggressive"):
    return numpy.int32(2)
   if (_0=="moderate"):
    return numpy.int32(3)
   if (_0=="minimum"):
    return numpy.int32(4)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1onoffkey_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1onoffkey_1value_S(_0)
  @staticmethod
  def __string_1to_1onoffkey_1value_S(_0):
   if (_0=="on"):
    return numpy.int32(1)
   if (_0=="off"):
    return numpy.int32(0)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1transpose_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1transpose_1value_S(_0)
  @staticmethod
  def __string_1to_1transpose_1value_S(_0):
   if (_0=="no"):
    return numpy.int32(0)
   if (_0=="yes"):
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1mionodeseltype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1mionodeseltype_1value_S(_0)
  @staticmethod
  def __string_1to_1mionodeseltype_1value_S(_0):
   if (_0=="free"):
    return numpy.int32(0)
   if (_0=="first"):
    return numpy.int32(1)
   if (_0=="best"):
    return numpy.int32(2)
   if (_0=="worst"):
    return numpy.int32(3)
   if (_0=="hybrid"):
    return numpy.int32(4)
   if (_0=="pseudo"):
    return numpy.int32(5)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1rescode_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1rescode_1value_S(_0)
  @staticmethod
  def __string_1to_1rescode_1value_S(_0):
   if (_0=="ok"):
    return numpy.int32(0)
   if (_0=="wrnOpenParamFile"):
    return numpy.int32(50)
   if (_0=="wrnLargeBound"):
    return numpy.int32(51)
   if (_0=="wrnLargeLoBound"):
    return numpy.int32(52)
   if (_0=="wrnLargeUpBound"):
    return numpy.int32(53)
   if (_0=="wrnLargeConFx"):
    return numpy.int32(54)
   if (_0=="wrnLargeCj"):
    return numpy.int32(57)
   if (_0=="wrnLargeAij"):
    return numpy.int32(62)
   if (_0=="wrnZeroAij"):
    return numpy.int32(63)
   if (_0=="wrnNameMaxLen"):
    return numpy.int32(65)
   if (_0=="wrnSparMaxLen"):
    return numpy.int32(66)
   if (_0=="wrnMpsSplitRhsVector"):
    return numpy.int32(70)
   if (_0=="wrnMpsSplitRanVector"):
    return numpy.int32(71)
   if (_0=="wrnMpsSplitBouVector"):
    return numpy.int32(72)
   if (_0=="wrnLpOldQuadFormat"):
    return numpy.int32(80)
   if (_0=="wrnLpDropVariable"):
    return numpy.int32(85)
   if (_0=="wrnNzInUprTri"):
    return numpy.int32(200)
   if (_0=="wrnDroppedNzQobj"):
    return numpy.int32(201)
   if (_0=="wrnIgnoreInteger"):
    return numpy.int32(250)
   if (_0=="wrnNoGlobalOptimizer"):
    return numpy.int32(251)
   if (_0=="wrnMioInfeasibleFinal"):
    return numpy.int32(270)
   if (_0=="wrnSolFilter"):
    return numpy.int32(300)
   if (_0=="wrnUndefSolFileName"):
    return numpy.int32(350)
   if (_0=="wrnSolFileIgnoredCon"):
    return numpy.int32(351)
   if (_0=="wrnSolFileIgnoredVar"):
    return numpy.int32(352)
   if (_0=="wrnTooFewBasisVars"):
    return numpy.int32(400)
   if (_0=="wrnTooManyBasisVars"):
    return numpy.int32(405)
   if (_0=="wrnNoNonlinearFunctionWrite"):
    return numpy.int32(450)
   if (_0=="wrnLicenseExpire"):
    return numpy.int32(500)
   if (_0=="wrnLicenseServer"):
    return numpy.int32(501)
   if (_0=="wrnEmptyName"):
    return numpy.int32(502)
   if (_0=="wrnUsingGenericNames"):
    return numpy.int32(503)
   if (_0=="wrnLicenseFeatureExpire"):
    return numpy.int32(505)
   if (_0=="wrnParamNameDou"):
    return numpy.int32(510)
   if (_0=="wrnParamNameInt"):
    return numpy.int32(511)
   if (_0=="wrnParamNameStr"):
    return numpy.int32(512)
   if (_0=="wrnParamStrValue"):
    return numpy.int32(515)
   if (_0=="wrnParamIgnoredCmio"):
    return numpy.int32(516)
   if (_0=="wrnZerosInSparseRow"):
    return numpy.int32(705)
   if (_0=="wrnZerosInSparseCol"):
    return numpy.int32(710)
   if (_0=="wrnIncompleteLinearDependencyCheck"):
    return numpy.int32(800)
   if (_0=="wrnEliminatorSpace"):
    return numpy.int32(801)
   if (_0=="wrnPresolveOutofspace"):
    return numpy.int32(802)
   if (_0=="wrnWriteChangedNames"):
    return numpy.int32(803)
   if (_0=="wrnWriteDiscardedCfix"):
    return numpy.int32(804)
   if (_0=="wrnConstructSolutionInfeas"):
    return numpy.int32(805)
   if (_0=="wrnConstructInvalidSolItg"):
    return numpy.int32(807)
   if (_0=="wrnConstructNoSolItg"):
    return numpy.int32(810)
   if (_0=="wrnDuplicateConstraintNames"):
    return numpy.int32(850)
   if (_0=="wrnDuplicateVariableNames"):
    return numpy.int32(851)
   if (_0=="wrnDuplicateBarvariableNames"):
    return numpy.int32(852)
   if (_0=="wrnDuplicateConeNames"):
    return numpy.int32(853)
   if (_0=="wrnAnaLargeBounds"):
    return numpy.int32(900)
   if (_0=="wrnAnaCZero"):
    return numpy.int32(901)
   if (_0=="wrnAnaEmptyCols"):
    return numpy.int32(902)
   if (_0=="wrnAnaCloseBounds"):
    return numpy.int32(903)
   if (_0=="wrnAnaAlmostIntBounds"):
    return numpy.int32(904)
   if (_0=="wrnQuadConesWithRootFixedAtZero"):
    return numpy.int32(930)
   if (_0=="wrnRquadConesWithRootFixedAtZero"):
    return numpy.int32(931)
   if (_0=="wrnNoDualizer"):
    return numpy.int32(950)
   if (_0=="wrnSymMatLarge"):
    return numpy.int32(960)
   if (_0=="errLicense"):
    return numpy.int32(1000)
   if (_0=="errLicenseExpired"):
    return numpy.int32(1001)
   if (_0=="errLicenseVersion"):
    return numpy.int32(1002)
   if (_0=="errSizeLicense"):
    return numpy.int32(1005)
   if (_0=="errProbLicense"):
    return numpy.int32(1006)
   if (_0=="errFileLicense"):
    return numpy.int32(1007)
   if (_0=="errMissingLicenseFile"):
    return numpy.int32(1008)
   if (_0=="errSizeLicenseCon"):
    return numpy.int32(1010)
   if (_0=="errSizeLicenseVar"):
    return numpy.int32(1011)
   if (_0=="errSizeLicenseIntvar"):
    return numpy.int32(1012)
   if (_0=="errOptimizerLicense"):
    return numpy.int32(1013)
   if (_0=="errFlexlm"):
    return numpy.int32(1014)
   if (_0=="errLicenseServer"):
    return numpy.int32(1015)
   if (_0=="errLicenseMax"):
    return numpy.int32(1016)
   if (_0=="errLicenseMoseklmDaemon"):
    return numpy.int32(1017)
   if (_0=="errLicenseFeature"):
    return numpy.int32(1018)
   if (_0=="errPlatformNotLicensed"):
    return numpy.int32(1019)
   if (_0=="errLicenseCannotAllocate"):
    return numpy.int32(1020)
   if (_0=="errLicenseCannotConnect"):
    return numpy.int32(1021)
   if (_0=="errLicenseInvalidHostid"):
    return numpy.int32(1025)
   if (_0=="errLicenseServerVersion"):
    return numpy.int32(1026)
   if (_0=="errLicenseNoServerSupport"):
    return numpy.int32(1027)
   if (_0=="errLicenseNoServerLine"):
    return numpy.int32(1028)
   if (_0=="errOpenDl"):
    return numpy.int32(1030)
   if (_0=="errOlderDll"):
    return numpy.int32(1035)
   if (_0=="errNewerDll"):
    return numpy.int32(1036)
   if (_0=="errLinkFileDll"):
    return numpy.int32(1040)
   if (_0=="errThreadMutexInit"):
    return numpy.int32(1045)
   if (_0=="errThreadMutexLock"):
    return numpy.int32(1046)
   if (_0=="errThreadMutexUnlock"):
    return numpy.int32(1047)
   if (_0=="errThreadCreate"):
    return numpy.int32(1048)
   if (_0=="errThreadCondInit"):
    return numpy.int32(1049)
   if (_0=="errUnknown"):
    return numpy.int32(1050)
   if (_0=="errSpace"):
    return numpy.int32(1051)
   if (_0=="errFileOpen"):
    return numpy.int32(1052)
   if (_0=="errFileRead"):
    return numpy.int32(1053)
   if (_0=="errFileWrite"):
    return numpy.int32(1054)
   if (_0=="errDataFileExt"):
    return numpy.int32(1055)
   if (_0=="errInvalidFileName"):
    return numpy.int32(1056)
   if (_0=="errInvalidSolFileName"):
    return numpy.int32(1057)
   if (_0=="errEndOfFile"):
    return numpy.int32(1059)
   if (_0=="errNullEnv"):
    return numpy.int32(1060)
   if (_0=="errNullTask"):
    return numpy.int32(1061)
   if (_0=="errInvalidStream"):
    return numpy.int32(1062)
   if (_0=="errNoInitEnv"):
    return numpy.int32(1063)
   if (_0=="errInvalidTask"):
    return numpy.int32(1064)
   if (_0=="errNullPointer"):
    return numpy.int32(1065)
   if (_0=="errLivingTasks"):
    return numpy.int32(1066)
   if (_0=="errBlankName"):
    return numpy.int32(1070)
   if (_0=="errDupName"):
    return numpy.int32(1071)
   if (_0=="errInvalidObjName"):
    return numpy.int32(1075)
   if (_0=="errInvalidConName"):
    return numpy.int32(1076)
   if (_0=="errInvalidVarName"):
    return numpy.int32(1077)
   if (_0=="errInvalidConeName"):
    return numpy.int32(1078)
   if (_0=="errInvalidBarvarName"):
    return numpy.int32(1079)
   if (_0=="errSpaceLeaking"):
    return numpy.int32(1080)
   if (_0=="errSpaceNoInfo"):
    return numpy.int32(1081)
   if (_0=="errReadFormat"):
    return numpy.int32(1090)
   if (_0=="errMpsFile"):
    return numpy.int32(1100)
   if (_0=="errMpsInvField"):
    return numpy.int32(1101)
   if (_0=="errMpsInvMarker"):
    return numpy.int32(1102)
   if (_0=="errMpsNullConName"):
    return numpy.int32(1103)
   if (_0=="errMpsNullVarName"):
    return numpy.int32(1104)
   if (_0=="errMpsUndefConName"):
    return numpy.int32(1105)
   if (_0=="errMpsUndefVarName"):
    return numpy.int32(1106)
   if (_0=="errMpsInvConKey"):
    return numpy.int32(1107)
   if (_0=="errMpsInvBoundKey"):
    return numpy.int32(1108)
   if (_0=="errMpsInvSecName"):
    return numpy.int32(1109)
   if (_0=="errMpsNoObjective"):
    return numpy.int32(1110)
   if (_0=="errMpsSplittedVar"):
    return numpy.int32(1111)
   if (_0=="errMpsMulConName"):
    return numpy.int32(1112)
   if (_0=="errMpsMulQsec"):
    return numpy.int32(1113)
   if (_0=="errMpsMulQobj"):
    return numpy.int32(1114)
   if (_0=="errMpsInvSecOrder"):
    return numpy.int32(1115)
   if (_0=="errMpsMulCsec"):
    return numpy.int32(1116)
   if (_0=="errMpsConeType"):
    return numpy.int32(1117)
   if (_0=="errMpsConeOverlap"):
    return numpy.int32(1118)
   if (_0=="errMpsConeRepeat"):
    return numpy.int32(1119)
   if (_0=="errMpsNonSymmetricQ"):
    return numpy.int32(1120)
   if (_0=="errMpsDuplicateQElement"):
    return numpy.int32(1121)
   if (_0=="errMpsInvalidObjsense"):
    return numpy.int32(1122)
   if (_0=="errMpsTabInField2"):
    return numpy.int32(1125)
   if (_0=="errMpsTabInField3"):
    return numpy.int32(1126)
   if (_0=="errMpsTabInField5"):
    return numpy.int32(1127)
   if (_0=="errMpsInvalidObjName"):
    return numpy.int32(1128)
   if (_0=="errLpIncompatible"):
    return numpy.int32(1150)
   if (_0=="errLpEmpty"):
    return numpy.int32(1151)
   if (_0=="errLpDupSlackName"):
    return numpy.int32(1152)
   if (_0=="errWriteMpsInvalidName"):
    return numpy.int32(1153)
   if (_0=="errLpInvalidVarName"):
    return numpy.int32(1154)
   if (_0=="errLpFreeConstraint"):
    return numpy.int32(1155)
   if (_0=="errWriteOpfInvalidVarName"):
    return numpy.int32(1156)
   if (_0=="errLpFileFormat"):
    return numpy.int32(1157)
   if (_0=="errWriteLpFormat"):
    return numpy.int32(1158)
   if (_0=="errReadLpMissingEndTag"):
    return numpy.int32(1159)
   if (_0=="errLpFormat"):
    return numpy.int32(1160)
   if (_0=="errWriteLpNonUniqueName"):
    return numpy.int32(1161)
   if (_0=="errReadLpNonexistingName"):
    return numpy.int32(1162)
   if (_0=="errLpWriteConicProblem"):
    return numpy.int32(1163)
   if (_0=="errLpWriteGecoProblem"):
    return numpy.int32(1164)
   if (_0=="errWritingFile"):
    return numpy.int32(1166)
   if (_0=="errOpfFormat"):
    return numpy.int32(1168)
   if (_0=="errOpfNewVariable"):
    return numpy.int32(1169)
   if (_0=="errInvalidNameInSolFile"):
    return numpy.int32(1170)
   if (_0=="errLpInvalidConName"):
    return numpy.int32(1171)
   if (_0=="errOpfPrematureEof"):
    return numpy.int32(1172)
   if (_0=="errJsonSyntax"):
    return numpy.int32(1175)
   if (_0=="errJsonString"):
    return numpy.int32(1176)
   if (_0=="errJsonNumberOverflow"):
    return numpy.int32(1177)
   if (_0=="errJsonFormat"):
    return numpy.int32(1178)
   if (_0=="errJsonData"):
    return numpy.int32(1179)
   if (_0=="errJsonMissingData"):
    return numpy.int32(1180)
   if (_0=="errArgumentLenneq"):
    return numpy.int32(1197)
   if (_0=="errArgumentType"):
    return numpy.int32(1198)
   if (_0=="errNrArguments"):
    return numpy.int32(1199)
   if (_0=="errInArgument"):
    return numpy.int32(1200)
   if (_0=="errArgumentDimension"):
    return numpy.int32(1201)
   if (_0=="errIndexIsTooSmall"):
    return numpy.int32(1203)
   if (_0=="errIndexIsTooLarge"):
    return numpy.int32(1204)
   if (_0=="errParamName"):
    return numpy.int32(1205)
   if (_0=="errParamNameDou"):
    return numpy.int32(1206)
   if (_0=="errParamNameInt"):
    return numpy.int32(1207)
   if (_0=="errParamNameStr"):
    return numpy.int32(1208)
   if (_0=="errParamIndex"):
    return numpy.int32(1210)
   if (_0=="errParamIsTooLarge"):
    return numpy.int32(1215)
   if (_0=="errParamIsTooSmall"):
    return numpy.int32(1216)
   if (_0=="errParamValueStr"):
    return numpy.int32(1217)
   if (_0=="errParamType"):
    return numpy.int32(1218)
   if (_0=="errInfDouIndex"):
    return numpy.int32(1219)
   if (_0=="errInfIntIndex"):
    return numpy.int32(1220)
   if (_0=="errIndexArrIsTooSmall"):
    return numpy.int32(1221)
   if (_0=="errIndexArrIsTooLarge"):
    return numpy.int32(1222)
   if (_0=="errInfLintIndex"):
    return numpy.int32(1225)
   if (_0=="errArgIsTooSmall"):
    return numpy.int32(1226)
   if (_0=="errArgIsTooLarge"):
    return numpy.int32(1227)
   if (_0=="errInvalidWhichsol"):
    return numpy.int32(1228)
   if (_0=="errInfDouName"):
    return numpy.int32(1230)
   if (_0=="errInfIntName"):
    return numpy.int32(1231)
   if (_0=="errInfType"):
    return numpy.int32(1232)
   if (_0=="errInfLintName"):
    return numpy.int32(1234)
   if (_0=="errIndex"):
    return numpy.int32(1235)
   if (_0=="errWhichsol"):
    return numpy.int32(1236)
   if (_0=="errSolitem"):
    return numpy.int32(1237)
   if (_0=="errWhichitemNotAllowed"):
    return numpy.int32(1238)
   if (_0=="errMaxnumcon"):
    return numpy.int32(1240)
   if (_0=="errMaxnumvar"):
    return numpy.int32(1241)
   if (_0=="errMaxnumbarvar"):
    return numpy.int32(1242)
   if (_0=="errMaxnumqnz"):
    return numpy.int32(1243)
   if (_0=="errTooSmallMaxNumNz"):
    return numpy.int32(1245)
   if (_0=="errInvalidIdx"):
    return numpy.int32(1246)
   if (_0=="errInvalidMaxNum"):
    return numpy.int32(1247)
   if (_0=="errNumconlim"):
    return numpy.int32(1250)
   if (_0=="errNumvarlim"):
    return numpy.int32(1251)
   if (_0=="errTooSmallMaxnumanz"):
    return numpy.int32(1252)
   if (_0=="errInvAptre"):
    return numpy.int32(1253)
   if (_0=="errMulAElement"):
    return numpy.int32(1254)
   if (_0=="errInvBk"):
    return numpy.int32(1255)
   if (_0=="errInvBkc"):
    return numpy.int32(1256)
   if (_0=="errInvBkx"):
    return numpy.int32(1257)
   if (_0=="errInvVarType"):
    return numpy.int32(1258)
   if (_0=="errSolverProbtype"):
    return numpy.int32(1259)
   if (_0=="errObjectiveRange"):
    return numpy.int32(1260)
   if (_0=="errFirst"):
    return numpy.int32(1261)
   if (_0=="errLast"):
    return numpy.int32(1262)
   if (_0=="errNegativeSurplus"):
    return numpy.int32(1263)
   if (_0=="errNegativeAppend"):
    return numpy.int32(1264)
   if (_0=="errUndefSolution"):
    return numpy.int32(1265)
   if (_0=="errBasis"):
    return numpy.int32(1266)
   if (_0=="errInvSkc"):
    return numpy.int32(1267)
   if (_0=="errInvSkx"):
    return numpy.int32(1268)
   if (_0=="errInvSkn"):
    return numpy.int32(1274)
   if (_0=="errInvSkStr"):
    return numpy.int32(1269)
   if (_0=="errInvSk"):
    return numpy.int32(1270)
   if (_0=="errInvConeTypeStr"):
    return numpy.int32(1271)
   if (_0=="errInvConeType"):
    return numpy.int32(1272)
   if (_0=="errInvalidSurplus"):
    return numpy.int32(1275)
   if (_0=="errInvNameItem"):
    return numpy.int32(1280)
   if (_0=="errProItem"):
    return numpy.int32(1281)
   if (_0=="errInvalidFormatType"):
    return numpy.int32(1283)
   if (_0=="errFirsti"):
    return numpy.int32(1285)
   if (_0=="errLasti"):
    return numpy.int32(1286)
   if (_0=="errFirstj"):
    return numpy.int32(1287)
   if (_0=="errLastj"):
    return numpy.int32(1288)
   if (_0=="errMaxLenIsTooSmall"):
    return numpy.int32(1289)
   if (_0=="errNonlinearEquality"):
    return numpy.int32(1290)
   if (_0=="errNonconvex"):
    return numpy.int32(1291)
   if (_0=="errNonlinearRanged"):
    return numpy.int32(1292)
   if (_0=="errConQNotPsd"):
    return numpy.int32(1293)
   if (_0=="errConQNotNsd"):
    return numpy.int32(1294)
   if (_0=="errObjQNotPsd"):
    return numpy.int32(1295)
   if (_0=="errObjQNotNsd"):
    return numpy.int32(1296)
   if (_0=="errArgumentPermArray"):
    return numpy.int32(1299)
   if (_0=="errConeIndex"):
    return numpy.int32(1300)
   if (_0=="errConeSize"):
    return numpy.int32(1301)
   if (_0=="errConeOverlap"):
    return numpy.int32(1302)
   if (_0=="errConeRepVar"):
    return numpy.int32(1303)
   if (_0=="errMaxnumcone"):
    return numpy.int32(1304)
   if (_0=="errConeType"):
    return numpy.int32(1305)
   if (_0=="errConeTypeStr"):
    return numpy.int32(1306)
   if (_0=="errConeOverlapAppend"):
    return numpy.int32(1307)
   if (_0=="errRemoveConeVariable"):
    return numpy.int32(1310)
   if (_0=="errSolFileInvalidNumber"):
    return numpy.int32(1350)
   if (_0=="errHugeC"):
    return numpy.int32(1375)
   if (_0=="errHugeAij"):
    return numpy.int32(1380)
   if (_0=="errDuplicateAij"):
    return numpy.int32(1385)
   if (_0=="errLowerBoundIsANan"):
    return numpy.int32(1390)
   if (_0=="errUpperBoundIsANan"):
    return numpy.int32(1391)
   if (_0=="errInfiniteBound"):
    return numpy.int32(1400)
   if (_0=="errInvQobjSubi"):
    return numpy.int32(1401)
   if (_0=="errInvQobjSubj"):
    return numpy.int32(1402)
   if (_0=="errInvQobjVal"):
    return numpy.int32(1403)
   if (_0=="errInvQconSubk"):
    return numpy.int32(1404)
   if (_0=="errInvQconSubi"):
    return numpy.int32(1405)
   if (_0=="errInvQconSubj"):
    return numpy.int32(1406)
   if (_0=="errInvQconVal"):
    return numpy.int32(1407)
   if (_0=="errQconSubiTooSmall"):
    return numpy.int32(1408)
   if (_0=="errQconSubiTooLarge"):
    return numpy.int32(1409)
   if (_0=="errQobjUpperTriangle"):
    return numpy.int32(1415)
   if (_0=="errQconUpperTriangle"):
    return numpy.int32(1417)
   if (_0=="errFixedBoundValues"):
    return numpy.int32(1425)
   if (_0=="errNonlinearFunctionsNotAllowed"):
    return numpy.int32(1428)
   if (_0=="errUserFuncRet"):
    return numpy.int32(1430)
   if (_0=="errUserFuncRetData"):
    return numpy.int32(1431)
   if (_0=="errUserNloFunc"):
    return numpy.int32(1432)
   if (_0=="errUserNloEval"):
    return numpy.int32(1433)
   if (_0=="errUserNloEvalHessubi"):
    return numpy.int32(1440)
   if (_0=="errUserNloEvalHessubj"):
    return numpy.int32(1441)
   if (_0=="errInvalidObjectiveSense"):
    return numpy.int32(1445)
   if (_0=="errUndefinedObjectiveSense"):
    return numpy.int32(1446)
   if (_0=="errYIsUndefined"):
    return numpy.int32(1449)
   if (_0=="errNanInDoubleData"):
    return numpy.int32(1450)
   if (_0=="errNanInBlc"):
    return numpy.int32(1461)
   if (_0=="errNanInBuc"):
    return numpy.int32(1462)
   if (_0=="errNanInC"):
    return numpy.int32(1470)
   if (_0=="errNanInBlx"):
    return numpy.int32(1471)
   if (_0=="errNanInBux"):
    return numpy.int32(1472)
   if (_0=="errInvalidAij"):
    return numpy.int32(1473)
   if (_0=="errSymMatInvalid"):
    return numpy.int32(1480)
   if (_0=="errSymMatHuge"):
    return numpy.int32(1482)
   if (_0=="errInvProblem"):
    return numpy.int32(1500)
   if (_0=="errMixedConicAndNl"):
    return numpy.int32(1501)
   if (_0=="errGlobalInvConicProblem"):
    return numpy.int32(1503)
   if (_0=="errInvOptimizer"):
    return numpy.int32(1550)
   if (_0=="errMioNoOptimizer"):
    return numpy.int32(1551)
   if (_0=="errNoOptimizerVarType"):
    return numpy.int32(1552)
   if (_0=="errFinalSolution"):
    return numpy.int32(1560)
   if (_0=="errPostsolve"):
    return numpy.int32(1580)
   if (_0=="errOverflow"):
    return numpy.int32(1590)
   if (_0=="errNoBasisSol"):
    return numpy.int32(1600)
   if (_0=="errBasisFactor"):
    return numpy.int32(1610)
   if (_0=="errBasisSingular"):
    return numpy.int32(1615)
   if (_0=="errFactor"):
    return numpy.int32(1650)
   if (_0=="errFeasrepairCannotRelax"):
    return numpy.int32(1700)
   if (_0=="errFeasrepairSolvingRelaxed"):
    return numpy.int32(1701)
   if (_0=="errFeasrepairInconsistentBound"):
    return numpy.int32(1702)
   if (_0=="errRepairInvalidProblem"):
    return numpy.int32(1710)
   if (_0=="errRepairOptimizationFailed"):
    return numpy.int32(1711)
   if (_0=="errNameMaxLen"):
    return numpy.int32(1750)
   if (_0=="errNameIsNull"):
    return numpy.int32(1760)
   if (_0=="errInvalidCompression"):
    return numpy.int32(1800)
   if (_0=="errInvalidIomode"):
    return numpy.int32(1801)
   if (_0=="errNoPrimalInfeasCer"):
    return numpy.int32(2000)
   if (_0=="errNoDualInfeasCer"):
    return numpy.int32(2001)
   if (_0=="errNoSolutionInCallback"):
    return numpy.int32(2500)
   if (_0=="errInvMarki"):
    return numpy.int32(2501)
   if (_0=="errInvMarkj"):
    return numpy.int32(2502)
   if (_0=="errInvNumi"):
    return numpy.int32(2503)
   if (_0=="errInvNumj"):
    return numpy.int32(2504)
   if (_0=="errCannotCloneNl"):
    return numpy.int32(2505)
   if (_0=="errCannotHandleNl"):
    return numpy.int32(2506)
   if (_0=="errInvalidAccmode"):
    return numpy.int32(2520)
   if (_0=="errTaskIncompatible"):
    return numpy.int32(2560)
   if (_0=="errTaskInvalid"):
    return numpy.int32(2561)
   if (_0=="errTaskWrite"):
    return numpy.int32(2562)
   if (_0=="errLuMaxNumTries"):
    return numpy.int32(2800)
   if (_0=="errInvalidUtf8"):
    return numpy.int32(2900)
   if (_0=="errInvalidWchar"):
    return numpy.int32(2901)
   if (_0=="errNoDualForItgSol"):
    return numpy.int32(2950)
   if (_0=="errNoSnxForBasSol"):
    return numpy.int32(2953)
   if (_0=="errInternal"):
    return numpy.int32(3000)
   if (_0=="errApiArrayTooSmall"):
    return numpy.int32(3001)
   if (_0=="errApiCbConnect"):
    return numpy.int32(3002)
   if (_0=="errApiFatalError"):
    return numpy.int32(3005)
   if (_0=="errApiInternal"):
    return numpy.int32(3999)
   if (_0=="errSenFormat"):
    return numpy.int32(3050)
   if (_0=="errSenUndefName"):
    return numpy.int32(3051)
   if (_0=="errSenIndexRange"):
    return numpy.int32(3052)
   if (_0=="errSenBoundInvalidUp"):
    return numpy.int32(3053)
   if (_0=="errSenBoundInvalidLo"):
    return numpy.int32(3054)
   if (_0=="errSenIndexInvalid"):
    return numpy.int32(3055)
   if (_0=="errSenInvalidRegexp"):
    return numpy.int32(3056)
   if (_0=="errSenSolutionStatus"):
    return numpy.int32(3057)
   if (_0=="errSenNumerical"):
    return numpy.int32(3058)
   if (_0=="errSenUnhandledProblemType"):
    return numpy.int32(3080)
   if (_0=="errUnbStepSize"):
    return numpy.int32(3100)
   if (_0=="errIdenticalTasks"):
    return numpy.int32(3101)
   if (_0=="errAdInvalidCodelist"):
    return numpy.int32(3102)
   if (_0=="errInternalTestFailed"):
    return numpy.int32(3500)
   if (_0=="errXmlInvalidProblemType"):
    return numpy.int32(3600)
   if (_0=="errInvalidAmplStub"):
    return numpy.int32(3700)
   if (_0=="errInt64ToInt32Cast"):
    return numpy.int32(3800)
   if (_0=="errSizeLicenseNumcores"):
    return numpy.int32(3900)
   if (_0=="errInfeasUndefined"):
    return numpy.int32(3910)
   if (_0=="errNoBarxForSolution"):
    return numpy.int32(3915)
   if (_0=="errNoBarsForSolution"):
    return numpy.int32(3916)
   if (_0=="errBarVarDim"):
    return numpy.int32(3920)
   if (_0=="errSymMatInvalidRowIndex"):
    return numpy.int32(3940)
   if (_0=="errSymMatInvalidColIndex"):
    return numpy.int32(3941)
   if (_0=="errSymMatNotLowerTringular"):
    return numpy.int32(3942)
   if (_0=="errSymMatInvalidValue"):
    return numpy.int32(3943)
   if (_0=="errSymMatDuplicate"):
    return numpy.int32(3944)
   if (_0=="errInvalidSymMatDim"):
    return numpy.int32(3950)
   if (_0=="errInvalidFileFormatForSymMat"):
    return numpy.int32(4000)
   if (_0=="errInvalidFileFormatForCones"):
    return numpy.int32(4005)
   if (_0=="errInvalidFileFormatForGeneralNl"):
    return numpy.int32(4010)
   if (_0=="errDuplicateConstraintNames"):
    return numpy.int32(4500)
   if (_0=="errDuplicateVariableNames"):
    return numpy.int32(4501)
   if (_0=="errDuplicateBarvariableNames"):
    return numpy.int32(4502)
   if (_0=="errDuplicateConeNames"):
    return numpy.int32(4503)
   if (_0=="errNonUniqueArray"):
    return numpy.int32(5000)
   if (_0=="errArgumentIsTooLarge"):
    return numpy.int32(5005)
   if (_0=="errMioInternal"):
    return numpy.int32(5010)
   if (_0=="errInvalidProblemType"):
    return numpy.int32(6000)
   if (_0=="errUnhandledSolutionStatus"):
    return numpy.int32(6010)
   if (_0=="errUpperTriangle"):
    return numpy.int32(6020)
   if (_0=="errLauSingularMatrix"):
    return numpy.int32(7000)
   if (_0=="errLauNotPositiveDefinite"):
    return numpy.int32(7001)
   if (_0=="errLauInvalidLowerTriangularMatrix"):
    return numpy.int32(7002)
   if (_0=="errLauUnknown"):
    return numpy.int32(7005)
   if (_0=="errLauArgM"):
    return numpy.int32(7010)
   if (_0=="errLauArgN"):
    return numpy.int32(7011)
   if (_0=="errLauArgK"):
    return numpy.int32(7012)
   if (_0=="errLauArgTransa"):
    return numpy.int32(7015)
   if (_0=="errLauArgTransb"):
    return numpy.int32(7016)
   if (_0=="errLauArgUplo"):
    return numpy.int32(7017)
   if (_0=="errLauArgTrans"):
    return numpy.int32(7018)
   if (_0=="errLauInvalidSparseSymmetricMatrix"):
    return numpy.int32(7019)
   if (_0=="errCbfParse"):
    return numpy.int32(7100)
   if (_0=="errCbfObjSense"):
    return numpy.int32(7101)
   if (_0=="errCbfNoVariables"):
    return numpy.int32(7102)
   if (_0=="errCbfTooManyConstraints"):
    return numpy.int32(7103)
   if (_0=="errCbfTooManyVariables"):
    return numpy.int32(7104)
   if (_0=="errCbfNoVersionSpecified"):
    return numpy.int32(7105)
   if (_0=="errCbfSyntax"):
    return numpy.int32(7106)
   if (_0=="errCbfDuplicateObj"):
    return numpy.int32(7107)
   if (_0=="errCbfDuplicateCon"):
    return numpy.int32(7108)
   if (_0=="errCbfDuplicateVar"):
    return numpy.int32(7109)
   if (_0=="errCbfDuplicateInt"):
    return numpy.int32(7110)
   if (_0=="errCbfInvalidVarType"):
    return numpy.int32(7111)
   if (_0=="errCbfInvalidConType"):
    return numpy.int32(7112)
   if (_0=="errCbfInvalidDomainDimension"):
    return numpy.int32(7113)
   if (_0=="errCbfDuplicateObjacoord"):
    return numpy.int32(7114)
   if (_0=="errCbfDuplicateBcoord"):
    return numpy.int32(7115)
   if (_0=="errCbfDuplicateAcoord"):
    return numpy.int32(7116)
   if (_0=="errCbfTooFewVariables"):
    return numpy.int32(7117)
   if (_0=="errCbfTooFewConstraints"):
    return numpy.int32(7118)
   if (_0=="errCbfTooFewInts"):
    return numpy.int32(7119)
   if (_0=="errCbfTooManyInts"):
    return numpy.int32(7120)
   if (_0=="errCbfInvalidIntIndex"):
    return numpy.int32(7121)
   if (_0=="errCbfUnsupported"):
    return numpy.int32(7122)
   if (_0=="errCbfDuplicatePsdvar"):
    return numpy.int32(7123)
   if (_0=="errCbfInvalidPsdvarDimension"):
    return numpy.int32(7124)
   if (_0=="errCbfTooFewPsdvar"):
    return numpy.int32(7125)
   if (_0=="errMioInvalidRootOptimizer"):
    return numpy.int32(7130)
   if (_0=="errMioInvalidNodeOptimizer"):
    return numpy.int32(7131)
   if (_0=="errToconicConstrQNotPsd"):
    return numpy.int32(7150)
   if (_0=="errToconicConstraintFx"):
    return numpy.int32(7151)
   if (_0=="errToconicConstraintRa"):
    return numpy.int32(7152)
   if (_0=="errToconicConstrNotConic"):
    return numpy.int32(7153)
   if (_0=="errToconicObjectiveNotPsd"):
    return numpy.int32(7155)
   if (_0=="errServerConnect"):
    return numpy.int32(8000)
   if (_0=="errServerProtocol"):
    return numpy.int32(8001)
   if (_0=="errServerStatus"):
    return numpy.int32(8002)
   if (_0=="errServerToken"):
    return numpy.int32(8003)
   if (_0=="trmMaxIterations"):
    return numpy.int32(10000)
   if (_0=="trmMaxTime"):
    return numpy.int32(10001)
   if (_0=="trmObjectiveRange"):
    return numpy.int32(10002)
   if (_0=="trmMioNearRelGap"):
    return numpy.int32(10003)
   if (_0=="trmMioNearAbsGap"):
    return numpy.int32(10004)
   if (_0=="trmMioNumRelaxs"):
    return numpy.int32(10008)
   if (_0=="trmMioNumBranches"):
    return numpy.int32(10009)
   if (_0=="trmNumMaxNumIntSolutions"):
    return numpy.int32(10015)
   if (_0=="trmStall"):
    return numpy.int32(10006)
   if (_0=="trmUserCallback"):
    return numpy.int32(10007)
   if (_0=="trmMaxNumSetbacks"):
    return numpy.int32(10020)
   if (_0=="trmNumericalProblem"):
    return numpy.int32(10025)
   if (_0=="trmInternal"):
    return numpy.int32(10030)
   if (_0=="trmInternalStop"):
    return numpy.int32(10031)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1scalingtype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1scalingtype_1value_S(_0)
  @staticmethod
  def __string_1to_1scalingtype_1value_S(_0):
   if (_0=="free"):
    return numpy.int32(0)
   if (_0=="none"):
    return numpy.int32(1)
   if (_0=="moderate"):
    return numpy.int32(2)
   if (_0=="aggressive"):
    return numpy.int32(3)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1prosta_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1prosta_1value_S(_0)
  @staticmethod
  def __string_1to_1prosta_1value_S(_0):
   if (_0=="unknown"):
    return numpy.int32(0)
   if (_0=="primAndDualFeas"):
    return numpy.int32(1)
   if (_0=="primFeas"):
    return numpy.int32(2)
   if (_0=="dualFeas"):
    return numpy.int32(3)
   if (_0=="nearPrimAndDualFeas"):
    return numpy.int32(8)
   if (_0=="nearPrimFeas"):
    return numpy.int32(9)
   if (_0=="nearDualFeas"):
    return numpy.int32(10)
   if (_0=="primInfeas"):
    return numpy.int32(4)
   if (_0=="dualInfeas"):
    return numpy.int32(5)
   if (_0=="primAndDualInfeas"):
    return numpy.int32(6)
   if (_0=="illPosed"):
    return numpy.int32(7)
   if (_0=="primInfeasOrUnbounded"):
    return numpy.int32(11)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1rescodetype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1rescodetype_1value_S(_0)
  @staticmethod
  def __string_1to_1rescodetype_1value_S(_0):
   if (_0=="ok"):
    return numpy.int32(0)
   if (_0=="wrn"):
    return numpy.int32(1)
   if (_0=="trm"):
    return numpy.int32(2)
   if (_0=="err"):
    return numpy.int32(3)
   if (_0=="unk"):
    return numpy.int32(4)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1parametertype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1parametertype_1value_S(_0)
  @staticmethod
  def __string_1to_1parametertype_1value_S(_0):
   if (_0=="invalidType"):
    return numpy.int32(0)
   if (_0=="douType"):
    return numpy.int32(1)
   if (_0=="intType"):
    return numpy.int32(2)
   if (_0=="strType"):
    return numpy.int32(3)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1dinfitem_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1dinfitem_1value_S(_0)
  @staticmethod
  def __string_1to_1dinfitem_1value_S(_0):
   if (_0=="biTime"):
    return numpy.int32(5)
   if (_0=="biPrimalTime"):
    return numpy.int32(4)
   if (_0=="biDualTime"):
    return numpy.int32(3)
   if (_0=="biCleanTime"):
    return numpy.int32(2)
   if (_0=="biCleanPrimalTime"):
    return numpy.int32(1)
   if (_0=="biCleanDualTime"):
    return numpy.int32(0)
   if (_0=="intpntTime"):
    return numpy.int32(13)
   if (_0=="intpntOrderTime"):
    return numpy.int32(10)
   if (_0=="intpntPrimalObj"):
    return numpy.int32(12)
   if (_0=="intpntDualObj"):
    return numpy.int32(7)
   if (_0=="intpntPrimalFeas"):
    return numpy.int32(11)
   if (_0=="intpntDualFeas"):
    return numpy.int32(6)
   if (_0=="intpntOptStatus"):
    return numpy.int32(9)
   if (_0=="simTime"):
    return numpy.int32(47)
   if (_0=="simPrimalTime"):
    return numpy.int32(46)
   if (_0=="simDualTime"):
    return numpy.int32(43)
   if (_0=="simObj"):
    return numpy.int32(45)
   if (_0=="simFeas"):
    return numpy.int32(44)
   if (_0=="mioTime"):
    return numpy.int32(31)
   if (_0=="mioRootPresolveTime"):
    return numpy.int32(30)
   if (_0=="mioRootOptimizerTime"):
    return numpy.int32(29)
   if (_0=="mioOptimizerTime"):
    return numpy.int32(26)
   if (_0=="mioHeuristicTime"):
    return numpy.int32(19)
   if (_0=="toConicTime"):
    return numpy.int32(91)
   if (_0=="mioConstructSolutionObj"):
    return numpy.int32(16)
   if (_0=="mioObjInt"):
    return numpy.int32(24)
   if (_0=="mioObjBound"):
    return numpy.int32(23)
   if (_0=="mioObjRelGap"):
    return numpy.int32(25)
   if (_0=="mioObjAbsGap"):
    return numpy.int32(22)
   if (_0=="mioUserObjCut"):
    return numpy.int32(32)
   if (_0=="mioCmirSeparationTime"):
    return numpy.int32(15)
   if (_0=="mioCliqueSeparationTime"):
    return numpy.int32(14)
   if (_0=="mioKnapsackCoverSeparationTime"):
    return numpy.int32(21)
   if (_0=="mioGmiSeparationTime"):
    return numpy.int32(18)
   if (_0=="mioImpliedBoundTime"):
    return numpy.int32(20)
   if (_0=="mioRootCutgenTime"):
    return numpy.int32(28)
   if (_0=="mioProbingTime"):
    return numpy.int32(27)
   if (_0=="optimizerTime"):
    return numpy.int32(33)
   if (_0=="presolveTime"):
    return numpy.int32(36)
   if (_0=="mioDualBoundAfterPresolve"):
    return numpy.int32(17)
   if (_0=="presolveEliTime"):
    return numpy.int32(34)
   if (_0=="presolveLindepTime"):
    return numpy.int32(35)
   if (_0=="rdTime"):
    return numpy.int32(42)
   if (_0=="solItrPrimalObj"):
    return numpy.int32(86)
   if (_0=="solItrPviolcon"):
    return numpy.int32(88)
   if (_0=="solItrPviolvar"):
    return numpy.int32(90)
   if (_0=="solItrPviolbarvar"):
    return numpy.int32(87)
   if (_0=="solItrPviolcones"):
    return numpy.int32(89)
   if (_0=="solItrDualObj"):
    return numpy.int32(71)
   if (_0=="solItrDviolcon"):
    return numpy.int32(73)
   if (_0=="solItrDviolvar"):
    return numpy.int32(75)
   if (_0=="solItrDviolbarvar"):
    return numpy.int32(72)
   if (_0=="solItrDviolcones"):
    return numpy.int32(74)
   if (_0=="solItrNrmXc"):
    return numpy.int32(83)
   if (_0=="solItrNrmXx"):
    return numpy.int32(84)
   if (_0=="solItrNrmBarx"):
    return numpy.int32(77)
   if (_0=="solItrNrmY"):
    return numpy.int32(85)
   if (_0=="solItrNrmSlc"):
    return numpy.int32(78)
   if (_0=="solItrNrmSuc"):
    return numpy.int32(81)
   if (_0=="solItrNrmSlx"):
    return numpy.int32(79)
   if (_0=="solItrNrmSux"):
    return numpy.int32(82)
   if (_0=="solItrNrmSnx"):
    return numpy.int32(80)
   if (_0=="solItrNrmBars"):
    return numpy.int32(76)
   if (_0=="solBasPrimalObj"):
    return numpy.int32(59)
   if (_0=="solBasPviolcon"):
    return numpy.int32(60)
   if (_0=="solBasPviolvar"):
    return numpy.int32(61)
   if (_0=="solBasDualObj"):
    return numpy.int32(48)
   if (_0=="solBasDviolcon"):
    return numpy.int32(49)
   if (_0=="solBasDviolvar"):
    return numpy.int32(50)
   if (_0=="solBasNrmXc"):
    return numpy.int32(56)
   if (_0=="solBasNrmXx"):
    return numpy.int32(57)
   if (_0=="solBasNrmBarx"):
    return numpy.int32(51)
   if (_0=="solBasNrmY"):
    return numpy.int32(58)
   if (_0=="solBasNrmSlc"):
    return numpy.int32(52)
   if (_0=="solBasNrmSuc"):
    return numpy.int32(54)
   if (_0=="solBasNrmSlx"):
    return numpy.int32(53)
   if (_0=="solBasNrmSux"):
    return numpy.int32(55)
   if (_0=="solItgPrimalObj"):
    return numpy.int32(65)
   if (_0=="solItgPviolcon"):
    return numpy.int32(67)
   if (_0=="solItgPviolvar"):
    return numpy.int32(70)
   if (_0=="solItgPviolbarvar"):
    return numpy.int32(66)
   if (_0=="solItgPviolcones"):
    return numpy.int32(68)
   if (_0=="solItgPviolitg"):
    return numpy.int32(69)
   if (_0=="solItgNrmXc"):
    return numpy.int32(63)
   if (_0=="solItgNrmXx"):
    return numpy.int32(64)
   if (_0=="solItgNrmBarx"):
    return numpy.int32(62)
   if (_0=="intpntFactorNumFlops"):
    return numpy.int32(8)
   if (_0=="qcqoReformulateTime"):
    return numpy.int32(39)
   if (_0=="qcqoReformulateMaxPerturbation"):
    return numpy.int32(38)
   if (_0=="qcqoReformulateWorstCholeskyDiagScaling"):
    return numpy.int32(41)
   if (_0=="qcqoReformulateWorstCholeskyColumnScaling"):
    return numpy.int32(40)
   if (_0=="primalRepairPenaltyObj"):
    return numpy.int32(37)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1miomode_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1miomode_1value_S(_0)
  @staticmethod
  def __string_1to_1miomode_1value_S(_0):
   if (_0=="ignored"):
    return numpy.int32(0)
   if (_0=="satisfied"):
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1xmlwriteroutputtype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1xmlwriteroutputtype_1value_S(_0)
  @staticmethod
  def __string_1to_1xmlwriteroutputtype_1value_S(_0):
   if (_0=="row"):
    return numpy.int32(0)
   if (_0=="col"):
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1simseltype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1simseltype_1value_S(_0)
  @staticmethod
  def __string_1to_1simseltype_1value_S(_0):
   if (_0=="free"):
    return numpy.int32(0)
   if (_0=="full"):
    return numpy.int32(1)
   if (_0=="ase"):
    return numpy.int32(2)
   if (_0=="devex"):
    return numpy.int32(3)
   if (_0=="se"):
    return numpy.int32(4)
   if (_0=="partial"):
    return numpy.int32(5)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1internal_1liinf_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1internal_1liinf_1value_S(_0)
  @staticmethod
  def __string_1to_1internal_1liinf_1value_S(_0):
   if (_0=="intpntLenbarvar"):
    return numpy.int32(5)
   if (_0=="intpntFactorNumNzBefore"):
    return numpy.int32(2)
   if (_0=="intpntFactorMlOrderSparseLNz"):
    return numpy.int32(1)
   if (_0=="intpntFactorGpOrderSparseLNz"):
    return numpy.int32(0)
   if (_0=="presolveStackSize"):
    return numpy.int32(6)
   if (_0=="intpntFactorVNz"):
    return numpy.int32(4)
   if (_0=="intpntFactorUpdatedVNz"):
    return numpy.int32(3)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1iomode_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1iomode_1value_S(_0)
  @staticmethod
  def __string_1to_1iomode_1value_S(_0):
   if (_0=="read"):
    return numpy.int32(0)
   if (_0=="write"):
    return numpy.int32(1)
   if (_0=="readwrite"):
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1streamtype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1streamtype_1value_S(_0)
  @staticmethod
  def __string_1to_1streamtype_1value_S(_0):
   if (_0=="log"):
    return numpy.int32(0)
   if (_0=="msg"):
    return numpy.int32(1)
   if (_0=="err"):
    return numpy.int32(2)
   if (_0=="wrn"):
    return numpy.int32(3)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1conetype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1conetype_1value_S(_0)
  @staticmethod
  def __string_1to_1conetype_1value_S(_0):
   if (_0=="quad"):
    return numpy.int32(0)
   if (_0=="rquad"):
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1mark_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1mark_1value_S(_0)
  @staticmethod
  def __string_1to_1mark_1value_S(_0):
   if (_0=="lo"):
    return numpy.int32(0)
   if (_0=="up"):
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1feature_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1feature_1value_S(_0)
  @staticmethod
  def __string_1to_1feature_1value_S(_0):
   if (_0=="pts"):
    return numpy.int32(0)
   if (_0=="pton"):
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1symmattype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1symmattype_1value_S(_0)
  @staticmethod
  def __string_1to_1symmattype_1value_S(_0):
   if (_0=="sparse"):
    return numpy.int32(0)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1callbackcode_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1callbackcode_1value_S(_0)
  @staticmethod
  def __string_1to_1callbackcode_1value_S(_0):
   if (_0=="beginRootCutgen"):
    return numpy.int32(22)
   if (_0=="imRootCutgen"):
    return numpy.int32(76)
   if (_0=="endRootCutgen"):
    return numpy.int32(51)
   if (_0=="beginOptimizer"):
    return numpy.int32(12)
   if (_0=="endOptimizer"):
    return numpy.int32(41)
   if (_0=="beginPresolve"):
    return numpy.int32(13)
   if (_0=="updatePresolve"):
    return numpy.int32(88)
   if (_0=="imPresolve"):
    return numpy.int32(70)
   if (_0=="endPresolve"):
    return numpy.int32(42)
   if (_0=="beginIntpnt"):
    return numpy.int32(9)
   if (_0=="intpnt"):
    return numpy.int32(79)
   if (_0=="imIntpnt"):
    return numpy.int32(62)
   if (_0=="endIntpnt"):
    return numpy.int32(38)
   if (_0=="beginConic"):
    return numpy.int32(1)
   if (_0=="conic"):
    return numpy.int32(27)
   if (_0=="imConic"):
    return numpy.int32(57)
   if (_0=="endConic"):
    return numpy.int32(30)
   if (_0=="primalSimplex"):
    return numpy.int32(81)
   if (_0=="dualSimplex"):
    return numpy.int32(28)
   if (_0=="beginBi"):
    return numpy.int32(0)
   if (_0=="imBi"):
    return numpy.int32(56)
   if (_0=="endBi"):
    return numpy.int32(29)
   if (_0=="beginPrimalBi"):
    return numpy.int32(14)
   if (_0=="imPrimalBi"):
    return numpy.int32(71)
   if (_0=="updatePrimalBi"):
    return numpy.int32(89)
   if (_0=="endPrimalBi"):
    return numpy.int32(43)
   if (_0=="beginDualBi"):
    return numpy.int32(2)
   if (_0=="imDualBi"):
    return numpy.int32(58)
   if (_0=="updateDualBi"):
    return numpy.int32(85)
   if (_0=="endDualBi"):
    return numpy.int32(31)
   if (_0=="beginSimplexBi"):
    return numpy.int32(24)
   if (_0=="imSimplexBi"):
    return numpy.int32(78)
   if (_0=="beginPrimalSimplexBi"):
    return numpy.int32(19)
   if (_0=="updatePrimalSimplexBi"):
    return numpy.int32(91)
   if (_0=="endPrimalSimplexBi"):
    return numpy.int32(48)
   if (_0=="beginDualSimplexBi"):
    return numpy.int32(6)
   if (_0=="updateDualSimplexBi"):
    return numpy.int32(87)
   if (_0=="endDualSimplexBi"):
    return numpy.int32(35)
   if (_0=="endSimplexBi"):
    return numpy.int32(53)
   if (_0=="beginMio"):
    return numpy.int32(11)
   if (_0=="imMio"):
    return numpy.int32(65)
   if (_0=="newIntMio"):
    return numpy.int32(80)
   if (_0=="endMio"):
    return numpy.int32(40)
   if (_0=="beginSimplex"):
    return numpy.int32(23)
   if (_0=="beginDualSimplex"):
    return numpy.int32(5)
   if (_0=="imDualSimplex"):
    return numpy.int32(60)
   if (_0=="updateDualSimplex"):
    return numpy.int32(86)
   if (_0=="endDualSimplex"):
    return numpy.int32(34)
   if (_0=="beginPrimalSimplex"):
    return numpy.int32(18)
   if (_0=="imPrimalSimplex"):
    return numpy.int32(73)
   if (_0=="updatePrimalSimplex"):
    return numpy.int32(90)
   if (_0=="endPrimalSimplex"):
    return numpy.int32(47)
   if (_0=="endSimplex"):
    return numpy.int32(52)
   if (_0=="beginInfeasAna"):
    return numpy.int32(8)
   if (_0=="endInfeasAna"):
    return numpy.int32(37)
   if (_0=="imPrimalSensivity"):
    return numpy.int32(72)
   if (_0=="imDualSensivity"):
    return numpy.int32(59)
   if (_0=="imMioIntpnt"):
    return numpy.int32(67)
   if (_0=="imMioPrimalSimplex"):
    return numpy.int32(68)
   if (_0=="imMioDualSimplex"):
    return numpy.int32(66)
   if (_0=="beginPrimalSetupBi"):
    return numpy.int32(17)
   if (_0=="endPrimalSetupBi"):
    return numpy.int32(46)
   if (_0=="beginDualSetupBi"):
    return numpy.int32(4)
   if (_0=="endDualSetupBi"):
    return numpy.int32(33)
   if (_0=="beginPrimalSensitivity"):
    return numpy.int32(16)
   if (_0=="endPrimalSensitivity"):
    return numpy.int32(45)
   if (_0=="beginDualSensitivity"):
    return numpy.int32(3)
   if (_0=="endDualSensitivity"):
    return numpy.int32(32)
   if (_0=="beginLicenseWait"):
    return numpy.int32(10)
   if (_0=="endLicenseWait"):
    return numpy.int32(39)
   if (_0=="imLicenseWait"):
    return numpy.int32(63)
   if (_0=="beginQcqoReformulate"):
    return numpy.int32(20)
   if (_0=="endQcqoReformulate"):
    return numpy.int32(49)
   if (_0=="imQoReformulate"):
    return numpy.int32(74)
   if (_0=="beginToConic"):
    return numpy.int32(25)
   if (_0=="endToConic"):
    return numpy.int32(54)
   if (_0=="beginFullConvexityCheck"):
    return numpy.int32(7)
   if (_0=="endFullConvexityCheck"):
    return numpy.int32(36)
   if (_0=="imFullConvexityCheck"):
    return numpy.int32(61)
   if (_0=="beginPrimalRepair"):
    return numpy.int32(15)
   if (_0=="endPrimalRepair"):
    return numpy.int32(44)
   if (_0=="beginRead"):
    return numpy.int32(21)
   if (_0=="imRead"):
    return numpy.int32(75)
   if (_0=="endRead"):
    return numpy.int32(50)
   if (_0=="beginWrite"):
    return numpy.int32(26)
   if (_0=="endWrite"):
    return numpy.int32(55)
   if (_0=="readOpfSection"):
    return numpy.int32(83)
   if (_0=="imLu"):
    return numpy.int32(64)
   if (_0=="imOrder"):
    return numpy.int32(69)
   if (_0=="imSimplex"):
    return numpy.int32(77)
   if (_0=="readOpf"):
    return numpy.int32(82)
   if (_0=="writeOpf"):
    return numpy.int32(92)
   if (_0=="solvingRemote"):
    return numpy.int32(84)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1simhotstart_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1simhotstart_1value_S(_0)
  @staticmethod
  def __string_1to_1simhotstart_1value_S(_0):
   if (_0=="none"):
    return numpy.int32(0)
   if (_0=="free"):
    return numpy.int32(1)
   if (_0=="statusKeys"):
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1liinfitem_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1liinfitem_1value_S(_0)
  @staticmethod
  def __string_1to_1liinfitem_1value_S(_0):
   if (_0=="mioPresolvedAnz"):
    return numpy.int32(8)
   if (_0=="mioSimplexIter"):
    return numpy.int32(10)
   if (_0=="mioIntpntIter"):
    return numpy.int32(7)
   if (_0=="biPrimalIter"):
    return numpy.int32(5)
   if (_0=="biDualIter"):
    return numpy.int32(4)
   if (_0=="biCleanPrimalIter"):
    return numpy.int32(3)
   if (_0=="biCleanDualIter"):
    return numpy.int32(1)
   if (_0=="biCleanPrimalDegIter"):
    return numpy.int32(2)
   if (_0=="biCleanDualDegIter"):
    return numpy.int32(0)
   if (_0=="intpntFactorNumNz"):
    return numpy.int32(6)
   if (_0=="rdNumanz"):
    return numpy.int32(11)
   if (_0=="rdNumqnz"):
    return numpy.int32(12)
   if (_0=="mioSimMaxiterSetbacks"):
    return numpy.int32(9)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1branchdir_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1branchdir_1value_S(_0)
  @staticmethod
  def __string_1to_1branchdir_1value_S(_0):
   if (_0=="free"):
    return numpy.int32(0)
   if (_0=="up"):
    return numpy.int32(1)
   if (_0=="down"):
    return numpy.int32(2)
   if (_0=="near"):
    return numpy.int32(3)
   if (_0=="far"):
    return numpy.int32(4)
   if (_0=="rootLp"):
    return numpy.int32(5)
   if (_0=="guided"):
    return numpy.int32(6)
   if (_0=="pseudocost"):
    return numpy.int32(7)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1basindtype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1basindtype_1value_S(_0)
  @staticmethod
  def __string_1to_1basindtype_1value_S(_0):
   if (_0=="never"):
    return numpy.int32(0)
   if (_0=="always"):
    return numpy.int32(1)
   if (_0=="noError"):
    return numpy.int32(2)
   if (_0=="ifFeasible"):
    return numpy.int32(3)
   if (_0=="reservered"):
    return numpy.int32(4)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1internal_1iinf_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1internal_1iinf_1value_S(_0)
  @staticmethod
  def __string_1to_1internal_1iinf_1value_S(_0):
   if (_0=="presolveCompressedStackSize"):
    return numpy.int32(31)
   if (_0=="presolveLindepWork"):
    return numpy.int32(59)
   if (_0=="presolveLindepPivots"):
    return numpy.int32(57)
   if (_0=="presolveLindepSkipped"):
    return numpy.int32(58)
   if (_0=="presolveOutofspace"):
    return numpy.int32(77)
   if (_0=="presolveBadPrecision"):
    return numpy.int32(30)
   if (_0=="optObjectiveSense"):
    return numpy.int32(28)
   if (_0=="optimizer"):
    return numpy.int32(29)
   if (_0=="intpntFirRefIter"):
    return numpy.int32(9)
   if (_0=="intpntNumRefSteps"):
    return numpy.int32(14)
   if (_0=="intpntFactorDim"):
    return numpy.int32(2)
   if (_0=="intpntFactorNumDenseA"):
    return numpy.int32(4)
   if (_0=="intpntFactorNumDenseADup"):
    return numpy.int32(5)
   if (_0=="intpntFactorNumDenseW"):
    return numpy.int32(6)
   if (_0=="intpntFactorNumDenseWANull"):
    return numpy.int32(7)
   if (_0=="intpntNumcon"):
    return numpy.int32(21)
   if (_0=="intpntNumvar"):
    return numpy.int32(26)
   if (_0=="intpntNumbarvar"):
    return numpy.int32(15)
   if (_0=="intpntNumblo"):
    return numpy.int32(18)
   if (_0=="intpntNumbup"):
    return numpy.int32(20)
   if (_0=="intpntNumbfr"):
    return numpy.int32(16)
   if (_0=="intpntNumbfx"):
    return numpy.int32(17)
   if (_0=="intpntNumcone"):
    return numpy.int32(22)
   if (_0=="intpntNumconevar"):
    return numpy.int32(23)
   if (_0=="intpntNumbndcone"):
    return numpy.int32(19)
   if (_0=="intpntNumrqcones"):
    return numpy.int32(25)
   if (_0=="intpntNumqcones"):
    return numpy.int32(24)
   if (_0=="intpntMinconedim"):
    return numpy.int32(13)
   if (_0=="intpntMaxconedim"):
    return numpy.int32(12)
   if (_0=="intpntMaxbarvardim"):
    return numpy.int32(11)
   if (_0=="presolveNumcon"):
    return numpy.int32(66)
   if (_0=="presolveNumcfr"):
    return numpy.int32(62)
   if (_0=="presolveNumcfx"):
    return numpy.int32(63)
   if (_0=="presolveNumclo"):
    return numpy.int32(64)
   if (_0=="presolveNumcup"):
    return numpy.int32(68)
   if (_0=="presolveNumcra"):
    return numpy.int32(67)
   if (_0=="presolveNumcnl"):
    return numpy.int32(65)
   if (_0=="presolveNumvar"):
    return numpy.int32(70)
   if (_0=="presolveNumvfr"):
    return numpy.int32(71)
   if (_0=="presolveNumvfx"):
    return numpy.int32(72)
   if (_0=="presolveNumvlo"):
    return numpy.int32(73)
   if (_0=="presolveNumvup"):
    return numpy.int32(76)
   if (_0=="presolveNumvra"):
    return numpy.int32(75)
   if (_0=="presolveNumvnl"):
    return numpy.int32(74)
   if (_0=="presolveNumnza"):
    return numpy.int32(69)
   if (_0=="presolveFnumcon"):
    return numpy.int32(39)
   if (_0=="presolveFnumcfr"):
    return numpy.int32(35)
   if (_0=="presolveFnumcfx"):
    return numpy.int32(36)
   if (_0=="presolveFnumclo"):
    return numpy.int32(37)
   if (_0=="presolveFnumcup"):
    return numpy.int32(41)
   if (_0=="presolveFnumcra"):
    return numpy.int32(40)
   if (_0=="presolveFnumcnl"):
    return numpy.int32(38)
   if (_0=="presolveFnumvar"):
    return numpy.int32(43)
   if (_0=="presolveFnumvfr"):
    return numpy.int32(44)
   if (_0=="presolveFnumvfx"):
    return numpy.int32(45)
   if (_0=="presolveFnumvlo"):
    return numpy.int32(46)
   if (_0=="presolveFnumvup"):
    return numpy.int32(49)
   if (_0=="presolveFnumvra"):
    return numpy.int32(48)
   if (_0=="presolveFnumvnl"):
    return numpy.int32(47)
   if (_0=="presolveFnumnza"):
    return numpy.int32(42)
   if (_0=="presolveNumElimns"):
    return numpy.int32(61)
   if (_0=="presolveEliNumTries"):
    return numpy.int32(34)
   if (_0=="presolveEliNumFreedCon"):
    return numpy.int32(32)
   if (_0=="presolveEliNumFreedConTotal"):
    return numpy.int32(33)
   if (_0=="presolveLindepNumTries"):
    return numpy.int32(55)
   if (_0=="presolveLindepNum"):
    return numpy.int32(54)
   if (_0=="presolveForceConNum"):
    return numpy.int32(50)
   if (_0=="presolveForceConNumVar"):
    return numpy.int32(51)
   if (_0=="presolveForceVarNum"):
    return numpy.int32(52)
   if (_0=="presolveForceVarNumCon"):
    return numpy.int32(53)
   if (_0=="presolvePivOnConNum"):
    return numpy.int32(78)
   if (_0=="presolveNumDouBlocks"):
    return numpy.int32(60)
   if (_0=="intpntFactorNum"):
    return numpy.int32(3)
   if (_0=="intpntFactorNumSolve"):
    return numpy.int32(8)
   if (_0=="simPrimalHotstartNumBasics"):
    return numpy.int32(88)
   if (_0=="simPrimalHotstartBasisRank"):
    return numpy.int32(87)
   if (_0=="simDualHotstartNumBasics"):
    return numpy.int32(80)
   if (_0=="simDualHotstartBasisRank"):
    return numpy.int32(79)
   if (_0=="intpntGpOrderEmployed"):
    return numpy.int32(10)
   if (_0=="numLuFactorizations"):
    return numpy.int32(27)
   if (_0=="simPrimalTrust"):
    return numpy.int32(90)
   if (_0=="simDualTrust"):
    return numpy.int32(82)
   if (_0=="simPrimalNumSetbacks"):
    return numpy.int32(89)
   if (_0=="simDualNumSetbacks"):
    return numpy.int32(81)
   if (_0=="simNumDupvec"):
    return numpy.int32(85)
   if (_0=="simNumPrimalBoundswaps"):
    return numpy.int32(86)
   if (_0=="simNumDualBoundswaps"):
    return numpy.int32(83)
   if (_0=="simNumDualIntegerPivots"):
    return numpy.int32(84)
   if (_0=="biPrimalInfo"):
    return numpy.int32(1)
   if (_0=="biDualInfo"):
    return numpy.int32(0)
   if (_0=="presolveLindepNumTruncTries"):
    return numpy.int32(56)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1boundkey_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1boundkey_1value_S(_0)
  @staticmethod
  def __string_1to_1boundkey_1value_S(_0):
   if (_0=="lo"):
    return numpy.int32(0)
   if (_0=="up"):
    return numpy.int32(1)
   if (_0=="fx"):
    return numpy.int32(2)
   if (_0=="fr"):
    return numpy.int32(3)
   if (_0=="ra"):
    return numpy.int32(4)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1solitem_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1solitem_1value_S(_0)
  @staticmethod
  def __string_1to_1solitem_1value_S(_0):
   if (_0=="xc"):
    return numpy.int32(0)
   if (_0=="xx"):
    return numpy.int32(1)
   if (_0=="y"):
    return numpy.int32(2)
   if (_0=="slc"):
    return numpy.int32(3)
   if (_0=="suc"):
    return numpy.int32(4)
   if (_0=="slx"):
    return numpy.int32(5)
   if (_0=="sux"):
    return numpy.int32(6)
   if (_0=="snx"):
    return numpy.int32(7)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1objsense_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1objsense_1value_S(_0)
  @staticmethod
  def __string_1to_1objsense_1value_S(_0):
   if (_0=="minimize"):
    return numpy.int32(0)
   if (_0=="maximize"):
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1solsta_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1solsta_1value_S(_0)
  @staticmethod
  def __string_1to_1solsta_1value_S(_0):
   if (_0=="unknown"):
    return numpy.int32(0)
   if (_0=="optimal"):
    return numpy.int32(1)
   if (_0=="primFeas"):
    return numpy.int32(2)
   if (_0=="dualFeas"):
    return numpy.int32(3)
   if (_0=="primAndDualFeas"):
    return numpy.int32(4)
   if (_0=="nearOptimal"):
    return numpy.int32(7)
   if (_0=="nearPrimFeas"):
    return numpy.int32(8)
   if (_0=="nearDualFeas"):
    return numpy.int32(9)
   if (_0=="nearPrimAndDualFeas"):
    return numpy.int32(10)
   if (_0=="primInfeasCer"):
    return numpy.int32(5)
   if (_0=="dualInfeasCer"):
    return numpy.int32(6)
   if (_0=="nearPrimInfeasCer"):
    return numpy.int32(11)
   if (_0=="nearDualInfeasCer"):
    return numpy.int32(12)
   if (_0=="primIllposedCer"):
    return numpy.int32(13)
   if (_0=="dualIllposedCer"):
    return numpy.int32(14)
   if (_0=="integerOptimal"):
    return numpy.int32(15)
   if (_0=="nearIntegerOptimal"):
    return numpy.int32(16)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1iparam_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1iparam_1value_S(_0)
  @staticmethod
  def __string_1to_1iparam_1value_S(_0):
   if (_0=="autoUpdateSolInfo"):
    return numpy.int32(3)
   if (_0=="removeUnusedSolutions"):
    return numpy.int32(111)
   if (_0=="intpntHotstart"):
    return numpy.int32(18)
   if (_0=="mioMtUserCb"):
    return numpy.int32(70)
   if (_0=="numThreads"):
    return numpy.int32(80)
   if (_0=="intpntMultiThread"):
    return numpy.int32(22)
   if (_0=="timingLevel"):
    return numpy.int32(144)
   if (_0=="mtSpincount"):
    return numpy.int32(79)
   if (_0=="maxNumWarnings"):
    return numpy.int32(56)
   if (_0=="optimizer"):
    return numpy.int32(90)
   if (_0=="biMaxIterations"):
    return numpy.int32(8)
   if (_0=="licenseTrhExpiryWrn"):
    return numpy.int32(32)
   if (_0=="logCutSecondOpt"):
    return numpy.int32(39)
   if (_0=="logAnaPro"):
    return numpy.int32(35)
   if (_0=="logResponse"):
    return numpy.int32(49)
   if (_0=="logBi"):
    return numpy.int32(36)
   if (_0=="logBiFreq"):
    return numpy.int32(37)
   if (_0=="biCleanOptimizer"):
    return numpy.int32(5)
   if (_0=="intpntMaxNumRefinementSteps"):
    return numpy.int32(21)
   if (_0=="intpntStartingPoint"):
    return numpy.int32(28)
   if (_0=="intpntDiffStep"):
    return numpy.int32(17)
   if (_0=="intpntScaling"):
    return numpy.int32(26)
   if (_0=="intpntSolveForm"):
    return numpy.int32(27)
   if (_0=="logIntpnt"):
    return numpy.int32(44)
   if (_0=="intpntMaxIterations"):
    return numpy.int32(19)
   if (_0=="intpntOffColTrh"):
    return numpy.int32(23)
   if (_0=="intpntOrderMethod"):
    return numpy.int32(24)
   if (_0=="intpntBasis"):
    return numpy.int32(16)
   if (_0=="biIgnoreMaxIter"):
    return numpy.int32(6)
   if (_0=="biIgnoreNumError"):
    return numpy.int32(7)
   if (_0=="intpntMaxNumCor"):
    return numpy.int32(20)
   if (_0=="presolveUse"):
    return numpy.int32(100)
   if (_0=="presolveLevel"):
    return numpy.int32(95)
   if (_0=="logPresolve"):
    return numpy.int32(48)
   if (_0=="presolveLindepUse"):
    return numpy.int32(98)
   if (_0=="presolveEliminatorMaxNumTries"):
    return numpy.int32(94)
   if (_0=="presolveEliminatorMaxFill"):
    return numpy.int32(93)
   if (_0=="presolveMaxNumReductions"):
    return numpy.int32(99)
   if (_0=="simStabilityPriority"):
    return numpy.int32(137)
   if (_0=="simPrimalCrash"):
    return numpy.int32(127)
   if (_0=="logSim"):
    return numpy.int32(52)
   if (_0=="logSimMinor"):
    return numpy.int32(54)
   if (_0=="logSimFreq"):
    return numpy.int32(53)
   if (_0=="simPrimalRestrictSelection"):
    return numpy.int32(129)
   if (_0=="simPrimalSelection"):
    return numpy.int32(130)
   if (_0=="simDualRestrictSelection"):
    return numpy.int32(119)
   if (_0=="simDualSelection"):
    return numpy.int32(120)
   if (_0=="simMaxIterations"):
    return numpy.int32(124)
   if (_0=="simHotstartLu"):
    return numpy.int32(123)
   if (_0=="simRefactorFreq"):
    return numpy.int32(131)
   if (_0=="mioMode"):
    return numpy.int32(69)
   if (_0=="logMio"):
    return numpy.int32(45)
   if (_0=="logMioFreq"):
    return numpy.int32(46)
   if (_0=="mioMaxNumRelaxs"):
    return numpy.int32(67)
   if (_0=="mioMaxNumBranches"):
    return numpy.int32(66)
   if (_0=="mioMaxNumSolutions"):
    return numpy.int32(68)
   if (_0=="mioNodeSelection"):
    return numpy.int32(72)
   if (_0=="mioHeuristicLevel"):
    return numpy.int32(65)
   if (_0=="mioProbingLevel"):
    return numpy.int32(74)
   if (_0=="mioCutSelectionLevel"):
    return numpy.int32(64)
   if (_0=="mioVbDetectionLevel"):
    return numpy.int32(78)
   if (_0=="mioBranchDir"):
    return numpy.int32(57)
   if (_0=="mioRootOptimizer"):
    return numpy.int32(76)
   if (_0=="mioNodeOptimizer"):
    return numpy.int32(71)
   if (_0=="mioPerspectiveReformulate"):
    return numpy.int32(73)
   if (_0=="readDataFormat"):
    return numpy.int32(103)
   if (_0=="readDataCompressed"):
    return numpy.int32(102)
   if (_0=="readKeepFreeCon"):
    return numpy.int32(105)
   if (_0=="readMpsFormat"):
    return numpy.int32(108)
   if (_0=="writeMpsFormat"):
    return numpy.int32(163)
   if (_0=="readMpsWidth"):
    return numpy.int32(109)
   if (_0=="readDebug"):
    return numpy.int32(104)
   if (_0=="readLpQuotedNames"):
    return numpy.int32(107)
   if (_0=="writeDataFormat"):
    return numpy.int32(149)
   if (_0=="writeDataParam"):
    return numpy.int32(150)
   if (_0=="writeFreeCon"):
    return numpy.int32(151)
   if (_0=="writeGenericNames"):
    return numpy.int32(152)
   if (_0=="writeGenericNamesIo"):
    return numpy.int32(153)
   if (_0=="writeDataCompressed"):
    return numpy.int32(148)
   if (_0=="writeMpsInt"):
    return numpy.int32(164)
   if (_0=="writeLpStrictFormat"):
    return numpy.int32(161)
   if (_0=="writeLpQuotedNames"):
    return numpy.int32(160)
   if (_0=="writeLpLineWidth"):
    return numpy.int32(159)
   if (_0=="writeLpTermsPerLine"):
    return numpy.int32(162)
   if (_0=="writeLpFullObj"):
    return numpy.int32(158)
   if (_0=="writePrecision"):
    return numpy.int32(165)
   if (_0=="writeSolIgnoreInvalidNames"):
    return numpy.int32(169)
   if (_0=="writeSolHead"):
    return numpy.int32(168)
   if (_0=="writeSolConstraints"):
    return numpy.int32(167)
   if (_0=="writeSolVariables"):
    return numpy.int32(170)
   if (_0=="writeSolBarvariables"):
    return numpy.int32(166)
   if (_0=="writeBasHead"):
    return numpy.int32(146)
   if (_0=="writeBasConstraints"):
    return numpy.int32(145)
   if (_0=="writeBasVariables"):
    return numpy.int32(147)
   if (_0=="writeIntHead"):
    return numpy.int32(156)
   if (_0=="writeIntConstraints"):
    return numpy.int32(155)
   if (_0=="writeIntVariables"):
    return numpy.int32(157)
   if (_0=="solReadNameWidth"):
    return numpy.int32(141)
   if (_0=="solReadWidth"):
    return numpy.int32(142)
   if (_0=="infeasReportAuto"):
    return numpy.int32(14)
   if (_0=="infeasReportLevel"):
    return numpy.int32(15)
   if (_0=="infeasGenericNames"):
    return numpy.int32(12)
   if (_0=="logInfeasAna"):
    return numpy.int32(43)
   if (_0=="licenseWait"):
    return numpy.int32(33)
   if (_0=="licenseSuppressExpireWrns"):
    return numpy.int32(31)
   if (_0=="licensePauseTime"):
    return numpy.int32(30)
   if (_0=="licenseDebug"):
    return numpy.int32(29)
   if (_0=="solFilterKeepBasic"):
    return numpy.int32(139)
   if (_0=="solFilterKeepRanged"):
    return numpy.int32(140)
   if (_0=="log"):
    return numpy.int32(34)
   if (_0=="logExpand"):
    return numpy.int32(40)
   if (_0=="logFile"):
    return numpy.int32(42)
   if (_0=="logOrder"):
    return numpy.int32(47)
   if (_0=="logSensitivity"):
    return numpy.int32(50)
   if (_0=="logSensitivityOpt"):
    return numpy.int32(51)
   if (_0=="readTaskIgnoreParam"):
    return numpy.int32(110)
   if (_0=="writeTaskIncSol"):
    return numpy.int32(171)
   if (_0=="paramReadCaseName"):
    return numpy.int32(91)
   if (_0=="paramReadIgnError"):
    return numpy.int32(92)
   if (_0=="solutionCallback"):
    return numpy.int32(143)
   if (_0=="simScaling"):
    return numpy.int32(134)
   if (_0=="simScalingMethod"):
    return numpy.int32(135)
   if (_0=="simPrimalPhaseoneMethod"):
    return numpy.int32(128)
   if (_0=="simDualPhaseoneMethod"):
    return numpy.int32(118)
   if (_0=="simMaxNumSetbacks"):
    return numpy.int32(125)
   if (_0=="simHotstart"):
    return numpy.int32(122)
   if (_0=="simBasisFactorUse"):
    return numpy.int32(115)
   if (_0=="simDegen"):
    return numpy.int32(116)
   if (_0=="simReformulation"):
    return numpy.int32(132)
   if (_0=="simExploitDupvec"):
    return numpy.int32(121)
   if (_0=="simSaveLu"):
    return numpy.int32(133)
   if (_0=="simNonSingular"):
    return numpy.int32(126)
   if (_0=="simDualCrash"):
    return numpy.int32(117)
   if (_0=="logStorage"):
    return numpy.int32(55)
   if (_0=="infeasPreferPrimal"):
    return numpy.int32(13)
   if (_0=="readLpDropNewVarsInBou"):
    return numpy.int32(106)
   if (_0=="opfMaxTermsPerLine"):
    return numpy.int32(81)
   if (_0=="opfWriteHints"):
    return numpy.int32(83)
   if (_0=="opfWriteParameters"):
    return numpy.int32(84)
   if (_0=="opfWriteProblem"):
    return numpy.int32(85)
   if (_0=="opfWriteHeader"):
    return numpy.int32(82)
   if (_0=="opfWriteSolutions"):
    return numpy.int32(89)
   if (_0=="opfWriteSolBas"):
    return numpy.int32(86)
   if (_0=="opfWriteSolItg"):
    return numpy.int32(87)
   if (_0=="opfWriteSolItr"):
    return numpy.int32(88)
   if (_0=="primalRepairOptimizer"):
    return numpy.int32(101)
   if (_0=="mioRootRepeatPresolveLevel"):
    return numpy.int32(77)
   if (_0=="mioCutCmir"):
    return numpy.int32(60)
   if (_0=="mioCutClique"):
    return numpy.int32(59)
   if (_0=="mioCutImpliedBound"):
    return numpy.int32(62)
   if (_0=="mioCutKnapsackCover"):
    return numpy.int32(63)
   if (_0=="mioCutGmi"):
    return numpy.int32(61)
   if (_0=="sensitivityType"):
    return numpy.int32(114)
   if (_0=="mioConstructSol"):
    return numpy.int32(58)
   if (_0=="presolveLindepRelWorkTrh"):
    return numpy.int32(97)
   if (_0=="presolveLindepAbsWorkTrh"):
    return numpy.int32(96)
   if (_0=="sensitivityAll"):
    return numpy.int32(112)
   if (_0=="logFeasRepair"):
    return numpy.int32(41)
   if (_0=="cacheLicense"):
    return numpy.int32(9)
   if (_0=="intpntRegularizationUse"):
    return numpy.int32(25)
   if (_0=="simSolveForm"):
    return numpy.int32(136)
   if (_0=="simSwitchOptimizer"):
    return numpy.int32(138)
   if (_0=="writeIgnoreIncompatibleItems"):
    return numpy.int32(154)
   if (_0=="checkConvexity"):
    return numpy.int32(10)
   if (_0=="logCheckConvexity"):
    return numpy.int32(38)
   if (_0=="autoSortABeforeOpt"):
    return numpy.int32(2)
   if (_0=="sensitivityOptimizer"):
    return numpy.int32(113)
   if (_0=="writeXmlMode"):
    return numpy.int32(172)
   if (_0=="anaSolBasis"):
    return numpy.int32(0)
   if (_0=="anaSolPrintViolated"):
    return numpy.int32(1)
   if (_0=="basisSolveUsePlusOne"):
    return numpy.int32(4)
   if (_0=="compressStatfile"):
    return numpy.int32(11)
   if (_0=="mioRinsMaxNodes"):
    return numpy.int32(75)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1sparam_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1sparam_1value_S(_0)
  @staticmethod
  def __string_1to_1sparam_1value_S(_0):
   if (_0=="dataFileName"):
    return numpy.int32(1)
   if (_0=="paramReadFileName"):
    return numpy.int32(7)
   if (_0=="paramWriteFileName"):
    return numpy.int32(8)
   if (_0=="paramCommentSign"):
    return numpy.int32(6)
   if (_0=="debugFileName"):
    return numpy.int32(2)
   if (_0=="basSolFileName"):
    return numpy.int32(0)
   if (_0=="itrSolFileName"):
    return numpy.int32(4)
   if (_0=="intSolFileName"):
    return numpy.int32(3)
   if (_0=="solFilterXcLow"):
    return numpy.int32(16)
   if (_0=="solFilterXcUpr"):
    return numpy.int32(17)
   if (_0=="solFilterXxLow"):
    return numpy.int32(18)
   if (_0=="solFilterXxUpr"):
    return numpy.int32(19)
   if (_0=="readMpsObjName"):
    return numpy.int32(10)
   if (_0=="readMpsRanName"):
    return numpy.int32(11)
   if (_0=="readMpsRhsName"):
    return numpy.int32(12)
   if (_0=="readMpsBouName"):
    return numpy.int32(9)
   if (_0=="statFileName"):
    return numpy.int32(20)
   if (_0=="statName"):
    return numpy.int32(22)
   if (_0=="statKey"):
    return numpy.int32(21)
   if (_0=="writeLpGenVarName"):
    return numpy.int32(23)
   if (_0=="sensitivityResFileName"):
    return numpy.int32(15)
   if (_0=="sensitivityFileName"):
    return numpy.int32(14)
   if (_0=="mioDebugString"):
    return numpy.int32(5)
   if (_0=="remoteAccessToken"):
    return numpy.int32(13)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1intpnthotstart_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1intpnthotstart_1value_S(_0)
  @staticmethod
  def __string_1to_1intpnthotstart_1value_S(_0):
   if (_0=="none"):
    return numpy.int32(0)
   if (_0=="primal"):
    return numpy.int32(1)
   if (_0=="dual"):
    return numpy.int32(2)
   if (_0=="primalDual"):
    return numpy.int32(3)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1uplo_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1uplo_1value_S(_0)
  @staticmethod
  def __string_1to_1uplo_1value_S(_0):
   if (_0=="lo"):
    return numpy.int32(0)
   if (_0=="up"):
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1sensitivitytype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1sensitivitytype_1value_S(_0)
  @staticmethod
  def __string_1to_1sensitivitytype_1value_S(_0):
   if (_0=="basis"):
    return numpy.int32(0)
   if (_0=="optimalPartition"):
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1accmode_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1accmode_1value_S(_0)
  @staticmethod
  def __string_1to_1accmode_1value_S(_0):
   if (_0=="var"):
    return numpy.int32(0)
   if (_0=="con"):
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1problemitem_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1problemitem_1value_S(_0)
  @staticmethod
  def __string_1to_1problemitem_1value_S(_0):
   if (_0=="var"):
    return numpy.int32(0)
   if (_0=="con"):
    return numpy.int32(1)
   if (_0=="cone"):
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1solveform_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1solveform_1value_S(_0)
  @staticmethod
  def __string_1to_1solveform_1value_S(_0):
   if (_0=="free"):
    return numpy.int32(0)
   if (_0=="primal"):
    return numpy.int32(1)
   if (_0=="dual"):
    return numpy.int32(2)
   return numpy.int32((- 1))
 return Parameters
mosek_fusion_Parameters=__mk_mosek_fusion_Parameters()
del __mk_mosek_fusion_Parameters
def __mk_mosek_fusion_Utils_StringIntMap():
  class StringIntMap:
    def __init__ (self):
      self.__d = {}
    def _hasItem_S(self,key): return key in self.__d
    def _getItem_S(self,key): return self.__d[key]
    def _setItem_SI(self,key,val): self.__d[key] = val
    def _keys_(self): return numpy.array(list(self.__d.keys()))
    def _values_(self): return numpy.array(list(self.__d.values()))
    def _clone_(self):
      r = self.__class__()
      r.__d.update(self.__d)
      return r
  return StringIntMap
mosek_fusion_Utils_StringIntMap=__mk_mosek_fusion_Utils_StringIntMap()
def __mk_mosek_fusion_Utils_IntMap():
  class IntMap:
    def __init__ (self):
      self.__d = {}
    def _hasItem_J(self,key): return key in self.__d
    def _getItem_J(self,key): return self.__d[key]
    def _setItem_JI(self,key,val): self.__d[key] = val
    def _keys_(self): return numpy.array(list(self.__d.keys()))
    def _values_(self): return numpy.array(list(self.__d.values()))
    def _clone_(self):
      r = self.__class__()
      r.__d.update(self.__d)
      return r
  
  
  
  return IntMap
mosek_fusion_Utils_IntMap=__mk_mosek_fusion_Utils_IntMap()
def __mk_mosek_fusion_Utils_StringBuffer():
  class StringBuffer:
    def __init__(self):
      self.__buf = []
    def __a(self,v):
      self.__buf.append(str(v))
      return self 
    def __a_array(self,v):
      if v is None: self.__buf.append("None")
      else: self.__buf.append(str(v))
      return self
  
    _a_I   = __a
    _a_J   = __a
    _a_U   = __a
    _a_D   = __a
    _a_S   = __a
    _a_B   = __a
    _a__3I = __a_array
    def _a__3J(self,v):
      if v is not None: self.__buf.extend([ '[',','.join(['%i' % i for i in v]),']'])
      else:             self.__buf.append('None')  
      return self
    def _a__3D(self,v):
      if v is not None: self.__buf.extend([ '[',','.join(['%g' % i for i in v]),']'])
      else:             self.__buf.append('None')  
      return self
    _a__3S = __a_array
    def _lf_(self): 
      self.__buf.append('\n')
      return self
    def _clear_ (self):
      self.__buf = []
      return self
    def _toString_(self):
      return ''.join(self.__buf)
    def _toString_(self):
      return ''.join(self.__buf)
    def _consolePrint_(self):
      print(self._toString_())
      self._clear_()
      return(self)
  
  return StringBuffer
mosek_fusion_Utils_StringBuffer=__mk_mosek_fusion_Utils_StringBuffer()
def __mk_mosek_fusion_Utils_Tools():
  
  import random,ctypes,math
  class Tools:
    @staticmethod
    def __arraycopy(src,srcoffset,tgt,tgtoffset,size):
      if len(tgt) < tgtoffset+size or len(src) < srcoffset+size:
        raise IndexError("Copy slice out of range")
      tgt[tgtoffset:tgtoffset+size] = src[srcoffset:srcoffset+size]
  
    _arraycopy__3II_3III =  __arraycopy
    _arraycopy__3JI_3JII = __arraycopy
    _arraycopy__3_3II_3_3III = __arraycopy
    _arraycopy__3_3DI_3_3DII = __arraycopy
    _arraycopy__3DI_3DII = __arraycopy
    _arraycopy__3IJ_3IJJ = __arraycopy
    _arraycopy__3JJ_3JJJ = __arraycopy
    _arraycopy__3DJ_3DJJ = __arraycopy
  
    @staticmethod
    def __arrayclone(a): 
      if isinstance(a,numpy.ndarray):
        return a.copy()
      else:      
        return numpy.array(a)
  
    _arraycopy__3D = __arrayclone
    _arraycopy__3I = __arrayclone
    _arraycopy__3J = __arrayclone
    _arraycopy__3S = __arrayclone
  
    @staticmethod
    def __arraylength(a): return len(a)
  
    _arraylength__3Lmosek_4fusion_4Variable_2   = __arraylength
    _arraylength__3Lmosek_4fusion_4Constranit_2 = __arraylength  
    _arraylength__3Lmosek_4fusion_4Matrix_2     = __arraylength  
    _arraylength__3S   = __arraylength  
    _arraylength__3I   = __arraylength  
    _arraylength__3J   = __arraylength  
    _arraylength__3D   = __arraylength  
    _arraylength__3_3D = __arraylength  
    _arraylength__3_3I = __arraylength  
    _uarraylength__3I  = __arraylength 
    _uarraylength__3J  = __arraylength 
    _uarraylength__3D  = __arraylength 
    _uarraylength__3Lmosek_4fusion_4Variable_2   = __arraylength 
    _uarraylength__3Lmosek_4fusion_4Constraint_2 = __arraylength 
    _uarraylength__3Lmosek_4fusion_4Matrix_2     = __arraylength 
    _uarraylength__3_3S = __arraylength 
    _uarraylength__3_3D = __arraylength 
    _uarraylength__3_3I = __arraylength 
  
    @staticmethod
    def __matrixheight(m): return m.shape[0]
    @staticmethod
    def __matrixwidth(m): return m.shape[1]
    
    _matrixheight__3_3D = __matrixheight
    _matrixwidth__3_3D  = __matrixwidth
    _matrixheight__3_3Lmosek_4fusion_4Matrix_2 = __matrixheight
    _matrixwidth__3_3Lmosek_4fusion_4Matrix_2  = __matrixwidth
   
    @staticmethod   
    def _range_J (last): return numpy.arange(last,dtype=numpy.int64)
    @staticmethod   
    def _range_JJ(first,last): return numpy.arange(first,last,dtype=numpy.int64)
    @staticmethod   
    def _range_JJJ(first,last,step): return numpy.arange(first,last,step,dtype=numpy.int64)
  
    @staticmethod   
    def _range_I (last): return numpy.arange(last,dtype=numpy.int32)
    @staticmethod   
    def _range_II(first,last): return numpy.arange(first,last,dtype=numpy.int32)
    @staticmethod   
    def _range_III(first,last,step): return numpy.arange(first,last,step,dtype=numpy.int32)
  
    @staticmethod   
    def _zeros_I (num): return  numpy.zeros((num,),dtype=numpy.float64)
    @staticmethod   
    def _zeros_II (dimi,dimj): return  numpy.zeros((dimi,dimj),dtype=numpy.float64)
    @staticmethod   
    def _ones_I(num):  return  numpy.ones((num,),numpy.float64)
    
    __rand = random.Random()
    @staticmethod   
    def _randInt_I(max):
      return Tools.__rand.randint(0,max-1)
      
    @staticmethod   
    def _argsort__3J_3I_3JII(perm,val1,val2,first,last):
      if last-first > 1:
        p = list(perm[first:last])
        p.sort(lambda lhs,rhs: cmp(val1[lhs],val1[rhs]) or cmp(val2[lhs],val2[rhs]))
        perm[first:last] = p
  
    @staticmethod   
    def _argsort__3J_3I_3I(perm,val1,val2):    
      Tools._argsort__3I_3I_3III(perm,val1,val2,0,len(perm))
    
    @staticmethod   
    def _argsort__3J_3I(perm,vals):
      Tools._argsort__3I_3III(perm,vals,0,len(perm))
  
    @staticmethod   
    def _argsort__3J_3III(perm,val,first,last):
      if last-first > 1:
        p = list(perm[first:last])
        p.sort(lambda lhs,rhs: cmp(val[lhs],val[rhs]))
        perm[first:last] = p
  
    @staticmethod
    def _sort__3I_II (vals,first,last):
      if last-first > 1:
        tmp = vals[first:last]
        tmp.sort()
        vals[first:last] = tmp
  
    @staticmethod   
    def _makevector_DI(val,num): 
      r = numpy.zeros((num,), numpy.float64)
      r[:] = val
      return r
    @staticmethod   
    def _makevector_II(val,num): 
      r = numpy.zeros((num,), numpy.int32)
      r[:] = val
      return r
    @staticmethod   
    def _makevector_JI(val,num): 
      r = numpy.zeros((num,), numpy.int64)
      r[:] = val
      return r
    @staticmethod   
    def _repeatrange_III(first,last,num):
      res = numpy.zeros(((last-first)*num,),numpy.int32)
      ra = numpy.arange(first,last)
      l = last-first
      for i in range(num):
        res[i*l:(i+1)*l] = ra
      return res
    @staticmethod   
    def _repeatrange_JJJ(first,last,num):
      res = numpy.zeros(((last-first)*num,),numpy.int64)
      ra = numpy.arange(first,last)
      l = last-first
      for i in range(num):
        res[i*l:(i+1)*l] = ra
      return res
    @staticmethod
    def  _stringvalue_I(v): return str(v)
    @staticmethod
    def  _stringvalue_J(v): return str(v)
  
    @staticmethod
    def _toDouble_S(v):    
      return float(v)
  
    @staticmethod
    def _sqrt_D(v):
      return math.sqrt(v)
    
    @staticmethod
    def _toInt_S(v):
      return int(v)
  
  
    @staticmethod 
    def _argsort2(perm,v,first,last):
      l = sorted(perm[first:last],key=lambda i: v[i])
      perm[first:last] = l
    
    @staticmethod 
    def _argsort2x(perm,v0,v1,first,last):
      l = sorted(perm[first:last],key=lambda i: (v0[i],v1[i]))
      perm[first:last] = l
  
  
  
    @staticmethod 
    def _argsort__3J_3IJJ(perm,v,first,last):
      return Tools._argsort2(perm,v,first,last)
    
    @staticmethod 
    def _argsort__3J_3JJJ(perm,v,first,last):
      return Tools._argsort2(perm,v,first,last)
  
    @staticmethod 
    def _argsort__3J_3I_3IJJ(perm,v0,v1,first,last):
      return Tools._argsort2x(perm,v0,v1,first,last)
    
    @staticmethod 
    def _argsort__3J_3J_3JJJ(perm,v0,v1,first,last):
      return Tools._argsort2x(perm,v0,v1,first,last)
  
    @staticmethod
    def _bucketsort__3JJJ_3III(perm,first,last,v,minval,maxval):
      if True:
        count = numpy.zeros((maxval-minval+2,),numpy.int64)
        for i in range(first,last): count[v[perm[i]]-minval+1] += 1
        ptrb = count.cumsum()
        rperm = numpy.zeros((last-first,),numpy.int64)
        for i in range(first,last):
          rperm[ptrb[v[perm[i]]-minval]] = perm[i]
          ptrb[v[perm[i]]-minval] += 1
        perm[first:last] = rperm
  
      else:
        perm_ct = perm.ctypes
        v_ct    = v.ctypes
        if perm_ct.strides[0] == 8:
          #print( perm_ct.strides[:], perm_ct.shape[:],perm_ct.get_data())
          arg_perm  = perm_ct.data_as(ctypes.POINTER(ctypes.c_longlong))
          copy_perm = False
        else:
          tmpperm = numpy.array(perm_ct[first:last],numpy.int64)
          arg_perm  = tmpperm.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong))
          copy_perm = True
  
        if v_ct.strides[0] == 4:
          arg_v = v_ct.data_as(ctypes.POINTER(ctypes.c_int))
          copy_v = False
        else:
          tmpv = numpy.array(v_ct,numpy.int32)
          arg_v  = tmpv.ctypes.data_as(ctypes.POINTER(ctypes.c_int))
          copy_v = True
  
        n = last-first
        m = maxval - minval + 1
        workspace = (ctypes.c_longlong*(m+n))()
  
        mosek.__library__.MSK_bucketsort__3JS_3III_3V(arg_perm,first,last,arg_v,minval,maxval,workspace)
        del arg_perm,arg_v
  
        if copy_v: 
          v[:] = tmpv
          del tmpv
        if copy_perm: 
          perm[first:last] = tmpperm
          del tmpperm
  
      
    @staticmethod
    def _bucketsort__3JJJ_3JJJ(perm,first,last,v,minval,maxval):
      if True:
        count = numpy.zeros((maxval-minval+2,),numpy.int64)
        for i in range(first,last): count[v[perm[i]]-minval+1] += 1
        ptrb = count.cumsum()
        rperm = numpy.zeros((last-first,),numpy.int64)
        for i in range(first,last):
          rperm[ptrb[v[perm[i]]-minval]] = perm[i]
          ptrb[v[perm[i]]-minval] += 1
        perm[first:last] = rperm
        #print( rperm,v)
  
      else:
        perm_ct = perm.ctypes
        v_ct    = v.ctypes
        
       
        if perm_ct.strides[0] == 8:
          arg_perm  = perm_ct.data_as(ctypes.POINTER(ctypes.c_longlong))
          copy_perm = False
        else:
          tmpperm = numpy.array(perm_ct[first:last],numpy.int64)
          arg_perm  = tmpperm.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong))
          copy_perm = True
  
  
        if v_ct.strides[0] == 8:
          arg_v = v_ct.data_as(ctypes.POINTER(ctypes.c_longlong))
          copy_v = False
        else:
          tmpv = numpy.array(v_ct,numpy.int64)
          arg_v  = tmpv.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong))
          copy_v = True
  
        n = last-first
        m = maxval - minval + 1
        workspace = (ctypes.c_longlong*(m+n))()
  
        mosek.__library__.MSK_bucketsort__3JS_3JJJ_3V(arg_perm,first,last,arg_v,minval,maxval,workspace)
  
        if copy_v: v[:] = tmpv
        if copy_perm: perm[first:last] = tmpperm
  
  
  
  
  return Tools
mosek_fusion_Utils_Tools=__mk_mosek_fusion_Utils_Tools()
def __mk_mosek_fusion_SolverInfo():
  from bisect import bisect_left
  import mosek
  class SolverInfo:
    dinfnames  = [ "biCleanDualTime","biCleanPrimalTime","biCleanTime","biDualTime","biPrimalTime","biTime","intpntDualFeas","intpntDualObj","intpntFactorNumFlops","intpntOptStatus","intpntOrderTime","intpntPrimalFeas","intpntPrimalObj","intpntTime","mioCliqueSeparationTime","mioCmirSeparationTime","mioConstructSolutionObj","mioDualBoundAfterPresolve","mioGmiSeparationTime","mioHeuristicTime","mioImpliedBoundTime","mioKnapsackCoverSeparationTime","mioObjAbsGap","mioObjBound","mioObjInt","mioObjRelGap","mioOptimizerTime","mioProbingTime","mioRootCutgenTime","mioRootOptimizerTime","mioRootPresolveTime","mioTime","mioUserObjCut","optimizerTime","presolveEliTime","presolveLindepTime","presolveTime","primalRepairPenaltyObj","qcqoReformulateMaxPerturbation","qcqoReformulateTime","qcqoReformulateWorstCholeskyColumnScaling","qcqoReformulateWorstCholeskyDiagScaling","rdTime","simDualTime","simFeas","simObj","simPrimalTime","simTime","solBasDualObj","solBasDviolcon","solBasDviolvar","solBasNrmBarx","solBasNrmSlc","solBasNrmSlx","solBasNrmSuc","solBasNrmSux","solBasNrmXc","solBasNrmXx","solBasNrmY","solBasPrimalObj","solBasPviolcon","solBasPviolvar","solItgNrmBarx","solItgNrmXc","solItgNrmXx","solItgPrimalObj","solItgPviolbarvar","solItgPviolcon","solItgPviolcones","solItgPviolitg","solItgPviolvar","solItrDualObj","solItrDviolbarvar","solItrDviolcon","solItrDviolcones","solItrDviolvar","solItrNrmBars","solItrNrmBarx","solItrNrmSlc","solItrNrmSlx","solItrNrmSnx","solItrNrmSuc","solItrNrmSux","solItrNrmXc","solItrNrmXx","solItrNrmY","solItrPrimalObj","solItrPviolbarvar","solItrPviolcon","solItrPviolcones","solItrPviolvar","toConicTime" ];
    iinfnames  = [ "anaProNumCon","anaProNumConEq","anaProNumConFr","anaProNumConLo","anaProNumConRa","anaProNumConUp","anaProNumVar","anaProNumVarBin","anaProNumVarCont","anaProNumVarEq","anaProNumVarFr","anaProNumVarInt","anaProNumVarLo","anaProNumVarRa","anaProNumVarUp","intpntFactorDimDense","intpntIter","intpntNumThreads","intpntSolveDual","mioAbsgapSatisfied","mioCliqueTableSize","mioConstructNumRoundings","mioConstructSolution","mioInitialSolution","mioNearAbsgapSatisfied","mioNearRelgapSatisfied","mioNodeDepth","mioNumActiveNodes","mioNumBranch","mioNumCliqueCuts","mioNumCmirCuts","mioNumGomoryCuts","mioNumImpliedBoundCuts","mioNumIntSolutions","mioNumKnapsackCoverCuts","mioNumRelax","mioNumRepeatedPresolve","mioNumcon","mioNumint","mioNumvar","mioObjBoundDefined","mioPresolvedNumbin","mioPresolvedNumcon","mioPresolvedNumcont","mioPresolvedNumint","mioPresolvedNumvar","mioRelgapSatisfied","mioTotalNumCuts","mioUserObjCut","optNumcon","optNumvar","optimizeResponse","rdNumbarvar","rdNumcon","rdNumcone","rdNumintvar","rdNumq","rdNumvar","rdProtype","simDualDegIter","simDualHotstart","simDualHotstartLu","simDualInfIter","simDualIter","simNumcon","simNumvar","simPrimalDegIter","simPrimalHotstart","simPrimalHotstartLu","simPrimalInfIter","simPrimalIter","simSolveDual","solBasProsta","solBasSolsta","solItgProsta","solItgSolsta","solItrProsta","solItrSolsta","stoNumARealloc" ];
    liinfnames = [ "biCleanDualDegIter","biCleanDualIter","biCleanPrimalDegIter","biCleanPrimalIter","biDualIter","biPrimalIter","intpntFactorNumNz","mioIntpntIter","mioPresolvedAnz","mioSimMaxiterSetbacks","mioSimplexIter","rdNumanz","rdNumqnz" ];
    dinfsyms   = [ mosek.dinfitem.bi_clean_dual_time,mosek.dinfitem.bi_clean_primal_time,mosek.dinfitem.bi_clean_time,mosek.dinfitem.bi_dual_time,mosek.dinfitem.bi_primal_time,mosek.dinfitem.bi_time,mosek.dinfitem.intpnt_dual_feas,mosek.dinfitem.intpnt_dual_obj,mosek.dinfitem.intpnt_factor_num_flops,mosek.dinfitem.intpnt_opt_status,mosek.dinfitem.intpnt_order_time,mosek.dinfitem.intpnt_primal_feas,mosek.dinfitem.intpnt_primal_obj,mosek.dinfitem.intpnt_time,mosek.dinfitem.mio_clique_separation_time,mosek.dinfitem.mio_cmir_separation_time,mosek.dinfitem.mio_construct_solution_obj,mosek.dinfitem.mio_dual_bound_after_presolve,mosek.dinfitem.mio_gmi_separation_time,mosek.dinfitem.mio_heuristic_time,mosek.dinfitem.mio_implied_bound_time,mosek.dinfitem.mio_knapsack_cover_separation_time,mosek.dinfitem.mio_obj_abs_gap,mosek.dinfitem.mio_obj_bound,mosek.dinfitem.mio_obj_int,mosek.dinfitem.mio_obj_rel_gap,mosek.dinfitem.mio_optimizer_time,mosek.dinfitem.mio_probing_time,mosek.dinfitem.mio_root_cutgen_time,mosek.dinfitem.mio_root_optimizer_time,mosek.dinfitem.mio_root_presolve_time,mosek.dinfitem.mio_time,mosek.dinfitem.mio_user_obj_cut,mosek.dinfitem.optimizer_time,mosek.dinfitem.presolve_eli_time,mosek.dinfitem.presolve_lindep_time,mosek.dinfitem.presolve_time,mosek.dinfitem.primal_repair_penalty_obj,mosek.dinfitem.qcqo_reformulate_max_perturbation,mosek.dinfitem.qcqo_reformulate_time,mosek.dinfitem.qcqo_reformulate_worst_cholesky_column_scaling,mosek.dinfitem.qcqo_reformulate_worst_cholesky_diag_scaling,mosek.dinfitem.rd_time,mosek.dinfitem.sim_dual_time,mosek.dinfitem.sim_feas,mosek.dinfitem.sim_obj,mosek.dinfitem.sim_primal_time,mosek.dinfitem.sim_time,mosek.dinfitem.sol_bas_dual_obj,mosek.dinfitem.sol_bas_dviolcon,mosek.dinfitem.sol_bas_dviolvar,mosek.dinfitem.sol_bas_nrm_barx,mosek.dinfitem.sol_bas_nrm_slc,mosek.dinfitem.sol_bas_nrm_slx,mosek.dinfitem.sol_bas_nrm_suc,mosek.dinfitem.sol_bas_nrm_sux,mosek.dinfitem.sol_bas_nrm_xc,mosek.dinfitem.sol_bas_nrm_xx,mosek.dinfitem.sol_bas_nrm_y,mosek.dinfitem.sol_bas_primal_obj,mosek.dinfitem.sol_bas_pviolcon,mosek.dinfitem.sol_bas_pviolvar,mosek.dinfitem.sol_itg_nrm_barx,mosek.dinfitem.sol_itg_nrm_xc,mosek.dinfitem.sol_itg_nrm_xx,mosek.dinfitem.sol_itg_primal_obj,mosek.dinfitem.sol_itg_pviolbarvar,mosek.dinfitem.sol_itg_pviolcon,mosek.dinfitem.sol_itg_pviolcones,mosek.dinfitem.sol_itg_pviolitg,mosek.dinfitem.sol_itg_pviolvar,mosek.dinfitem.sol_itr_dual_obj,mosek.dinfitem.sol_itr_dviolbarvar,mosek.dinfitem.sol_itr_dviolcon,mosek.dinfitem.sol_itr_dviolcones,mosek.dinfitem.sol_itr_dviolvar,mosek.dinfitem.sol_itr_nrm_bars,mosek.dinfitem.sol_itr_nrm_barx,mosek.dinfitem.sol_itr_nrm_slc,mosek.dinfitem.sol_itr_nrm_slx,mosek.dinfitem.sol_itr_nrm_snx,mosek.dinfitem.sol_itr_nrm_suc,mosek.dinfitem.sol_itr_nrm_sux,mosek.dinfitem.sol_itr_nrm_xc,mosek.dinfitem.sol_itr_nrm_xx,mosek.dinfitem.sol_itr_nrm_y,mosek.dinfitem.sol_itr_primal_obj,mosek.dinfitem.sol_itr_pviolbarvar,mosek.dinfitem.sol_itr_pviolcon,mosek.dinfitem.sol_itr_pviolcones,mosek.dinfitem.sol_itr_pviolvar,mosek.dinfitem.to_conic_time ];
    iinfsyms   = [ mosek.iinfitem.ana_pro_num_con,mosek.iinfitem.ana_pro_num_con_eq,mosek.iinfitem.ana_pro_num_con_fr,mosek.iinfitem.ana_pro_num_con_lo,mosek.iinfitem.ana_pro_num_con_ra,mosek.iinfitem.ana_pro_num_con_up,mosek.iinfitem.ana_pro_num_var,mosek.iinfitem.ana_pro_num_var_bin,mosek.iinfitem.ana_pro_num_var_cont,mosek.iinfitem.ana_pro_num_var_eq,mosek.iinfitem.ana_pro_num_var_fr,mosek.iinfitem.ana_pro_num_var_int,mosek.iinfitem.ana_pro_num_var_lo,mosek.iinfitem.ana_pro_num_var_ra,mosek.iinfitem.ana_pro_num_var_up,mosek.iinfitem.intpnt_factor_dim_dense,mosek.iinfitem.intpnt_iter,mosek.iinfitem.intpnt_num_threads,mosek.iinfitem.intpnt_solve_dual,mosek.iinfitem.mio_absgap_satisfied,mosek.iinfitem.mio_clique_table_size,mosek.iinfitem.mio_construct_num_roundings,mosek.iinfitem.mio_construct_solution,mosek.iinfitem.mio_initial_solution,mosek.iinfitem.mio_near_absgap_satisfied,mosek.iinfitem.mio_near_relgap_satisfied,mosek.iinfitem.mio_node_depth,mosek.iinfitem.mio_num_active_nodes,mosek.iinfitem.mio_num_branch,mosek.iinfitem.mio_num_clique_cuts,mosek.iinfitem.mio_num_cmir_cuts,mosek.iinfitem.mio_num_gomory_cuts,mosek.iinfitem.mio_num_implied_bound_cuts,mosek.iinfitem.mio_num_int_solutions,mosek.iinfitem.mio_num_knapsack_cover_cuts,mosek.iinfitem.mio_num_relax,mosek.iinfitem.mio_num_repeated_presolve,mosek.iinfitem.mio_numcon,mosek.iinfitem.mio_numint,mosek.iinfitem.mio_numvar,mosek.iinfitem.mio_obj_bound_defined,mosek.iinfitem.mio_presolved_numbin,mosek.iinfitem.mio_presolved_numcon,mosek.iinfitem.mio_presolved_numcont,mosek.iinfitem.mio_presolved_numint,mosek.iinfitem.mio_presolved_numvar,mosek.iinfitem.mio_relgap_satisfied,mosek.iinfitem.mio_total_num_cuts,mosek.iinfitem.mio_user_obj_cut,mosek.iinfitem.opt_numcon,mosek.iinfitem.opt_numvar,mosek.iinfitem.optimize_response,mosek.iinfitem.rd_numbarvar,mosek.iinfitem.rd_numcon,mosek.iinfitem.rd_numcone,mosek.iinfitem.rd_numintvar,mosek.iinfitem.rd_numq,mosek.iinfitem.rd_numvar,mosek.iinfitem.rd_protype,mosek.iinfitem.sim_dual_deg_iter,mosek.iinfitem.sim_dual_hotstart,mosek.iinfitem.sim_dual_hotstart_lu,mosek.iinfitem.sim_dual_inf_iter,mosek.iinfitem.sim_dual_iter,mosek.iinfitem.sim_numcon,mosek.iinfitem.sim_numvar,mosek.iinfitem.sim_primal_deg_iter,mosek.iinfitem.sim_primal_hotstart,mosek.iinfitem.sim_primal_hotstart_lu,mosek.iinfitem.sim_primal_inf_iter,mosek.iinfitem.sim_primal_iter,mosek.iinfitem.sim_solve_dual,mosek.iinfitem.sol_bas_prosta,mosek.iinfitem.sol_bas_solsta,mosek.iinfitem.sol_itg_prosta,mosek.iinfitem.sol_itg_solsta,mosek.iinfitem.sol_itr_prosta,mosek.iinfitem.sol_itr_solsta,mosek.iinfitem.sto_num_a_realloc ];
    liinfsyms  = [ mosek.liinfitem.bi_clean_dual_deg_iter,mosek.liinfitem.bi_clean_dual_iter,mosek.liinfitem.bi_clean_primal_deg_iter,mosek.liinfitem.bi_clean_primal_iter,mosek.liinfitem.bi_dual_iter,mosek.liinfitem.bi_primal_iter,mosek.liinfitem.intpnt_factor_num_nz,mosek.liinfitem.mio_intpnt_iter,mosek.liinfitem.mio_presolved_anz,mosek.liinfitem.mio_sim_maxiter_setbacks,mosek.liinfitem.mio_simplex_iter,mosek.liinfitem.rd_numanz,mosek.liinfitem.rd_numqnz ];
    @staticmethod
    def _getdouinf(infname):
      idx = bisect_left(SolverInfo.dinfnames, infname)
      if idx != len(SolverInfo.dinfnames) and SolverInfo.dinfnames[idx] == infname:
        return SolverInfo.dinfsyms[idx]
      else:
        return None
    @staticmethod
    def _getintinf(infname):
      idx = bisect_left(SolverInfo.iinfnames, infname)
      if idx != len(SolverInfo.iinfnames) and SolverInfo.iinfnames[idx] == infname:
        return SolverInfo.iinfsyms[idx]
      else:
        return None
    @staticmethod
    def _getlintinf(infname):
      idx = bisect_left(SolverInfo.liinfnames, infname)
      if idx != len(SolverInfo.liinfnames) and SolverInfo.liinfnames[idx] == infname:
        return SolverInfo.liinfsyms[idx]
      else:
        return None
  return SolverInfo
mosek_fusion_SolverInfo=__mk_mosek_fusion_SolverInfo()
def __arg_match_Emosek_4fusion_4PSDKey_2__(v):
  return isinstance(v,mosek_fusion_PSDKey)
def __arg_alt_match_Emosek_4fusion_4PSDKey_2__(v):
  return isinstance(v,mosek_fusion_PSDKey)
def __arg_match_Lmosek_4fusion_4PSDConstraint_2__(v):
  return v is None or isinstance(v,mosek_fusion_PSDConstraint)
def __arg_alt_match_Lmosek_4fusion_4PSDConstraint_2__(v):
  return __arg_match_Lmosek_4fusion_4PSDConstraint_2__(v)
def __arg_match_Emosek_4fusion_4SolutionType_2__(v):
  return isinstance(v,mosek_fusion_SolutionType)
def __arg_alt_match_Emosek_4fusion_4SolutionType_2__(v):
  return isinstance(v,mosek_fusion_SolutionType)
def __arg_match_Lmosek_4fusion_4RangedVariable_2__(v):
  return v is None or isinstance(v,mosek_fusion_RangedVariable)
def __arg_alt_match_Lmosek_4fusion_4RangedVariable_2__(v):
  return __arg_match_Lmosek_4fusion_4RangedVariable_2__(v)
def __arg_match_Lmosek_4fusion_4NDSparseArray_2__(v):
  return v is None or isinstance(v,mosek_fusion_NDSparseArray)
def __arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(v):
  return __arg_match_Lmosek_4fusion_4NDSparseArray_2__(v)
def __arg_match__3_3D__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([__arg_match__3D__(i) for i in v.flatten()])
def __arg_alt_match__3_3D__(v):
  return __arg_match__3_3D__(v) or __arg_match_listof__(v,__arg_alt_match__3D__)
def __arg_match_Lmosek_4fusion_4RangedConstraint_2__(v):
  return v is None or isinstance(v,mosek_fusion_RangedConstraint)
def __arg_alt_match_Lmosek_4fusion_4RangedConstraint_2__(v):
  return __arg_match_Lmosek_4fusion_4RangedConstraint_2__(v)
def __arg_match_Lmosek_4fusion_4ModelVariable_2__(v):
  return v is None or isinstance(v,mosek_fusion_ModelVariable)
def __arg_alt_match_Lmosek_4fusion_4ModelVariable_2__(v):
  return __arg_match_Lmosek_4fusion_4ModelVariable_2__(v)
def __arg_match_Lmosek_4fusion_4Set_2__(v):
  return v is None or isinstance(v,mosek_fusion_Set)
def __arg_alt_match_Lmosek_4fusion_4Set_2__(v):
  return __arg_match_Lmosek_4fusion_4Set_2__(v)
def __arg_match_Lmosek_4fusion_4QConeDomain_2__(v):
  return v is None or isinstance(v,mosek_fusion_QConeDomain)
def __arg_alt_match_Lmosek_4fusion_4QConeDomain_2__(v):
  return __arg_match_Lmosek_4fusion_4QConeDomain_2__(v)
def __arg_match_Lmosek_4fusion_4LinPSDDomain_2__(v):
  return v is None or isinstance(v,mosek_fusion_LinPSDDomain)
def __arg_alt_match_Lmosek_4fusion_4LinPSDDomain_2__(v):
  return __arg_match_Lmosek_4fusion_4LinPSDDomain_2__(v)
def __arg_match__3Lmosek_4fusion_4Expression_2__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([isinstance(i,mosek_fusion_Expression) for i in v.flatten()])
def __arg_alt_match__3Lmosek_4fusion_4Expression_2__(v):
  return __arg_match__3Lmosek_4fusion_4Expression_2__(v) or __arg_match_listof__(v,__arg_alt_match_Lmosek_4fusion_4Expression_2__)
def __arg_match_J__(v):
  return isinstance(v,numpy.int64) or isinstance(v,long) or isinstance(v,int) or isinstance(v,numpy.int32)
def __arg_alt_match_J__(v):
  return __arg_match_J__(v)
def __arg_match_Lmosek_4fusion_4Constraint_2__(v):
  return v is None or isinstance(v,mosek_fusion_Constraint)
def __arg_alt_match_Lmosek_4fusion_4Constraint_2__(v):
  return __arg_match_Lmosek_4fusion_4Constraint_2__(v)
def __arg_match__3J__(v):
  return v is None or (isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(numpy.int64))
def __arg_alt_match__3J__(v):
  return __arg_match__3J__(v) or __arg_match_listof__(v,__arg_alt_match_J__)
def __arg_match__3_3J__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([__arg_match__3J__(i) for i in v.flatten()])
def __arg_alt_match__3_3J__(v):
  return __arg_match__3_3J__(v) or __arg_match_listof__(v,__arg_alt_match__3J__)
def __arg_match_Lmosek_4fusion_4LinearPSDConstraint_2__(v):
  return v is None or isinstance(v,mosek_fusion_LinearPSDConstraint)
def __arg_alt_match_Lmosek_4fusion_4LinearPSDConstraint_2__(v):
  return __arg_match_Lmosek_4fusion_4LinearPSDConstraint_2__(v)
def __arg_match_Lmosek_4fusion_4SymRangedVariable_2__(v):
  return v is None or isinstance(v,mosek_fusion_SymRangedVariable)
def __arg_alt_match_Lmosek_4fusion_4SymRangedVariable_2__(v):
  return __arg_match_Lmosek_4fusion_4SymRangedVariable_2__(v)
def __arg_match_Lmosek_4fusion_4LinearPSDVariable_2__(v):
  return v is None or isinstance(v,mosek_fusion_LinearPSDVariable)
def __arg_alt_match_Lmosek_4fusion_4LinearPSDVariable_2__(v):
  return __arg_match_Lmosek_4fusion_4LinearPSDVariable_2__(v)
def __arg_match_Lmosek_4fusion_4ConstraintCache_2__(v):
  return v is None or isinstance(v,mosek_fusion_ConstraintCache)
def __arg_alt_match_Lmosek_4fusion_4ConstraintCache_2__(v):
  return __arg_match_Lmosek_4fusion_4ConstraintCache_2__(v)
def __arg_match__3Lmosek_4fusion_4Variable_2__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([isinstance(i,mosek_fusion_Variable) for i in v.flatten()])
def __arg_alt_match__3Lmosek_4fusion_4Variable_2__(v):
  return __arg_match__3Lmosek_4fusion_4Variable_2__(v) or __arg_match_listof__(v,__arg_alt_match_Lmosek_4fusion_4Variable_2__)
def __arg_match_Lmosek_4fusion_4SymmetricMatrix_2__(v):
  return v is None or isinstance(v,mosek_fusion_SymmetricMatrix)
def __arg_alt_match_Lmosek_4fusion_4SymmetricMatrix_2__(v):
  return __arg_match_Lmosek_4fusion_4SymmetricMatrix_2__(v)
def __arg_match__3D__(v):
  return v is None or (isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(numpy.float64))
def __arg_alt_match__3D__(v):
  return __arg_match__3D__(v) or __arg_match_listof__(v,__arg_alt_match_D__)
def __arg_match_Lmosek_4fusion_4ConicVariable_2__(v):
  return v is None or isinstance(v,mosek_fusion_ConicVariable)
def __arg_alt_match_Lmosek_4fusion_4ConicVariable_2__(v):
  return __arg_match_Lmosek_4fusion_4ConicVariable_2__(v)
def __arg_match_Lmosek_4fusion_4SymmetricRangeDomain_2__(v):
  return v is None or isinstance(v,mosek_fusion_SymmetricRangeDomain)
def __arg_alt_match_Lmosek_4fusion_4SymmetricRangeDomain_2__(v):
  return __arg_match_Lmosek_4fusion_4SymmetricRangeDomain_2__(v)
def __arg_match_Lmosek_4fusion_4FlatExpr_2__(v):
  return v is None or isinstance(v,mosek_fusion_FlatExpr)
def __arg_alt_match_Lmosek_4fusion_4FlatExpr_2__(v):
  return __arg_match_Lmosek_4fusion_4FlatExpr_2__(v)
def __arg_match__3I__(v):
  return v is None or (isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(numpy.int32))
def __arg_alt_match__3I__(v):
  return __arg_match__3I__(v) or __arg_match_listof__(v,__arg_alt_match_I__)
def __arg_match__3_5D__(v):
  return v is None or (isinstance(v,numpy.ndarray) and v.ndim == 2 and v.dtype == numpy.dtype(numpy.float64))
def __arg_alt_match__3_5D__(v):
  return _monty.arg_match_sloppy_array(v,__arg_alt_match_D__,2)
def __arg_match_LSystem_4StreamWriter_2__(v):
  return v is None or isinstance(v,object)
def __arg_alt_match_LSystem_4StreamWriter_2__(v):
  return __arg_match_LSystem_4StreamWriter_2__(v)
def __arg_match_Lmosek_4fusion_4LinearVariable_2__(v):
  return v is None or isinstance(v,mosek_fusion_LinearVariable)
def __arg_alt_match_Lmosek_4fusion_4LinearVariable_2__(v):
  return __arg_match_Lmosek_4fusion_4LinearVariable_2__(v)
def __arg_match_Lmosek_4fusion_4RangeDomain_2__(v):
  return v is None or isinstance(v,mosek_fusion_RangeDomain)
def __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(v):
  return __arg_match_Lmosek_4fusion_4RangeDomain_2__(v)
def __arg_match_I__(v):
  return isinstance(v,numpy.int32) or isinstance(v,int)
def __arg_alt_match_I__(v):
  return __arg_match_I__(v)
def __arg_match__3S__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == object and all([isinstance(i0,basestring) for i0 in v ])
def __arg_alt_match__3S__(v):
  return __arg_match__3S__(v) or __arg_match_listof__(v,__arg_alt_match_S__)
def __arg_match_Lmosek_4fusion_4PSDDomain_2__(v):
  return v is None or isinstance(v,mosek_fusion_PSDDomain)
def __arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(v):
  return __arg_match_Lmosek_4fusion_4PSDDomain_2__(v)
def __arg_match_Lmosek_4fusion_4LinearDomain_2__(v):
  return v is None or isinstance(v,mosek_fusion_LinearDomain)
def __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(v):
  return __arg_match_Lmosek_4fusion_4LinearDomain_2__(v)
def __arg_match__3_5I__(v):
  return v is None or (isinstance(v,numpy.ndarray) and v.ndim == 2 and v.dtype == numpy.dtype(numpy.int32))
def __arg_alt_match__3_5I__(v):
  return _monty.arg_match_sloppy_array(v,__arg_alt_match_I__,2)
def __arg_match_Emosek_4fusion_4SolutionStatus_2__(v):
  return isinstance(v,mosek_fusion_SolutionStatus)
def __arg_alt_match_Emosek_4fusion_4SolutionStatus_2__(v):
  return isinstance(v,mosek_fusion_SolutionStatus)
def __arg_match_LSystem_4CallbackHandler_2__(v):
  return v is None or isinstance(v,object)
def __arg_alt_match_LSystem_4CallbackHandler_2__(v):
  return __arg_match_LSystem_4CallbackHandler_2__(v)
def __arg_match_Lmosek_4fusion_4Matrix_2__(v):
  return v is None or isinstance(v,mosek_fusion_Matrix)
def __arg_alt_match_Lmosek_4fusion_4Matrix_2__(v):
  return __arg_match_Lmosek_4fusion_4Matrix_2__(v)
def __arg_match_Emosek_4fusion_4AccSolutionStatus_2__(v):
  return isinstance(v,mosek_fusion_AccSolutionStatus)
def __arg_alt_match_Emosek_4fusion_4AccSolutionStatus_2__(v):
  return isinstance(v,mosek_fusion_AccSolutionStatus)
def __arg_match__3Lmosek_4fusion_4Constraint_2__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([isinstance(i,mosek_fusion_Constraint) for i in v.flatten()])
def __arg_alt_match__3Lmosek_4fusion_4Constraint_2__(v):
  return __arg_match__3Lmosek_4fusion_4Constraint_2__(v) or __arg_match_listof__(v,__arg_alt_match_Lmosek_4fusion_4Constraint_2__)
def __arg_match_Lmosek_4fusion_4ModelConstraint_2__(v):
  return v is None or isinstance(v,mosek_fusion_ModelConstraint)
def __arg_alt_match_Lmosek_4fusion_4ModelConstraint_2__(v):
  return __arg_match_Lmosek_4fusion_4ModelConstraint_2__(v)
def __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(v):
  return v is None or isinstance(v,mosek_fusion_Utils_StringBuffer)
def __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(v):
  return __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(v)
def __arg_match_Lmosek_4fusion_4PSDVariable_2__(v):
  return v is None or isinstance(v,mosek_fusion_PSDVariable)
def __arg_alt_match_Lmosek_4fusion_4PSDVariable_2__(v):
  return __arg_match_Lmosek_4fusion_4PSDVariable_2__(v)
def __arg_match__3_3I__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([__arg_match__3I__(i) for i in v.flatten()])
def __arg_alt_match__3_3I__(v):
  return __arg_match__3_3I__(v) or __arg_match_listof__(v,__arg_alt_match__3I__)
def __arg_match__3Lmosek_4fusion_4Set_2__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([isinstance(i,mosek_fusion_Set) for i in v.flatten()])
def __arg_alt_match__3Lmosek_4fusion_4Set_2__(v):
  return __arg_match__3Lmosek_4fusion_4Set_2__(v) or __arg_match_listof__(v,__arg_alt_match_Lmosek_4fusion_4Set_2__)
def __arg_match_Lmosek_4fusion_4BaseVariable_2__(v):
  return v is None or isinstance(v,mosek_fusion_BaseVariable)
def __arg_alt_match_Lmosek_4fusion_4BaseVariable_2__(v):
  return __arg_match_Lmosek_4fusion_4BaseVariable_2__(v)
def __arg_match_Lmosek_4fusion_4Model_2__(v):
  return v is None or isinstance(v,mosek_fusion_Model)
def __arg_alt_match_Lmosek_4fusion_4Model_2__(v):
  return __arg_match_Lmosek_4fusion_4Model_2__(v)
def __arg_match_Lmosek_4fusion_4SymmetricLinearDomain_2__(v):
  return v is None or isinstance(v,mosek_fusion_SymmetricLinearDomain)
def __arg_alt_match_Lmosek_4fusion_4SymmetricLinearDomain_2__(v):
  return __arg_match_Lmosek_4fusion_4SymmetricLinearDomain_2__(v)
def __arg_match_Lmosek_4fusion_4FusionException_2__(v):
  return v is None or isinstance(v,mosek_fusion_FusionException)
def __arg_alt_match_Lmosek_4fusion_4FusionException_2__(v):
  return __arg_match_Lmosek_4fusion_4FusionException_2__(v)
def __arg_match_Lmosek_4fusion_4SolutionStruct_2__(v):
  return v is None or isinstance(v,mosek_fusion_SolutionStruct)
def __arg_alt_match_Lmosek_4fusion_4SolutionStruct_2__(v):
  return __arg_match_Lmosek_4fusion_4SolutionStruct_2__(v)
def __arg_match_Emosek_4fusion_4RelationKey_2__(v):
  return isinstance(v,mosek_fusion_RelationKey)
def __arg_alt_match_Emosek_4fusion_4RelationKey_2__(v):
  return isinstance(v,mosek_fusion_RelationKey)
def __arg_match__3_3Lmosek_4fusion_4Expression_2__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([__arg_match__3Lmosek_4fusion_4Expression_2__(i) for i in v.flatten()])
def __arg_alt_match__3_3Lmosek_4fusion_4Expression_2__(v):
  return __arg_match__3_3Lmosek_4fusion_4Expression_2__(v) or __arg_match_listof__(v,__arg_alt_match__3Lmosek_4fusion_4Expression_2__)
def __arg_match__3_3Lmosek_4fusion_4Matrix_2__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([__arg_match__3Lmosek_4fusion_4Matrix_2__(i) for i in v.flatten()])
def __arg_alt_match__3_3Lmosek_4fusion_4Matrix_2__(v):
  return __arg_match__3_3Lmosek_4fusion_4Matrix_2__(v) or __arg_match_listof__(v,__arg_alt_match__3Lmosek_4fusion_4Matrix_2__)
def __arg_match_Lmosek_4fusion_4LinearConstraint_2__(v):
  return v is None or isinstance(v,mosek_fusion_LinearConstraint)
def __arg_alt_match_Lmosek_4fusion_4LinearConstraint_2__(v):
  return __arg_match_Lmosek_4fusion_4LinearConstraint_2__(v)
def __arg_match_Emosek_4fusion_4QConeKey_2__(v):
  return isinstance(v,mosek_fusion_QConeKey)
def __arg_alt_match_Emosek_4fusion_4QConeKey_2__(v):
  return isinstance(v,mosek_fusion_QConeKey)
def __arg_match_Lmosek_4fusion_4Variable_2__(v):
  return v is None or isinstance(v,mosek_fusion_Variable)
def __arg_alt_match_Lmosek_4fusion_4Variable_2__(v):
  return __arg_match_Lmosek_4fusion_4Variable_2__(v)
def __arg_match_Lmosek_4fusion_4SymLinearVariable_2__(v):
  return v is None or isinstance(v,mosek_fusion_SymLinearVariable)
def __arg_alt_match_Lmosek_4fusion_4SymLinearVariable_2__(v):
  return __arg_match_Lmosek_4fusion_4SymLinearVariable_2__(v)
def __arg_match_LSystem_4DataCallbackHandler_2__(v):
  return v is None or isinstance(v,object)
def __arg_alt_match_LSystem_4DataCallbackHandler_2__(v):
  return __arg_match_LSystem_4DataCallbackHandler_2__(v)
def __arg_match_Emosek_4fusion_4ObjectiveSense_2__(v):
  return isinstance(v,mosek_fusion_ObjectiveSense)
def __arg_alt_match_Emosek_4fusion_4ObjectiveSense_2__(v):
  return isinstance(v,mosek_fusion_ObjectiveSense)
def __arg_match_Lmosek_4fusion_4Expression_2__(v):
  return v is None or isinstance(v,mosek_fusion_Expression)
def __arg_alt_match_Lmosek_4fusion_4Expression_2__(v):
  return __arg_match_Lmosek_4fusion_4Expression_2__(v)
def __arg_match__3_3Lmosek_4fusion_4Variable_2__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([__arg_match__3Lmosek_4fusion_4Variable_2__(i) for i in v.flatten()])
def __arg_alt_match__3_3Lmosek_4fusion_4Variable_2__(v):
  return __arg_match__3_3Lmosek_4fusion_4Variable_2__(v) or __arg_match_listof__(v,__arg_alt_match__3Lmosek_4fusion_4Variable_2__)
def __arg_match_Lmosek_4fusion_4ConicConstraint_2__(v):
  return v is None or isinstance(v,mosek_fusion_ConicConstraint)
def __arg_alt_match_Lmosek_4fusion_4ConicConstraint_2__(v):
  return __arg_match_Lmosek_4fusion_4ConicConstraint_2__(v)
def __arg_match__3Lmosek_4fusion_4Matrix_2__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([isinstance(i,mosek_fusion_Matrix) for i in v.flatten()])
def __arg_alt_match__3Lmosek_4fusion_4Matrix_2__(v):
  return __arg_match__3Lmosek_4fusion_4Matrix_2__(v) or __arg_match_listof__(v,__arg_alt_match_Lmosek_4fusion_4Matrix_2__)
def __arg_match_Lmosek_4fusion_4SymmetricExpr_2__(v):
  return v is None or isinstance(v,mosek_fusion_SymmetricExpr)
def __arg_alt_match_Lmosek_4fusion_4SymmetricExpr_2__(v):
  return __arg_match_Lmosek_4fusion_4SymmetricExpr_2__(v)
def __arg_match_D__(v):
  return isinstance(v,numpy.float64) or isinstance(v,float) or isinstance(v,int) or isinstance(v,numpy.int32) or isinstance(v,numpy.int64)
def __arg_alt_match_D__(v):
  return __arg_match_D__(v)
def __arg_match__3Lmosek_4fusion_4SymmetricMatrix_2__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([isinstance(i,mosek_fusion_SymmetricMatrix) for i in v.flatten()])
def __arg_alt_match__3Lmosek_4fusion_4SymmetricMatrix_2__(v):
  return __arg_match__3Lmosek_4fusion_4SymmetricMatrix_2__(v) or __arg_match_listof__(v,__arg_alt_match_Lmosek_4fusion_4SymmetricMatrix_2__)
def __arg_match_Z__(v):
  return isinstance(v,bool) or isinstance(v,numpy.bool_)
def __arg_alt_match_Z__(v):
  return __arg_match_Z__(v)
def __arg_match_S__(v):
  return isinstance(v,basestring)
def __arg_alt_match_S__(v):
  return __arg_match_S__(v)
def __arg_match_listof__(v,f): return isinstance(v,list) and all([ f(i) for i in v])
import mosek
import mosek.fusion
import mosek.fusion.Utils
import fragments
